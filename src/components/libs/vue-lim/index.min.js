if (typeof window !== 'undefined') {
  // @ts-ignore
  if (!window.process) window.process = { env: {} };
  // @ts-ignore
  if (!window.Buffer) window.Buffer = {
      // @ts-ignore
      from: (array) => new Uint8Array(array),
      // @ts-ignore
      isBuffer: (v) => v instanceof Uint8Array,
  };
}function n0(e, t) {
for (var r = 0; r < t.length; r++) {
  const i = t[r];
  if (typeof i != "string" && !Array.isArray(i)) {
    for (const s in i)
      if (s !== "default" && !(s in e)) {
        const n = Object.getOwnPropertyDescriptor(i, s);
        n && Object.defineProperty(e, s, n.get ? n : {
          enumerable: !0,
          get: () => i[s]
        });
      }
  }
}
return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
function co(e, t) {
(t == null || t > e.length) && (t = e.length);
for (var r = 0, i = Array(t); r < t; r++) i[r] = e[r];
return i;
}
function ea(e, t) {
if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function a0(e, t) {
for (var r = 0; r < t.length; r++) {
  var i = t[r];
  i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, l0(i.key), i);
}
}
function ta(e, t, r) {
return t && a0(e.prototype, t), Object.defineProperty(e, "prototype", {
  writable: !1
}), e;
}
function o0(e, t) {
var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
if (!r) {
  if (Array.isArray(e) || (r = c0(e)) || t) {
    r && (e = r);
    var i = 0, s = function() {
    };
    return {
      s,
      n: function() {
        return i >= e.length ? {
          done: !0
        } : {
          done: !1,
          value: e[i++]
        };
      },
      e: function(u) {
        throw u;
      },
      f: s
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var n, a = !0, o = !1;
return {
  s: function() {
    r = r.call(e);
  },
  n: function() {
    var u = r.next();
    return a = u.done, u;
  },
  e: function(u) {
    o = !0, n = u;
  },
  f: function() {
    try {
      a || r.return == null || r.return();
    } finally {
      if (o) throw n;
    }
  }
};
}
function u0(e, t) {
if (typeof e != "object" || !e) return e;
var r = e[Symbol.toPrimitive];
if (r !== void 0) {
  var i = r.call(e, t);
  if (typeof i != "object") return i;
  throw new TypeError("@@toPrimitive must return a primitive value.");
}
return String(e);
}
function l0(e) {
var t = u0(e, "string");
return typeof t == "symbol" ? t : t + "";
}
function c0(e, t) {
if (e) {
  if (typeof e == "string") return co(e, t);
  var r = {}.toString.call(e).slice(8, -1);
  return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? co(e, t) : void 0;
}
}
const Vl = new Uint16Array(
// prettier-ignore
'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((e) => e.charCodeAt(0))
), ql = new Uint16Array(
// prettier-ignore
"Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((e) => e.charCodeAt(0))
);
var en;
const f0 = /* @__PURE__ */ new Map([
[0, 65533],
// C1 Unicode control character reference replacements
[128, 8364],
[130, 8218],
[131, 402],
[132, 8222],
[133, 8230],
[134, 8224],
[135, 8225],
[136, 710],
[137, 8240],
[138, 352],
[139, 8249],
[140, 338],
[142, 381],
[145, 8216],
[146, 8217],
[147, 8220],
[148, 8221],
[149, 8226],
[150, 8211],
[151, 8212],
[152, 732],
[153, 8482],
[154, 353],
[155, 8250],
[156, 339],
[158, 382],
[159, 376]
]), _n = (
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
(en = String.fromCodePoint) !== null && en !== void 0 ? en : function(e) {
  let t = "";
  return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
}
);
function p0(e) {
var t;
return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = f0.get(e)) !== null && t !== void 0 ? t : e;
}
var ut;
(function(e) {
e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(ut || (ut = {}));
const h0 = 32;
var nr;
(function(e) {
e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(nr || (nr = {}));
function kn(e) {
return e >= ut.ZERO && e <= ut.NINE;
}
function d0(e) {
return e >= ut.UPPER_A && e <= ut.UPPER_F || e >= ut.LOWER_A && e <= ut.LOWER_F;
}
function m0(e) {
return e >= ut.UPPER_A && e <= ut.UPPER_Z || e >= ut.LOWER_A && e <= ut.LOWER_Z || kn(e);
}
function y0(e) {
return e === ut.EQUALS || m0(e);
}
var ot;
(function(e) {
e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(ot || (ot = {}));
var Mt;
(function(e) {
e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(Mt || (Mt = {}));
class $l {
constructor(t, r, i) {
  this.decodeTree = t, this.emitCodePoint = r, this.errors = i, this.state = ot.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Mt.Strict;
}
/** Resets the instance to make it reusable. */
startEntity(t) {
  this.decodeMode = t, this.state = ot.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
}
/**
 * Write an entity to the decoder. This can be called multiple times with partial entities.
 * If the entity is incomplete, the decoder will return -1.
 *
 * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
 * entity is incomplete, and resume when the next string is written.
 *
 * @param string The string containing the entity (or a continuation of the entity).
 * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
 * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
 */
write(t, r) {
  switch (this.state) {
    case ot.EntityStart:
      return t.charCodeAt(r) === ut.NUM ? (this.state = ot.NumericStart, this.consumed += 1, this.stateNumericStart(t, r + 1)) : (this.state = ot.NamedEntity, this.stateNamedEntity(t, r));
    case ot.NumericStart:
      return this.stateNumericStart(t, r);
    case ot.NumericDecimal:
      return this.stateNumericDecimal(t, r);
    case ot.NumericHex:
      return this.stateNumericHex(t, r);
    case ot.NamedEntity:
      return this.stateNamedEntity(t, r);
  }
}
/**
 * Switches between the numeric decimal and hexadecimal states.
 *
 * Equivalent to the `Numeric character reference state` in the HTML spec.
 *
 * @param str The string containing the entity (or a continuation of the entity).
 * @param offset The current offset.
 * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
 */
stateNumericStart(t, r) {
  return r >= t.length ? -1 : (t.charCodeAt(r) | h0) === ut.LOWER_X ? (this.state = ot.NumericHex, this.consumed += 1, this.stateNumericHex(t, r + 1)) : (this.state = ot.NumericDecimal, this.stateNumericDecimal(t, r));
}
addToNumericResult(t, r, i, s) {
  if (r !== i) {
    const n = i - r;
    this.result = this.result * Math.pow(s, n) + parseInt(t.substr(r, n), s), this.consumed += n;
  }
}
/**
 * Parses a hexadecimal numeric entity.
 *
 * Equivalent to the `Hexademical character reference state` in the HTML spec.
 *
 * @param str The string containing the entity (or a continuation of the entity).
 * @param offset The current offset.
 * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
 */
stateNumericHex(t, r) {
  const i = r;
  for (; r < t.length; ) {
    const s = t.charCodeAt(r);
    if (kn(s) || d0(s))
      r += 1;
    else
      return this.addToNumericResult(t, i, r, 16), this.emitNumericEntity(s, 3);
  }
  return this.addToNumericResult(t, i, r, 16), -1;
}
/**
 * Parses a decimal numeric entity.
 *
 * Equivalent to the `Decimal character reference state` in the HTML spec.
 *
 * @param str The string containing the entity (or a continuation of the entity).
 * @param offset The current offset.
 * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
 */
stateNumericDecimal(t, r) {
  const i = r;
  for (; r < t.length; ) {
    const s = t.charCodeAt(r);
    if (kn(s))
      r += 1;
    else
      return this.addToNumericResult(t, i, r, 10), this.emitNumericEntity(s, 2);
  }
  return this.addToNumericResult(t, i, r, 10), -1;
}
/**
 * Validate and emit a numeric entity.
 *
 * Implements the logic from the `Hexademical character reference start
 * state` and `Numeric character reference end state` in the HTML spec.
 *
 * @param lastCp The last code point of the entity. Used to see if the
 *               entity was terminated with a semicolon.
 * @param expectedLength The minimum number of characters that should be
 *                       consumed. Used to validate that at least one digit
 *                       was consumed.
 * @returns The number of characters that were consumed.
 */
emitNumericEntity(t, r) {
  var i;
  if (this.consumed <= r)
    return (i = this.errors) === null || i === void 0 || i.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
  if (t === ut.SEMI)
    this.consumed += 1;
  else if (this.decodeMode === Mt.Strict)
    return 0;
  return this.emitCodePoint(p0(this.result), this.consumed), this.errors && (t !== ut.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
}
/**
 * Parses a named entity.
 *
 * Equivalent to the `Named character reference state` in the HTML spec.
 *
 * @param str The string containing the entity (or a continuation of the entity).
 * @param offset The current offset.
 * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
 */
stateNamedEntity(t, r) {
  const { decodeTree: i } = this;
  let s = i[this.treeIndex], n = (s & nr.VALUE_LENGTH) >> 14;
  for (; r < t.length; r++, this.excess++) {
    const a = t.charCodeAt(r);
    if (this.treeIndex = b0(i, s, this.treeIndex + Math.max(1, n), a), this.treeIndex < 0)
      return this.result === 0 || // If we are parsing an attribute
      this.decodeMode === Mt.Attribute && // We shouldn't have consumed any characters after the entity,
      (n === 0 || // And there should be no invalid characters.
      y0(a)) ? 0 : this.emitNotTerminatedNamedEntity();
    if (s = i[this.treeIndex], n = (s & nr.VALUE_LENGTH) >> 14, n !== 0) {
      if (a === ut.SEMI)
        return this.emitNamedEntityData(this.treeIndex, n, this.consumed + this.excess);
      this.decodeMode !== Mt.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
    }
  }
  return -1;
}
/**
 * Emit a named entity that was not terminated with a semicolon.
 *
 * @returns The number of characters consumed.
 */
emitNotTerminatedNamedEntity() {
  var t;
  const { result: r, decodeTree: i } = this, s = (i[r] & nr.VALUE_LENGTH) >> 14;
  return this.emitNamedEntityData(r, s, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
}
/**
 * Emit a named entity.
 *
 * @param result The index of the entity in the decode tree.
 * @param valueLength The number of bytes in the entity.
 * @param consumed The number of characters consumed.
 *
 * @returns The number of characters consumed.
 */
emitNamedEntityData(t, r, i) {
  const { decodeTree: s } = this;
  return this.emitCodePoint(r === 1 ? s[t] & ~nr.VALUE_LENGTH : s[t + 1], i), r === 3 && this.emitCodePoint(s[t + 2], i), i;
}
/**
 * Signal to the parser that the end of the input was reached.
 *
 * Remaining data will be emitted and relevant errors will be produced.
 *
 * @returns The number of characters consumed.
 */
end() {
  var t;
  switch (this.state) {
    case ot.NamedEntity:
      return this.result !== 0 && (this.decodeMode !== Mt.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
    case ot.NumericDecimal:
      return this.emitNumericEntity(0, 2);
    case ot.NumericHex:
      return this.emitNumericEntity(0, 3);
    case ot.NumericStart:
      return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    case ot.EntityStart:
      return 0;
  }
}
}
function Kl(e) {
let t = "";
const r = new $l(e, (i) => t += _n(i));
return function(s, n) {
  let a = 0, o = 0;
  for (; (o = s.indexOf("&", o)) >= 0; ) {
    t += s.slice(a, o), r.startEntity(n);
    const l = r.write(
      s,
      // Skip the "&"
      o + 1
    );
    if (l < 0) {
      a = o + r.end();
      break;
    }
    a = o + l, o = l === 0 ? a + 1 : a;
  }
  const u = t + s.slice(a);
  return t = "", u;
};
}
function b0(e, t, r, i) {
const s = (t & nr.BRANCH_LENGTH) >> 7, n = t & nr.JUMP_TABLE;
if (s === 0)
  return n !== 0 && i === n ? r : -1;
if (n) {
  const u = i - n;
  return u < 0 || u >= s ? -1 : e[r + u] - 1;
}
let a = r, o = a + s - 1;
for (; a <= o; ) {
  const u = a + o >>> 1, l = e[u];
  if (l < i)
    a = u + 1;
  else if (l > i)
    o = u - 1;
  else
    return e[u + s];
}
return -1;
}
Kl(Vl);
Kl(ql);
var be;
(function(e) {
e[e.Tab = 9] = "Tab", e[e.NewLine = 10] = "NewLine", e[e.FormFeed = 12] = "FormFeed", e[e.CarriageReturn = 13] = "CarriageReturn", e[e.Space = 32] = "Space", e[e.ExclamationMark = 33] = "ExclamationMark", e[e.Number = 35] = "Number", e[e.Amp = 38] = "Amp", e[e.SingleQuote = 39] = "SingleQuote", e[e.DoubleQuote = 34] = "DoubleQuote", e[e.Dash = 45] = "Dash", e[e.Slash = 47] = "Slash", e[e.Zero = 48] = "Zero", e[e.Nine = 57] = "Nine", e[e.Semi = 59] = "Semi", e[e.Lt = 60] = "Lt", e[e.Eq = 61] = "Eq", e[e.Gt = 62] = "Gt", e[e.Questionmark = 63] = "Questionmark", e[e.UpperA = 65] = "UpperA", e[e.LowerA = 97] = "LowerA", e[e.UpperF = 70] = "UpperF", e[e.LowerF = 102] = "LowerF", e[e.UpperZ = 90] = "UpperZ", e[e.LowerZ = 122] = "LowerZ", e[e.LowerX = 120] = "LowerX", e[e.OpeningSquareBracket = 91] = "OpeningSquareBracket";
})(be || (be = {}));
var te;
(function(e) {
e[e.Text = 1] = "Text", e[e.BeforeTagName = 2] = "BeforeTagName", e[e.InTagName = 3] = "InTagName", e[e.InSelfClosingTag = 4] = "InSelfClosingTag", e[e.BeforeClosingTagName = 5] = "BeforeClosingTagName", e[e.InClosingTagName = 6] = "InClosingTagName", e[e.AfterClosingTagName = 7] = "AfterClosingTagName", e[e.BeforeAttributeName = 8] = "BeforeAttributeName", e[e.InAttributeName = 9] = "InAttributeName", e[e.AfterAttributeName = 10] = "AfterAttributeName", e[e.BeforeAttributeValue = 11] = "BeforeAttributeValue", e[e.InAttributeValueDq = 12] = "InAttributeValueDq", e[e.InAttributeValueSq = 13] = "InAttributeValueSq", e[e.InAttributeValueNq = 14] = "InAttributeValueNq", e[e.BeforeDeclaration = 15] = "BeforeDeclaration", e[e.InDeclaration = 16] = "InDeclaration", e[e.InProcessingInstruction = 17] = "InProcessingInstruction", e[e.BeforeComment = 18] = "BeforeComment", e[e.CDATASequence = 19] = "CDATASequence", e[e.InSpecialComment = 20] = "InSpecialComment", e[e.InCommentLike = 21] = "InCommentLike", e[e.BeforeSpecialS = 22] = "BeforeSpecialS", e[e.BeforeSpecialT = 23] = "BeforeSpecialT", e[e.SpecialStartSequence = 24] = "SpecialStartSequence", e[e.InSpecialTag = 25] = "InSpecialTag", e[e.InEntity = 26] = "InEntity";
})(te || (te = {}));
function $t(e) {
return e === be.Space || e === be.NewLine || e === be.Tab || e === be.FormFeed || e === be.CarriageReturn;
}
function _i(e) {
return e === be.Slash || e === be.Gt || $t(e);
}
function T0(e) {
return e >= be.LowerA && e <= be.LowerZ || e >= be.UpperA && e <= be.UpperZ;
}
var Bt;
(function(e) {
e[e.NoValue = 0] = "NoValue", e[e.Unquoted = 1] = "Unquoted", e[e.Single = 2] = "Single", e[e.Double = 3] = "Double";
})(Bt || (Bt = {}));
const ct = {
Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
// CDATA[
CdataEnd: new Uint8Array([93, 93, 62]),
// ]]>
CommentEnd: new Uint8Array([45, 45, 62]),
// `-->`
ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
// `<\/script`
StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
// `</style`
TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
// `</title`
TextareaEnd: new Uint8Array([
  60,
  47,
  116,
  101,
  120,
  116,
  97,
  114,
  101,
  97
])
// `</textarea`
};
let g0 = class {
constructor({ xmlMode: t = !1, decodeEntities: r = !0 }, i) {
  this.cbs = i, this.state = te.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = te.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.xmlMode = t, this.decodeEntities = r, this.entityDecoder = new $l(t ? ql : Vl, (s, n) => this.emitCodePoint(s, n));
}
reset() {
  this.state = te.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = te.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
}
write(t) {
  this.offset += this.buffer.length, this.buffer = t, this.parse();
}
end() {
  this.running && this.finish();
}
pause() {
  this.running = !1;
}
resume() {
  this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
}
stateText(t) {
  t === be.Lt || !this.decodeEntities && this.fastForwardTo(be.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = te.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && t === be.Amp && this.startEntity();
}
stateSpecialStartSequence(t) {
  const r = this.sequenceIndex === this.currentSequence.length;
  if (!(r ? (
    // If we are at the end of the sequence, make sure the tag name has ended
    _i(t)
  ) : (
    // Otherwise, do a case-insensitive comparison
    (t | 32) === this.currentSequence[this.sequenceIndex]
  )))
    this.isSpecial = !1;
  else if (!r) {
    this.sequenceIndex++;
    return;
  }
  this.sequenceIndex = 0, this.state = te.InTagName, this.stateInTagName(t);
}
/** Look for an end tag. For <title> tags, also decode entities. */
stateInSpecialTag(t) {
  if (this.sequenceIndex === this.currentSequence.length) {
    if (t === be.Gt || $t(t)) {
      const r = this.index - this.currentSequence.length;
      if (this.sectionStart < r) {
        const i = this.index;
        this.index = r, this.cbs.ontext(this.sectionStart, r), this.index = i;
      }
      this.isSpecial = !1, this.sectionStart = r + 2, this.stateInClosingTagName(t);
      return;
    }
    this.sequenceIndex = 0;
  }
  (t | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === ct.TitleEnd ? this.decodeEntities && t === be.Amp && this.startEntity() : this.fastForwardTo(be.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(t === be.Lt);
}
stateCDATASequence(t) {
  t === ct.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === ct.Cdata.length && (this.state = te.InCommentLike, this.currentSequence = ct.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = te.InDeclaration, this.stateInDeclaration(t));
}
/**
 * When we wait for one specific character, we can speed things up
 * by skipping through the buffer until we find it.
 *
 * @returns Whether the character was found.
 */
fastForwardTo(t) {
  for (; ++this.index < this.buffer.length + this.offset; )
    if (this.buffer.charCodeAt(this.index - this.offset) === t)
      return !0;
  return this.index = this.buffer.length + this.offset - 1, !1;
}
/**
 * Comments and CDATA end with `-->` and `]]>`.
 *
 * Their common qualities are:
 * - Their end sequences have a distinct character they start with.
 * - That character is then repeated, so we have to check multiple repeats.
 * - All characters but the start character of the sequence can be skipped.
 */
stateInCommentLike(t) {
  t === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === ct.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = te.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : t !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
}
/**
 * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
 *
 * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
 * We allow anything that wouldn't end the tag.
 */
isTagStartChar(t) {
  return this.xmlMode ? !_i(t) : T0(t);
}
startSpecial(t, r) {
  this.isSpecial = !0, this.currentSequence = t, this.sequenceIndex = r, this.state = te.SpecialStartSequence;
}
stateBeforeTagName(t) {
  if (t === be.ExclamationMark)
    this.state = te.BeforeDeclaration, this.sectionStart = this.index + 1;
  else if (t === be.Questionmark)
    this.state = te.InProcessingInstruction, this.sectionStart = this.index + 1;
  else if (this.isTagStartChar(t)) {
    const r = t | 32;
    this.sectionStart = this.index, this.xmlMode ? this.state = te.InTagName : r === ct.ScriptEnd[2] ? this.state = te.BeforeSpecialS : r === ct.TitleEnd[2] ? this.state = te.BeforeSpecialT : this.state = te.InTagName;
  } else t === be.Slash ? this.state = te.BeforeClosingTagName : (this.state = te.Text, this.stateText(t));
}
stateInTagName(t) {
  _i(t) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = te.BeforeAttributeName, this.stateBeforeAttributeName(t));
}
stateBeforeClosingTagName(t) {
  $t(t) || (t === be.Gt ? this.state = te.Text : (this.state = this.isTagStartChar(t) ? te.InClosingTagName : te.InSpecialComment, this.sectionStart = this.index));
}
stateInClosingTagName(t) {
  (t === be.Gt || $t(t)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = te.AfterClosingTagName, this.stateAfterClosingTagName(t));
}
stateAfterClosingTagName(t) {
  (t === be.Gt || this.fastForwardTo(be.Gt)) && (this.state = te.Text, this.sectionStart = this.index + 1);
}
stateBeforeAttributeName(t) {
  t === be.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = te.InSpecialTag, this.sequenceIndex = 0) : this.state = te.Text, this.sectionStart = this.index + 1) : t === be.Slash ? this.state = te.InSelfClosingTag : $t(t) || (this.state = te.InAttributeName, this.sectionStart = this.index);
}
stateInSelfClosingTag(t) {
  t === be.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = te.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : $t(t) || (this.state = te.BeforeAttributeName, this.stateBeforeAttributeName(t));
}
stateInAttributeName(t) {
  (t === be.Eq || _i(t)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = this.index, this.state = te.AfterAttributeName, this.stateAfterAttributeName(t));
}
stateAfterAttributeName(t) {
  t === be.Eq ? this.state = te.BeforeAttributeValue : t === be.Slash || t === be.Gt ? (this.cbs.onattribend(Bt.NoValue, this.sectionStart), this.sectionStart = -1, this.state = te.BeforeAttributeName, this.stateBeforeAttributeName(t)) : $t(t) || (this.cbs.onattribend(Bt.NoValue, this.sectionStart), this.state = te.InAttributeName, this.sectionStart = this.index);
}
stateBeforeAttributeValue(t) {
  t === be.DoubleQuote ? (this.state = te.InAttributeValueDq, this.sectionStart = this.index + 1) : t === be.SingleQuote ? (this.state = te.InAttributeValueSq, this.sectionStart = this.index + 1) : $t(t) || (this.sectionStart = this.index, this.state = te.InAttributeValueNq, this.stateInAttributeValueNoQuotes(t));
}
handleInAttributeValue(t, r) {
  t === r || !this.decodeEntities && this.fastForwardTo(r) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(r === be.DoubleQuote ? Bt.Double : Bt.Single, this.index + 1), this.state = te.BeforeAttributeName) : this.decodeEntities && t === be.Amp && this.startEntity();
}
stateInAttributeValueDoubleQuotes(t) {
  this.handleInAttributeValue(t, be.DoubleQuote);
}
stateInAttributeValueSingleQuotes(t) {
  this.handleInAttributeValue(t, be.SingleQuote);
}
stateInAttributeValueNoQuotes(t) {
  $t(t) || t === be.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(Bt.Unquoted, this.index), this.state = te.BeforeAttributeName, this.stateBeforeAttributeName(t)) : this.decodeEntities && t === be.Amp && this.startEntity();
}
stateBeforeDeclaration(t) {
  t === be.OpeningSquareBracket ? (this.state = te.CDATASequence, this.sequenceIndex = 0) : this.state = t === be.Dash ? te.BeforeComment : te.InDeclaration;
}
stateInDeclaration(t) {
  (t === be.Gt || this.fastForwardTo(be.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = te.Text, this.sectionStart = this.index + 1);
}
stateInProcessingInstruction(t) {
  (t === be.Gt || this.fastForwardTo(be.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = te.Text, this.sectionStart = this.index + 1);
}
stateBeforeComment(t) {
  t === be.Dash ? (this.state = te.InCommentLike, this.currentSequence = ct.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = te.InDeclaration;
}
stateInSpecialComment(t) {
  (t === be.Gt || this.fastForwardTo(be.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = te.Text, this.sectionStart = this.index + 1);
}
stateBeforeSpecialS(t) {
  const r = t | 32;
  r === ct.ScriptEnd[3] ? this.startSpecial(ct.ScriptEnd, 4) : r === ct.StyleEnd[3] ? this.startSpecial(ct.StyleEnd, 4) : (this.state = te.InTagName, this.stateInTagName(t));
}
stateBeforeSpecialT(t) {
  const r = t | 32;
  r === ct.TitleEnd[3] ? this.startSpecial(ct.TitleEnd, 4) : r === ct.TextareaEnd[3] ? this.startSpecial(ct.TextareaEnd, 4) : (this.state = te.InTagName, this.stateInTagName(t));
}
startEntity() {
  this.baseState = this.state, this.state = te.InEntity, this.entityStart = this.index, this.entityDecoder.startEntity(this.xmlMode ? Mt.Strict : this.baseState === te.Text || this.baseState === te.InSpecialTag ? Mt.Legacy : Mt.Attribute);
}
stateInEntity() {
  const t = this.entityDecoder.write(this.buffer, this.index - this.offset);
  t >= 0 ? (this.state = this.baseState, t === 0 && (this.index = this.entityStart)) : this.index = this.offset + this.buffer.length - 1;
}
/**
 * Remove data that has already been consumed from the buffer.
 */
cleanup() {
  this.running && this.sectionStart !== this.index && (this.state === te.Text || this.state === te.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === te.InAttributeValueDq || this.state === te.InAttributeValueSq || this.state === te.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
}
shouldContinue() {
  return this.index < this.buffer.length + this.offset && this.running;
}
/**
 * Iterates through the buffer, calling the function corresponding to the current state.
 *
 * States that are more likely to be hit are higher up, as a performance improvement.
 */
parse() {
  for (; this.shouldContinue(); ) {
    const t = this.buffer.charCodeAt(this.index - this.offset);
    switch (this.state) {
      case te.Text: {
        this.stateText(t);
        break;
      }
      case te.SpecialStartSequence: {
        this.stateSpecialStartSequence(t);
        break;
      }
      case te.InSpecialTag: {
        this.stateInSpecialTag(t);
        break;
      }
      case te.CDATASequence: {
        this.stateCDATASequence(t);
        break;
      }
      case te.InAttributeValueDq: {
        this.stateInAttributeValueDoubleQuotes(t);
        break;
      }
      case te.InAttributeName: {
        this.stateInAttributeName(t);
        break;
      }
      case te.InCommentLike: {
        this.stateInCommentLike(t);
        break;
      }
      case te.InSpecialComment: {
        this.stateInSpecialComment(t);
        break;
      }
      case te.BeforeAttributeName: {
        this.stateBeforeAttributeName(t);
        break;
      }
      case te.InTagName: {
        this.stateInTagName(t);
        break;
      }
      case te.InClosingTagName: {
        this.stateInClosingTagName(t);
        break;
      }
      case te.BeforeTagName: {
        this.stateBeforeTagName(t);
        break;
      }
      case te.AfterAttributeName: {
        this.stateAfterAttributeName(t);
        break;
      }
      case te.InAttributeValueSq: {
        this.stateInAttributeValueSingleQuotes(t);
        break;
      }
      case te.BeforeAttributeValue: {
        this.stateBeforeAttributeValue(t);
        break;
      }
      case te.BeforeClosingTagName: {
        this.stateBeforeClosingTagName(t);
        break;
      }
      case te.AfterClosingTagName: {
        this.stateAfterClosingTagName(t);
        break;
      }
      case te.BeforeSpecialS: {
        this.stateBeforeSpecialS(t);
        break;
      }
      case te.BeforeSpecialT: {
        this.stateBeforeSpecialT(t);
        break;
      }
      case te.InAttributeValueNq: {
        this.stateInAttributeValueNoQuotes(t);
        break;
      }
      case te.InSelfClosingTag: {
        this.stateInSelfClosingTag(t);
        break;
      }
      case te.InDeclaration: {
        this.stateInDeclaration(t);
        break;
      }
      case te.BeforeDeclaration: {
        this.stateBeforeDeclaration(t);
        break;
      }
      case te.BeforeComment: {
        this.stateBeforeComment(t);
        break;
      }
      case te.InProcessingInstruction: {
        this.stateInProcessingInstruction(t);
        break;
      }
      case te.InEntity: {
        this.stateInEntity();
        break;
      }
    }
    this.index++;
  }
  this.cleanup();
}
finish() {
  this.state === te.InEntity && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
}
/** Handle any trailing data. */
handleTrailingData() {
  const t = this.buffer.length + this.offset;
  this.sectionStart >= t || (this.state === te.InCommentLike ? this.currentSequence === ct.CdataEnd ? this.cbs.oncdata(this.sectionStart, t, 0) : this.cbs.oncomment(this.sectionStart, t, 0) : this.state === te.InTagName || this.state === te.BeforeAttributeName || this.state === te.BeforeAttributeValue || this.state === te.AfterAttributeName || this.state === te.InAttributeName || this.state === te.InAttributeValueSq || this.state === te.InAttributeValueDq || this.state === te.InAttributeValueNq || this.state === te.InClosingTagName || this.cbs.ontext(this.sectionStart, t));
}
emitCodePoint(t, r) {
  this.baseState !== te.Text && this.baseState !== te.InSpecialTag ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + r, this.index = this.sectionStart - 1, this.cbs.onattribentity(t)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + r, this.index = this.sectionStart - 1, this.cbs.ontextentity(t, this.sectionStart));
}
};
const Ir = /* @__PURE__ */ new Set([
"input",
"option",
"optgroup",
"select",
"button",
"datalist",
"textarea"
]), We = /* @__PURE__ */ new Set(["p"]), fo = /* @__PURE__ */ new Set(["thead", "tbody"]), po = /* @__PURE__ */ new Set(["dd", "dt"]), ho = /* @__PURE__ */ new Set(["rt", "rp"]), S0 = /* @__PURE__ */ new Map([
["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
["th", /* @__PURE__ */ new Set(["th"])],
["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
["li", /* @__PURE__ */ new Set(["li"])],
["p", We],
["h1", We],
["h2", We],
["h3", We],
["h4", We],
["h5", We],
["h6", We],
["select", Ir],
["input", Ir],
["output", Ir],
["button", Ir],
["datalist", Ir],
["textarea", Ir],
["option", /* @__PURE__ */ new Set(["option"])],
["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
["dd", po],
["dt", po],
["address", We],
["article", We],
["aside", We],
["blockquote", We],
["details", We],
["div", We],
["dl", We],
["fieldset", We],
["figcaption", We],
["figure", We],
["footer", We],
["form", We],
["header", We],
["hr", We],
["main", We],
["nav", We],
["ol", We],
["pre", We],
["section", We],
["table", We],
["ul", We],
["rt", ho],
["rp", ho],
["tbody", fo],
["tfoot", fo]
]), x0 = /* @__PURE__ */ new Set([
"area",
"base",
"basefont",
"br",
"col",
"command",
"embed",
"frame",
"hr",
"img",
"input",
"isindex",
"keygen",
"link",
"meta",
"param",
"source",
"track",
"wbr"
]), mo = /* @__PURE__ */ new Set(["math", "svg"]), yo = /* @__PURE__ */ new Set([
"mi",
"mo",
"mn",
"ms",
"mtext",
"annotation-xml",
"foreignobject",
"desc",
"title"
]), E0 = /\s|\//;
let P0 = class {
constructor(t, r = {}) {
  var i, s, n, a, o, u;
  this.options = r, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = t ?? {}, this.htmlMode = !this.options.xmlMode, this.lowerCaseTagNames = (i = r.lowerCaseTags) !== null && i !== void 0 ? i : this.htmlMode, this.lowerCaseAttributeNames = (s = r.lowerCaseAttributeNames) !== null && s !== void 0 ? s : this.htmlMode, this.recognizeSelfClosing = (n = r.recognizeSelfClosing) !== null && n !== void 0 ? n : !this.htmlMode, this.tokenizer = new ((a = r.Tokenizer) !== null && a !== void 0 ? a : g0)(this.options, this), this.foreignContext = [!this.htmlMode], (u = (o = this.cbs).onparserinit) === null || u === void 0 || u.call(o, this);
}
// Tokenizer event handlers
/** @internal */
ontext(t, r) {
  var i, s;
  const n = this.getSlice(t, r);
  this.endIndex = r - 1, (s = (i = this.cbs).ontext) === null || s === void 0 || s.call(i, n), this.startIndex = r;
}
/** @internal */
ontextentity(t, r) {
  var i, s;
  this.endIndex = r - 1, (s = (i = this.cbs).ontext) === null || s === void 0 || s.call(i, _n(t)), this.startIndex = r;
}
/**
 * Checks if the current tag is a void element. Override this if you want
 * to specify your own additional void elements.
 */
isVoidElement(t) {
  return this.htmlMode && x0.has(t);
}
/** @internal */
onopentagname(t, r) {
  this.endIndex = r;
  let i = this.getSlice(t, r);
  this.lowerCaseTagNames && (i = i.toLowerCase()), this.emitOpenTag(i);
}
emitOpenTag(t) {
  var r, i, s, n;
  this.openTagStart = this.startIndex, this.tagname = t;
  const a = this.htmlMode && S0.get(t);
  if (a)
    for (; this.stack.length > 0 && a.has(this.stack[0]); ) {
      const o = this.stack.shift();
      (i = (r = this.cbs).onclosetag) === null || i === void 0 || i.call(r, o, !0);
    }
  this.isVoidElement(t) || (this.stack.unshift(t), this.htmlMode && (mo.has(t) ? this.foreignContext.unshift(!0) : yo.has(t) && this.foreignContext.unshift(!1))), (n = (s = this.cbs).onopentagname) === null || n === void 0 || n.call(s, t), this.cbs.onopentag && (this.attribs = {});
}
endOpenTag(t) {
  var r, i;
  this.startIndex = this.openTagStart, this.attribs && ((i = (r = this.cbs).onopentag) === null || i === void 0 || i.call(r, this.tagname, this.attribs, t), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
}
/** @internal */
onopentagend(t) {
  this.endIndex = t, this.endOpenTag(!1), this.startIndex = t + 1;
}
/** @internal */
onclosetag(t, r) {
  var i, s, n, a, o, u, l, c;
  this.endIndex = r;
  let f = this.getSlice(t, r);
  if (this.lowerCaseTagNames && (f = f.toLowerCase()), this.htmlMode && (mo.has(f) || yo.has(f)) && this.foreignContext.shift(), this.isVoidElement(f))
    this.htmlMode && f === "br" && ((a = (n = this.cbs).onopentagname) === null || a === void 0 || a.call(n, "br"), (u = (o = this.cbs).onopentag) === null || u === void 0 || u.call(o, "br", {}, !0), (c = (l = this.cbs).onclosetag) === null || c === void 0 || c.call(l, "br", !1));
  else {
    const p = this.stack.indexOf(f);
    if (p !== -1)
      for (let h = 0; h <= p; h++) {
        const y = this.stack.shift();
        (s = (i = this.cbs).onclosetag) === null || s === void 0 || s.call(i, y, h !== p);
      }
    else this.htmlMode && f === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
  }
  this.startIndex = r + 1;
}
/** @internal */
onselfclosingtag(t) {
  this.endIndex = t, this.recognizeSelfClosing || this.foreignContext[0] ? (this.closeCurrentTag(!1), this.startIndex = t + 1) : this.onopentagend(t);
}
closeCurrentTag(t) {
  var r, i;
  const s = this.tagname;
  this.endOpenTag(t), this.stack[0] === s && ((i = (r = this.cbs).onclosetag) === null || i === void 0 || i.call(r, s, !t), this.stack.shift());
}
/** @internal */
onattribname(t, r) {
  this.startIndex = t;
  const i = this.getSlice(t, r);
  this.attribname = this.lowerCaseAttributeNames ? i.toLowerCase() : i;
}
/** @internal */
onattribdata(t, r) {
  this.attribvalue += this.getSlice(t, r);
}
/** @internal */
onattribentity(t) {
  this.attribvalue += _n(t);
}
/** @internal */
onattribend(t, r) {
  var i, s;
  this.endIndex = r, (s = (i = this.cbs).onattribute) === null || s === void 0 || s.call(i, this.attribname, this.attribvalue, t === Bt.Double ? '"' : t === Bt.Single ? "'" : t === Bt.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
}
getInstructionName(t) {
  const r = t.search(E0);
  let i = r < 0 ? t : t.substr(0, r);
  return this.lowerCaseTagNames && (i = i.toLowerCase()), i;
}
/** @internal */
ondeclaration(t, r) {
  this.endIndex = r;
  const i = this.getSlice(t, r);
  if (this.cbs.onprocessinginstruction) {
    const s = this.getInstructionName(i);
    this.cbs.onprocessinginstruction(`!${s}`, `!${i}`);
  }
  this.startIndex = r + 1;
}
/** @internal */
onprocessinginstruction(t, r) {
  this.endIndex = r;
  const i = this.getSlice(t, r);
  if (this.cbs.onprocessinginstruction) {
    const s = this.getInstructionName(i);
    this.cbs.onprocessinginstruction(`?${s}`, `?${i}`);
  }
  this.startIndex = r + 1;
}
/** @internal */
oncomment(t, r, i) {
  var s, n, a, o;
  this.endIndex = r, (n = (s = this.cbs).oncomment) === null || n === void 0 || n.call(s, this.getSlice(t, r - i)), (o = (a = this.cbs).oncommentend) === null || o === void 0 || o.call(a), this.startIndex = r + 1;
}
/** @internal */
oncdata(t, r, i) {
  var s, n, a, o, u, l, c, f, p, h;
  this.endIndex = r;
  const y = this.getSlice(t, r - i);
  !this.htmlMode || this.options.recognizeCDATA ? ((n = (s = this.cbs).oncdatastart) === null || n === void 0 || n.call(s), (o = (a = this.cbs).ontext) === null || o === void 0 || o.call(a, y), (l = (u = this.cbs).oncdataend) === null || l === void 0 || l.call(u)) : ((f = (c = this.cbs).oncomment) === null || f === void 0 || f.call(c, `[CDATA[${y}]]`), (h = (p = this.cbs).oncommentend) === null || h === void 0 || h.call(p)), this.startIndex = r + 1;
}
/** @internal */
onend() {
  var t, r;
  if (this.cbs.onclosetag) {
    this.endIndex = this.startIndex;
    for (let i = 0; i < this.stack.length; i++)
      this.cbs.onclosetag(this.stack[i], !0);
  }
  (r = (t = this.cbs).onend) === null || r === void 0 || r.call(t);
}
/**
 * Resets the parser to a blank state, ready to parse a new HTML document
 */
reset() {
  var t, r, i, s;
  (r = (t = this.cbs).onreset) === null || r === void 0 || r.call(t), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (s = (i = this.cbs).onparserinit) === null || s === void 0 || s.call(i, this), this.buffers.length = 0, this.foreignContext.length = 0, this.foreignContext.unshift(!this.htmlMode), this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
}
/**
 * Resets the parser, then parses a complete document and
 * pushes it to the handler.
 *
 * @param data Document to parse.
 */
parseComplete(t) {
  this.reset(), this.end(t);
}
getSlice(t, r) {
  for (; t - this.bufferOffset >= this.buffers[0].length; )
    this.shiftBuffer();
  let i = this.buffers[0].slice(t - this.bufferOffset, r - this.bufferOffset);
  for (; r - this.bufferOffset > this.buffers[0].length; )
    this.shiftBuffer(), i += this.buffers[0].slice(0, r - this.bufferOffset);
  return i;
}
shiftBuffer() {
  this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
}
/**
 * Parses a chunk of data and calls the corresponding callbacks.
 *
 * @param chunk Chunk to parse.
 */
write(t) {
  var r, i;
  if (this.ended) {
    (i = (r = this.cbs).onerror) === null || i === void 0 || i.call(r, new Error(".write() after done!"));
    return;
  }
  this.buffers.push(t), this.tokenizer.running && (this.tokenizer.write(t), this.writeIndex++);
}
/**
 * Parses the end of the buffer and clears the stack, calls onend.
 *
 * @param chunk Optional final chunk to parse.
 */
end(t) {
  var r, i;
  if (this.ended) {
    (i = (r = this.cbs).onerror) === null || i === void 0 || i.call(r, new Error(".end() after done!"));
    return;
  }
  t && this.write(t), this.ended = !0, this.tokenizer.end();
}
/**
 * Pauses parsing. The parser won't emit events until `resume` is called.
 */
pause() {
  this.tokenizer.pause();
}
/**
 * Resumes parsing after `pause` was called.
 */
resume() {
  for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
    this.tokenizer.write(this.buffers[this.writeIndex++]);
  this.ended && this.tokenizer.end();
}
/**
 * Alias of `write`, for backwards compatibility.
 *
 * @param chunk Chunk to parse.
 * @deprecated
 */
parseChunk(t) {
  this.write(t);
}
/**
 * Alias of `end`, for backwards compatibility.
 *
 * @param chunk Optional final chunk to parse.
 * @deprecated
 */
done(t) {
  this.end(t);
}
};
var Tr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Wl(e) {
return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var tn = {}, zt = {}, _e = {};
Object.defineProperty(_e, "__esModule", {
value: !0
});
_e.Var = _e.User = _e.Statement = _e.SpreadProperty = _e.Scope = _e.RestProperty = _e.ReferencedMemberExpression = _e.ReferencedIdentifier = _e.Referenced = _e.Pure = _e.NumericLiteralTypeAnnotation = _e.Generated = _e.ForAwaitStatement = _e.Flow = _e.Expression = _e.ExistentialTypeParam = _e.BlockScoped = _e.BindingIdentifier = void 0;
_e.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
_e.ReferencedMemberExpression = ["MemberExpression"];
_e.BindingIdentifier = ["Identifier"];
_e.Statement = ["Statement"];
_e.Expression = ["Expression"];
_e.Scope = ["Scopable", "Pattern"];
_e.Referenced = null;
_e.BlockScoped = null;
_e.Var = ["VariableDeclaration"];
_e.User = null;
_e.Generated = null;
_e.Pure = null;
_e.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
_e.RestProperty = ["RestElement"];
_e.SpreadProperty = ["RestElement"];
_e.ExistentialTypeParam = ["ExistsTypeAnnotation"];
_e.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
_e.ForAwaitStatement = ["ForOfStatement"];
var rt = {}, rn = {}, ys = {}, bs = {}, Ts = {}, T = {}, li = {};
Object.defineProperty(li, "__esModule", {
value: !0
});
li.default = v0;
function v0(e, t) {
const r = Object.keys(t);
for (const i of r)
  if (e[i] !== t[i])
    return !1;
return !0;
}
var kr = {};
Object.defineProperty(kr, "__esModule", {
value: !0
});
kr.default = A0;
const bo = /* @__PURE__ */ new Set();
function A0(e, t, r = "") {
if (bo.has(e)) return;
bo.add(e);
const {
  internal: i,
  trace: s
} = I0(1, 2);
i || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${s}`);
}
function I0(e, t) {
const {
  stackTraceLimit: r,
  prepareStackTrace: i
} = Error;
let s;
if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(a, o) {
  s = o;
}, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = i, !s) return {
  internal: !1,
  trace: ""
};
const n = s.slice(1 + e, 1 + e + t);
return {
  internal: /[\\/]@babel[\\/]/.test(n[1].getFileName()),
  trace: n.map((a) => `    at ${a}`).join(`
`)
};
}
Object.defineProperty(T, "__esModule", {
value: !0
});
T.isAccessor = UT;
T.isAnyTypeAnnotation = oy;
T.isArgumentPlaceholder = Bb;
T.isArrayExpression = C0;
T.isArrayPattern = Am;
T.isArrayTypeAnnotation = uy;
T.isArrowFunctionExpression = Im;
T.isAssignmentExpression = w0;
T.isAssignmentPattern = vm;
T.isAwaitExpression = Hm;
T.isBigIntLiteral = zm;
T.isBinary = lT;
T.isBinaryExpression = N0;
T.isBindExpression = Fb;
T.isBlock = pT;
T.isBlockParent = fT;
T.isBlockStatement = D0;
T.isBooleanLiteral = em;
T.isBooleanLiteralTypeAnnotation = cy;
T.isBooleanTypeAnnotation = ly;
T.isBreakStatement = L0;
T.isCallExpression = M0;
T.isCatchClause = B0;
T.isClass = FT;
T.isClassAccessorProperty = ry;
T.isClassBody = Cm;
T.isClassDeclaration = Nm;
T.isClassExpression = wm;
T.isClassImplements = py;
T.isClassMethod = Vm;
T.isClassPrivateMethod = sy;
T.isClassPrivateProperty = iy;
T.isClassProperty = ty;
T.isCompletionStatement = mT;
T.isConditional = yT;
T.isConditionalExpression = F0;
T.isContinueStatement = j0;
T.isDebuggerStatement = R0;
T.isDecimalLiteral = Kb;
T.isDeclaration = AT;
T.isDeclareClass = hy;
T.isDeclareExportAllDeclaration = Ey;
T.isDeclareExportDeclaration = xy;
T.isDeclareFunction = dy;
T.isDeclareInterface = my;
T.isDeclareModule = yy;
T.isDeclareModuleExports = by;
T.isDeclareOpaqueType = gy;
T.isDeclareTypeAlias = Ty;
T.isDeclareVariable = Sy;
T.isDeclaredPredicate = Py;
T.isDecorator = Rb;
T.isDirective = _0;
T.isDirectiveLiteral = k0;
T.isDoExpression = Ub;
T.isDoWhileStatement = U0;
T.isEmptyStatement = V0;
T.isEmptyTypeAnnotation = Ly;
T.isEnumBody = YT;
T.isEnumBooleanBody = ub;
T.isEnumBooleanMember = pb;
T.isEnumDeclaration = ob;
T.isEnumDefaultedMember = mb;
T.isEnumMember = XT;
T.isEnumNumberBody = lb;
T.isEnumNumberMember = hb;
T.isEnumStringBody = cb;
T.isEnumStringMember = db;
T.isEnumSymbolBody = fb;
T.isExistsTypeAnnotation = vy;
T.isExportAllDeclaration = Om;
T.isExportDeclaration = jT;
T.isExportDefaultDeclaration = _m;
T.isExportDefaultSpecifier = Vb;
T.isExportNamedDeclaration = km;
T.isExportNamespaceSpecifier = Qm;
T.isExportSpecifier = Dm;
T.isExpression = uT;
T.isExpressionStatement = q0;
T.isExpressionWrapper = gT;
T.isFile = $0;
T.isFlow = qT;
T.isFlowBaseAnnotation = KT;
T.isFlowDeclaration = WT;
T.isFlowPredicate = JT;
T.isFlowType = $T;
T.isFor = ST;
T.isForInStatement = K0;
T.isForOfStatement = Lm;
T.isForStatement = W0;
T.isForXStatement = xT;
T.isFunction = ET;
T.isFunctionDeclaration = J0;
T.isFunctionExpression = Y0;
T.isFunctionParent = PT;
T.isFunctionTypeAnnotation = Ay;
T.isFunctionTypeParam = Iy;
T.isGenericTypeAnnotation = Cy;
T.isIdentifier = X0;
T.isIfStatement = H0;
T.isImmutable = OT;
T.isImport = Gm;
T.isImportAttribute = jb;
T.isImportDeclaration = Mm;
T.isImportDefaultSpecifier = Bm;
T.isImportExpression = Rm;
T.isImportNamespaceSpecifier = Fm;
T.isImportOrExportDeclaration = Jl;
T.isImportSpecifier = jm;
T.isIndexedAccessType = yb;
T.isInferredPredicate = wy;
T.isInterfaceDeclaration = Oy;
T.isInterfaceExtends = Ny;
T.isInterfaceTypeAnnotation = _y;
T.isInterpreterDirective = O0;
T.isIntersectionTypeAnnotation = ky;
T.isJSX = HT;
T.isJSXAttribute = Tb;
T.isJSXClosingElement = gb;
T.isJSXClosingFragment = kb;
T.isJSXElement = Sb;
T.isJSXEmptyExpression = xb;
T.isJSXExpressionContainer = Eb;
T.isJSXFragment = Ob;
T.isJSXIdentifier = vb;
T.isJSXMemberExpression = Ab;
T.isJSXNamespacedName = Ib;
T.isJSXOpeningElement = Cb;
T.isJSXOpeningFragment = _b;
T.isJSXSpreadAttribute = wb;
T.isJSXSpreadChild = Pb;
T.isJSXText = Nb;
T.isLVal = CT;
T.isLabeledStatement = G0;
T.isLiteral = NT;
T.isLogicalExpression = rm;
T.isLoop = bT;
T.isMemberExpression = im;
T.isMetaProperty = Um;
T.isMethod = kT;
T.isMiscellaneous = GT;
T.isMixedTypeAnnotation = Dy;
T.isModuleDeclaration = ng;
T.isModuleExpression = Wb;
T.isModuleSpecifier = RT;
T.isNewExpression = sm;
T.isNoop = Db;
T.isNullLiteral = Z0;
T.isNullLiteralTypeAnnotation = fy;
T.isNullableTypeAnnotation = My;
T.isNumberLiteral = tg;
T.isNumberLiteralTypeAnnotation = By;
T.isNumberTypeAnnotation = Fy;
T.isNumericLiteral = Q0;
T.isObjectExpression = am;
T.isObjectMember = DT;
T.isObjectMethod = om;
T.isObjectPattern = qm;
T.isObjectProperty = um;
T.isObjectTypeAnnotation = jy;
T.isObjectTypeCallProperty = Uy;
T.isObjectTypeIndexer = Vy;
T.isObjectTypeInternalSlot = Ry;
T.isObjectTypeProperty = qy;
T.isObjectTypeSpreadProperty = $y;
T.isOpaqueType = Ky;
T.isOptionalCallExpression = ey;
T.isOptionalIndexedAccessType = bb;
T.isOptionalMemberExpression = Zm;
T.isParenthesizedExpression = pm;
T.isPattern = BT;
T.isPatternLike = IT;
T.isPipelineBareFunction = Xb;
T.isPipelinePrimaryTopicReference = Hb;
T.isPipelineTopicExpression = Yb;
T.isPlaceholder = Lb;
T.isPrivate = VT;
T.isPrivateName = ny;
T.isProgram = nm;
T.isProperty = LT;
T.isPureish = vT;
T.isQualifiedTypeIdentifier = Wy;
T.isRecordExpression = qb;
T.isRegExpLiteral = tm;
T.isRegexLiteral = rg;
T.isRestElement = lm;
T.isRestProperty = ig;
T.isReturnStatement = cm;
T.isScopable = cT;
T.isSequenceExpression = fm;
T.isSpreadElement = $m;
T.isSpreadProperty = sg;
T.isStandardized = oT;
T.isStatement = hT;
T.isStaticBlock = ay;
T.isStringLiteral = z0;
T.isStringLiteralTypeAnnotation = Jy;
T.isStringTypeAnnotation = Yy;
T.isSuper = Km;
T.isSwitchCase = hm;
T.isSwitchStatement = dm;
T.isSymbolTypeAnnotation = Xy;
T.isTSAnyKeyword = n1;
T.isTSArrayType = A1;
T.isTSAsExpression = K1;
T.isTSBaseType = eg;
T.isTSBigIntKeyword = o1;
T.isTSBooleanKeyword = a1;
T.isTSCallSignatureDeclaration = e1;
T.isTSConditionalType = k1;
T.isTSConstructSignatureDeclaration = t1;
T.isTSConstructorType = S1;
T.isTSDeclareFunction = zb;
T.isTSDeclareMethod = Qb;
T.isTSEntityName = wT;
T.isTSEnumDeclaration = Y1;
T.isTSEnumMember = X1;
T.isTSExportAssignment = tT;
T.isTSExpressionWithTypeArguments = R1;
T.isTSExternalModuleReference = Z1;
T.isTSFunctionType = g1;
T.isTSImportEqualsDeclaration = Q1;
T.isTSImportType = z1;
T.isTSIndexSignature = s1;
T.isTSIndexedAccessType = B1;
T.isTSInferType = D1;
T.isTSInstantiationExpression = $1;
T.isTSInterfaceBody = V1;
T.isTSInterfaceDeclaration = U1;
T.isTSIntersectionType = _1;
T.isTSIntrinsicKeyword = u1;
T.isTSLiteralType = j1;
T.isTSMappedType = F1;
T.isTSMethodSignature = i1;
T.isTSModuleBlock = G1;
T.isTSModuleDeclaration = H1;
T.isTSNamedTupleMember = N1;
T.isTSNamespaceExportDeclaration = rT;
T.isTSNeverKeyword = l1;
T.isTSNonNullExpression = eT;
T.isTSNullKeyword = c1;
T.isTSNumberKeyword = f1;
T.isTSObjectKeyword = p1;
T.isTSOptionalType = C1;
T.isTSParameterProperty = Gb;
T.isTSParenthesizedType = L1;
T.isTSPropertySignature = r1;
T.isTSQualifiedName = Zb;
T.isTSRestType = w1;
T.isTSSatisfiesExpression = W1;
T.isTSStringKeyword = h1;
T.isTSSymbolKeyword = d1;
T.isTSThisType = T1;
T.isTSTupleType = I1;
T.isTSType = ZT;
T.isTSTypeAliasDeclaration = q1;
T.isTSTypeAnnotation = iT;
T.isTSTypeAssertion = J1;
T.isTSTypeElement = QT;
T.isTSTypeLiteral = v1;
T.isTSTypeOperator = M1;
T.isTSTypeParameter = aT;
T.isTSTypeParameterDeclaration = nT;
T.isTSTypeParameterInstantiation = sT;
T.isTSTypePredicate = E1;
T.isTSTypeQuery = P1;
T.isTSTypeReference = x1;
T.isTSUndefinedKeyword = m1;
T.isTSUnionType = O1;
T.isTSUnknownKeyword = y1;
T.isTSVoidKeyword = b1;
T.isTaggedTemplateExpression = Wm;
T.isTemplateElement = Jm;
T.isTemplateLiteral = Ym;
T.isTerminatorless = dT;
T.isThisExpression = mm;
T.isThisTypeAnnotation = Hy;
T.isThrowStatement = ym;
T.isTopicReference = Jb;
T.isTryStatement = bm;
T.isTupleExpression = $b;
T.isTupleTypeAnnotation = Gy;
T.isTypeAlias = Qy;
T.isTypeAnnotation = Zy;
T.isTypeCastExpression = eb;
T.isTypeParameter = tb;
T.isTypeParameterDeclaration = rb;
T.isTypeParameterInstantiation = ib;
T.isTypeScript = zT;
T.isTypeofTypeAnnotation = zy;
T.isUnaryExpression = Tm;
T.isUnaryLike = MT;
T.isUnionTypeAnnotation = sb;
T.isUpdateExpression = gm;
T.isUserWhitespacable = _T;
T.isV8IntrinsicIdentifier = Mb;
T.isVariableDeclaration = Sm;
T.isVariableDeclarator = xm;
T.isVariance = nb;
T.isVoidTypeAnnotation = ab;
T.isWhile = TT;
T.isWhileStatement = Em;
T.isWithStatement = Pm;
T.isYieldExpression = Xm;
var E = li, ci = kr;
function C0(e, t) {
return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function w0(e, t) {
return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function N0(e, t) {
return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function O0(e, t) {
return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, E.default)(e, t);
}
function _0(e, t) {
return !e || e.type !== "Directive" ? !1 : t == null || (0, E.default)(e, t);
}
function k0(e, t) {
return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function D0(e, t) {
return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function L0(e, t) {
return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function M0(e, t) {
return !e || e.type !== "CallExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function B0(e, t) {
return !e || e.type !== "CatchClause" ? !1 : t == null || (0, E.default)(e, t);
}
function F0(e, t) {
return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function j0(e, t) {
return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function R0(e, t) {
return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function U0(e, t) {
return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function V0(e, t) {
return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function q0(e, t) {
return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function $0(e, t) {
return !e || e.type !== "File" ? !1 : t == null || (0, E.default)(e, t);
}
function K0(e, t) {
return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function W0(e, t) {
return !e || e.type !== "ForStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function J0(e, t) {
return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function Y0(e, t) {
return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function X0(e, t) {
return !e || e.type !== "Identifier" ? !1 : t == null || (0, E.default)(e, t);
}
function H0(e, t) {
return !e || e.type !== "IfStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function G0(e, t) {
return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function z0(e, t) {
return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function Q0(e, t) {
return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function Z0(e, t) {
return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function em(e, t) {
return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function tm(e, t) {
return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function rm(e, t) {
return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function im(e, t) {
return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function sm(e, t) {
return !e || e.type !== "NewExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function nm(e, t) {
return !e || e.type !== "Program" ? !1 : t == null || (0, E.default)(e, t);
}
function am(e, t) {
return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function om(e, t) {
return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, E.default)(e, t);
}
function um(e, t) {
return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, E.default)(e, t);
}
function lm(e, t) {
return !e || e.type !== "RestElement" ? !1 : t == null || (0, E.default)(e, t);
}
function cm(e, t) {
return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function fm(e, t) {
return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function pm(e, t) {
return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function hm(e, t) {
return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, E.default)(e, t);
}
function dm(e, t) {
return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function mm(e, t) {
return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function ym(e, t) {
return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function bm(e, t) {
return !e || e.type !== "TryStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function Tm(e, t) {
return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function gm(e, t) {
return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Sm(e, t) {
return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function xm(e, t) {
return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, E.default)(e, t);
}
function Em(e, t) {
return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function Pm(e, t) {
return !e || e.type !== "WithStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function vm(e, t) {
return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, E.default)(e, t);
}
function Am(e, t) {
return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, E.default)(e, t);
}
function Im(e, t) {
return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Cm(e, t) {
return !e || e.type !== "ClassBody" ? !1 : t == null || (0, E.default)(e, t);
}
function wm(e, t) {
return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Nm(e, t) {
return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function Om(e, t) {
return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function _m(e, t) {
return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function km(e, t) {
return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function Dm(e, t) {
return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, E.default)(e, t);
}
function Lm(e, t) {
return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, E.default)(e, t);
}
function Mm(e, t) {
return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function Bm(e, t) {
return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, E.default)(e, t);
}
function Fm(e, t) {
return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, E.default)(e, t);
}
function jm(e, t) {
return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, E.default)(e, t);
}
function Rm(e, t) {
return !e || e.type !== "ImportExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Um(e, t) {
return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, E.default)(e, t);
}
function Vm(e, t) {
return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, E.default)(e, t);
}
function qm(e, t) {
return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, E.default)(e, t);
}
function $m(e, t) {
return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, E.default)(e, t);
}
function Km(e, t) {
return !e || e.type !== "Super" ? !1 : t == null || (0, E.default)(e, t);
}
function Wm(e, t) {
return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Jm(e, t) {
return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, E.default)(e, t);
}
function Ym(e, t) {
return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function Xm(e, t) {
return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Hm(e, t) {
return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Gm(e, t) {
return !e || e.type !== "Import" ? !1 : t == null || (0, E.default)(e, t);
}
function zm(e, t) {
return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function Qm(e, t) {
return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, E.default)(e, t);
}
function Zm(e, t) {
return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function ey(e, t) {
return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function ty(e, t) {
return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, E.default)(e, t);
}
function ry(e, t) {
return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, E.default)(e, t);
}
function iy(e, t) {
return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, E.default)(e, t);
}
function sy(e, t) {
return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, E.default)(e, t);
}
function ny(e, t) {
return !e || e.type !== "PrivateName" ? !1 : t == null || (0, E.default)(e, t);
}
function ay(e, t) {
return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, E.default)(e, t);
}
function oy(e, t) {
return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function uy(e, t) {
return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function ly(e, t) {
return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function cy(e, t) {
return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function fy(e, t) {
return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function py(e, t) {
return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, E.default)(e, t);
}
function hy(e, t) {
return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, E.default)(e, t);
}
function dy(e, t) {
return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, E.default)(e, t);
}
function my(e, t) {
return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, E.default)(e, t);
}
function yy(e, t) {
return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, E.default)(e, t);
}
function by(e, t) {
return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, E.default)(e, t);
}
function Ty(e, t) {
return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, E.default)(e, t);
}
function gy(e, t) {
return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, E.default)(e, t);
}
function Sy(e, t) {
return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, E.default)(e, t);
}
function xy(e, t) {
return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function Ey(e, t) {
return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function Py(e, t) {
return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, E.default)(e, t);
}
function vy(e, t) {
return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function Ay(e, t) {
return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function Iy(e, t) {
return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, E.default)(e, t);
}
function Cy(e, t) {
return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function wy(e, t) {
return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, E.default)(e, t);
}
function Ny(e, t) {
return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, E.default)(e, t);
}
function Oy(e, t) {
return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function _y(e, t) {
return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function ky(e, t) {
return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function Dy(e, t) {
return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function Ly(e, t) {
return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function My(e, t) {
return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function By(e, t) {
return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function Fy(e, t) {
return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function jy(e, t) {
return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function Ry(e, t) {
return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, E.default)(e, t);
}
function Uy(e, t) {
return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, E.default)(e, t);
}
function Vy(e, t) {
return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, E.default)(e, t);
}
function qy(e, t) {
return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, E.default)(e, t);
}
function $y(e, t) {
return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, E.default)(e, t);
}
function Ky(e, t) {
return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, E.default)(e, t);
}
function Wy(e, t) {
return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, E.default)(e, t);
}
function Jy(e, t) {
return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function Yy(e, t) {
return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function Xy(e, t) {
return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function Hy(e, t) {
return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function Gy(e, t) {
return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function zy(e, t) {
return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function Qy(e, t) {
return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, E.default)(e, t);
}
function Zy(e, t) {
return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function eb(e, t) {
return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function tb(e, t) {
return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, E.default)(e, t);
}
function rb(e, t) {
return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function ib(e, t) {
return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, E.default)(e, t);
}
function sb(e, t) {
return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function nb(e, t) {
return !e || e.type !== "Variance" ? !1 : t == null || (0, E.default)(e, t);
}
function ab(e, t) {
return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function ob(e, t) {
return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function ub(e, t) {
return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, E.default)(e, t);
}
function lb(e, t) {
return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, E.default)(e, t);
}
function cb(e, t) {
return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, E.default)(e, t);
}
function fb(e, t) {
return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, E.default)(e, t);
}
function pb(e, t) {
return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, E.default)(e, t);
}
function hb(e, t) {
return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, E.default)(e, t);
}
function db(e, t) {
return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, E.default)(e, t);
}
function mb(e, t) {
return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, E.default)(e, t);
}
function yb(e, t) {
return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, E.default)(e, t);
}
function bb(e, t) {
return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, E.default)(e, t);
}
function Tb(e, t) {
return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, E.default)(e, t);
}
function gb(e, t) {
return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, E.default)(e, t);
}
function Sb(e, t) {
return !e || e.type !== "JSXElement" ? !1 : t == null || (0, E.default)(e, t);
}
function xb(e, t) {
return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Eb(e, t) {
return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, E.default)(e, t);
}
function Pb(e, t) {
return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, E.default)(e, t);
}
function vb(e, t) {
return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, E.default)(e, t);
}
function Ab(e, t) {
return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Ib(e, t) {
return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, E.default)(e, t);
}
function Cb(e, t) {
return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, E.default)(e, t);
}
function wb(e, t) {
return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, E.default)(e, t);
}
function Nb(e, t) {
return !e || e.type !== "JSXText" ? !1 : t == null || (0, E.default)(e, t);
}
function Ob(e, t) {
return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, E.default)(e, t);
}
function _b(e, t) {
return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, E.default)(e, t);
}
function kb(e, t) {
return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, E.default)(e, t);
}
function Db(e, t) {
return !e || e.type !== "Noop" ? !1 : t == null || (0, E.default)(e, t);
}
function Lb(e, t) {
return !e || e.type !== "Placeholder" ? !1 : t == null || (0, E.default)(e, t);
}
function Mb(e, t) {
return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, E.default)(e, t);
}
function Bb(e, t) {
return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, E.default)(e, t);
}
function Fb(e, t) {
return !e || e.type !== "BindExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function jb(e, t) {
return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, E.default)(e, t);
}
function Rb(e, t) {
return !e || e.type !== "Decorator" ? !1 : t == null || (0, E.default)(e, t);
}
function Ub(e, t) {
return !e || e.type !== "DoExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Vb(e, t) {
return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, E.default)(e, t);
}
function qb(e, t) {
return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function $b(e, t) {
return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Kb(e, t) {
return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function Wb(e, t) {
return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Jb(e, t) {
return !e || e.type !== "TopicReference" ? !1 : t == null || (0, E.default)(e, t);
}
function Yb(e, t) {
return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function Xb(e, t) {
return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, E.default)(e, t);
}
function Hb(e, t) {
return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, E.default)(e, t);
}
function Gb(e, t) {
return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, E.default)(e, t);
}
function zb(e, t) {
return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, E.default)(e, t);
}
function Qb(e, t) {
return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, E.default)(e, t);
}
function Zb(e, t) {
return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, E.default)(e, t);
}
function e1(e, t) {
return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function t1(e, t) {
return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function r1(e, t) {
return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, E.default)(e, t);
}
function i1(e, t) {
return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, E.default)(e, t);
}
function s1(e, t) {
return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, E.default)(e, t);
}
function n1(e, t) {
return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function a1(e, t) {
return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function o1(e, t) {
return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function u1(e, t) {
return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function l1(e, t) {
return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function c1(e, t) {
return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function f1(e, t) {
return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function p1(e, t) {
return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function h1(e, t) {
return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function d1(e, t) {
return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function m1(e, t) {
return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function y1(e, t) {
return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function b1(e, t) {
return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, E.default)(e, t);
}
function T1(e, t) {
return !e || e.type !== "TSThisType" ? !1 : t == null || (0, E.default)(e, t);
}
function g1(e, t) {
return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, E.default)(e, t);
}
function S1(e, t) {
return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, E.default)(e, t);
}
function x1(e, t) {
return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, E.default)(e, t);
}
function E1(e, t) {
return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, E.default)(e, t);
}
function P1(e, t) {
return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, E.default)(e, t);
}
function v1(e, t) {
return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function A1(e, t) {
return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, E.default)(e, t);
}
function I1(e, t) {
return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, E.default)(e, t);
}
function C1(e, t) {
return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, E.default)(e, t);
}
function w1(e, t) {
return !e || e.type !== "TSRestType" ? !1 : t == null || (0, E.default)(e, t);
}
function N1(e, t) {
return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, E.default)(e, t);
}
function O1(e, t) {
return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, E.default)(e, t);
}
function _1(e, t) {
return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, E.default)(e, t);
}
function k1(e, t) {
return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, E.default)(e, t);
}
function D1(e, t) {
return !e || e.type !== "TSInferType" ? !1 : t == null || (0, E.default)(e, t);
}
function L1(e, t) {
return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, E.default)(e, t);
}
function M1(e, t) {
return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, E.default)(e, t);
}
function B1(e, t) {
return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, E.default)(e, t);
}
function F1(e, t) {
return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, E.default)(e, t);
}
function j1(e, t) {
return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, E.default)(e, t);
}
function R1(e, t) {
return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, E.default)(e, t);
}
function U1(e, t) {
return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function V1(e, t) {
return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, E.default)(e, t);
}
function q1(e, t) {
return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function $1(e, t) {
return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function K1(e, t) {
return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function W1(e, t) {
return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function J1(e, t) {
return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, E.default)(e, t);
}
function Y1(e, t) {
return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function X1(e, t) {
return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, E.default)(e, t);
}
function H1(e, t) {
return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function G1(e, t) {
return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, E.default)(e, t);
}
function z1(e, t) {
return !e || e.type !== "TSImportType" ? !1 : t == null || (0, E.default)(e, t);
}
function Q1(e, t) {
return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function Z1(e, t) {
return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, E.default)(e, t);
}
function eT(e, t) {
return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, E.default)(e, t);
}
function tT(e, t) {
return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, E.default)(e, t);
}
function rT(e, t) {
return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function iT(e, t) {
return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, E.default)(e, t);
}
function sT(e, t) {
return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, E.default)(e, t);
}
function nT(e, t) {
return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, E.default)(e, t);
}
function aT(e, t) {
return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, E.default)(e, t);
}
function oT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ArrayExpression":
  case "AssignmentExpression":
  case "BinaryExpression":
  case "InterpreterDirective":
  case "Directive":
  case "DirectiveLiteral":
  case "BlockStatement":
  case "BreakStatement":
  case "CallExpression":
  case "CatchClause":
  case "ConditionalExpression":
  case "ContinueStatement":
  case "DebuggerStatement":
  case "DoWhileStatement":
  case "EmptyStatement":
  case "ExpressionStatement":
  case "File":
  case "ForInStatement":
  case "ForStatement":
  case "FunctionDeclaration":
  case "FunctionExpression":
  case "Identifier":
  case "IfStatement":
  case "LabeledStatement":
  case "StringLiteral":
  case "NumericLiteral":
  case "NullLiteral":
  case "BooleanLiteral":
  case "RegExpLiteral":
  case "LogicalExpression":
  case "MemberExpression":
  case "NewExpression":
  case "Program":
  case "ObjectExpression":
  case "ObjectMethod":
  case "ObjectProperty":
  case "RestElement":
  case "ReturnStatement":
  case "SequenceExpression":
  case "ParenthesizedExpression":
  case "SwitchCase":
  case "SwitchStatement":
  case "ThisExpression":
  case "ThrowStatement":
  case "TryStatement":
  case "UnaryExpression":
  case "UpdateExpression":
  case "VariableDeclaration":
  case "VariableDeclarator":
  case "WhileStatement":
  case "WithStatement":
  case "AssignmentPattern":
  case "ArrayPattern":
  case "ArrowFunctionExpression":
  case "ClassBody":
  case "ClassExpression":
  case "ClassDeclaration":
  case "ExportAllDeclaration":
  case "ExportDefaultDeclaration":
  case "ExportNamedDeclaration":
  case "ExportSpecifier":
  case "ForOfStatement":
  case "ImportDeclaration":
  case "ImportDefaultSpecifier":
  case "ImportNamespaceSpecifier":
  case "ImportSpecifier":
  case "ImportExpression":
  case "MetaProperty":
  case "ClassMethod":
  case "ObjectPattern":
  case "SpreadElement":
  case "Super":
  case "TaggedTemplateExpression":
  case "TemplateElement":
  case "TemplateLiteral":
  case "YieldExpression":
  case "AwaitExpression":
  case "Import":
  case "BigIntLiteral":
  case "ExportNamespaceSpecifier":
  case "OptionalMemberExpression":
  case "OptionalCallExpression":
  case "ClassProperty":
  case "ClassAccessorProperty":
  case "ClassPrivateProperty":
  case "ClassPrivateMethod":
  case "PrivateName":
  case "StaticBlock":
    break;
  case "Placeholder":
    switch (e.expectedNode) {
      case "Identifier":
      case "StringLiteral":
      case "BlockStatement":
      case "ClassBody":
        break;
      default:
        return !1;
    }
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function uT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ArrayExpression":
  case "AssignmentExpression":
  case "BinaryExpression":
  case "CallExpression":
  case "ConditionalExpression":
  case "FunctionExpression":
  case "Identifier":
  case "StringLiteral":
  case "NumericLiteral":
  case "NullLiteral":
  case "BooleanLiteral":
  case "RegExpLiteral":
  case "LogicalExpression":
  case "MemberExpression":
  case "NewExpression":
  case "ObjectExpression":
  case "SequenceExpression":
  case "ParenthesizedExpression":
  case "ThisExpression":
  case "UnaryExpression":
  case "UpdateExpression":
  case "ArrowFunctionExpression":
  case "ClassExpression":
  case "ImportExpression":
  case "MetaProperty":
  case "Super":
  case "TaggedTemplateExpression":
  case "TemplateLiteral":
  case "YieldExpression":
  case "AwaitExpression":
  case "Import":
  case "BigIntLiteral":
  case "OptionalMemberExpression":
  case "OptionalCallExpression":
  case "TypeCastExpression":
  case "JSXElement":
  case "JSXFragment":
  case "BindExpression":
  case "DoExpression":
  case "RecordExpression":
  case "TupleExpression":
  case "DecimalLiteral":
  case "ModuleExpression":
  case "TopicReference":
  case "PipelineTopicExpression":
  case "PipelineBareFunction":
  case "PipelinePrimaryTopicReference":
  case "TSInstantiationExpression":
  case "TSAsExpression":
  case "TSSatisfiesExpression":
  case "TSTypeAssertion":
  case "TSNonNullExpression":
    break;
  case "Placeholder":
    switch (e.expectedNode) {
      case "Expression":
      case "Identifier":
      case "StringLiteral":
        break;
      default:
        return !1;
    }
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function lT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "BinaryExpression":
  case "LogicalExpression":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function cT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "BlockStatement":
  case "CatchClause":
  case "DoWhileStatement":
  case "ForInStatement":
  case "ForStatement":
  case "FunctionDeclaration":
  case "FunctionExpression":
  case "Program":
  case "ObjectMethod":
  case "SwitchStatement":
  case "WhileStatement":
  case "ArrowFunctionExpression":
  case "ClassExpression":
  case "ClassDeclaration":
  case "ForOfStatement":
  case "ClassMethod":
  case "ClassPrivateMethod":
  case "StaticBlock":
  case "TSModuleBlock":
    break;
  case "Placeholder":
    if (e.expectedNode === "BlockStatement") break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function fT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "BlockStatement":
  case "CatchClause":
  case "DoWhileStatement":
  case "ForInStatement":
  case "ForStatement":
  case "FunctionDeclaration":
  case "FunctionExpression":
  case "Program":
  case "ObjectMethod":
  case "SwitchStatement":
  case "WhileStatement":
  case "ArrowFunctionExpression":
  case "ForOfStatement":
  case "ClassMethod":
  case "ClassPrivateMethod":
  case "StaticBlock":
  case "TSModuleBlock":
    break;
  case "Placeholder":
    if (e.expectedNode === "BlockStatement") break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function pT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "BlockStatement":
  case "Program":
  case "TSModuleBlock":
    break;
  case "Placeholder":
    if (e.expectedNode === "BlockStatement") break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function hT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "BlockStatement":
  case "BreakStatement":
  case "ContinueStatement":
  case "DebuggerStatement":
  case "DoWhileStatement":
  case "EmptyStatement":
  case "ExpressionStatement":
  case "ForInStatement":
  case "ForStatement":
  case "FunctionDeclaration":
  case "IfStatement":
  case "LabeledStatement":
  case "ReturnStatement":
  case "SwitchStatement":
  case "ThrowStatement":
  case "TryStatement":
  case "VariableDeclaration":
  case "WhileStatement":
  case "WithStatement":
  case "ClassDeclaration":
  case "ExportAllDeclaration":
  case "ExportDefaultDeclaration":
  case "ExportNamedDeclaration":
  case "ForOfStatement":
  case "ImportDeclaration":
  case "DeclareClass":
  case "DeclareFunction":
  case "DeclareInterface":
  case "DeclareModule":
  case "DeclareModuleExports":
  case "DeclareTypeAlias":
  case "DeclareOpaqueType":
  case "DeclareVariable":
  case "DeclareExportDeclaration":
  case "DeclareExportAllDeclaration":
  case "InterfaceDeclaration":
  case "OpaqueType":
  case "TypeAlias":
  case "EnumDeclaration":
  case "TSDeclareFunction":
  case "TSInterfaceDeclaration":
  case "TSTypeAliasDeclaration":
  case "TSEnumDeclaration":
  case "TSModuleDeclaration":
  case "TSImportEqualsDeclaration":
  case "TSExportAssignment":
  case "TSNamespaceExportDeclaration":
    break;
  case "Placeholder":
    switch (e.expectedNode) {
      case "Statement":
      case "Declaration":
      case "BlockStatement":
        break;
      default:
        return !1;
    }
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function dT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "BreakStatement":
  case "ContinueStatement":
  case "ReturnStatement":
  case "ThrowStatement":
  case "YieldExpression":
  case "AwaitExpression":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function mT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "BreakStatement":
  case "ContinueStatement":
  case "ReturnStatement":
  case "ThrowStatement":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function yT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ConditionalExpression":
  case "IfStatement":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function bT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "DoWhileStatement":
  case "ForInStatement":
  case "ForStatement":
  case "WhileStatement":
  case "ForOfStatement":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function TT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "DoWhileStatement":
  case "WhileStatement":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function gT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ExpressionStatement":
  case "ParenthesizedExpression":
  case "TypeCastExpression":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function ST(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ForInStatement":
  case "ForStatement":
  case "ForOfStatement":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function xT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ForInStatement":
  case "ForOfStatement":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function ET(e, t) {
if (!e) return !1;
switch (e.type) {
  case "FunctionDeclaration":
  case "FunctionExpression":
  case "ObjectMethod":
  case "ArrowFunctionExpression":
  case "ClassMethod":
  case "ClassPrivateMethod":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function PT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "FunctionDeclaration":
  case "FunctionExpression":
  case "ObjectMethod":
  case "ArrowFunctionExpression":
  case "ClassMethod":
  case "ClassPrivateMethod":
  case "StaticBlock":
  case "TSModuleBlock":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function vT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "FunctionDeclaration":
  case "FunctionExpression":
  case "StringLiteral":
  case "NumericLiteral":
  case "NullLiteral":
  case "BooleanLiteral":
  case "RegExpLiteral":
  case "ArrowFunctionExpression":
  case "BigIntLiteral":
  case "DecimalLiteral":
    break;
  case "Placeholder":
    if (e.expectedNode === "StringLiteral") break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function AT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "FunctionDeclaration":
  case "VariableDeclaration":
  case "ClassDeclaration":
  case "ExportAllDeclaration":
  case "ExportDefaultDeclaration":
  case "ExportNamedDeclaration":
  case "ImportDeclaration":
  case "DeclareClass":
  case "DeclareFunction":
  case "DeclareInterface":
  case "DeclareModule":
  case "DeclareModuleExports":
  case "DeclareTypeAlias":
  case "DeclareOpaqueType":
  case "DeclareVariable":
  case "DeclareExportDeclaration":
  case "DeclareExportAllDeclaration":
  case "InterfaceDeclaration":
  case "OpaqueType":
  case "TypeAlias":
  case "EnumDeclaration":
  case "TSDeclareFunction":
  case "TSInterfaceDeclaration":
  case "TSTypeAliasDeclaration":
  case "TSEnumDeclaration":
  case "TSModuleDeclaration":
    break;
  case "Placeholder":
    if (e.expectedNode === "Declaration") break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function IT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "Identifier":
  case "RestElement":
  case "AssignmentPattern":
  case "ArrayPattern":
  case "ObjectPattern":
  case "TSAsExpression":
  case "TSSatisfiesExpression":
  case "TSTypeAssertion":
  case "TSNonNullExpression":
    break;
  case "Placeholder":
    switch (e.expectedNode) {
      case "Pattern":
      case "Identifier":
        break;
      default:
        return !1;
    }
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function CT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "Identifier":
  case "MemberExpression":
  case "RestElement":
  case "AssignmentPattern":
  case "ArrayPattern":
  case "ObjectPattern":
  case "TSParameterProperty":
  case "TSAsExpression":
  case "TSSatisfiesExpression":
  case "TSTypeAssertion":
  case "TSNonNullExpression":
    break;
  case "Placeholder":
    switch (e.expectedNode) {
      case "Pattern":
      case "Identifier":
        break;
      default:
        return !1;
    }
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function wT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "Identifier":
  case "TSQualifiedName":
    break;
  case "Placeholder":
    if (e.expectedNode === "Identifier") break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function NT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "StringLiteral":
  case "NumericLiteral":
  case "NullLiteral":
  case "BooleanLiteral":
  case "RegExpLiteral":
  case "TemplateLiteral":
  case "BigIntLiteral":
  case "DecimalLiteral":
    break;
  case "Placeholder":
    if (e.expectedNode === "StringLiteral") break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function OT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "StringLiteral":
  case "NumericLiteral":
  case "NullLiteral":
  case "BooleanLiteral":
  case "BigIntLiteral":
  case "JSXAttribute":
  case "JSXClosingElement":
  case "JSXElement":
  case "JSXExpressionContainer":
  case "JSXSpreadChild":
  case "JSXOpeningElement":
  case "JSXText":
  case "JSXFragment":
  case "JSXOpeningFragment":
  case "JSXClosingFragment":
  case "DecimalLiteral":
    break;
  case "Placeholder":
    if (e.expectedNode === "StringLiteral") break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function _T(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ObjectMethod":
  case "ObjectProperty":
  case "ObjectTypeInternalSlot":
  case "ObjectTypeCallProperty":
  case "ObjectTypeIndexer":
  case "ObjectTypeProperty":
  case "ObjectTypeSpreadProperty":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function kT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ObjectMethod":
  case "ClassMethod":
  case "ClassPrivateMethod":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function DT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ObjectMethod":
  case "ObjectProperty":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function LT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ObjectProperty":
  case "ClassProperty":
  case "ClassAccessorProperty":
  case "ClassPrivateProperty":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function MT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "UnaryExpression":
  case "SpreadElement":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function BT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "AssignmentPattern":
  case "ArrayPattern":
  case "ObjectPattern":
    break;
  case "Placeholder":
    if (e.expectedNode === "Pattern") break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function FT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ClassExpression":
  case "ClassDeclaration":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function Jl(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ExportAllDeclaration":
  case "ExportDefaultDeclaration":
  case "ExportNamedDeclaration":
  case "ImportDeclaration":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function jT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ExportAllDeclaration":
  case "ExportDefaultDeclaration":
  case "ExportNamedDeclaration":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function RT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ExportSpecifier":
  case "ImportDefaultSpecifier":
  case "ImportNamespaceSpecifier":
  case "ImportSpecifier":
  case "ExportNamespaceSpecifier":
  case "ExportDefaultSpecifier":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function UT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ClassAccessorProperty":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function VT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "ClassPrivateProperty":
  case "ClassPrivateMethod":
  case "PrivateName":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function qT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "AnyTypeAnnotation":
  case "ArrayTypeAnnotation":
  case "BooleanTypeAnnotation":
  case "BooleanLiteralTypeAnnotation":
  case "NullLiteralTypeAnnotation":
  case "ClassImplements":
  case "DeclareClass":
  case "DeclareFunction":
  case "DeclareInterface":
  case "DeclareModule":
  case "DeclareModuleExports":
  case "DeclareTypeAlias":
  case "DeclareOpaqueType":
  case "DeclareVariable":
  case "DeclareExportDeclaration":
  case "DeclareExportAllDeclaration":
  case "DeclaredPredicate":
  case "ExistsTypeAnnotation":
  case "FunctionTypeAnnotation":
  case "FunctionTypeParam":
  case "GenericTypeAnnotation":
  case "InferredPredicate":
  case "InterfaceExtends":
  case "InterfaceDeclaration":
  case "InterfaceTypeAnnotation":
  case "IntersectionTypeAnnotation":
  case "MixedTypeAnnotation":
  case "EmptyTypeAnnotation":
  case "NullableTypeAnnotation":
  case "NumberLiteralTypeAnnotation":
  case "NumberTypeAnnotation":
  case "ObjectTypeAnnotation":
  case "ObjectTypeInternalSlot":
  case "ObjectTypeCallProperty":
  case "ObjectTypeIndexer":
  case "ObjectTypeProperty":
  case "ObjectTypeSpreadProperty":
  case "OpaqueType":
  case "QualifiedTypeIdentifier":
  case "StringLiteralTypeAnnotation":
  case "StringTypeAnnotation":
  case "SymbolTypeAnnotation":
  case "ThisTypeAnnotation":
  case "TupleTypeAnnotation":
  case "TypeofTypeAnnotation":
  case "TypeAlias":
  case "TypeAnnotation":
  case "TypeCastExpression":
  case "TypeParameter":
  case "TypeParameterDeclaration":
  case "TypeParameterInstantiation":
  case "UnionTypeAnnotation":
  case "Variance":
  case "VoidTypeAnnotation":
  case "EnumDeclaration":
  case "EnumBooleanBody":
  case "EnumNumberBody":
  case "EnumStringBody":
  case "EnumSymbolBody":
  case "EnumBooleanMember":
  case "EnumNumberMember":
  case "EnumStringMember":
  case "EnumDefaultedMember":
  case "IndexedAccessType":
  case "OptionalIndexedAccessType":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function $T(e, t) {
if (!e) return !1;
switch (e.type) {
  case "AnyTypeAnnotation":
  case "ArrayTypeAnnotation":
  case "BooleanTypeAnnotation":
  case "BooleanLiteralTypeAnnotation":
  case "NullLiteralTypeAnnotation":
  case "ExistsTypeAnnotation":
  case "FunctionTypeAnnotation":
  case "GenericTypeAnnotation":
  case "InterfaceTypeAnnotation":
  case "IntersectionTypeAnnotation":
  case "MixedTypeAnnotation":
  case "EmptyTypeAnnotation":
  case "NullableTypeAnnotation":
  case "NumberLiteralTypeAnnotation":
  case "NumberTypeAnnotation":
  case "ObjectTypeAnnotation":
  case "StringLiteralTypeAnnotation":
  case "StringTypeAnnotation":
  case "SymbolTypeAnnotation":
  case "ThisTypeAnnotation":
  case "TupleTypeAnnotation":
  case "TypeofTypeAnnotation":
  case "UnionTypeAnnotation":
  case "VoidTypeAnnotation":
  case "IndexedAccessType":
  case "OptionalIndexedAccessType":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function KT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "AnyTypeAnnotation":
  case "BooleanTypeAnnotation":
  case "NullLiteralTypeAnnotation":
  case "MixedTypeAnnotation":
  case "EmptyTypeAnnotation":
  case "NumberTypeAnnotation":
  case "StringTypeAnnotation":
  case "SymbolTypeAnnotation":
  case "ThisTypeAnnotation":
  case "VoidTypeAnnotation":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function WT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "DeclareClass":
  case "DeclareFunction":
  case "DeclareInterface":
  case "DeclareModule":
  case "DeclareModuleExports":
  case "DeclareTypeAlias":
  case "DeclareOpaqueType":
  case "DeclareVariable":
  case "DeclareExportDeclaration":
  case "DeclareExportAllDeclaration":
  case "InterfaceDeclaration":
  case "OpaqueType":
  case "TypeAlias":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function JT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "DeclaredPredicate":
  case "InferredPredicate":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function YT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "EnumBooleanBody":
  case "EnumNumberBody":
  case "EnumStringBody":
  case "EnumSymbolBody":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function XT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "EnumBooleanMember":
  case "EnumNumberMember":
  case "EnumStringMember":
  case "EnumDefaultedMember":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function HT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "JSXAttribute":
  case "JSXClosingElement":
  case "JSXElement":
  case "JSXEmptyExpression":
  case "JSXExpressionContainer":
  case "JSXSpreadChild":
  case "JSXIdentifier":
  case "JSXMemberExpression":
  case "JSXNamespacedName":
  case "JSXOpeningElement":
  case "JSXSpreadAttribute":
  case "JSXText":
  case "JSXFragment":
  case "JSXOpeningFragment":
  case "JSXClosingFragment":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function GT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "Noop":
  case "Placeholder":
  case "V8IntrinsicIdentifier":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function zT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "TSParameterProperty":
  case "TSDeclareFunction":
  case "TSDeclareMethod":
  case "TSQualifiedName":
  case "TSCallSignatureDeclaration":
  case "TSConstructSignatureDeclaration":
  case "TSPropertySignature":
  case "TSMethodSignature":
  case "TSIndexSignature":
  case "TSAnyKeyword":
  case "TSBooleanKeyword":
  case "TSBigIntKeyword":
  case "TSIntrinsicKeyword":
  case "TSNeverKeyword":
  case "TSNullKeyword":
  case "TSNumberKeyword":
  case "TSObjectKeyword":
  case "TSStringKeyword":
  case "TSSymbolKeyword":
  case "TSUndefinedKeyword":
  case "TSUnknownKeyword":
  case "TSVoidKeyword":
  case "TSThisType":
  case "TSFunctionType":
  case "TSConstructorType":
  case "TSTypeReference":
  case "TSTypePredicate":
  case "TSTypeQuery":
  case "TSTypeLiteral":
  case "TSArrayType":
  case "TSTupleType":
  case "TSOptionalType":
  case "TSRestType":
  case "TSNamedTupleMember":
  case "TSUnionType":
  case "TSIntersectionType":
  case "TSConditionalType":
  case "TSInferType":
  case "TSParenthesizedType":
  case "TSTypeOperator":
  case "TSIndexedAccessType":
  case "TSMappedType":
  case "TSLiteralType":
  case "TSExpressionWithTypeArguments":
  case "TSInterfaceDeclaration":
  case "TSInterfaceBody":
  case "TSTypeAliasDeclaration":
  case "TSInstantiationExpression":
  case "TSAsExpression":
  case "TSSatisfiesExpression":
  case "TSTypeAssertion":
  case "TSEnumDeclaration":
  case "TSEnumMember":
  case "TSModuleDeclaration":
  case "TSModuleBlock":
  case "TSImportType":
  case "TSImportEqualsDeclaration":
  case "TSExternalModuleReference":
  case "TSNonNullExpression":
  case "TSExportAssignment":
  case "TSNamespaceExportDeclaration":
  case "TSTypeAnnotation":
  case "TSTypeParameterInstantiation":
  case "TSTypeParameterDeclaration":
  case "TSTypeParameter":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function QT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "TSCallSignatureDeclaration":
  case "TSConstructSignatureDeclaration":
  case "TSPropertySignature":
  case "TSMethodSignature":
  case "TSIndexSignature":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function ZT(e, t) {
if (!e) return !1;
switch (e.type) {
  case "TSAnyKeyword":
  case "TSBooleanKeyword":
  case "TSBigIntKeyword":
  case "TSIntrinsicKeyword":
  case "TSNeverKeyword":
  case "TSNullKeyword":
  case "TSNumberKeyword":
  case "TSObjectKeyword":
  case "TSStringKeyword":
  case "TSSymbolKeyword":
  case "TSUndefinedKeyword":
  case "TSUnknownKeyword":
  case "TSVoidKeyword":
  case "TSThisType":
  case "TSFunctionType":
  case "TSConstructorType":
  case "TSTypeReference":
  case "TSTypePredicate":
  case "TSTypeQuery":
  case "TSTypeLiteral":
  case "TSArrayType":
  case "TSTupleType":
  case "TSOptionalType":
  case "TSRestType":
  case "TSUnionType":
  case "TSIntersectionType":
  case "TSConditionalType":
  case "TSInferType":
  case "TSParenthesizedType":
  case "TSTypeOperator":
  case "TSIndexedAccessType":
  case "TSMappedType":
  case "TSLiteralType":
  case "TSExpressionWithTypeArguments":
  case "TSImportType":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function eg(e, t) {
if (!e) return !1;
switch (e.type) {
  case "TSAnyKeyword":
  case "TSBooleanKeyword":
  case "TSBigIntKeyword":
  case "TSIntrinsicKeyword":
  case "TSNeverKeyword":
  case "TSNullKeyword":
  case "TSNumberKeyword":
  case "TSObjectKeyword":
  case "TSStringKeyword":
  case "TSSymbolKeyword":
  case "TSUndefinedKeyword":
  case "TSUnknownKeyword":
  case "TSVoidKeyword":
  case "TSThisType":
  case "TSLiteralType":
    break;
  default:
    return !1;
}
return t == null || (0, E.default)(e, t);
}
function tg(e, t) {
return (0, ci.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function rg(e, t) {
return (0, ci.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, E.default)(e, t);
}
function ig(e, t) {
return (0, ci.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, E.default)(e, t);
}
function sg(e, t) {
return (0, ci.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, E.default)(e, t);
}
function ng(e, t) {
return (0, ci.default)("isModuleDeclaration", "isImportOrExportDeclaration"), Jl(e, t);
}
Object.defineProperty(Ts, "__esModule", {
value: !0
});
Ts.default = ag;
var jr = T;
function ag(e, t, r) {
if (!(0, jr.isMemberExpression)(e)) return !1;
const i = Array.isArray(t) ? t : t.split("."), s = [];
let n;
for (n = e; (0, jr.isMemberExpression)(n); n = n.object)
  s.push(n.property);
if (s.push(n), s.length < i.length || !r && s.length > i.length) return !1;
for (let a = 0, o = s.length - 1; a < i.length; a++, o--) {
  const u = s[o];
  let l;
  if ((0, jr.isIdentifier)(u))
    l = u.name;
  else if ((0, jr.isStringLiteral)(u))
    l = u.value;
  else if ((0, jr.isThisExpression)(u))
    l = "this";
  else
    return !1;
  if (i[a] !== l) return !1;
}
return !0;
}
Object.defineProperty(bs, "__esModule", {
value: !0
});
bs.default = ug;
var og = Ts;
function ug(e, t) {
const r = e.split(".");
return (i) => (0, og.default)(i, r, t);
}
Object.defineProperty(ys, "__esModule", {
value: !0
});
ys.default = void 0;
var lg = bs;
const cg = (0, lg.default)("React.Component");
ys.default = cg;
var ra = {};
Object.defineProperty(ra, "__esModule", {
value: !0
});
ra.default = fg;
function fg(e) {
return !!e && /^[a-z]/.test(e);
}
var ki = {}, Di = {}, b = {}, Li = {}, Cr = {}, sn = {};
let Rr = null;
function ri(e) {
if (Rr !== null && typeof Rr.property) {
  const t = Rr;
  return Rr = ri.prototype = null, t;
}
return Rr = ri.prototype = e ?? /* @__PURE__ */ Object.create(null), new ri();
}
ri();
var pg = function(t) {
return ri(t);
}, mt = {}, Mi = {}, Bi = {}, To;
function ia() {
if (To) return Bi;
To = 1, Object.defineProperty(Bi, "__esModule", {
  value: !0
}), Bi.default = t;
var e = Dt();
function t(r, i) {
  if (r === i) return !0;
  if (r == null || e.ALIAS_KEYS[i]) return !1;
  const s = e.FLIPPED_ALIAS_KEYS[i];
  if (s) {
    if (s[0] === r) return !0;
    for (const n of s)
      if (r === n) return !0;
  }
  return !1;
}
return Bi;
}
var Fi = {}, go;
function Yl() {
if (go) return Fi;
go = 1, Object.defineProperty(Fi, "__esModule", {
  value: !0
}), Fi.default = t;
var e = Dt();
function t(r, i) {
  if (r === i) return !0;
  const s = e.PLACEHOLDERS_ALIAS[r];
  if (s) {
    for (const n of s)
      if (i === n) return !0;
  }
  return !1;
}
return Fi;
}
var So;
function fi() {
if (So) return Mi;
So = 1, Object.defineProperty(Mi, "__esModule", {
  value: !0
}), Mi.default = s;
var e = li, t = ia(), r = Yl(), i = Dt();
function s(n, a, o) {
  return a ? (0, t.default)(a.type, n) ? typeof o > "u" ? !0 : (0, e.default)(a, o) : !o && a.type === "Placeholder" && n in i.FLIPPED_ALIAS_KEYS ? (0, r.default)(a.expectedNode, n) : !1 : !1;
}
return Mi;
}
var gr = {}, pi = {}, hi = {};
Object.defineProperty(hi, "__esModule", {
value: !0
});
hi.isIdentifierChar = zl;
hi.isIdentifierName = yg;
hi.isIdentifierStart = Gl;
let sa = "", Xl = "";
const hg = new RegExp("[" + sa + "]"), dg = new RegExp("[" + sa + Xl + "]");
sa = Xl = null;
const Hl = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], mg = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function Dn(e, t) {
let r = 65536;
for (let i = 0, s = t.length; i < s; i += 2) {
  if (r += t[i], r > e) return !1;
  if (r += t[i + 1], r >= e) return !0;
}
return !1;
}
function Gl(e) {
return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && hg.test(String.fromCharCode(e)) : Dn(e, Hl);
}
function zl(e) {
return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && dg.test(String.fromCharCode(e)) : Dn(e, Hl) || Dn(e, mg);
}
function yg(e) {
let t = !0;
for (let r = 0; r < e.length; r++) {
  let i = e.charCodeAt(r);
  if ((i & 64512) === 55296 && r + 1 < e.length) {
    const s = e.charCodeAt(++r);
    (s & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (s & 1023));
  }
  if (t) {
    if (t = !1, !Gl(i))
      return !1;
  } else if (!zl(i))
    return !1;
}
return !t;
}
var Sr = {};
Object.defineProperty(Sr, "__esModule", {
value: !0
});
Sr.isKeyword = xg;
Sr.isReservedWord = Ql;
Sr.isStrictBindOnlyReservedWord = ec;
Sr.isStrictBindReservedWord = Sg;
Sr.isStrictReservedWord = Zl;
const na = {
keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
strictBind: ["eval", "arguments"]
}, bg = new Set(na.keyword), Tg = new Set(na.strict), gg = new Set(na.strictBind);
function Ql(e, t) {
return t && e === "await" || e === "enum";
}
function Zl(e, t) {
return Ql(e, t) || Tg.has(e);
}
function ec(e) {
return gg.has(e);
}
function Sg(e, t) {
return Zl(e, t) || ec(e);
}
function xg(e) {
return bg.has(e);
}
(function(e) {
Object.defineProperty(e, "__esModule", {
  value: !0
}), Object.defineProperty(e, "isIdentifierChar", {
  enumerable: !0,
  get: function() {
    return t.isIdentifierChar;
  }
}), Object.defineProperty(e, "isIdentifierName", {
  enumerable: !0,
  get: function() {
    return t.isIdentifierName;
  }
}), Object.defineProperty(e, "isIdentifierStart", {
  enumerable: !0,
  get: function() {
    return t.isIdentifierStart;
  }
}), Object.defineProperty(e, "isKeyword", {
  enumerable: !0,
  get: function() {
    return r.isKeyword;
  }
}), Object.defineProperty(e, "isReservedWord", {
  enumerable: !0,
  get: function() {
    return r.isReservedWord;
  }
}), Object.defineProperty(e, "isStrictBindOnlyReservedWord", {
  enumerable: !0,
  get: function() {
    return r.isStrictBindOnlyReservedWord;
  }
}), Object.defineProperty(e, "isStrictBindReservedWord", {
  enumerable: !0,
  get: function() {
    return r.isStrictBindReservedWord;
  }
}), Object.defineProperty(e, "isStrictReservedWord", {
  enumerable: !0,
  get: function() {
    return r.isStrictReservedWord;
  }
});
var t = hi, r = Sr;
})(pi);
Object.defineProperty(gr, "__esModule", {
value: !0
});
gr.default = Eg;
var nn = pi;
function Eg(e, t = !0) {
return typeof e != "string" || t && ((0, nn.isKeyword)(e) || (0, nn.isStrictReservedWord)(e, !0)) ? !1 : (0, nn.isIdentifierName)(e);
}
var di = {};
Object.defineProperty(di, "__esModule", {
value: !0
});
di.readCodePoint = rc;
di.readInt = tc;
di.readStringContents = vg;
var Pg = function(t) {
return t >= 48 && t <= 57;
};
const xo = {
decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
}, ji = {
bin: (e) => e === 48 || e === 49,
oct: (e) => e >= 48 && e <= 55,
dec: (e) => e >= 48 && e <= 57,
hex: (e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102
};
function vg(e, t, r, i, s, n) {
const a = r, o = i, u = s;
let l = "", c = null, f = r;
const {
  length: p
} = t;
for (; ; ) {
  if (r >= p) {
    n.unterminated(a, o, u), l += t.slice(f, r);
    break;
  }
  const h = t.charCodeAt(r);
  if (Ag(e, h, t, r)) {
    l += t.slice(f, r);
    break;
  }
  if (h === 92) {
    l += t.slice(f, r);
    const y = Ig(t, r, i, s, e === "template", n);
    y.ch === null && !c ? c = {
      pos: r,
      lineStart: i,
      curLine: s
    } : l += y.ch, {
      pos: r,
      lineStart: i,
      curLine: s
    } = y, f = r;
  } else h === 8232 || h === 8233 ? (++r, ++s, i = r) : h === 10 || h === 13 ? e === "template" ? (l += t.slice(f, r) + `
`, ++r, h === 13 && t.charCodeAt(r) === 10 && ++r, ++s, f = i = r) : n.unterminated(a, o, u) : ++r;
}
return {
  pos: r,
  str: l,
  firstInvalidLoc: c,
  lineStart: i,
  curLine: s,
  containsInvalid: !!c
};
}
function Ag(e, t, r, i) {
return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
}
function Ig(e, t, r, i, s, n) {
const a = !s;
t++;
const o = (l) => ({
  pos: t,
  ch: l,
  lineStart: r,
  curLine: i
}), u = e.charCodeAt(t++);
switch (u) {
  case 110:
    return o(`
`);
  case 114:
    return o("\r");
  case 120: {
    let l;
    return {
      code: l,
      pos: t
    } = Ln(e, t, r, i, 2, !1, a, n), o(l === null ? null : String.fromCharCode(l));
  }
  case 117: {
    let l;
    return {
      code: l,
      pos: t
    } = rc(e, t, r, i, a, n), o(l === null ? null : String.fromCodePoint(l));
  }
  case 116:
    return o("	");
  case 98:
    return o("\b");
  case 118:
    return o("\v");
  case 102:
    return o("\f");
  case 13:
    e.charCodeAt(t) === 10 && ++t;
  case 10:
    r = t, ++i;
  case 8232:
  case 8233:
    return o("");
  case 56:
  case 57:
    if (s)
      return o(null);
    n.strictNumericEscape(t - 1, r, i);
  default:
    if (u >= 48 && u <= 55) {
      const l = t - 1;
      let f = /^[0-7]+/.exec(e.slice(l, t + 2))[0], p = parseInt(f, 8);
      p > 255 && (f = f.slice(0, -1), p = parseInt(f, 8)), t += f.length - 1;
      const h = e.charCodeAt(t);
      if (f !== "0" || h === 56 || h === 57) {
        if (s)
          return o(null);
        n.strictNumericEscape(l, r, i);
      }
      return o(String.fromCharCode(p));
    }
    return o(String.fromCharCode(u));
}
}
function Ln(e, t, r, i, s, n, a, o) {
const u = t;
let l;
return {
  n: l,
  pos: t
} = tc(e, t, r, i, 16, s, n, !1, o, !a), l === null && (a ? o.invalidEscapeSequence(u, r, i) : t = u - 1), {
  code: l,
  pos: t
};
}
function tc(e, t, r, i, s, n, a, o, u, l) {
const c = t, f = s === 16 ? xo.hex : xo.decBinOct, p = s === 16 ? ji.hex : s === 10 ? ji.dec : s === 8 ? ji.oct : ji.bin;
let h = !1, y = 0;
for (let g = 0, A = n ?? 1 / 0; g < A; ++g) {
  const C = e.charCodeAt(t);
  let _;
  if (C === 95 && o !== "bail") {
    const j = e.charCodeAt(t - 1), G = e.charCodeAt(t + 1);
    if (o) {
      if (Number.isNaN(G) || !p(G) || f.has(j) || f.has(G)) {
        if (l) return {
          n: null,
          pos: t
        };
        u.unexpectedNumericSeparator(t, r, i);
      }
    } else {
      if (l) return {
        n: null,
        pos: t
      };
      u.numericSeparatorInEscapeSequence(t, r, i);
    }
    ++t;
    continue;
  }
  if (C >= 97 ? _ = C - 97 + 10 : C >= 65 ? _ = C - 65 + 10 : Pg(C) ? _ = C - 48 : _ = 1 / 0, _ >= s) {
    if (_ <= 9 && l)
      return {
        n: null,
        pos: t
      };
    if (_ <= 9 && u.invalidDigit(t, r, i, s))
      _ = 0;
    else if (a)
      _ = 0, h = !0;
    else
      break;
  }
  ++t, y = y * s + _;
}
return t === c || n != null && t - c !== n || h ? {
  n: null,
  pos: t
} : {
  n: y,
  pos: t
};
}
function rc(e, t, r, i, s, n) {
const a = e.charCodeAt(t);
let o;
if (a === 123) {
  if (++t, {
    code: o,
    pos: t
  } = Ln(e, t, r, i, e.indexOf("}", t) - t, !0, s, n), ++t, o !== null && o > 1114111)
    if (s)
      n.invalidCodePoint(t, r, i);
    else
      return {
        code: null,
        pos: t
      };
} else
  ({
    code: o,
    pos: t
  } = Ln(e, t, r, i, 4, !1, s, n));
return {
  code: o,
  pos: t
};
}
var xe = {};
Object.defineProperty(xe, "__esModule", {
value: !0
});
xe.UPDATE_OPERATORS = xe.UNARY_OPERATORS = xe.STRING_UNARY_OPERATORS = xe.STATEMENT_OR_BLOCK_KEYS = xe.NUMBER_UNARY_OPERATORS = xe.NUMBER_BINARY_OPERATORS = xe.NOT_LOCAL_BINDING = xe.LOGICAL_OPERATORS = xe.INHERIT_KEYS = xe.FOR_INIT_KEYS = xe.FLATTENABLE_KEYS = xe.EQUALITY_BINARY_OPERATORS = xe.COMPARISON_BINARY_OPERATORS = xe.COMMENT_KEYS = xe.BOOLEAN_UNARY_OPERATORS = xe.BOOLEAN_NUMBER_BINARY_OPERATORS = xe.BOOLEAN_BINARY_OPERATORS = xe.BLOCK_SCOPED_SYMBOL = xe.BINARY_OPERATORS = xe.ASSIGNMENT_OPERATORS = void 0;
xe.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
xe.FLATTENABLE_KEYS = ["body", "expressions"];
xe.FOR_INIT_KEYS = ["left", "init"];
xe.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
const Cg = xe.LOGICAL_OPERATORS = ["||", "&&", "??"];
xe.UPDATE_OPERATORS = ["++", "--"];
const wg = xe.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], Ng = xe.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], Og = xe.COMPARISON_BINARY_OPERATORS = [...Ng, "in", "instanceof"], _g = xe.BOOLEAN_BINARY_OPERATORS = [...Og, ...wg], ic = xe.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
xe.BINARY_OPERATORS = ["+", ...ic, ..._g, "|>"];
xe.ASSIGNMENT_OPERATORS = ["=", "+=", ...ic.map((e) => e + "="), ...Cg.map((e) => e + "=")];
const kg = xe.BOOLEAN_UNARY_OPERATORS = ["delete", "!"], Dg = xe.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], Lg = xe.STRING_UNARY_OPERATORS = ["typeof"];
xe.UNARY_OPERATORS = ["void", "throw", ...kg, ...Dg, ...Lg];
xe.INHERIT_KEYS = {
optional: ["typeAnnotation", "typeParameters", "returnType"],
force: ["start", "loc", "end"]
};
xe.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
xe.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
var Le = {}, Eo;
function ur() {
if (Eo) return Le;
Eo = 1, Object.defineProperty(Le, "__esModule", {
  value: !0
}), Le.VISITOR_KEYS = Le.NODE_PARENT_VALIDATIONS = Le.NODE_FIELDS = Le.FLIPPED_ALIAS_KEYS = Le.DEPRECATED_KEYS = Le.BUILDER_KEYS = Le.ALIAS_KEYS = void 0, Le.arrayOf = g, Le.arrayOfType = A, Le.assertEach = _, Le.assertNodeOrValueType = fe, Le.assertNodeType = G, Le.assertOneOf = j, Le.assertOptionalChainStart = K, Le.assertShape = oe, Le.assertValueType = re, Le.chain = X, Le.default = L, Le.defineAliasedType = U, Le.typeIs = f, Le.validate = c, Le.validateArrayOfType = C, Le.validateOptional = h, Le.validateOptionalType = y, Le.validateType = p;
var e = fi(), t = aa();
const r = Le.VISITOR_KEYS = {}, i = Le.ALIAS_KEYS = {}, s = Le.FLIPPED_ALIAS_KEYS = {}, n = Le.NODE_FIELDS = {}, a = Le.BUILDER_KEYS = {}, o = Le.DEPRECATED_KEYS = {}, u = Le.NODE_PARENT_VALIDATIONS = {};
function l(k) {
  return Array.isArray(k) ? "array" : k === null ? "null" : typeof k;
}
function c(k) {
  return {
    validate: k
  };
}
function f(k) {
  return typeof k == "string" ? G(k) : G(...k);
}
function p(k) {
  return c(f(k));
}
function h(k) {
  return {
    validate: k,
    optional: !0
  };
}
function y(k) {
  return {
    validate: f(k),
    optional: !0
  };
}
function g(k) {
  return X(re("array"), _(k));
}
function A(k) {
  return g(f(k));
}
function C(k) {
  return c(A(k));
}
function _(k) {
  function F(B, O, D) {
    if (Array.isArray(D))
      for (let R = 0; R < D.length; R++) {
        const q = `${O}[${R}]`, V = D[R];
        k(B, q, V), process.env.BABEL_TYPES_8_BREAKING && (0, t.validateChild)(B, q, V);
      }
  }
  return F.each = k, F;
}
function j(...k) {
  function F(B, O, D) {
    if (!k.includes(D))
      throw new TypeError(`Property ${O} expected value to be one of ${JSON.stringify(k)} but got ${JSON.stringify(D)}`);
  }
  return F.oneOf = k, F;
}
function G(...k) {
  function F(B, O, D) {
    for (const R of k)
      if ((0, e.default)(R, D)) {
        (0, t.validateChild)(B, O, D);
        return;
      }
    throw new TypeError(`Property ${O} of ${B.type} expected node to be of a type ${JSON.stringify(k)} but instead got ${JSON.stringify(D == null ? void 0 : D.type)}`);
  }
  return F.oneOfNodeTypes = k, F;
}
function fe(...k) {
  function F(B, O, D) {
    for (const R of k)
      if (l(D) === R || (0, e.default)(R, D)) {
        (0, t.validateChild)(B, O, D);
        return;
      }
    throw new TypeError(`Property ${O} of ${B.type} expected node to be of a type ${JSON.stringify(k)} but instead got ${JSON.stringify(D == null ? void 0 : D.type)}`);
  }
  return F.oneOfNodeOrValueTypes = k, F;
}
function re(k) {
  function F(B, O, D) {
    if (!(l(D) === k))
      throw new TypeError(`Property ${O} expected type of ${k} but got ${l(D)}`);
  }
  return F.type = k, F;
}
function oe(k) {
  function F(B, O, D) {
    const R = [];
    for (const q of Object.keys(k))
      try {
        (0, t.validateField)(B, q, D[q], k[q]);
      } catch (V) {
        if (V instanceof TypeError) {
          R.push(V.message);
          continue;
        }
        throw V;
      }
    if (R.length)
      throw new TypeError(`Property ${O} of ${B.type} expected to have the following:
${R.join(`
`)}`);
  }
  return F.shapeOf = k, F;
}
function K() {
  function k(F) {
    var B;
    let O = F;
    for (; F; ) {
      const {
        type: D
      } = O;
      if (D === "OptionalCallExpression") {
        if (O.optional) return;
        O = O.callee;
        continue;
      }
      if (D === "OptionalMemberExpression") {
        if (O.optional) return;
        O = O.object;
        continue;
      }
      break;
    }
    throw new TypeError(`Non-optional ${F.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(B = O) == null ? void 0 : B.type}`);
  }
  return k;
}
function X(...k) {
  function F(...B) {
    for (const O of k)
      O(...B);
  }
  if (F.chainOf = k, k.length >= 2 && "type" in k[0] && k[0].type === "array" && !("each" in k[1]))
    throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
  return F;
}
const ie = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], W = ["default", "optional", "deprecated", "validate"], Q = {};
function U(...k) {
  return (F, B = {}) => {
    let O = B.aliases;
    if (!O) {
      var D, R;
      B.inherits && (O = (D = Q[B.inherits].aliases) == null ? void 0 : D.slice()), (R = O) != null || (O = []), B.aliases = O;
    }
    const q = k.filter((V) => !O.includes(V));
    O.unshift(...q), L(F, B);
  };
}
function L(k, F = {}) {
  const B = F.inherits && Q[F.inherits] || {};
  let O = F.fields;
  if (!O && (O = {}, B.fields)) {
    const V = Object.getOwnPropertyNames(B.fields);
    for (const H of V) {
      const ne = B.fields[H], ue = ne.default;
      if (Array.isArray(ue) ? ue.length > 0 : ue && typeof ue == "object")
        throw new Error("field defaults can only be primitives or empty arrays currently");
      O[H] = {
        default: Array.isArray(ue) ? [] : ue,
        optional: ne.optional,
        deprecated: ne.deprecated,
        validate: ne.validate
      };
    }
  }
  const D = F.visitor || B.visitor || [], R = F.aliases || B.aliases || [], q = F.builder || B.builder || F.visitor || [];
  for (const V of Object.keys(F))
    if (!ie.includes(V))
      throw new Error(`Unknown type option "${V}" on ${k}`);
  F.deprecatedAlias && (o[F.deprecatedAlias] = k);
  for (const V of D.concat(q))
    O[V] = O[V] || {};
  for (const V of Object.keys(O)) {
    const H = O[V];
    H.default !== void 0 && !q.includes(V) && (H.optional = !0), H.default === void 0 ? H.default = null : !H.validate && H.default != null && (H.validate = re(l(H.default)));
    for (const ne of Object.keys(H))
      if (!W.includes(ne))
        throw new Error(`Unknown field key "${ne}" on ${k}.${V}`);
  }
  r[k] = F.visitor = D, a[k] = F.builder = q, n[k] = F.fields = O, i[k] = F.aliases = R, R.forEach((V) => {
    s[V] = s[V] || [], s[V].push(k);
  }), F.validate && (u[k] = F.validate), Q[k] = F;
}
return Le;
}
var Po;
function sc() {
if (Po) return mt;
Po = 1, Object.defineProperty(mt, "__esModule", {
  value: !0
}), mt.patternLikeCommon = mt.functionTypeAnnotationCommon = mt.functionDeclarationCommon = mt.functionCommon = mt.classMethodOrPropertyCommon = mt.classMethodOrDeclareMethodCommon = void 0;
var e = fi(), t = gr, r = pi, i = di, s = xe, n = ur();
const a = (0, n.defineAliasedType)("Standardized");
a("ArrayExpression", {
  fields: {
    elements: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
      default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
}), a("AssignmentExpression", {
  fields: {
    operator: {
      validate: function() {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return (0, n.assertValueType)("string");
        const h = (0, n.assertOneOf)(...s.ASSIGNMENT_OPERATORS), y = (0, n.assertOneOf)("=");
        return function(g, A, C) {
          ((0, e.default)("Pattern", g.left) ? y : h)(g, A, C);
        };
      }()
    },
    left: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, n.assertNodeType)("LVal", "OptionalMemberExpression")
    },
    right: {
      validate: (0, n.assertNodeType)("Expression")
    }
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"]
}), a("BinaryExpression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: (0, n.assertOneOf)(...s.BINARY_OPERATORS)
    },
    left: {
      validate: function() {
        const h = (0, n.assertNodeType)("Expression"), y = (0, n.assertNodeType)("Expression", "PrivateName");
        return Object.assign(function(A, C, _) {
          (A.operator === "in" ? y : h)(A, C, _);
        }, {
          oneOfNodeTypes: ["Expression", "PrivateName"]
        });
      }()
    },
    right: {
      validate: (0, n.assertNodeType)("Expression")
    }
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"]
}), a("InterpreterDirective", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, n.assertValueType)("string")
    }
  }
}), a("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: (0, n.assertNodeType)("DirectiveLiteral")
    }
  }
}), a("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, n.assertValueType)("string")
    }
  }
}), a("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
}), a("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, n.assertNodeType)("Identifier"),
      optional: !0
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
}), a("CallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: Object.assign({
    callee: {
      validate: (0, n.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
    },
    arguments: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression", "SpreadElement", "ArgumentPlaceholder")))
    }
  }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
    optional: {
      validate: (0, n.assertOneOf)(!0, !1),
      optional: !0
    }
  }, {
    typeArguments: {
      validate: (0, n.assertNodeType)("TypeParameterInstantiation"),
      optional: !0
    },
    typeParameters: {
      validate: (0, n.assertNodeType)("TSTypeParameterInstantiation"),
      optional: !0
    }
  })
}), a("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: (0, n.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
      optional: !0
    },
    body: {
      validate: (0, n.assertNodeType)("BlockStatement")
    }
  },
  aliases: ["Scopable", "BlockParent"]
}), a("ConditionalExpression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: (0, n.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, n.assertNodeType)("Expression")
    },
    alternate: {
      validate: (0, n.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression", "Conditional"]
}), a("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, n.assertNodeType)("Identifier"),
      optional: !0
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
}), a("DebuggerStatement", {
  aliases: ["Statement"]
}), a("DoWhileStatement", {
  visitor: ["test", "body"],
  fields: {
    test: {
      validate: (0, n.assertNodeType)("Expression")
    },
    body: {
      validate: (0, n.assertNodeType)("Statement")
    }
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
}), a("EmptyStatement", {
  aliases: ["Statement"]
}), a("ExpressionStatement", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, n.assertNodeType)("Expression")
    }
  },
  aliases: ["Statement", "ExpressionWrapper"]
}), a("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: (0, n.assertNodeType)("Program")
    },
    comments: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertEach)((0, n.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
      }, {
        each: {
          oneOfNodeTypes: ["CommentBlock", "CommentLine"]
        }
      }),
      optional: !0
    },
    tokens: {
      validate: (0, n.assertEach)(Object.assign(() => {
      }, {
        type: "any"
      })),
      optional: !0
    }
  }
}), a("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, n.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, n.assertNodeType)("Expression")
    },
    body: {
      validate: (0, n.assertNodeType)("Statement")
    }
  }
}), a("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: (0, n.assertNodeType)("VariableDeclaration", "Expression"),
      optional: !0
    },
    test: {
      validate: (0, n.assertNodeType)("Expression"),
      optional: !0
    },
    update: {
      validate: (0, n.assertNodeType)("Expression"),
      optional: !0
    },
    body: {
      validate: (0, n.assertNodeType)("Statement")
    }
  }
});
const o = () => ({
  params: {
    validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Identifier", "Pattern", "RestElement")))
  },
  generator: {
    default: !1
  },
  async: {
    default: !1
  }
});
mt.functionCommon = o;
const u = () => ({
  returnType: {
    validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: !0
  },
  typeParameters: {
    validate: (0, n.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    optional: !0
  }
});
mt.functionTypeAnnotationCommon = u;
const l = () => Object.assign({}, o(), {
  declare: {
    validate: (0, n.assertValueType)("boolean"),
    optional: !0
  },
  id: {
    validate: (0, n.assertNodeType)("Identifier"),
    optional: !0
  }
});
mt.functionDeclarationCommon = l, a("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "params", "body", "returnType", "typeParameters"],
  fields: Object.assign({}, l(), u(), {
    body: {
      validate: (0, n.assertNodeType)("BlockStatement")
    },
    predicate: {
      validate: (0, n.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
      optional: !0
    }
  }),
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
  validate: function() {
    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {
    };
    const h = (0, n.assertNodeType)("Identifier");
    return function(y, g, A) {
      (0, e.default)("ExportDefaultDeclaration", y) || h(A, "id", A.id);
    };
  }()
}), a("FunctionExpression", {
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, o(), u(), {
    id: {
      validate: (0, n.assertNodeType)("Identifier"),
      optional: !0
    },
    body: {
      validate: (0, n.assertNodeType)("BlockStatement")
    },
    predicate: {
      validate: (0, n.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
      optional: !0
    }
  })
});
const c = () => ({
  typeAnnotation: {
    validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: !0
  },
  optional: {
    validate: (0, n.assertValueType)("boolean"),
    optional: !0
  },
  decorators: {
    validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
    optional: !0
  }
});
mt.patternLikeCommon = c, a("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation", "decorators"],
  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
  fields: Object.assign({}, c(), {
    name: {
      validate: (0, n.chain)((0, n.assertValueType)("string"), Object.assign(function(h, y, g) {
        if (process.env.BABEL_TYPES_8_BREAKING && !(0, t.default)(g, !1))
          throw new TypeError(`"${g}" is not a valid identifier name`);
      }, {
        type: "string"
      }))
    }
  }),
  validate(h, y, g) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const A = /\.(\w+)$/.exec(y);
    if (!A) return;
    const [, C] = A, _ = {
      computed: !1
    };
    if (C === "property") {
      if ((0, e.default)("MemberExpression", h, _) || (0, e.default)("OptionalMemberExpression", h, _)) return;
    } else if (C === "key") {
      if ((0, e.default)("Property", h, _) || (0, e.default)("Method", h, _)) return;
    } else if (C === "exported") {
      if ((0, e.default)("ExportSpecifier", h)) return;
    } else if (C === "imported") {
      if ((0, e.default)("ImportSpecifier", h, {
        imported: g
      })) return;
    } else if (C === "meta" && (0, e.default)("MetaProperty", h, {
      meta: g
    }))
      return;
    if (((0, r.isKeyword)(g.name) || (0, r.isReservedWord)(g.name, !1)) && g.name !== "this")
      throw new TypeError(`"${g.name}" is not a valid identifier`);
  }
}), a("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: (0, n.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, n.assertNodeType)("Statement")
    },
    alternate: {
      optional: !0,
      validate: (0, n.assertNodeType)("Statement")
    }
  }
}), a("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: (0, n.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, n.assertNodeType)("Statement")
    }
  }
}), a("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, n.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
}), a("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: (0, n.chain)((0, n.assertValueType)("number"), Object.assign(function(h, y, g) {
      }, {
        type: "number"
      }))
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
}), a("NullLiteral", {
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
}), a("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, n.assertValueType)("boolean")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
}), a("RegExpLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Pureish", "Literal"],
  fields: {
    pattern: {
      validate: (0, n.assertValueType)("string")
    },
    flags: {
      validate: (0, n.chain)((0, n.assertValueType)("string"), Object.assign(function(h, y, g) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        const A = /[^gimsuy]/.exec(g);
        if (A)
          throw new TypeError(`"${A[0]}" is not a valid RegExp flag`);
      }, {
        type: "string"
      })),
      default: ""
    }
  }
}), a("LogicalExpression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: {
    operator: {
      validate: (0, n.assertOneOf)(...s.LOGICAL_OPERATORS)
    },
    left: {
      validate: (0, n.assertNodeType)("Expression")
    },
    right: {
      validate: (0, n.assertNodeType)("Expression")
    }
  }
}), a("MemberExpression", {
  builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: Object.assign({
    object: {
      validate: (0, n.assertNodeType)("Expression", "Super")
    },
    property: {
      validate: function() {
        const h = (0, n.assertNodeType)("Identifier", "PrivateName"), y = (0, n.assertNodeType)("Expression"), g = function(A, C, _) {
          (A.computed ? y : h)(A, C, _);
        };
        return g.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], g;
      }()
    },
    computed: {
      default: !1
    }
  }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
    optional: {
      validate: (0, n.assertOneOf)(!0, !1),
      optional: !0
    }
  })
}), a("NewExpression", {
  inherits: "CallExpression"
}), a("Program", {
  visitor: ["directives", "body"],
  builder: ["body", "directives", "sourceType", "interpreter"],
  fields: {
    sourceType: {
      validate: (0, n.assertOneOf)("script", "module"),
      default: "script"
    },
    interpreter: {
      validate: (0, n.assertNodeType)("InterpreterDirective"),
      default: null,
      optional: !0
    },
    directives: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block"]
}), a("ObjectExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
    }
  }
}), a("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
  fields: Object.assign({}, o(), u(), {
    kind: Object.assign({
      validate: (0, n.assertOneOf)("method", "get", "set")
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      default: "method"
    }),
    computed: {
      default: !1
    },
    key: {
      validate: function() {
        const h = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), y = (0, n.assertNodeType)("Expression"), g = function(A, C, _) {
          (A.computed ? y : h)(A, C, _);
        };
        return g.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], g;
      }()
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    },
    body: {
      validate: (0, n.assertNodeType)("BlockStatement")
    }
  }),
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
}), a("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
  fields: {
    computed: {
      default: !1
    },
    key: {
      validate: function() {
        const h = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), y = (0, n.assertNodeType)("Expression");
        return Object.assign(function(A, C, _) {
          (A.computed ? y : h)(A, C, _);
        }, {
          oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
        });
      }()
    },
    value: {
      validate: (0, n.assertNodeType)("Expression", "PatternLike")
    },
    shorthand: {
      validate: (0, n.chain)((0, n.assertValueType)("boolean"), Object.assign(function(h, y, g) {
        if (process.env.BABEL_TYPES_8_BREAKING && g && h.computed)
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
      }, {
        type: "boolean"
      }), function(h, y, g) {
        if (process.env.BABEL_TYPES_8_BREAKING && g && !(0, e.default)("Identifier", h.key))
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
      }),
      default: !1
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    }
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"],
  validate: function() {
    const h = (0, n.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), y = (0, n.assertNodeType)("Expression");
    return function(g, A, C) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      ((0, e.default)("ObjectPattern", g) ? h : y)(C, "value", C.value);
    };
  }()
}), a("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  builder: ["argument"],
  aliases: ["LVal", "PatternLike"],
  deprecatedAlias: "RestProperty",
  fields: Object.assign({}, c(), {
    argument: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, n.assertNodeType)("LVal")
    }
  }),
  validate(h, y) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const g = /(\w+)\[(\d+)\]/.exec(y);
    if (!g) throw new Error("Internal Babel error: malformed key.");
    const [, A, C] = g;
    if (h[A].length > +C + 1)
      throw new TypeError(`RestElement must be last element of ${A}`);
  }
}), a("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, n.assertNodeType)("Expression"),
      optional: !0
    }
  }
}), a("SequenceExpression", {
  visitor: ["expressions"],
  fields: {
    expressions: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression")))
    }
  },
  aliases: ["Expression"]
}), a("ParenthesizedExpression", {
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: {
    expression: {
      validate: (0, n.assertNodeType)("Expression")
    }
  }
}), a("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: (0, n.assertNodeType)("Expression"),
      optional: !0
    },
    consequent: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
    }
  }
}), a("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: (0, n.assertNodeType)("Expression")
    },
    cases: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("SwitchCase")))
    }
  }
}), a("ThisExpression", {
  aliases: ["Expression"]
}), a("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, n.assertNodeType)("Expression")
    }
  }
}), a("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    block: {
      validate: (0, n.chain)((0, n.assertNodeType)("BlockStatement"), Object.assign(function(h) {
        if (process.env.BABEL_TYPES_8_BREAKING && !h.handler && !h.finalizer)
          throw new TypeError("TryStatement expects either a handler or finalizer, or both");
      }, {
        oneOfNodeTypes: ["BlockStatement"]
      }))
    },
    handler: {
      optional: !0,
      validate: (0, n.assertNodeType)("CatchClause")
    },
    finalizer: {
      optional: !0,
      validate: (0, n.assertNodeType)("BlockStatement")
    }
  }
}), a("UnaryExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: !0
    },
    argument: {
      validate: (0, n.assertNodeType)("Expression")
    },
    operator: {
      validate: (0, n.assertOneOf)(...s.UNARY_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["UnaryLike", "Expression"]
}), a("UpdateExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: !1
    },
    argument: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("Identifier", "MemberExpression") : (0, n.assertNodeType)("Expression")
    },
    operator: {
      validate: (0, n.assertOneOf)(...s.UPDATE_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["Expression"]
}), a("VariableDeclaration", {
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: {
    declare: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    kind: {
      validate: (0, n.assertOneOf)("var", "let", "const", "using", "await using")
    },
    declarations: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("VariableDeclarator")))
    }
  },
  validate(h, y, g) {
    if (process.env.BABEL_TYPES_8_BREAKING && (0, e.default)("ForXStatement", h, {
      left: g
    }) && g.declarations.length !== 1)
      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${h.type}`);
  }
}), a("VariableDeclarator", {
  visitor: ["id", "init"],
  fields: {
    id: {
      validate: function() {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return (0, n.assertNodeType)("LVal");
        const h = (0, n.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), y = (0, n.assertNodeType)("Identifier");
        return function(g, A, C) {
          (g.init ? h : y)(g, A, C);
        };
      }()
    },
    definite: {
      optional: !0,
      validate: (0, n.assertValueType)("boolean")
    },
    init: {
      optional: !0,
      validate: (0, n.assertNodeType)("Expression")
    }
  }
}), a("WhileStatement", {
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: {
    test: {
      validate: (0, n.assertNodeType)("Expression")
    },
    body: {
      validate: (0, n.assertNodeType)("Statement")
    }
  }
}), a("WithStatement", {
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: {
    object: {
      validate: (0, n.assertNodeType)("Expression")
    },
    body: {
      validate: (0, n.assertNodeType)("Statement")
    }
  }
}), a("AssignmentPattern", {
  visitor: ["left", "right", "decorators"],
  builder: ["left", "right"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, c(), {
    left: {
      validate: (0, n.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
    },
    right: {
      validate: (0, n.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    }
  })
}), a("ArrayPattern", {
  visitor: ["elements", "typeAnnotation"],
  builder: ["elements"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, c(), {
    elements: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeOrValueType)("null", "PatternLike", "LVal")))
    }
  })
}), a("ArrowFunctionExpression", {
  builder: ["params", "body", "async"],
  visitor: ["params", "body", "returnType", "typeParameters"],
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, o(), u(), {
    expression: {
      validate: (0, n.assertValueType)("boolean")
    },
    body: {
      validate: (0, n.assertNodeType)("BlockStatement", "Expression")
    },
    predicate: {
      validate: (0, n.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
      optional: !0
    }
  })
}), a("ClassBody", {
  visitor: ["body"],
  fields: {
    body: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
    }
  }
}), a("ClassExpression", {
  builder: ["id", "superClass", "body", "decorators"],
  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
  aliases: ["Scopable", "Class", "Expression"],
  fields: {
    id: {
      validate: (0, n.assertNodeType)("Identifier"),
      optional: !0
    },
    typeParameters: {
      validate: (0, n.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    },
    body: {
      validate: (0, n.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: !0,
      validate: (0, n.assertNodeType)("Expression")
    },
    superTypeParameters: {
      validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: !0
    },
    implements: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
      optional: !0
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    },
    mixins: {
      validate: (0, n.assertNodeType)("InterfaceExtends"),
      optional: !0
    }
  }
}), a("ClassDeclaration", {
  inherits: "ClassExpression",
  aliases: ["Scopable", "Class", "Statement", "Declaration"],
  fields: {
    id: {
      validate: (0, n.assertNodeType)("Identifier"),
      optional: !0
    },
    typeParameters: {
      validate: (0, n.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    },
    body: {
      validate: (0, n.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: !0,
      validate: (0, n.assertNodeType)("Expression")
    },
    superTypeParameters: {
      validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: !0
    },
    implements: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
      optional: !0
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    },
    mixins: {
      validate: (0, n.assertNodeType)("InterfaceExtends"),
      optional: !0
    },
    declare: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    abstract: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    }
  },
  validate: function() {
    const h = (0, n.assertNodeType)("Identifier");
    return function(y, g, A) {
      process.env.BABEL_TYPES_8_BREAKING && ((0, e.default)("ExportDefaultDeclaration", y) || h(A, "id", A.id));
    };
  }()
}), a("ExportAllDeclaration", {
  builder: ["source"],
  visitor: ["source", "attributes", "assertions"],
  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
  fields: {
    source: {
      validate: (0, n.assertNodeType)("StringLiteral")
    },
    exportKind: (0, n.validateOptional)((0, n.assertOneOf)("type", "value")),
    attributes: {
      optional: !0,
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
    },
    assertions: {
      optional: !0,
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
    }
  }
}), a("ExportDefaultDeclaration", {
  visitor: ["declaration"],
  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, n.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
    },
    exportKind: (0, n.validateOptional)((0, n.assertOneOf)("value"))
  }
}), a("ExportNamedDeclaration", {
  builder: ["declaration", "specifiers", "source"],
  visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      optional: !0,
      validate: (0, n.chain)((0, n.assertNodeType)("Declaration"), Object.assign(function(h, y, g) {
        if (process.env.BABEL_TYPES_8_BREAKING && g && h.specifiers.length)
          throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
      }, {
        oneOfNodeTypes: ["Declaration"]
      }), function(h, y, g) {
        if (process.env.BABEL_TYPES_8_BREAKING && g && h.source)
          throw new TypeError("Cannot export a declaration from a source");
      })
    },
    attributes: {
      optional: !0,
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
    },
    assertions: {
      optional: !0,
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
    },
    specifiers: {
      default: [],
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)(function() {
        const h = (0, n.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), y = (0, n.assertNodeType)("ExportSpecifier");
        return process.env.BABEL_TYPES_8_BREAKING ? function(g, A, C) {
          (g.source ? h : y)(g, A, C);
        } : h;
      }()))
    },
    source: {
      validate: (0, n.assertNodeType)("StringLiteral"),
      optional: !0
    },
    exportKind: (0, n.validateOptional)((0, n.assertOneOf)("type", "value"))
  }
}), a("ExportSpecifier", {
  visitor: ["local", "exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, n.assertNodeType)("Identifier")
    },
    exported: {
      validate: (0, n.assertNodeType)("Identifier", "StringLiteral")
    },
    exportKind: {
      validate: (0, n.assertOneOf)("type", "value"),
      optional: !0
    }
  }
}), a("ForOfStatement", {
  visitor: ["left", "right", "body"],
  builder: ["left", "right", "body", "await"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: function() {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return (0, n.assertNodeType)("VariableDeclaration", "LVal");
        const h = (0, n.assertNodeType)("VariableDeclaration"), y = (0, n.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
        return function(g, A, C) {
          (0, e.default)("VariableDeclaration", C) ? h(g, A, C) : y(g, A, C);
        };
      }()
    },
    right: {
      validate: (0, n.assertNodeType)("Expression")
    },
    body: {
      validate: (0, n.assertNodeType)("Statement")
    },
    await: {
      default: !1
    }
  }
}), a("ImportDeclaration", {
  builder: ["specifiers", "source"],
  visitor: ["specifiers", "source", "attributes", "assertions"],
  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
  fields: {
    attributes: {
      optional: !0,
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
    },
    assertions: {
      optional: !0,
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
    },
    module: {
      optional: !0,
      validate: (0, n.assertValueType)("boolean")
    },
    phase: {
      default: null,
      validate: (0, n.assertOneOf)("source", "defer")
    },
    specifiers: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
    },
    source: {
      validate: (0, n.assertNodeType)("StringLiteral")
    },
    importKind: {
      validate: (0, n.assertOneOf)("type", "typeof", "value"),
      optional: !0
    }
  }
}), a("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, n.assertNodeType)("Identifier")
    }
  }
}), a("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, n.assertNodeType)("Identifier")
    }
  }
}), a("ImportSpecifier", {
  visitor: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, n.assertNodeType)("Identifier")
    },
    imported: {
      validate: (0, n.assertNodeType)("Identifier", "StringLiteral")
    },
    importKind: {
      validate: (0, n.assertOneOf)("type", "typeof", "value"),
      optional: !0
    }
  }
}), a("ImportExpression", {
  visitor: ["source", "options"],
  aliases: ["Expression"],
  fields: {
    phase: {
      default: null,
      validate: (0, n.assertOneOf)("source", "defer")
    },
    source: {
      validate: (0, n.assertNodeType)("Expression")
    },
    options: {
      validate: (0, n.assertNodeType)("Expression"),
      optional: !0
    }
  }
}), a("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: {
    meta: {
      validate: (0, n.chain)((0, n.assertNodeType)("Identifier"), Object.assign(function(h, y, g) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        let A;
        switch (g.name) {
          case "function":
            A = "sent";
            break;
          case "new":
            A = "target";
            break;
          case "import":
            A = "meta";
            break;
        }
        if (!(0, e.default)("Identifier", h.property, {
          name: A
        }))
          throw new TypeError("Unrecognised MetaProperty");
      }, {
        oneOfNodeTypes: ["Identifier"]
      }))
    },
    property: {
      validate: (0, n.assertNodeType)("Identifier")
    }
  }
});
const f = () => ({
  abstract: {
    validate: (0, n.assertValueType)("boolean"),
    optional: !0
  },
  accessibility: {
    validate: (0, n.assertOneOf)("public", "private", "protected"),
    optional: !0
  },
  static: {
    default: !1
  },
  override: {
    default: !1
  },
  computed: {
    default: !1
  },
  optional: {
    validate: (0, n.assertValueType)("boolean"),
    optional: !0
  },
  key: {
    validate: (0, n.chain)(function() {
      const h = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), y = (0, n.assertNodeType)("Expression");
      return function(g, A, C) {
        (g.computed ? y : h)(g, A, C);
      };
    }(), (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
  }
});
mt.classMethodOrPropertyCommon = f;
const p = () => Object.assign({}, o(), f(), {
  params: {
    validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
  },
  kind: {
    validate: (0, n.assertOneOf)("get", "set", "method", "constructor"),
    default: "method"
  },
  access: {
    validate: (0, n.chain)((0, n.assertValueType)("string"), (0, n.assertOneOf)("public", "private", "protected")),
    optional: !0
  },
  decorators: {
    validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
    optional: !0
  }
});
return mt.classMethodOrDeclareMethodCommon = p, a("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  fields: Object.assign({}, p(), u(), {
    body: {
      validate: (0, n.assertNodeType)("BlockStatement")
    }
  })
}), a("ObjectPattern", {
  visitor: ["properties", "typeAnnotation", "decorators"],
  builder: ["properties"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, c(), {
    properties: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("RestElement", "ObjectProperty")))
    }
  })
}), a("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  deprecatedAlias: "SpreadProperty",
  fields: {
    argument: {
      validate: (0, n.assertNodeType)("Expression")
    }
  }
}), a("Super", {
  aliases: ["Expression"]
}), a("TaggedTemplateExpression", {
  visitor: ["tag", "quasi", "typeParameters"],
  builder: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: {
    tag: {
      validate: (0, n.assertNodeType)("Expression")
    },
    quasi: {
      validate: (0, n.assertNodeType)("TemplateLiteral")
    },
    typeParameters: {
      validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: !0
    }
  }
}), a("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {
      validate: (0, n.chain)((0, n.assertShape)({
        raw: {
          validate: (0, n.assertValueType)("string")
        },
        cooked: {
          validate: (0, n.assertValueType)("string"),
          optional: !0
        }
      }), function(y) {
        const g = y.value.raw;
        let A = !1;
        const C = () => {
          throw new Error("Internal @babel/types error.");
        }, {
          str: _,
          firstInvalidLoc: j
        } = (0, i.readStringContents)("template", g, 0, 0, 0, {
          unterminated() {
            A = !0;
          },
          strictNumericEscape: C,
          invalidEscapeSequence: C,
          numericSeparatorInEscapeSequence: C,
          unexpectedNumericSeparator: C,
          invalidDigit: C,
          invalidCodePoint: C
        });
        if (!A) throw new Error("Invalid raw");
        y.value.cooked = j ? null : _;
      })
    },
    tail: {
      default: !1
    }
  }
}), a("TemplateLiteral", {
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: {
    quasis: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TemplateElement")))
    },
    expressions: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression", "TSType")), function(h, y, g) {
        if (h.quasis.length !== g.length + 1)
          throw new TypeError(`Number of ${h.type} quasis should be exactly one more than the number of expressions.
Expected ${g.length + 1} quasis but got ${h.quasis.length}`);
      })
    }
  }
}), a("YieldExpression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    delegate: {
      validate: (0, n.chain)((0, n.assertValueType)("boolean"), Object.assign(function(h, y, g) {
        if (process.env.BABEL_TYPES_8_BREAKING && g && !h.argument)
          throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
      }, {
        type: "boolean"
      })),
      default: !1
    },
    argument: {
      optional: !0,
      validate: (0, n.assertNodeType)("Expression")
    }
  }
}), a("AwaitExpression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    argument: {
      validate: (0, n.assertNodeType)("Expression")
    }
  }
}), a("Import", {
  aliases: ["Expression"]
}), a("BigIntLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, n.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
}), a("ExportNamespaceSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, n.assertNodeType)("Identifier")
    }
  }
}), a("OptionalMemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression"],
  fields: {
    object: {
      validate: (0, n.assertNodeType)("Expression")
    },
    property: {
      validate: function() {
        const h = (0, n.assertNodeType)("Identifier"), y = (0, n.assertNodeType)("Expression");
        return Object.assign(function(A, C, _) {
          (A.computed ? y : h)(A, C, _);
        }, {
          oneOfNodeTypes: ["Expression", "Identifier"]
        });
      }()
    },
    computed: {
      default: !1
    },
    optional: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.chain)((0, n.assertValueType)("boolean"), (0, n.assertOptionalChainStart)()) : (0, n.assertValueType)("boolean")
    }
  }
}), a("OptionalCallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments", "optional"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: (0, n.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression", "SpreadElement", "ArgumentPlaceholder")))
    },
    optional: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.chain)((0, n.assertValueType)("boolean"), (0, n.assertOptionalChainStart)()) : (0, n.assertValueType)("boolean")
    },
    typeArguments: {
      validate: (0, n.assertNodeType)("TypeParameterInstantiation"),
      optional: !0
    },
    typeParameters: {
      validate: (0, n.assertNodeType)("TSTypeParameterInstantiation"),
      optional: !0
    }
  }
}), a("ClassProperty", {
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property"],
  fields: Object.assign({}, f(), {
    value: {
      validate: (0, n.assertNodeType)("Expression"),
      optional: !0
    },
    definite: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    typeAnnotation: {
      validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    },
    readonly: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    declare: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    variance: {
      validate: (0, n.assertNodeType)("Variance"),
      optional: !0
    }
  })
}), a("ClassAccessorProperty", {
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property", "Accessor"],
  fields: Object.assign({}, f(), {
    key: {
      validate: (0, n.chain)(function() {
        const h = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), y = (0, n.assertNodeType)("Expression");
        return function(g, A, C) {
          (g.computed ? y : h)(g, A, C);
        };
      }(), (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
    },
    value: {
      validate: (0, n.assertNodeType)("Expression"),
      optional: !0
    },
    definite: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    typeAnnotation: {
      validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    },
    readonly: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    declare: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    variance: {
      validate: (0, n.assertNodeType)("Variance"),
      optional: !0
    }
  })
}), a("ClassPrivateProperty", {
  visitor: ["key", "value", "decorators", "typeAnnotation"],
  builder: ["key", "value", "decorators", "static"],
  aliases: ["Property", "Private"],
  fields: {
    key: {
      validate: (0, n.assertNodeType)("PrivateName")
    },
    value: {
      validate: (0, n.assertNodeType)("Expression"),
      optional: !0
    },
    typeAnnotation: {
      validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    },
    static: {
      validate: (0, n.assertValueType)("boolean"),
      default: !1
    },
    readonly: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    definite: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    variance: {
      validate: (0, n.assertNodeType)("Variance"),
      optional: !0
    }
  }
}), a("ClassPrivateMethod", {
  builder: ["kind", "key", "params", "body", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
  fields: Object.assign({}, p(), u(), {
    kind: {
      validate: (0, n.assertOneOf)("get", "set", "method"),
      default: "method"
    },
    key: {
      validate: (0, n.assertNodeType)("PrivateName")
    },
    body: {
      validate: (0, n.assertNodeType)("BlockStatement")
    }
  })
}), a("PrivateName", {
  visitor: ["id"],
  aliases: ["Private"],
  fields: {
    id: {
      validate: (0, n.assertNodeType)("Identifier")
    }
  }
}), a("StaticBlock", {
  visitor: ["body"],
  fields: {
    body: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "FunctionParent"]
}), mt;
}
var vo = {}, Ao;
function Mg() {
if (Ao) return vo;
Ao = 1;
var e = ur();
const t = (0, e.defineAliasedType)("Flow"), r = (i) => {
  const s = i === "DeclareClass";
  t(i, {
    builder: ["id", "typeParameters", "extends", "body"],
    visitor: ["id", "typeParameters", "extends", ...s ? ["mixins", "implements"] : [], "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      extends: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends"))
    }, s ? {
      mixins: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends")),
      implements: (0, e.validateOptional)((0, e.arrayOfType)("ClassImplements"))
    } : {}, {
      body: (0, e.validateType)("ObjectTypeAnnotation")
    })
  });
};
return t("AnyTypeAnnotation", {
  aliases: ["FlowType", "FlowBaseAnnotation"]
}), t("ArrayTypeAnnotation", {
  visitor: ["elementType"],
  aliases: ["FlowType"],
  fields: {
    elementType: (0, e.validateType)("FlowType")
  }
}), t("BooleanTypeAnnotation", {
  aliases: ["FlowType", "FlowBaseAnnotation"]
}), t("BooleanLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["FlowType"],
  fields: {
    value: (0, e.validate)((0, e.assertValueType)("boolean"))
  }
}), t("NullLiteralTypeAnnotation", {
  aliases: ["FlowType", "FlowBaseAnnotation"]
}), t("ClassImplements", {
  visitor: ["id", "typeParameters"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
  }
}), r("DeclareClass"), t("DeclareFunction", {
  visitor: ["id"],
  aliases: ["FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    predicate: (0, e.validateOptionalType)("DeclaredPredicate")
  }
}), r("DeclareInterface"), t("DeclareModule", {
  builder: ["id", "body", "kind"],
  visitor: ["id", "body"],
  aliases: ["FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, e.validateType)(["Identifier", "StringLiteral"]),
    body: (0, e.validateType)("BlockStatement"),
    kind: (0, e.validateOptional)((0, e.assertOneOf)("CommonJS", "ES"))
  }
}), t("DeclareModuleExports", {
  visitor: ["typeAnnotation"],
  aliases: ["FlowDeclaration", "Statement", "Declaration"],
  fields: {
    typeAnnotation: (0, e.validateType)("TypeAnnotation")
  }
}), t("DeclareTypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, e.validateType)("FlowType")
  }
}), t("DeclareOpaqueType", {
  visitor: ["id", "typeParameters", "supertype"],
  aliases: ["FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, e.validateOptionalType)("FlowType"),
    impltype: (0, e.validateOptionalType)("FlowType")
  }
}), t("DeclareVariable", {
  visitor: ["id"],
  aliases: ["FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, e.validateType)("Identifier")
  }
}), t("DeclareExportDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["FlowDeclaration", "Statement", "Declaration"],
  fields: {
    declaration: (0, e.validateOptionalType)("Flow"),
    specifiers: (0, e.validateOptional)((0, e.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
    source: (0, e.validateOptionalType)("StringLiteral"),
    default: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
  }
}), t("DeclareExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["FlowDeclaration", "Statement", "Declaration"],
  fields: {
    source: (0, e.validateType)("StringLiteral"),
    exportKind: (0, e.validateOptional)((0, e.assertOneOf)("type", "value"))
  }
}), t("DeclaredPredicate", {
  visitor: ["value"],
  aliases: ["FlowPredicate"],
  fields: {
    value: (0, e.validateType)("Flow")
  }
}), t("ExistsTypeAnnotation", {
  aliases: ["FlowType"]
}), t("FunctionTypeAnnotation", {
  visitor: ["typeParameters", "params", "rest", "returnType"],
  aliases: ["FlowType"],
  fields: {
    typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
    params: (0, e.validate)((0, e.arrayOfType)("FunctionTypeParam")),
    rest: (0, e.validateOptionalType)("FunctionTypeParam"),
    this: (0, e.validateOptionalType)("FunctionTypeParam"),
    returnType: (0, e.validateType)("FlowType")
  }
}), t("FunctionTypeParam", {
  visitor: ["name", "typeAnnotation"],
  fields: {
    name: (0, e.validateOptionalType)("Identifier"),
    typeAnnotation: (0, e.validateType)("FlowType"),
    optional: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
  }
}), t("GenericTypeAnnotation", {
  visitor: ["id", "typeParameters"],
  aliases: ["FlowType"],
  fields: {
    id: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
  }
}), t("InferredPredicate", {
  aliases: ["FlowPredicate"]
}), t("InterfaceExtends", {
  visitor: ["id", "typeParameters"],
  fields: {
    id: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
  }
}), r("InterfaceDeclaration"), t("InterfaceTypeAnnotation", {
  visitor: ["extends", "body"],
  aliases: ["FlowType"],
  fields: {
    extends: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends")),
    body: (0, e.validateType)("ObjectTypeAnnotation")
  }
}), t("IntersectionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["FlowType"],
  fields: {
    types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
  }
}), t("MixedTypeAnnotation", {
  aliases: ["FlowType", "FlowBaseAnnotation"]
}), t("EmptyTypeAnnotation", {
  aliases: ["FlowType", "FlowBaseAnnotation"]
}), t("NullableTypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["FlowType"],
  fields: {
    typeAnnotation: (0, e.validateType)("FlowType")
  }
}), t("NumberLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["FlowType"],
  fields: {
    value: (0, e.validate)((0, e.assertValueType)("number"))
  }
}), t("NumberTypeAnnotation", {
  aliases: ["FlowType", "FlowBaseAnnotation"]
}), t("ObjectTypeAnnotation", {
  visitor: ["properties", "indexers", "callProperties", "internalSlots"],
  aliases: ["FlowType"],
  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
  fields: {
    properties: (0, e.validate)((0, e.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
    indexers: {
      validate: (0, e.arrayOfType)("ObjectTypeIndexer"),
      optional: !0,
      default: []
    },
    callProperties: {
      validate: (0, e.arrayOfType)("ObjectTypeCallProperty"),
      optional: !0,
      default: []
    },
    internalSlots: {
      validate: (0, e.arrayOfType)("ObjectTypeInternalSlot"),
      optional: !0,
      default: []
    },
    exact: {
      validate: (0, e.assertValueType)("boolean"),
      default: !1
    },
    inexact: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
  }
}), t("ObjectTypeInternalSlot", {
  visitor: ["id", "value"],
  builder: ["id", "value", "optional", "static", "method"],
  aliases: ["UserWhitespacable"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    value: (0, e.validateType)("FlowType"),
    optional: (0, e.validate)((0, e.assertValueType)("boolean")),
    static: (0, e.validate)((0, e.assertValueType)("boolean")),
    method: (0, e.validate)((0, e.assertValueType)("boolean"))
  }
}), t("ObjectTypeCallProperty", {
  visitor: ["value"],
  aliases: ["UserWhitespacable"],
  fields: {
    value: (0, e.validateType)("FlowType"),
    static: (0, e.validate)((0, e.assertValueType)("boolean"))
  }
}), t("ObjectTypeIndexer", {
  visitor: ["id", "key", "value", "variance"],
  aliases: ["UserWhitespacable"],
  fields: {
    id: (0, e.validateOptionalType)("Identifier"),
    key: (0, e.validateType)("FlowType"),
    value: (0, e.validateType)("FlowType"),
    static: (0, e.validate)((0, e.assertValueType)("boolean")),
    variance: (0, e.validateOptionalType)("Variance")
  }
}), t("ObjectTypeProperty", {
  visitor: ["key", "value", "variance"],
  aliases: ["UserWhitespacable"],
  fields: {
    key: (0, e.validateType)(["Identifier", "StringLiteral"]),
    value: (0, e.validateType)("FlowType"),
    kind: (0, e.validate)((0, e.assertOneOf)("init", "get", "set")),
    static: (0, e.validate)((0, e.assertValueType)("boolean")),
    proto: (0, e.validate)((0, e.assertValueType)("boolean")),
    optional: (0, e.validate)((0, e.assertValueType)("boolean")),
    variance: (0, e.validateOptionalType)("Variance"),
    method: (0, e.validate)((0, e.assertValueType)("boolean"))
  }
}), t("ObjectTypeSpreadProperty", {
  visitor: ["argument"],
  aliases: ["UserWhitespacable"],
  fields: {
    argument: (0, e.validateType)("FlowType")
  }
}), t("OpaqueType", {
  visitor: ["id", "typeParameters", "supertype", "impltype"],
  aliases: ["FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, e.validateOptionalType)("FlowType"),
    impltype: (0, e.validateType)("FlowType")
  }
}), t("QualifiedTypeIdentifier", {
  visitor: ["id", "qualification"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    qualification: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"])
  }
}), t("StringLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["FlowType"],
  fields: {
    value: (0, e.validate)((0, e.assertValueType)("string"))
  }
}), t("StringTypeAnnotation", {
  aliases: ["FlowType", "FlowBaseAnnotation"]
}), t("SymbolTypeAnnotation", {
  aliases: ["FlowType", "FlowBaseAnnotation"]
}), t("ThisTypeAnnotation", {
  aliases: ["FlowType", "FlowBaseAnnotation"]
}), t("TupleTypeAnnotation", {
  visitor: ["types"],
  aliases: ["FlowType"],
  fields: {
    types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
  }
}), t("TypeofTypeAnnotation", {
  visitor: ["argument"],
  aliases: ["FlowType"],
  fields: {
    argument: (0, e.validateType)("FlowType")
  }
}), t("TypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, e.validateType)("FlowType")
  }
}), t("TypeAnnotation", {
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, e.validateType)("FlowType")
  }
}), t("TypeCastExpression", {
  visitor: ["expression", "typeAnnotation"],
  aliases: ["ExpressionWrapper", "Expression"],
  fields: {
    expression: (0, e.validateType)("Expression"),
    typeAnnotation: (0, e.validateType)("TypeAnnotation")
  }
}), t("TypeParameter", {
  visitor: ["bound", "default", "variance"],
  fields: {
    name: (0, e.validate)((0, e.assertValueType)("string")),
    bound: (0, e.validateOptionalType)("TypeAnnotation"),
    default: (0, e.validateOptionalType)("FlowType"),
    variance: (0, e.validateOptionalType)("Variance")
  }
}), t("TypeParameterDeclaration", {
  visitor: ["params"],
  fields: {
    params: (0, e.validate)((0, e.arrayOfType)("TypeParameter"))
  }
}), t("TypeParameterInstantiation", {
  visitor: ["params"],
  fields: {
    params: (0, e.validate)((0, e.arrayOfType)("FlowType"))
  }
}), t("UnionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["FlowType"],
  fields: {
    types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
  }
}), t("Variance", {
  builder: ["kind"],
  fields: {
    kind: (0, e.validate)((0, e.assertOneOf)("minus", "plus"))
  }
}), t("VoidTypeAnnotation", {
  aliases: ["FlowType", "FlowBaseAnnotation"]
}), t("EnumDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "body"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    body: (0, e.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
  }
}), t("EnumBooleanBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
    members: (0, e.validateArrayOfType)("EnumBooleanMember"),
    hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
  }
}), t("EnumNumberBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
    members: (0, e.validateArrayOfType)("EnumNumberMember"),
    hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
  }
}), t("EnumStringBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
    members: (0, e.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
    hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
  }
}), t("EnumSymbolBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    members: (0, e.validateArrayOfType)("EnumDefaultedMember"),
    hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
  }
}), t("EnumBooleanMember", {
  aliases: ["EnumMember"],
  visitor: ["id"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    init: (0, e.validateType)("BooleanLiteral")
  }
}), t("EnumNumberMember", {
  aliases: ["EnumMember"],
  visitor: ["id", "init"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    init: (0, e.validateType)("NumericLiteral")
  }
}), t("EnumStringMember", {
  aliases: ["EnumMember"],
  visitor: ["id", "init"],
  fields: {
    id: (0, e.validateType)("Identifier"),
    init: (0, e.validateType)("StringLiteral")
  }
}), t("EnumDefaultedMember", {
  aliases: ["EnumMember"],
  visitor: ["id"],
  fields: {
    id: (0, e.validateType)("Identifier")
  }
}), t("IndexedAccessType", {
  visitor: ["objectType", "indexType"],
  aliases: ["FlowType"],
  fields: {
    objectType: (0, e.validateType)("FlowType"),
    indexType: (0, e.validateType)("FlowType")
  }
}), t("OptionalIndexedAccessType", {
  visitor: ["objectType", "indexType"],
  aliases: ["FlowType"],
  fields: {
    objectType: (0, e.validateType)("FlowType"),
    indexType: (0, e.validateType)("FlowType"),
    optional: (0, e.validate)((0, e.assertValueType)("boolean"))
  }
}), vo;
}
var Io = {}, Co;
function Bg() {
if (Co) return Io;
Co = 1;
var e = ur();
const t = (0, e.defineAliasedType)("JSX");
return t("JSXAttribute", {
  visitor: ["name", "value"],
  aliases: ["Immutable"],
  fields: {
    name: {
      validate: (0, e.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
    },
    value: {
      optional: !0,
      validate: (0, e.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
    }
  }
}), t("JSXClosingElement", {
  visitor: ["name"],
  aliases: ["Immutable"],
  fields: {
    name: {
      validate: (0, e.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    }
  }
}), t("JSXElement", {
  builder: ["openingElement", "closingElement", "children", "selfClosing"],
  visitor: ["openingElement", "children", "closingElement"],
  aliases: ["Immutable", "Expression"],
  fields: Object.assign({
    openingElement: {
      validate: (0, e.assertNodeType)("JSXOpeningElement")
    },
    closingElement: {
      optional: !0,
      validate: (0, e.assertNodeType)("JSXClosingElement")
    },
    children: {
      validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    }
  }, {
    selfClosing: {
      validate: (0, e.assertValueType)("boolean"),
      optional: !0
    }
  })
}), t("JSXEmptyExpression", {}), t("JSXExpressionContainer", {
  visitor: ["expression"],
  aliases: ["Immutable"],
  fields: {
    expression: {
      validate: (0, e.assertNodeType)("Expression", "JSXEmptyExpression")
    }
  }
}), t("JSXSpreadChild", {
  visitor: ["expression"],
  aliases: ["Immutable"],
  fields: {
    expression: {
      validate: (0, e.assertNodeType)("Expression")
    }
  }
}), t("JSXIdentifier", {
  builder: ["name"],
  fields: {
    name: {
      validate: (0, e.assertValueType)("string")
    }
  }
}), t("JSXMemberExpression", {
  visitor: ["object", "property"],
  fields: {
    object: {
      validate: (0, e.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
    },
    property: {
      validate: (0, e.assertNodeType)("JSXIdentifier")
    }
  }
}), t("JSXNamespacedName", {
  visitor: ["namespace", "name"],
  fields: {
    namespace: {
      validate: (0, e.assertNodeType)("JSXIdentifier")
    },
    name: {
      validate: (0, e.assertNodeType)("JSXIdentifier")
    }
  }
}), t("JSXOpeningElement", {
  builder: ["name", "attributes", "selfClosing"],
  visitor: ["name", "attributes"],
  aliases: ["Immutable"],
  fields: {
    name: {
      validate: (0, e.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    },
    selfClosing: {
      default: !1
    },
    attributes: {
      validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
    },
    typeParameters: {
      validate: (0, e.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: !0
    }
  }
}), t("JSXSpreadAttribute", {
  visitor: ["argument"],
  fields: {
    argument: {
      validate: (0, e.assertNodeType)("Expression")
    }
  }
}), t("JSXText", {
  aliases: ["Immutable"],
  builder: ["value"],
  fields: {
    value: {
      validate: (0, e.assertValueType)("string")
    }
  }
}), t("JSXFragment", {
  builder: ["openingFragment", "closingFragment", "children"],
  visitor: ["openingFragment", "children", "closingFragment"],
  aliases: ["Immutable", "Expression"],
  fields: {
    openingFragment: {
      validate: (0, e.assertNodeType)("JSXOpeningFragment")
    },
    closingFragment: {
      validate: (0, e.assertNodeType)("JSXClosingFragment")
    },
    children: {
      validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    }
  }
}), t("JSXOpeningFragment", {
  aliases: ["Immutable"]
}), t("JSXClosingFragment", {
  aliases: ["Immutable"]
}), Io;
}
var wo = {}, jt = {}, No;
function nc() {
if (No) return jt;
No = 1, Object.defineProperty(jt, "__esModule", {
  value: !0
}), jt.PLACEHOLDERS_FLIPPED_ALIAS = jt.PLACEHOLDERS_ALIAS = jt.PLACEHOLDERS = void 0;
var e = ur();
const t = jt.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], r = jt.PLACEHOLDERS_ALIAS = {
  Declaration: ["Statement"],
  Pattern: ["PatternLike", "LVal"]
};
for (const s of t) {
  const n = e.ALIAS_KEYS[s];
  n != null && n.length && (r[s] = n);
}
const i = jt.PLACEHOLDERS_FLIPPED_ALIAS = {};
return Object.keys(r).forEach((s) => {
  r[s].forEach((n) => {
    hasOwnProperty.call(i, n) || (i[n] = []), i[n].push(s);
  });
}), jt;
}
var Oo;
function Fg() {
if (Oo) return wo;
Oo = 1;
var e = ur(), t = nc();
const r = (0, e.defineAliasedType)("Miscellaneous");
return r("Noop", {
  visitor: []
}), r("Placeholder", {
  visitor: [],
  builder: ["expectedNode", "name"],
  fields: {
    name: {
      validate: (0, e.assertNodeType)("Identifier")
    },
    expectedNode: {
      validate: (0, e.assertOneOf)(...t.PLACEHOLDERS)
    }
  }
}), r("V8IntrinsicIdentifier", {
  builder: ["name"],
  fields: {
    name: {
      validate: (0, e.assertValueType)("string")
    }
  }
}), wo;
}
var _o = {}, ko;
function jg() {
if (ko) return _o;
ko = 1;
var e = ur();
return (0, e.default)("ArgumentPlaceholder", {}), (0, e.default)("BindExpression", {
  visitor: ["object", "callee"],
  aliases: ["Expression"],
  fields: process.env.BABEL_TYPES_8_BREAKING ? {
    object: {
      validate: (0, e.assertNodeType)("Expression")
    },
    callee: {
      validate: (0, e.assertNodeType)("Expression")
    }
  } : {
    object: {
      validate: Object.assign(() => {
      }, {
        oneOfNodeTypes: ["Expression"]
      })
    },
    callee: {
      validate: Object.assign(() => {
      }, {
        oneOfNodeTypes: ["Expression"]
      })
    }
  }
}), (0, e.default)("ImportAttribute", {
  visitor: ["key", "value"],
  fields: {
    key: {
      validate: (0, e.assertNodeType)("Identifier", "StringLiteral")
    },
    value: {
      validate: (0, e.assertNodeType)("StringLiteral")
    }
  }
}), (0, e.default)("Decorator", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, e.assertNodeType)("Expression")
    }
  }
}), (0, e.default)("DoExpression", {
  visitor: ["body"],
  builder: ["body", "async"],
  aliases: ["Expression"],
  fields: {
    body: {
      validate: (0, e.assertNodeType)("BlockStatement")
    },
    async: {
      validate: (0, e.assertValueType)("boolean"),
      default: !1
    }
  }
}), (0, e.default)("ExportDefaultSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, e.assertNodeType)("Identifier")
    }
  }
}), (0, e.default)("RecordExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("ObjectProperty", "SpreadElement")))
    }
  }
}), (0, e.default)("TupleExpression", {
  fields: {
    elements: {
      validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("Expression", "SpreadElement"))),
      default: []
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
}), (0, e.default)("DecimalLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, e.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
}), (0, e.default)("ModuleExpression", {
  visitor: ["body"],
  fields: {
    body: {
      validate: (0, e.assertNodeType)("Program")
    }
  },
  aliases: ["Expression"]
}), (0, e.default)("TopicReference", {
  aliases: ["Expression"]
}), (0, e.default)("PipelineTopicExpression", {
  builder: ["expression"],
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, e.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression"]
}), (0, e.default)("PipelineBareFunction", {
  builder: ["callee"],
  visitor: ["callee"],
  fields: {
    callee: {
      validate: (0, e.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression"]
}), (0, e.default)("PipelinePrimaryTopicReference", {
  aliases: ["Expression"]
}), _o;
}
var Do = {}, Lo;
function Rg() {
if (Lo) return Do;
Lo = 1;
var e = ur(), t = sc(), r = fi();
const i = (0, e.defineAliasedType)("TypeScript"), s = (0, e.assertValueType)("boolean"), n = () => ({
  returnType: {
    validate: (0, e.assertNodeType)("TSTypeAnnotation", "Noop"),
    optional: !0
  },
  typeParameters: {
    validate: (0, e.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
    optional: !0
  }
});
i("TSParameterProperty", {
  aliases: ["LVal"],
  visitor: ["parameter"],
  fields: {
    accessibility: {
      validate: (0, e.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    readonly: {
      validate: (0, e.assertValueType)("boolean"),
      optional: !0
    },
    parameter: {
      validate: (0, e.assertNodeType)("Identifier", "AssignmentPattern")
    },
    override: {
      validate: (0, e.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("Decorator"))),
      optional: !0
    }
  }
}), i("TSDeclareFunction", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, (0, t.functionDeclarationCommon)(), n())
}), i("TSDeclareMethod", {
  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, (0, t.classMethodOrDeclareMethodCommon)(), n())
}), i("TSQualifiedName", {
  aliases: ["TSEntityName"],
  visitor: ["left", "right"],
  fields: {
    left: (0, e.validateType)("TSEntityName"),
    right: (0, e.validateType)("Identifier")
  }
});
const a = () => ({
  typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
  parameters: (0, e.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
  typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation")
}), o = {
  aliases: ["TSTypeElement"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"],
  fields: a()
};
i("TSCallSignatureDeclaration", o), i("TSConstructSignatureDeclaration", o);
const u = () => ({
  key: (0, e.validateType)("Expression"),
  computed: {
    default: !1
  },
  optional: (0, e.validateOptional)(s)
});
i("TSPropertySignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeAnnotation"],
  fields: Object.assign({}, u(), {
    readonly: (0, e.validateOptional)(s),
    typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation"),
    kind: {
      validate: (0, e.assertOneOf)("get", "set")
    }
  })
}), i("TSMethodSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
  fields: Object.assign({}, a(), u(), {
    kind: {
      validate: (0, e.assertOneOf)("method", "get", "set")
    }
  })
}), i("TSIndexSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["parameters", "typeAnnotation"],
  fields: {
    readonly: (0, e.validateOptional)(s),
    static: (0, e.validateOptional)(s),
    parameters: (0, e.validateArrayOfType)("Identifier"),
    typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation")
  }
});
const l = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
for (const h of l)
  i(h, {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
i("TSThisType", {
  aliases: ["TSType", "TSBaseType"],
  visitor: [],
  fields: {}
});
const c = {
  aliases: ["TSType"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"]
};
i("TSFunctionType", Object.assign({}, c, {
  fields: a()
})), i("TSConstructorType", Object.assign({}, c, {
  fields: Object.assign({}, a(), {
    abstract: (0, e.validateOptional)(s)
  })
})), i("TSTypeReference", {
  aliases: ["TSType"],
  visitor: ["typeName", "typeParameters"],
  fields: {
    typeName: (0, e.validateType)("TSEntityName"),
    typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
  }
}), i("TSTypePredicate", {
  aliases: ["TSType"],
  visitor: ["parameterName", "typeAnnotation"],
  builder: ["parameterName", "typeAnnotation", "asserts"],
  fields: {
    parameterName: (0, e.validateType)(["Identifier", "TSThisType"]),
    typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation"),
    asserts: (0, e.validateOptional)(s)
  }
}), i("TSTypeQuery", {
  aliases: ["TSType"],
  visitor: ["exprName", "typeParameters"],
  fields: {
    exprName: (0, e.validateType)(["TSEntityName", "TSImportType"]),
    typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
  }
}), i("TSTypeLiteral", {
  aliases: ["TSType"],
  visitor: ["members"],
  fields: {
    members: (0, e.validateArrayOfType)("TSTypeElement")
  }
}), i("TSArrayType", {
  aliases: ["TSType"],
  visitor: ["elementType"],
  fields: {
    elementType: (0, e.validateType)("TSType")
  }
}), i("TSTupleType", {
  aliases: ["TSType"],
  visitor: ["elementTypes"],
  fields: {
    elementTypes: (0, e.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
  }
}), i("TSOptionalType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, e.validateType)("TSType")
  }
}), i("TSRestType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, e.validateType)("TSType")
  }
}), i("TSNamedTupleMember", {
  visitor: ["label", "elementType"],
  builder: ["label", "elementType", "optional"],
  fields: {
    label: (0, e.validateType)("Identifier"),
    optional: {
      validate: s,
      default: !1
    },
    elementType: (0, e.validateType)("TSType")
  }
});
const f = {
  aliases: ["TSType"],
  visitor: ["types"],
  fields: {
    types: (0, e.validateArrayOfType)("TSType")
  }
};
i("TSUnionType", f), i("TSIntersectionType", f), i("TSConditionalType", {
  aliases: ["TSType"],
  visitor: ["checkType", "extendsType", "trueType", "falseType"],
  fields: {
    checkType: (0, e.validateType)("TSType"),
    extendsType: (0, e.validateType)("TSType"),
    trueType: (0, e.validateType)("TSType"),
    falseType: (0, e.validateType)("TSType")
  }
}), i("TSInferType", {
  aliases: ["TSType"],
  visitor: ["typeParameter"],
  fields: {
    typeParameter: (0, e.validateType)("TSTypeParameter")
  }
}), i("TSParenthesizedType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, e.validateType)("TSType")
  }
}), i("TSTypeOperator", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    operator: (0, e.validate)((0, e.assertValueType)("string")),
    typeAnnotation: (0, e.validateType)("TSType")
  }
}), i("TSIndexedAccessType", {
  aliases: ["TSType"],
  visitor: ["objectType", "indexType"],
  fields: {
    objectType: (0, e.validateType)("TSType"),
    indexType: (0, e.validateType)("TSType")
  }
}), i("TSMappedType", {
  aliases: ["TSType"],
  visitor: ["typeParameter", "typeAnnotation", "nameType"],
  fields: {
    readonly: (0, e.validateOptional)((0, e.assertOneOf)(!0, !1, "+", "-")),
    typeParameter: (0, e.validateType)("TSTypeParameter"),
    optional: (0, e.validateOptional)((0, e.assertOneOf)(!0, !1, "+", "-")),
    typeAnnotation: (0, e.validateOptionalType)("TSType"),
    nameType: (0, e.validateOptionalType)("TSType")
  }
}), i("TSLiteralType", {
  aliases: ["TSType", "TSBaseType"],
  visitor: ["literal"],
  fields: {
    literal: {
      validate: function() {
        const h = (0, e.assertNodeType)("NumericLiteral", "BigIntLiteral"), y = (0, e.assertOneOf)("-"), g = (0, e.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
        function A(C, _, j) {
          (0, r.default)("UnaryExpression", j) ? (y(j, "operator", j.operator), h(j, "argument", j.argument)) : g(C, _, j);
        }
        return A.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], A;
      }()
    }
  }
}), i("TSExpressionWithTypeArguments", {
  aliases: ["TSType"],
  visitor: ["expression", "typeParameters"],
  fields: {
    expression: (0, e.validateType)("TSEntityName"),
    typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
  }
}), i("TSInterfaceDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "extends", "body"],
  fields: {
    declare: (0, e.validateOptional)(s),
    id: (0, e.validateType)("Identifier"),
    typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
    extends: (0, e.validateOptional)((0, e.arrayOfType)("TSExpressionWithTypeArguments")),
    body: (0, e.validateType)("TSInterfaceBody")
  }
}), i("TSInterfaceBody", {
  visitor: ["body"],
  fields: {
    body: (0, e.validateArrayOfType)("TSTypeElement")
  }
}), i("TSTypeAliasDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "typeAnnotation"],
  fields: {
    declare: (0, e.validateOptional)(s),
    id: (0, e.validateType)("Identifier"),
    typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
    typeAnnotation: (0, e.validateType)("TSType")
  }
}), i("TSInstantiationExpression", {
  aliases: ["Expression"],
  visitor: ["expression", "typeParameters"],
  fields: {
    expression: (0, e.validateType)("Expression"),
    typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
const p = {
  aliases: ["Expression", "LVal", "PatternLike"],
  visitor: ["expression", "typeAnnotation"],
  fields: {
    expression: (0, e.validateType)("Expression"),
    typeAnnotation: (0, e.validateType)("TSType")
  }
};
return i("TSAsExpression", p), i("TSSatisfiesExpression", p), i("TSTypeAssertion", {
  aliases: ["Expression", "LVal", "PatternLike"],
  visitor: ["typeAnnotation", "expression"],
  fields: {
    typeAnnotation: (0, e.validateType)("TSType"),
    expression: (0, e.validateType)("Expression")
  }
}), i("TSEnumDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "members"],
  fields: {
    declare: (0, e.validateOptional)(s),
    const: (0, e.validateOptional)(s),
    id: (0, e.validateType)("Identifier"),
    members: (0, e.validateArrayOfType)("TSEnumMember"),
    initializer: (0, e.validateOptionalType)("Expression")
  }
}), i("TSEnumMember", {
  visitor: ["id", "initializer"],
  fields: {
    id: (0, e.validateType)(["Identifier", "StringLiteral"]),
    initializer: (0, e.validateOptionalType)("Expression")
  }
}), i("TSModuleDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "body"],
  fields: {
    declare: (0, e.validateOptional)(s),
    global: (0, e.validateOptional)(s),
    id: (0, e.validateType)(["Identifier", "StringLiteral"]),
    body: (0, e.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
  }
}), i("TSModuleBlock", {
  aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
  visitor: ["body"],
  fields: {
    body: (0, e.validateArrayOfType)("Statement")
  }
}), i("TSImportType", {
  aliases: ["TSType"],
  visitor: ["argument", "qualifier", "typeParameters"],
  fields: {
    argument: (0, e.validateType)("StringLiteral"),
    qualifier: (0, e.validateOptionalType)("TSEntityName"),
    typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation"),
    options: {
      validate: (0, e.assertNodeType)("Expression"),
      optional: !0
    }
  }
}), i("TSImportEqualsDeclaration", {
  aliases: ["Statement"],
  visitor: ["id", "moduleReference"],
  fields: {
    isExport: (0, e.validate)(s),
    id: (0, e.validateType)("Identifier"),
    moduleReference: (0, e.validateType)(["TSEntityName", "TSExternalModuleReference"]),
    importKind: {
      validate: (0, e.assertOneOf)("type", "value"),
      optional: !0
    }
  }
}), i("TSExternalModuleReference", {
  visitor: ["expression"],
  fields: {
    expression: (0, e.validateType)("StringLiteral")
  }
}), i("TSNonNullExpression", {
  aliases: ["Expression", "LVal", "PatternLike"],
  visitor: ["expression"],
  fields: {
    expression: (0, e.validateType)("Expression")
  }
}), i("TSExportAssignment", {
  aliases: ["Statement"],
  visitor: ["expression"],
  fields: {
    expression: (0, e.validateType)("Expression")
  }
}), i("TSNamespaceExportDeclaration", {
  aliases: ["Statement"],
  visitor: ["id"],
  fields: {
    id: (0, e.validateType)("Identifier")
  }
}), i("TSTypeAnnotation", {
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: {
      validate: (0, e.assertNodeType)("TSType")
    }
  }
}), i("TSTypeParameterInstantiation", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("TSType")))
    }
  }
}), i("TSTypeParameterDeclaration", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("TSTypeParameter")))
    }
  }
}), i("TSTypeParameter", {
  builder: ["constraint", "default", "name"],
  visitor: ["constraint", "default"],
  fields: {
    name: {
      validate: (0, e.assertValueType)("string")
    },
    in: {
      validate: (0, e.assertValueType)("boolean"),
      optional: !0
    },
    out: {
      validate: (0, e.assertValueType)("boolean"),
      optional: !0
    },
    const: {
      validate: (0, e.assertValueType)("boolean"),
      optional: !0
    },
    constraint: {
      validate: (0, e.assertNodeType)("TSType"),
      optional: !0
    },
    default: {
      validate: (0, e.assertNodeType)("TSType"),
      optional: !0
    }
  }
}), Do;
}
var gs = {};
Object.defineProperty(gs, "__esModule", {
value: !0
});
gs.DEPRECATED_ALIASES = void 0;
gs.DEPRECATED_ALIASES = {
ModuleDeclaration: "ImportOrExportDeclaration"
};
var Mo;
function Dt() {
return Mo || (Mo = 1, function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), Object.defineProperty(e, "ALIAS_KEYS", {
    enumerable: !0,
    get: function() {
      return r.ALIAS_KEYS;
    }
  }), Object.defineProperty(e, "BUILDER_KEYS", {
    enumerable: !0,
    get: function() {
      return r.BUILDER_KEYS;
    }
  }), Object.defineProperty(e, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: function() {
      return s.DEPRECATED_ALIASES;
    }
  }), Object.defineProperty(e, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: function() {
      return r.DEPRECATED_KEYS;
    }
  }), Object.defineProperty(e, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: function() {
      return r.FLIPPED_ALIAS_KEYS;
    }
  }), Object.defineProperty(e, "NODE_FIELDS", {
    enumerable: !0,
    get: function() {
      return r.NODE_FIELDS;
    }
  }), Object.defineProperty(e, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: function() {
      return r.NODE_PARENT_VALIDATIONS;
    }
  }), Object.defineProperty(e, "PLACEHOLDERS", {
    enumerable: !0,
    get: function() {
      return i.PLACEHOLDERS;
    }
  }), Object.defineProperty(e, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: function() {
      return i.PLACEHOLDERS_ALIAS;
    }
  }), Object.defineProperty(e, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: function() {
      return i.PLACEHOLDERS_FLIPPED_ALIAS;
    }
  }), e.TYPES = void 0, Object.defineProperty(e, "VISITOR_KEYS", {
    enumerable: !0,
    get: function() {
      return r.VISITOR_KEYS;
    }
  });
  var t = pg;
  sc(), Mg(), Bg(), Fg(), jg(), Rg();
  var r = ur(), i = nc(), s = gs;
  Object.keys(s.DEPRECATED_ALIASES).forEach((n) => {
    r.FLIPPED_ALIAS_KEYS[n] = r.FLIPPED_ALIAS_KEYS[s.DEPRECATED_ALIASES[n]];
  }), t(r.VISITOR_KEYS), t(r.ALIAS_KEYS), t(r.FLIPPED_ALIAS_KEYS), t(r.NODE_FIELDS), t(r.BUILDER_KEYS), t(r.DEPRECATED_KEYS), t(i.PLACEHOLDERS_ALIAS), t(i.PLACEHOLDERS_FLIPPED_ALIAS), e.TYPES = [].concat(Object.keys(r.VISITOR_KEYS), Object.keys(r.FLIPPED_ALIAS_KEYS), Object.keys(r.DEPRECATED_KEYS));
}(sn)), sn;
}
var Bo;
function aa() {
if (Bo) return Cr;
Bo = 1, Object.defineProperty(Cr, "__esModule", {
  value: !0
}), Cr.default = t, Cr.validateChild = i, Cr.validateField = r;
var e = Dt();
function t(s, n, a) {
  if (!s) return;
  const o = e.NODE_FIELDS[s.type];
  if (!o) return;
  const u = o[n];
  r(s, n, a, u), i(s, n, a);
}
function r(s, n, a, o) {
  o != null && o.validate && (o.optional && a == null || o.validate(s, n, a));
}
function i(s, n, a) {
  if (a == null) return;
  const o = e.NODE_PARENT_VALIDATIONS[a.type];
  o && o(s, n, a);
}
return Cr;
}
var Fo;
function Ug() {
if (Fo) return Li;
Fo = 1, Object.defineProperty(Li, "__esModule", {
  value: !0
}), Li.default = r;
var e = aa(), t = Ce();
function r(i) {
  const s = t.BUILDER_KEYS[i.type];
  for (const n of s)
    (0, e.default)(i, n, i[n]);
  return i;
}
return Li;
}
var jo;
function Pt() {
if (jo) return b;
jo = 1, Object.defineProperty(b, "__esModule", {
  value: !0
}), b.anyTypeAnnotation = ep, b.argumentPlaceholder = Nh, b.arrayExpression = r, b.arrayPattern = Ie, b.arrayTypeAnnotation = tp, b.arrowFunctionExpression = Ve, b.assignmentExpression = i, b.assignmentPattern = je, b.awaitExpression = xt, b.bigIntLiteral = Ii, b.binaryExpression = s, b.bindExpression = Oh, b.blockStatement = u, b.booleanLiteral = U, b.booleanLiteralTypeAnnotation = ip, b.booleanTypeAnnotation = rp, b.breakStatement = l, b.callExpression = c, b.catchClause = f, b.classAccessorProperty = Ar, b.classBody = ht, b.classDeclaration = J, b.classExpression = ze, b.classImplements = np, b.classMethod = Ke, b.classPrivateMethod = Ni, b.classPrivateProperty = wi, b.classProperty = Ft, b.conditionalExpression = p, b.continueStatement = h, b.debuggerStatement = y, b.decimalLiteral = Fh, b.declareClass = ap, b.declareExportAllDeclaration = mp, b.declareExportDeclaration = dp, b.declareFunction = op, b.declareInterface = up, b.declareModule = lp, b.declareModuleExports = cp, b.declareOpaqueType = pp, b.declareTypeAlias = fp, b.declareVariable = hp, b.declaredPredicate = yp, b.decorator = kh, b.directive = a, b.directiveLiteral = o, b.doExpression = Dh, b.doWhileStatement = g, b.emptyStatement = A, b.emptyTypeAnnotation = Cp, b.enumBooleanBody = th, b.enumBooleanMember = nh, b.enumDeclaration = eh, b.enumDefaultedMember = uh, b.enumNumberBody = rh, b.enumNumberMember = ah, b.enumStringBody = ih, b.enumStringMember = oh, b.enumSymbolBody = sh, b.existsTypeAnnotation = bp, b.exportAllDeclaration = d, b.exportDefaultDeclaration = P, b.exportDefaultSpecifier = Lh, b.exportNamedDeclaration = N, b.exportNamespaceSpecifier = Qs, b.exportSpecifier = M, b.expressionStatement = C, b.file = _, b.forInStatement = j, b.forOfStatement = Z, b.forStatement = G, b.functionDeclaration = fe, b.functionExpression = re, b.functionTypeAnnotation = Tp, b.functionTypeParam = gp, b.genericTypeAnnotation = Sp, b.identifier = oe, b.ifStatement = K, b.import = Br, b.importAttribute = _h, b.importDeclaration = ee, b.importDefaultSpecifier = Se, b.importExpression = Y, b.importNamespaceSpecifier = Ae, b.importSpecifier = Te, b.indexedAccessType = lh, b.inferredPredicate = xp, b.interfaceDeclaration = Pp, b.interfaceExtends = Ep, b.interfaceTypeAnnotation = vp, b.interpreterDirective = n, b.intersectionTypeAnnotation = Ap, b.jSXAttribute = b.jsxAttribute = fh, b.jSXClosingElement = b.jsxClosingElement = ph, b.jSXClosingFragment = b.jsxClosingFragment = Ah, b.jSXElement = b.jsxElement = hh, b.jSXEmptyExpression = b.jsxEmptyExpression = dh, b.jSXExpressionContainer = b.jsxExpressionContainer = mh, b.jSXFragment = b.jsxFragment = Ph, b.jSXIdentifier = b.jsxIdentifier = bh, b.jSXMemberExpression = b.jsxMemberExpression = Th, b.jSXNamespacedName = b.jsxNamespacedName = gh, b.jSXOpeningElement = b.jsxOpeningElement = Sh, b.jSXOpeningFragment = b.jsxOpeningFragment = vh, b.jSXSpreadAttribute = b.jsxSpreadAttribute = xh, b.jSXSpreadChild = b.jsxSpreadChild = yh, b.jSXText = b.jsxText = Eh, b.labeledStatement = X, b.logicalExpression = k, b.memberExpression = F, b.metaProperty = st, b.mixedTypeAnnotation = Ip, b.moduleExpression = jh, b.newExpression = B, b.noop = Ih, b.nullLiteral = Q, b.nullLiteralTypeAnnotation = sp, b.nullableTypeAnnotation = wp, b.numberLiteral = e0, b.numberLiteralTypeAnnotation = Np, b.numberTypeAnnotation = Op, b.numericLiteral = W, b.objectExpression = D, b.objectMethod = R, b.objectPattern = Ye, b.objectProperty = q, b.objectTypeAnnotation = _p, b.objectTypeCallProperty = Dp, b.objectTypeIndexer = Lp, b.objectTypeInternalSlot = kp, b.objectTypeProperty = Mp, b.objectTypeSpreadProperty = Bp, b.opaqueType = Fp, b.optionalCallExpression = Fr, b.optionalIndexedAccessType = ch, b.optionalMemberExpression = Ci, b.parenthesizedExpression = ue, b.pipelineBareFunction = Vh, b.pipelinePrimaryTopicReference = qh, b.pipelineTopicExpression = Uh, b.placeholder = Ch, b.privateName = Oi, b.program = O, b.qualifiedTypeIdentifier = jp, b.recordExpression = Mh, b.regExpLiteral = L, b.regexLiteral = t0, b.restElement = V, b.restProperty = r0, b.returnStatement = H, b.sequenceExpression = ne, b.spreadElement = nt, b.spreadProperty = i0, b.staticBlock = Zf, b.stringLiteral = ie, b.stringLiteralTypeAnnotation = Rp, b.stringTypeAnnotation = Up, b.super = St, b.switchCase = qe, b.switchStatement = pe, b.symbolTypeAnnotation = Vp, b.taggedTemplateExpression = v, b.templateElement = de, b.templateLiteral = Re, b.thisExpression = he, b.thisTypeAnnotation = qp, b.throwStatement = Ee, b.topicReference = Rh, b.tryStatement = we, b.tSAnyKeyword = b.tsAnyKeyword = Qh, b.tSArrayType = b.tsArrayType = Td, b.tSAsExpression = b.tsAsExpression = Fd, b.tSBigIntKeyword = b.tsBigIntKeyword = ed, b.tSBooleanKeyword = b.tsBooleanKeyword = Zh, b.tSCallSignatureDeclaration = b.tsCallSignatureDeclaration = Yh, b.tSConditionalType = b.tsConditionalType = Ad, b.tSConstructSignatureDeclaration = b.tsConstructSignatureDeclaration = Xh, b.tSConstructorType = b.tsConstructorType = hd, b.tSDeclareFunction = b.tsDeclareFunction = Kh, b.tSDeclareMethod = b.tsDeclareMethod = Wh, b.tSEnumDeclaration = b.tsEnumDeclaration = Ud, b.tSEnumMember = b.tsEnumMember = Vd, b.tSExportAssignment = b.tsExportAssignment = Xd, b.tSExpressionWithTypeArguments = b.tsExpressionWithTypeArguments = kd, b.tSExternalModuleReference = b.tsExternalModuleReference = Jd, b.tSFunctionType = b.tsFunctionType = pd, b.tSImportEqualsDeclaration = b.tsImportEqualsDeclaration = Wd, b.tSImportType = b.tsImportType = Kd, b.tSIndexSignature = b.tsIndexSignature = zh, b.tSIndexedAccessType = b.tsIndexedAccessType = Nd, b.tSInferType = b.tsInferType = Id, b.tSInstantiationExpression = b.tsInstantiationExpression = Bd, b.tSInterfaceBody = b.tsInterfaceBody = Ld, b.tSInterfaceDeclaration = b.tsInterfaceDeclaration = Dd, b.tSIntersectionType = b.tsIntersectionType = vd, b.tSIntrinsicKeyword = b.tsIntrinsicKeyword = td, b.tSLiteralType = b.tsLiteralType = _d, b.tSMappedType = b.tsMappedType = Od, b.tSMethodSignature = b.tsMethodSignature = Gh, b.tSModuleBlock = b.tsModuleBlock = $d, b.tSModuleDeclaration = b.tsModuleDeclaration = qd, b.tSNamedTupleMember = b.tsNamedTupleMember = Ed, b.tSNamespaceExportDeclaration = b.tsNamespaceExportDeclaration = Hd, b.tSNeverKeyword = b.tsNeverKeyword = rd, b.tSNonNullExpression = b.tsNonNullExpression = Yd, b.tSNullKeyword = b.tsNullKeyword = id, b.tSNumberKeyword = b.tsNumberKeyword = sd, b.tSObjectKeyword = b.tsObjectKeyword = nd, b.tSOptionalType = b.tsOptionalType = Sd, b.tSParameterProperty = b.tsParameterProperty = $h, b.tSParenthesizedType = b.tsParenthesizedType = Cd, b.tSPropertySignature = b.tsPropertySignature = Hh, b.tSQualifiedName = b.tsQualifiedName = Jh, b.tSRestType = b.tsRestType = xd, b.tSSatisfiesExpression = b.tsSatisfiesExpression = jd, b.tSStringKeyword = b.tsStringKeyword = ad, b.tSSymbolKeyword = b.tsSymbolKeyword = od, b.tSThisType = b.tsThisType = fd, b.tSTupleType = b.tsTupleType = gd, b.tSTypeAliasDeclaration = b.tsTypeAliasDeclaration = Md, b.tSTypeAnnotation = b.tsTypeAnnotation = Gd, b.tSTypeAssertion = b.tsTypeAssertion = Rd, b.tSTypeLiteral = b.tsTypeLiteral = bd, b.tSTypeOperator = b.tsTypeOperator = wd, b.tSTypeParameter = b.tsTypeParameter = Zd, b.tSTypeParameterDeclaration = b.tsTypeParameterDeclaration = Qd, b.tSTypeParameterInstantiation = b.tsTypeParameterInstantiation = zd, b.tSTypePredicate = b.tsTypePredicate = md, b.tSTypeQuery = b.tsTypeQuery = yd, b.tSTypeReference = b.tsTypeReference = dd, b.tSUndefinedKeyword = b.tsUndefinedKeyword = ud, b.tSUnionType = b.tsUnionType = Pd, b.tSUnknownKeyword = b.tsUnknownKeyword = ld, b.tSVoidKeyword = b.tsVoidKeyword = cd, b.tupleExpression = Bh, b.tupleTypeAnnotation = $p, b.typeAlias = Wp, b.typeAnnotation = Jp, b.typeCastExpression = Yp, b.typeParameter = Xp, b.typeParameterDeclaration = Hp, b.typeParameterInstantiation = Gp, b.typeofTypeAnnotation = Kp, b.unaryExpression = Pe, b.unionTypeAnnotation = zp, b.updateExpression = ke, b.v8IntrinsicIdentifier = wh, b.variableDeclaration = De, b.variableDeclarator = Je, b.variance = Qp, b.voidTypeAnnotation = Zp, b.whileStatement = it, b.withStatement = ve, b.yieldExpression = At;
var e = Ug(), t = kr;
function r(m = []) {
  return (0, e.default)({
    type: "ArrayExpression",
    elements: m
  });
}
function i(m, I, $) {
  return (0, e.default)({
    type: "AssignmentExpression",
    operator: m,
    left: I,
    right: $
  });
}
function s(m, I, $) {
  return (0, e.default)({
    type: "BinaryExpression",
    operator: m,
    left: I,
    right: $
  });
}
function n(m) {
  return (0, e.default)({
    type: "InterpreterDirective",
    value: m
  });
}
function a(m) {
  return (0, e.default)({
    type: "Directive",
    value: m
  });
}
function o(m) {
  return (0, e.default)({
    type: "DirectiveLiteral",
    value: m
  });
}
function u(m, I = []) {
  return (0, e.default)({
    type: "BlockStatement",
    body: m,
    directives: I
  });
}
function l(m = null) {
  return (0, e.default)({
    type: "BreakStatement",
    label: m
  });
}
function c(m, I) {
  return (0, e.default)({
    type: "CallExpression",
    callee: m,
    arguments: I
  });
}
function f(m = null, I) {
  return (0, e.default)({
    type: "CatchClause",
    param: m,
    body: I
  });
}
function p(m, I, $) {
  return (0, e.default)({
    type: "ConditionalExpression",
    test: m,
    consequent: I,
    alternate: $
  });
}
function h(m = null) {
  return (0, e.default)({
    type: "ContinueStatement",
    label: m
  });
}
function y() {
  return {
    type: "DebuggerStatement"
  };
}
function g(m, I) {
  return (0, e.default)({
    type: "DoWhileStatement",
    test: m,
    body: I
  });
}
function A() {
  return {
    type: "EmptyStatement"
  };
}
function C(m) {
  return (0, e.default)({
    type: "ExpressionStatement",
    expression: m
  });
}
function _(m, I = null, $ = null) {
  return (0, e.default)({
    type: "File",
    program: m,
    comments: I,
    tokens: $
  });
}
function j(m, I, $) {
  return (0, e.default)({
    type: "ForInStatement",
    left: m,
    right: I,
    body: $
  });
}
function G(m = null, I = null, $ = null, ce) {
  return (0, e.default)({
    type: "ForStatement",
    init: m,
    test: I,
    update: $,
    body: ce
  });
}
function fe(m = null, I, $, ce = !1, tt = !1) {
  return (0, e.default)({
    type: "FunctionDeclaration",
    id: m,
    params: I,
    body: $,
    generator: ce,
    async: tt
  });
}
function re(m = null, I, $, ce = !1, tt = !1) {
  return (0, e.default)({
    type: "FunctionExpression",
    id: m,
    params: I,
    body: $,
    generator: ce,
    async: tt
  });
}
function oe(m) {
  return (0, e.default)({
    type: "Identifier",
    name: m
  });
}
function K(m, I, $ = null) {
  return (0, e.default)({
    type: "IfStatement",
    test: m,
    consequent: I,
    alternate: $
  });
}
function X(m, I) {
  return (0, e.default)({
    type: "LabeledStatement",
    label: m,
    body: I
  });
}
function ie(m) {
  return (0, e.default)({
    type: "StringLiteral",
    value: m
  });
}
function W(m) {
  return (0, e.default)({
    type: "NumericLiteral",
    value: m
  });
}
function Q() {
  return {
    type: "NullLiteral"
  };
}
function U(m) {
  return (0, e.default)({
    type: "BooleanLiteral",
    value: m
  });
}
function L(m, I = "") {
  return (0, e.default)({
    type: "RegExpLiteral",
    pattern: m,
    flags: I
  });
}
function k(m, I, $) {
  return (0, e.default)({
    type: "LogicalExpression",
    operator: m,
    left: I,
    right: $
  });
}
function F(m, I, $ = !1, ce = null) {
  return (0, e.default)({
    type: "MemberExpression",
    object: m,
    property: I,
    computed: $,
    optional: ce
  });
}
function B(m, I) {
  return (0, e.default)({
    type: "NewExpression",
    callee: m,
    arguments: I
  });
}
function O(m, I = [], $ = "script", ce = null) {
  return (0, e.default)({
    type: "Program",
    body: m,
    directives: I,
    sourceType: $,
    interpreter: ce
  });
}
function D(m) {
  return (0, e.default)({
    type: "ObjectExpression",
    properties: m
  });
}
function R(m = "method", I, $, ce, tt = !1, cr = !1, Zs = !1) {
  return (0, e.default)({
    type: "ObjectMethod",
    kind: m,
    key: I,
    params: $,
    body: ce,
    computed: tt,
    generator: cr,
    async: Zs
  });
}
function q(m, I, $ = !1, ce = !1, tt = null) {
  return (0, e.default)({
    type: "ObjectProperty",
    key: m,
    value: I,
    computed: $,
    shorthand: ce,
    decorators: tt
  });
}
function V(m) {
  return (0, e.default)({
    type: "RestElement",
    argument: m
  });
}
function H(m = null) {
  return (0, e.default)({
    type: "ReturnStatement",
    argument: m
  });
}
function ne(m) {
  return (0, e.default)({
    type: "SequenceExpression",
    expressions: m
  });
}
function ue(m) {
  return (0, e.default)({
    type: "ParenthesizedExpression",
    expression: m
  });
}
function qe(m = null, I) {
  return (0, e.default)({
    type: "SwitchCase",
    test: m,
    consequent: I
  });
}
function pe(m, I) {
  return (0, e.default)({
    type: "SwitchStatement",
    discriminant: m,
    cases: I
  });
}
function he() {
  return {
    type: "ThisExpression"
  };
}
function Ee(m) {
  return (0, e.default)({
    type: "ThrowStatement",
    argument: m
  });
}
function we(m, I = null, $ = null) {
  return (0, e.default)({
    type: "TryStatement",
    block: m,
    handler: I,
    finalizer: $
  });
}
function Pe(m, I, $ = !0) {
  return (0, e.default)({
    type: "UnaryExpression",
    operator: m,
    argument: I,
    prefix: $
  });
}
function ke(m, I, $ = !1) {
  return (0, e.default)({
    type: "UpdateExpression",
    operator: m,
    argument: I,
    prefix: $
  });
}
function De(m, I) {
  return (0, e.default)({
    type: "VariableDeclaration",
    kind: m,
    declarations: I
  });
}
function Je(m, I = null) {
  return (0, e.default)({
    type: "VariableDeclarator",
    id: m,
    init: I
  });
}
function it(m, I) {
  return (0, e.default)({
    type: "WhileStatement",
    test: m,
    body: I
  });
}
function ve(m, I) {
  return (0, e.default)({
    type: "WithStatement",
    object: m,
    body: I
  });
}
function je(m, I) {
  return (0, e.default)({
    type: "AssignmentPattern",
    left: m,
    right: I
  });
}
function Ie(m) {
  return (0, e.default)({
    type: "ArrayPattern",
    elements: m
  });
}
function Ve(m, I, $ = !1) {
  return (0, e.default)({
    type: "ArrowFunctionExpression",
    params: m,
    body: I,
    async: $,
    expression: null
  });
}
function ht(m) {
  return (0, e.default)({
    type: "ClassBody",
    body: m
  });
}
function ze(m = null, I = null, $, ce = null) {
  return (0, e.default)({
    type: "ClassExpression",
    id: m,
    superClass: I,
    body: $,
    decorators: ce
  });
}
function J(m = null, I = null, $, ce = null) {
  return (0, e.default)({
    type: "ClassDeclaration",
    id: m,
    superClass: I,
    body: $,
    decorators: ce
  });
}
function d(m) {
  return (0, e.default)({
    type: "ExportAllDeclaration",
    source: m
  });
}
function P(m) {
  return (0, e.default)({
    type: "ExportDefaultDeclaration",
    declaration: m
  });
}
function N(m = null, I = [], $ = null) {
  return (0, e.default)({
    type: "ExportNamedDeclaration",
    declaration: m,
    specifiers: I,
    source: $
  });
}
function M(m, I) {
  return (0, e.default)({
    type: "ExportSpecifier",
    local: m,
    exported: I
  });
}
function Z(m, I, $, ce = !1) {
  return (0, e.default)({
    type: "ForOfStatement",
    left: m,
    right: I,
    body: $,
    await: ce
  });
}
function ee(m, I) {
  return (0, e.default)({
    type: "ImportDeclaration",
    specifiers: m,
    source: I
  });
}
function Se(m) {
  return (0, e.default)({
    type: "ImportDefaultSpecifier",
    local: m
  });
}
function Ae(m) {
  return (0, e.default)({
    type: "ImportNamespaceSpecifier",
    local: m
  });
}
function Te(m, I) {
  return (0, e.default)({
    type: "ImportSpecifier",
    local: m,
    imported: I
  });
}
function Y(m, I = null) {
  return (0, e.default)({
    type: "ImportExpression",
    source: m,
    options: I
  });
}
function st(m, I) {
  return (0, e.default)({
    type: "MetaProperty",
    meta: m,
    property: I
  });
}
function Ke(m = "method", I, $, ce, tt = !1, cr = !1, Zs = !1, s0 = !1) {
  return (0, e.default)({
    type: "ClassMethod",
    kind: m,
    key: I,
    params: $,
    body: ce,
    computed: tt,
    static: cr,
    generator: Zs,
    async: s0
  });
}
function Ye(m) {
  return (0, e.default)({
    type: "ObjectPattern",
    properties: m
  });
}
function nt(m) {
  return (0, e.default)({
    type: "SpreadElement",
    argument: m
  });
}
function St() {
  return {
    type: "Super"
  };
}
function v(m, I) {
  return (0, e.default)({
    type: "TaggedTemplateExpression",
    tag: m,
    quasi: I
  });
}
function de(m, I = !1) {
  return (0, e.default)({
    type: "TemplateElement",
    value: m,
    tail: I
  });
}
function Re(m, I) {
  return (0, e.default)({
    type: "TemplateLiteral",
    quasis: m,
    expressions: I
  });
}
function At(m = null, I = !1) {
  return (0, e.default)({
    type: "YieldExpression",
    argument: m,
    delegate: I
  });
}
function xt(m) {
  return (0, e.default)({
    type: "AwaitExpression",
    argument: m
  });
}
function Br() {
  return {
    type: "Import"
  };
}
function Ii(m) {
  return (0, e.default)({
    type: "BigIntLiteral",
    value: m
  });
}
function Qs(m) {
  return (0, e.default)({
    type: "ExportNamespaceSpecifier",
    exported: m
  });
}
function Ci(m, I, $ = !1, ce) {
  return (0, e.default)({
    type: "OptionalMemberExpression",
    object: m,
    property: I,
    computed: $,
    optional: ce
  });
}
function Fr(m, I, $) {
  return (0, e.default)({
    type: "OptionalCallExpression",
    callee: m,
    arguments: I,
    optional: $
  });
}
function Ft(m, I = null, $ = null, ce = null, tt = !1, cr = !1) {
  return (0, e.default)({
    type: "ClassProperty",
    key: m,
    value: I,
    typeAnnotation: $,
    decorators: ce,
    computed: tt,
    static: cr
  });
}
function Ar(m, I = null, $ = null, ce = null, tt = !1, cr = !1) {
  return (0, e.default)({
    type: "ClassAccessorProperty",
    key: m,
    value: I,
    typeAnnotation: $,
    decorators: ce,
    computed: tt,
    static: cr
  });
}
function wi(m, I = null, $ = null, ce = !1) {
  return (0, e.default)({
    type: "ClassPrivateProperty",
    key: m,
    value: I,
    decorators: $,
    static: ce
  });
}
function Ni(m = "method", I, $, ce, tt = !1) {
  return (0, e.default)({
    type: "ClassPrivateMethod",
    kind: m,
    key: I,
    params: $,
    body: ce,
    static: tt
  });
}
function Oi(m) {
  return (0, e.default)({
    type: "PrivateName",
    id: m
  });
}
function Zf(m) {
  return (0, e.default)({
    type: "StaticBlock",
    body: m
  });
}
function ep() {
  return {
    type: "AnyTypeAnnotation"
  };
}
function tp(m) {
  return (0, e.default)({
    type: "ArrayTypeAnnotation",
    elementType: m
  });
}
function rp() {
  return {
    type: "BooleanTypeAnnotation"
  };
}
function ip(m) {
  return (0, e.default)({
    type: "BooleanLiteralTypeAnnotation",
    value: m
  });
}
function sp() {
  return {
    type: "NullLiteralTypeAnnotation"
  };
}
function np(m, I = null) {
  return (0, e.default)({
    type: "ClassImplements",
    id: m,
    typeParameters: I
  });
}
function ap(m, I = null, $ = null, ce) {
  return (0, e.default)({
    type: "DeclareClass",
    id: m,
    typeParameters: I,
    extends: $,
    body: ce
  });
}
function op(m) {
  return (0, e.default)({
    type: "DeclareFunction",
    id: m
  });
}
function up(m, I = null, $ = null, ce) {
  return (0, e.default)({
    type: "DeclareInterface",
    id: m,
    typeParameters: I,
    extends: $,
    body: ce
  });
}
function lp(m, I, $ = null) {
  return (0, e.default)({
    type: "DeclareModule",
    id: m,
    body: I,
    kind: $
  });
}
function cp(m) {
  return (0, e.default)({
    type: "DeclareModuleExports",
    typeAnnotation: m
  });
}
function fp(m, I = null, $) {
  return (0, e.default)({
    type: "DeclareTypeAlias",
    id: m,
    typeParameters: I,
    right: $
  });
}
function pp(m, I = null, $ = null) {
  return (0, e.default)({
    type: "DeclareOpaqueType",
    id: m,
    typeParameters: I,
    supertype: $
  });
}
function hp(m) {
  return (0, e.default)({
    type: "DeclareVariable",
    id: m
  });
}
function dp(m = null, I = null, $ = null) {
  return (0, e.default)({
    type: "DeclareExportDeclaration",
    declaration: m,
    specifiers: I,
    source: $
  });
}
function mp(m) {
  return (0, e.default)({
    type: "DeclareExportAllDeclaration",
    source: m
  });
}
function yp(m) {
  return (0, e.default)({
    type: "DeclaredPredicate",
    value: m
  });
}
function bp() {
  return {
    type: "ExistsTypeAnnotation"
  };
}
function Tp(m = null, I, $ = null, ce) {
  return (0, e.default)({
    type: "FunctionTypeAnnotation",
    typeParameters: m,
    params: I,
    rest: $,
    returnType: ce
  });
}
function gp(m = null, I) {
  return (0, e.default)({
    type: "FunctionTypeParam",
    name: m,
    typeAnnotation: I
  });
}
function Sp(m, I = null) {
  return (0, e.default)({
    type: "GenericTypeAnnotation",
    id: m,
    typeParameters: I
  });
}
function xp() {
  return {
    type: "InferredPredicate"
  };
}
function Ep(m, I = null) {
  return (0, e.default)({
    type: "InterfaceExtends",
    id: m,
    typeParameters: I
  });
}
function Pp(m, I = null, $ = null, ce) {
  return (0, e.default)({
    type: "InterfaceDeclaration",
    id: m,
    typeParameters: I,
    extends: $,
    body: ce
  });
}
function vp(m = null, I) {
  return (0, e.default)({
    type: "InterfaceTypeAnnotation",
    extends: m,
    body: I
  });
}
function Ap(m) {
  return (0, e.default)({
    type: "IntersectionTypeAnnotation",
    types: m
  });
}
function Ip() {
  return {
    type: "MixedTypeAnnotation"
  };
}
function Cp() {
  return {
    type: "EmptyTypeAnnotation"
  };
}
function wp(m) {
  return (0, e.default)({
    type: "NullableTypeAnnotation",
    typeAnnotation: m
  });
}
function Np(m) {
  return (0, e.default)({
    type: "NumberLiteralTypeAnnotation",
    value: m
  });
}
function Op() {
  return {
    type: "NumberTypeAnnotation"
  };
}
function _p(m, I = [], $ = [], ce = [], tt = !1) {
  return (0, e.default)({
    type: "ObjectTypeAnnotation",
    properties: m,
    indexers: I,
    callProperties: $,
    internalSlots: ce,
    exact: tt
  });
}
function kp(m, I, $, ce, tt) {
  return (0, e.default)({
    type: "ObjectTypeInternalSlot",
    id: m,
    value: I,
    optional: $,
    static: ce,
    method: tt
  });
}
function Dp(m) {
  return (0, e.default)({
    type: "ObjectTypeCallProperty",
    value: m,
    static: null
  });
}
function Lp(m = null, I, $, ce = null) {
  return (0, e.default)({
    type: "ObjectTypeIndexer",
    id: m,
    key: I,
    value: $,
    variance: ce,
    static: null
  });
}
function Mp(m, I, $ = null) {
  return (0, e.default)({
    type: "ObjectTypeProperty",
    key: m,
    value: I,
    variance: $,
    kind: null,
    method: null,
    optional: null,
    proto: null,
    static: null
  });
}
function Bp(m) {
  return (0, e.default)({
    type: "ObjectTypeSpreadProperty",
    argument: m
  });
}
function Fp(m, I = null, $ = null, ce) {
  return (0, e.default)({
    type: "OpaqueType",
    id: m,
    typeParameters: I,
    supertype: $,
    impltype: ce
  });
}
function jp(m, I) {
  return (0, e.default)({
    type: "QualifiedTypeIdentifier",
    id: m,
    qualification: I
  });
}
function Rp(m) {
  return (0, e.default)({
    type: "StringLiteralTypeAnnotation",
    value: m
  });
}
function Up() {
  return {
    type: "StringTypeAnnotation"
  };
}
function Vp() {
  return {
    type: "SymbolTypeAnnotation"
  };
}
function qp() {
  return {
    type: "ThisTypeAnnotation"
  };
}
function $p(m) {
  return (0, e.default)({
    type: "TupleTypeAnnotation",
    types: m
  });
}
function Kp(m) {
  return (0, e.default)({
    type: "TypeofTypeAnnotation",
    argument: m
  });
}
function Wp(m, I = null, $) {
  return (0, e.default)({
    type: "TypeAlias",
    id: m,
    typeParameters: I,
    right: $
  });
}
function Jp(m) {
  return (0, e.default)({
    type: "TypeAnnotation",
    typeAnnotation: m
  });
}
function Yp(m, I) {
  return (0, e.default)({
    type: "TypeCastExpression",
    expression: m,
    typeAnnotation: I
  });
}
function Xp(m = null, I = null, $ = null) {
  return (0, e.default)({
    type: "TypeParameter",
    bound: m,
    default: I,
    variance: $,
    name: null
  });
}
function Hp(m) {
  return (0, e.default)({
    type: "TypeParameterDeclaration",
    params: m
  });
}
function Gp(m) {
  return (0, e.default)({
    type: "TypeParameterInstantiation",
    params: m
  });
}
function zp(m) {
  return (0, e.default)({
    type: "UnionTypeAnnotation",
    types: m
  });
}
function Qp(m) {
  return (0, e.default)({
    type: "Variance",
    kind: m
  });
}
function Zp() {
  return {
    type: "VoidTypeAnnotation"
  };
}
function eh(m, I) {
  return (0, e.default)({
    type: "EnumDeclaration",
    id: m,
    body: I
  });
}
function th(m) {
  return (0, e.default)({
    type: "EnumBooleanBody",
    members: m,
    explicitType: null,
    hasUnknownMembers: null
  });
}
function rh(m) {
  return (0, e.default)({
    type: "EnumNumberBody",
    members: m,
    explicitType: null,
    hasUnknownMembers: null
  });
}
function ih(m) {
  return (0, e.default)({
    type: "EnumStringBody",
    members: m,
    explicitType: null,
    hasUnknownMembers: null
  });
}
function sh(m) {
  return (0, e.default)({
    type: "EnumSymbolBody",
    members: m,
    hasUnknownMembers: null
  });
}
function nh(m) {
  return (0, e.default)({
    type: "EnumBooleanMember",
    id: m,
    init: null
  });
}
function ah(m, I) {
  return (0, e.default)({
    type: "EnumNumberMember",
    id: m,
    init: I
  });
}
function oh(m, I) {
  return (0, e.default)({
    type: "EnumStringMember",
    id: m,
    init: I
  });
}
function uh(m) {
  return (0, e.default)({
    type: "EnumDefaultedMember",
    id: m
  });
}
function lh(m, I) {
  return (0, e.default)({
    type: "IndexedAccessType",
    objectType: m,
    indexType: I
  });
}
function ch(m, I) {
  return (0, e.default)({
    type: "OptionalIndexedAccessType",
    objectType: m,
    indexType: I,
    optional: null
  });
}
function fh(m, I = null) {
  return (0, e.default)({
    type: "JSXAttribute",
    name: m,
    value: I
  });
}
function ph(m) {
  return (0, e.default)({
    type: "JSXClosingElement",
    name: m
  });
}
function hh(m, I = null, $, ce = null) {
  return (0, e.default)({
    type: "JSXElement",
    openingElement: m,
    closingElement: I,
    children: $,
    selfClosing: ce
  });
}
function dh() {
  return {
    type: "JSXEmptyExpression"
  };
}
function mh(m) {
  return (0, e.default)({
    type: "JSXExpressionContainer",
    expression: m
  });
}
function yh(m) {
  return (0, e.default)({
    type: "JSXSpreadChild",
    expression: m
  });
}
function bh(m) {
  return (0, e.default)({
    type: "JSXIdentifier",
    name: m
  });
}
function Th(m, I) {
  return (0, e.default)({
    type: "JSXMemberExpression",
    object: m,
    property: I
  });
}
function gh(m, I) {
  return (0, e.default)({
    type: "JSXNamespacedName",
    namespace: m,
    name: I
  });
}
function Sh(m, I, $ = !1) {
  return (0, e.default)({
    type: "JSXOpeningElement",
    name: m,
    attributes: I,
    selfClosing: $
  });
}
function xh(m) {
  return (0, e.default)({
    type: "JSXSpreadAttribute",
    argument: m
  });
}
function Eh(m) {
  return (0, e.default)({
    type: "JSXText",
    value: m
  });
}
function Ph(m, I, $) {
  return (0, e.default)({
    type: "JSXFragment",
    openingFragment: m,
    closingFragment: I,
    children: $
  });
}
function vh() {
  return {
    type: "JSXOpeningFragment"
  };
}
function Ah() {
  return {
    type: "JSXClosingFragment"
  };
}
function Ih() {
  return {
    type: "Noop"
  };
}
function Ch(m, I) {
  return (0, e.default)({
    type: "Placeholder",
    expectedNode: m,
    name: I
  });
}
function wh(m) {
  return (0, e.default)({
    type: "V8IntrinsicIdentifier",
    name: m
  });
}
function Nh() {
  return {
    type: "ArgumentPlaceholder"
  };
}
function Oh(m, I) {
  return (0, e.default)({
    type: "BindExpression",
    object: m,
    callee: I
  });
}
function _h(m, I) {
  return (0, e.default)({
    type: "ImportAttribute",
    key: m,
    value: I
  });
}
function kh(m) {
  return (0, e.default)({
    type: "Decorator",
    expression: m
  });
}
function Dh(m, I = !1) {
  return (0, e.default)({
    type: "DoExpression",
    body: m,
    async: I
  });
}
function Lh(m) {
  return (0, e.default)({
    type: "ExportDefaultSpecifier",
    exported: m
  });
}
function Mh(m) {
  return (0, e.default)({
    type: "RecordExpression",
    properties: m
  });
}
function Bh(m = []) {
  return (0, e.default)({
    type: "TupleExpression",
    elements: m
  });
}
function Fh(m) {
  return (0, e.default)({
    type: "DecimalLiteral",
    value: m
  });
}
function jh(m) {
  return (0, e.default)({
    type: "ModuleExpression",
    body: m
  });
}
function Rh() {
  return {
    type: "TopicReference"
  };
}
function Uh(m) {
  return (0, e.default)({
    type: "PipelineTopicExpression",
    expression: m
  });
}
function Vh(m) {
  return (0, e.default)({
    type: "PipelineBareFunction",
    callee: m
  });
}
function qh() {
  return {
    type: "PipelinePrimaryTopicReference"
  };
}
function $h(m) {
  return (0, e.default)({
    type: "TSParameterProperty",
    parameter: m
  });
}
function Kh(m = null, I = null, $, ce = null) {
  return (0, e.default)({
    type: "TSDeclareFunction",
    id: m,
    typeParameters: I,
    params: $,
    returnType: ce
  });
}
function Wh(m = null, I, $ = null, ce, tt = null) {
  return (0, e.default)({
    type: "TSDeclareMethod",
    decorators: m,
    key: I,
    typeParameters: $,
    params: ce,
    returnType: tt
  });
}
function Jh(m, I) {
  return (0, e.default)({
    type: "TSQualifiedName",
    left: m,
    right: I
  });
}
function Yh(m = null, I, $ = null) {
  return (0, e.default)({
    type: "TSCallSignatureDeclaration",
    typeParameters: m,
    parameters: I,
    typeAnnotation: $
  });
}
function Xh(m = null, I, $ = null) {
  return (0, e.default)({
    type: "TSConstructSignatureDeclaration",
    typeParameters: m,
    parameters: I,
    typeAnnotation: $
  });
}
function Hh(m, I = null) {
  return (0, e.default)({
    type: "TSPropertySignature",
    key: m,
    typeAnnotation: I,
    kind: null
  });
}
function Gh(m, I = null, $, ce = null) {
  return (0, e.default)({
    type: "TSMethodSignature",
    key: m,
    typeParameters: I,
    parameters: $,
    typeAnnotation: ce,
    kind: null
  });
}
function zh(m, I = null) {
  return (0, e.default)({
    type: "TSIndexSignature",
    parameters: m,
    typeAnnotation: I
  });
}
function Qh() {
  return {
    type: "TSAnyKeyword"
  };
}
function Zh() {
  return {
    type: "TSBooleanKeyword"
  };
}
function ed() {
  return {
    type: "TSBigIntKeyword"
  };
}
function td() {
  return {
    type: "TSIntrinsicKeyword"
  };
}
function rd() {
  return {
    type: "TSNeverKeyword"
  };
}
function id() {
  return {
    type: "TSNullKeyword"
  };
}
function sd() {
  return {
    type: "TSNumberKeyword"
  };
}
function nd() {
  return {
    type: "TSObjectKeyword"
  };
}
function ad() {
  return {
    type: "TSStringKeyword"
  };
}
function od() {
  return {
    type: "TSSymbolKeyword"
  };
}
function ud() {
  return {
    type: "TSUndefinedKeyword"
  };
}
function ld() {
  return {
    type: "TSUnknownKeyword"
  };
}
function cd() {
  return {
    type: "TSVoidKeyword"
  };
}
function fd() {
  return {
    type: "TSThisType"
  };
}
function pd(m = null, I, $ = null) {
  return (0, e.default)({
    type: "TSFunctionType",
    typeParameters: m,
    parameters: I,
    typeAnnotation: $
  });
}
function hd(m = null, I, $ = null) {
  return (0, e.default)({
    type: "TSConstructorType",
    typeParameters: m,
    parameters: I,
    typeAnnotation: $
  });
}
function dd(m, I = null) {
  return (0, e.default)({
    type: "TSTypeReference",
    typeName: m,
    typeParameters: I
  });
}
function md(m, I = null, $ = null) {
  return (0, e.default)({
    type: "TSTypePredicate",
    parameterName: m,
    typeAnnotation: I,
    asserts: $
  });
}
function yd(m, I = null) {
  return (0, e.default)({
    type: "TSTypeQuery",
    exprName: m,
    typeParameters: I
  });
}
function bd(m) {
  return (0, e.default)({
    type: "TSTypeLiteral",
    members: m
  });
}
function Td(m) {
  return (0, e.default)({
    type: "TSArrayType",
    elementType: m
  });
}
function gd(m) {
  return (0, e.default)({
    type: "TSTupleType",
    elementTypes: m
  });
}
function Sd(m) {
  return (0, e.default)({
    type: "TSOptionalType",
    typeAnnotation: m
  });
}
function xd(m) {
  return (0, e.default)({
    type: "TSRestType",
    typeAnnotation: m
  });
}
function Ed(m, I, $ = !1) {
  return (0, e.default)({
    type: "TSNamedTupleMember",
    label: m,
    elementType: I,
    optional: $
  });
}
function Pd(m) {
  return (0, e.default)({
    type: "TSUnionType",
    types: m
  });
}
function vd(m) {
  return (0, e.default)({
    type: "TSIntersectionType",
    types: m
  });
}
function Ad(m, I, $, ce) {
  return (0, e.default)({
    type: "TSConditionalType",
    checkType: m,
    extendsType: I,
    trueType: $,
    falseType: ce
  });
}
function Id(m) {
  return (0, e.default)({
    type: "TSInferType",
    typeParameter: m
  });
}
function Cd(m) {
  return (0, e.default)({
    type: "TSParenthesizedType",
    typeAnnotation: m
  });
}
function wd(m) {
  return (0, e.default)({
    type: "TSTypeOperator",
    typeAnnotation: m,
    operator: null
  });
}
function Nd(m, I) {
  return (0, e.default)({
    type: "TSIndexedAccessType",
    objectType: m,
    indexType: I
  });
}
function Od(m, I = null, $ = null) {
  return (0, e.default)({
    type: "TSMappedType",
    typeParameter: m,
    typeAnnotation: I,
    nameType: $
  });
}
function _d(m) {
  return (0, e.default)({
    type: "TSLiteralType",
    literal: m
  });
}
function kd(m, I = null) {
  return (0, e.default)({
    type: "TSExpressionWithTypeArguments",
    expression: m,
    typeParameters: I
  });
}
function Dd(m, I = null, $ = null, ce) {
  return (0, e.default)({
    type: "TSInterfaceDeclaration",
    id: m,
    typeParameters: I,
    extends: $,
    body: ce
  });
}
function Ld(m) {
  return (0, e.default)({
    type: "TSInterfaceBody",
    body: m
  });
}
function Md(m, I = null, $) {
  return (0, e.default)({
    type: "TSTypeAliasDeclaration",
    id: m,
    typeParameters: I,
    typeAnnotation: $
  });
}
function Bd(m, I = null) {
  return (0, e.default)({
    type: "TSInstantiationExpression",
    expression: m,
    typeParameters: I
  });
}
function Fd(m, I) {
  return (0, e.default)({
    type: "TSAsExpression",
    expression: m,
    typeAnnotation: I
  });
}
function jd(m, I) {
  return (0, e.default)({
    type: "TSSatisfiesExpression",
    expression: m,
    typeAnnotation: I
  });
}
function Rd(m, I) {
  return (0, e.default)({
    type: "TSTypeAssertion",
    typeAnnotation: m,
    expression: I
  });
}
function Ud(m, I) {
  return (0, e.default)({
    type: "TSEnumDeclaration",
    id: m,
    members: I
  });
}
function Vd(m, I = null) {
  return (0, e.default)({
    type: "TSEnumMember",
    id: m,
    initializer: I
  });
}
function qd(m, I) {
  return (0, e.default)({
    type: "TSModuleDeclaration",
    id: m,
    body: I
  });
}
function $d(m) {
  return (0, e.default)({
    type: "TSModuleBlock",
    body: m
  });
}
function Kd(m, I = null, $ = null) {
  return (0, e.default)({
    type: "TSImportType",
    argument: m,
    qualifier: I,
    typeParameters: $
  });
}
function Wd(m, I) {
  return (0, e.default)({
    type: "TSImportEqualsDeclaration",
    id: m,
    moduleReference: I,
    isExport: null
  });
}
function Jd(m) {
  return (0, e.default)({
    type: "TSExternalModuleReference",
    expression: m
  });
}
function Yd(m) {
  return (0, e.default)({
    type: "TSNonNullExpression",
    expression: m
  });
}
function Xd(m) {
  return (0, e.default)({
    type: "TSExportAssignment",
    expression: m
  });
}
function Hd(m) {
  return (0, e.default)({
    type: "TSNamespaceExportDeclaration",
    id: m
  });
}
function Gd(m) {
  return (0, e.default)({
    type: "TSTypeAnnotation",
    typeAnnotation: m
  });
}
function zd(m) {
  return (0, e.default)({
    type: "TSTypeParameterInstantiation",
    params: m
  });
}
function Qd(m) {
  return (0, e.default)({
    type: "TSTypeParameterDeclaration",
    params: m
  });
}
function Zd(m = null, I = null, $) {
  return (0, e.default)({
    type: "TSTypeParameter",
    constraint: m,
    default: I,
    name: $
  });
}
function e0(m) {
  return (0, t.default)("NumberLiteral", "NumericLiteral", "The node type "), W(m);
}
function t0(m, I = "") {
  return (0, t.default)("RegexLiteral", "RegExpLiteral", "The node type "), L(m, I);
}
function r0(m) {
  return (0, t.default)("RestProperty", "RestElement", "The node type "), V(m);
}
function i0(m) {
  return (0, t.default)("SpreadProperty", "SpreadElement", "The node type "), nt(m);
}
return b;
}
var Ro;
function Vg() {
if (Ro) return Di;
Ro = 1, Object.defineProperty(Di, "__esModule", {
  value: !0
}), Di.default = r;
var e = Pt(), t = Ce();
function r(i, s) {
  const n = i.value.split(/\r\n|\n|\r/);
  let a = 0;
  for (let u = 0; u < n.length; u++)
    /[^ \t]/.exec(n[u]) && (a = u);
  let o = "";
  for (let u = 0; u < n.length; u++) {
    const l = n[u], c = u === 0, f = u === n.length - 1, p = u === a;
    let h = l.replace(/\t/g, " ");
    c || (h = h.replace(/^[ ]+/, "")), f || (h = h.replace(/[ ]+$/, "")), h && (p || (h += " "), o += h);
  }
  o && s.push((0, t.inherits)((0, e.stringLiteral)(o), i));
}
return Di;
}
var Uo;
function qg() {
if (Uo) return ki;
Uo = 1, Object.defineProperty(ki, "__esModule", {
  value: !0
}), ki.default = r;
var e = T, t = Vg();
function r(i) {
  const s = [];
  for (let n = 0; n < i.children.length; n++) {
    let a = i.children[n];
    if ((0, e.isJSXText)(a)) {
      (0, t.default)(a, s);
      continue;
    }
    (0, e.isJSXExpressionContainer)(a) && (a = a.expression), !(0, e.isJSXEmptyExpression)(a) && s.push(a);
  }
  return s;
}
return ki;
}
var oa = {}, Ss = {};
Object.defineProperty(Ss, "__esModule", {
value: !0
});
Ss.default = Kg;
var $g = Dt();
function Kg(e) {
return !!(e && $g.VISITOR_KEYS[e.type]);
}
Object.defineProperty(oa, "__esModule", {
value: !0
});
oa.default = Jg;
var Wg = Ss;
function Jg(e) {
if (!(0, Wg.default)(e)) {
  var t;
  const r = (t = e == null ? void 0 : e.type) != null ? t : JSON.stringify(e);
  throw new TypeError(`Not a valid node of type "${r}"`);
}
}
var S = {};
Object.defineProperty(S, "__esModule", {
value: !0
});
S.assertAccessor = uv;
S.assertAnyTypeAnnotation = wx;
S.assertArgumentPlaceholder = i2;
S.assertArrayExpression = Xg;
S.assertArrayPattern = JS;
S.assertArrayTypeAnnotation = Nx;
S.assertArrowFunctionExpression = YS;
S.assertAssignmentExpression = Hg;
S.assertAssignmentPattern = WS;
S.assertAwaitExpression = yx;
S.assertBigIntLiteral = Tx;
S.assertBinary = OP;
S.assertBinaryExpression = Gg;
S.assertBindExpression = s2;
S.assertBlock = DP;
S.assertBlockParent = kP;
S.assertBlockStatement = eS;
S.assertBooleanLiteral = xS;
S.assertBooleanLiteralTypeAnnotation = _x;
S.assertBooleanTypeAnnotation = Ox;
S.assertBreakStatement = tS;
S.assertCallExpression = rS;
S.assertCatchClause = iS;
S.assertClass = sv;
S.assertClassAccessorProperty = Px;
S.assertClassBody = XS;
S.assertClassDeclaration = GS;
S.assertClassExpression = HS;
S.assertClassImplements = Dx;
S.assertClassMethod = ux;
S.assertClassPrivateMethod = Ax;
S.assertClassPrivateProperty = vx;
S.assertClassProperty = Ex;
S.assertCompletionStatement = BP;
S.assertConditional = FP;
S.assertConditionalExpression = sS;
S.assertContinueStatement = nS;
S.assertDebuggerStatement = aS;
S.assertDecimalLiteral = f2;
S.assertDeclaration = JP;
S.assertDeclareClass = Lx;
S.assertDeclareExportAllDeclaration = $x;
S.assertDeclareExportDeclaration = qx;
S.assertDeclareFunction = Mx;
S.assertDeclareInterface = Bx;
S.assertDeclareModule = Fx;
S.assertDeclareModuleExports = jx;
S.assertDeclareOpaqueType = Ux;
S.assertDeclareTypeAlias = Rx;
S.assertDeclareVariable = Vx;
S.assertDeclaredPredicate = Kx;
S.assertDecorator = a2;
S.assertDirective = Qg;
S.assertDirectiveLiteral = Zg;
S.assertDoExpression = o2;
S.assertDoWhileStatement = oS;
S.assertEmptyStatement = uS;
S.assertEmptyTypeAnnotation = tE;
S.assertEnumBody = mv;
S.assertEnumBooleanBody = NE;
S.assertEnumBooleanMember = DE;
S.assertEnumDeclaration = wE;
S.assertEnumDefaultedMember = BE;
S.assertEnumMember = yv;
S.assertEnumNumberBody = OE;
S.assertEnumNumberMember = LE;
S.assertEnumStringBody = _E;
S.assertEnumStringMember = ME;
S.assertEnumSymbolBody = kE;
S.assertExistsTypeAnnotation = Wx;
S.assertExportAllDeclaration = zS;
S.assertExportDeclaration = av;
S.assertExportDefaultDeclaration = QS;
S.assertExportDefaultSpecifier = u2;
S.assertExportNamedDeclaration = ZS;
S.assertExportNamespaceSpecifier = gx;
S.assertExportSpecifier = ex;
S.assertExpression = NP;
S.assertExpressionStatement = lS;
S.assertExpressionWrapper = UP;
S.assertFile = cS;
S.assertFlow = cv;
S.assertFlowBaseAnnotation = pv;
S.assertFlowDeclaration = hv;
S.assertFlowPredicate = dv;
S.assertFlowType = fv;
S.assertFor = VP;
S.assertForInStatement = fS;
S.assertForOfStatement = tx;
S.assertForStatement = pS;
S.assertForXStatement = qP;
S.assertFunction = $P;
S.assertFunctionDeclaration = hS;
S.assertFunctionExpression = dS;
S.assertFunctionParent = KP;
S.assertFunctionTypeAnnotation = Jx;
S.assertFunctionTypeParam = Yx;
S.assertGenericTypeAnnotation = Xx;
S.assertIdentifier = mS;
S.assertIfStatement = yS;
S.assertImmutable = zP;
S.assertImport = bx;
S.assertImportAttribute = n2;
S.assertImportDeclaration = rx;
S.assertImportDefaultSpecifier = ix;
S.assertImportExpression = ax;
S.assertImportNamespaceSpecifier = sx;
S.assertImportOrExportDeclaration = nv;
S.assertImportSpecifier = nx;
S.assertIndexedAccessType = FE;
S.assertInferredPredicate = Hx;
S.assertInterfaceDeclaration = zx;
S.assertInterfaceExtends = Gx;
S.assertInterfaceTypeAnnotation = Qx;
S.assertInterpreterDirective = zg;
S.assertIntersectionTypeAnnotation = Zx;
S.assertJSX = bv;
S.assertJSXAttribute = RE;
S.assertJSXClosingElement = UE;
S.assertJSXClosingFragment = ZE;
S.assertJSXElement = VE;
S.assertJSXEmptyExpression = qE;
S.assertJSXExpressionContainer = $E;
S.assertJSXFragment = zE;
S.assertJSXIdentifier = WE;
S.assertJSXMemberExpression = JE;
S.assertJSXNamespacedName = YE;
S.assertJSXOpeningElement = XE;
S.assertJSXOpeningFragment = QE;
S.assertJSXSpreadAttribute = HE;
S.assertJSXSpreadChild = KE;
S.assertJSXText = GE;
S.assertLVal = XP;
S.assertLabeledStatement = bS;
S.assertLiteral = GP;
S.assertLogicalExpression = PS;
S.assertLoop = jP;
S.assertMemberExpression = vS;
S.assertMetaProperty = ox;
S.assertMethod = ZP;
S.assertMiscellaneous = Tv;
S.assertMixedTypeAnnotation = eE;
S.assertModuleDeclaration = Cv;
S.assertModuleExpression = p2;
S.assertModuleSpecifier = ov;
S.assertNewExpression = AS;
S.assertNoop = e2;
S.assertNullLiteral = SS;
S.assertNullLiteralTypeAnnotation = kx;
S.assertNullableTypeAnnotation = rE;
S.assertNumberLiteral = Pv;
S.assertNumberLiteralTypeAnnotation = iE;
S.assertNumberTypeAnnotation = sE;
S.assertNumericLiteral = gS;
S.assertObjectExpression = CS;
S.assertObjectMember = ev;
S.assertObjectMethod = wS;
S.assertObjectPattern = lx;
S.assertObjectProperty = NS;
S.assertObjectTypeAnnotation = nE;
S.assertObjectTypeCallProperty = oE;
S.assertObjectTypeIndexer = uE;
S.assertObjectTypeInternalSlot = aE;
S.assertObjectTypeProperty = lE;
S.assertObjectTypeSpreadProperty = cE;
S.assertOpaqueType = fE;
S.assertOptionalCallExpression = xx;
S.assertOptionalIndexedAccessType = jE;
S.assertOptionalMemberExpression = Sx;
S.assertParenthesizedExpression = DS;
S.assertPattern = iv;
S.assertPatternLike = YP;
S.assertPipelineBareFunction = m2;
S.assertPipelinePrimaryTopicReference = y2;
S.assertPipelineTopicExpression = d2;
S.assertPlaceholder = t2;
S.assertPrivate = lv;
S.assertPrivateName = Ix;
S.assertProgram = IS;
S.assertProperty = tv;
S.assertPureish = WP;
S.assertQualifiedTypeIdentifier = pE;
S.assertRecordExpression = l2;
S.assertRegExpLiteral = ES;
S.assertRegexLiteral = vv;
S.assertRestElement = OS;
S.assertRestProperty = Av;
S.assertReturnStatement = _S;
S.assertScopable = _P;
S.assertSequenceExpression = kS;
S.assertSpreadElement = cx;
S.assertSpreadProperty = Iv;
S.assertStandardized = wP;
S.assertStatement = LP;
S.assertStaticBlock = Cx;
S.assertStringLiteral = TS;
S.assertStringLiteralTypeAnnotation = hE;
S.assertStringTypeAnnotation = dE;
S.assertSuper = fx;
S.assertSwitchCase = LS;
S.assertSwitchStatement = MS;
S.assertSymbolTypeAnnotation = mE;
S.assertTSAnyKeyword = I2;
S.assertTSArrayType = J2;
S.assertTSAsExpression = fP;
S.assertTSBaseType = Ev;
S.assertTSBigIntKeyword = w2;
S.assertTSBooleanKeyword = C2;
S.assertTSCallSignatureDeclaration = x2;
S.assertTSConditionalType = Z2;
S.assertTSConstructSignatureDeclaration = E2;
S.assertTSConstructorType = V2;
S.assertTSDeclareFunction = T2;
S.assertTSDeclareMethod = g2;
S.assertTSEntityName = HP;
S.assertTSEnumDeclaration = dP;
S.assertTSEnumMember = mP;
S.assertTSExportAssignment = EP;
S.assertTSExpressionWithTypeArguments = aP;
S.assertTSExternalModuleReference = SP;
S.assertTSFunctionType = U2;
S.assertTSImportEqualsDeclaration = gP;
S.assertTSImportType = TP;
S.assertTSIndexSignature = A2;
S.assertTSIndexedAccessType = iP;
S.assertTSInferType = eP;
S.assertTSInstantiationExpression = cP;
S.assertTSInterfaceBody = uP;
S.assertTSInterfaceDeclaration = oP;
S.assertTSIntersectionType = Q2;
S.assertTSIntrinsicKeyword = N2;
S.assertTSLiteralType = nP;
S.assertTSMappedType = sP;
S.assertTSMethodSignature = v2;
S.assertTSModuleBlock = bP;
S.assertTSModuleDeclaration = yP;
S.assertTSNamedTupleMember = G2;
S.assertTSNamespaceExportDeclaration = PP;
S.assertTSNeverKeyword = O2;
S.assertTSNonNullExpression = xP;
S.assertTSNullKeyword = _2;
S.assertTSNumberKeyword = k2;
S.assertTSObjectKeyword = D2;
S.assertTSOptionalType = X2;
S.assertTSParameterProperty = b2;
S.assertTSParenthesizedType = tP;
S.assertTSPropertySignature = P2;
S.assertTSQualifiedName = S2;
S.assertTSRestType = H2;
S.assertTSSatisfiesExpression = pP;
S.assertTSStringKeyword = L2;
S.assertTSSymbolKeyword = M2;
S.assertTSThisType = R2;
S.assertTSTupleType = Y2;
S.assertTSType = xv;
S.assertTSTypeAliasDeclaration = lP;
S.assertTSTypeAnnotation = vP;
S.assertTSTypeAssertion = hP;
S.assertTSTypeElement = Sv;
S.assertTSTypeLiteral = W2;
S.assertTSTypeOperator = rP;
S.assertTSTypeParameter = CP;
S.assertTSTypeParameterDeclaration = IP;
S.assertTSTypeParameterInstantiation = AP;
S.assertTSTypePredicate = $2;
S.assertTSTypeQuery = K2;
S.assertTSTypeReference = q2;
S.assertTSUndefinedKeyword = B2;
S.assertTSUnionType = z2;
S.assertTSUnknownKeyword = F2;
S.assertTSVoidKeyword = j2;
S.assertTaggedTemplateExpression = px;
S.assertTemplateElement = hx;
S.assertTemplateLiteral = dx;
S.assertTerminatorless = MP;
S.assertThisExpression = BS;
S.assertThisTypeAnnotation = yE;
S.assertThrowStatement = FS;
S.assertTopicReference = h2;
S.assertTryStatement = jS;
S.assertTupleExpression = c2;
S.assertTupleTypeAnnotation = bE;
S.assertTypeAlias = gE;
S.assertTypeAnnotation = SE;
S.assertTypeCastExpression = xE;
S.assertTypeParameter = EE;
S.assertTypeParameterDeclaration = PE;
S.assertTypeParameterInstantiation = vE;
S.assertTypeScript = gv;
S.assertTypeofTypeAnnotation = TE;
S.assertUnaryExpression = RS;
S.assertUnaryLike = rv;
S.assertUnionTypeAnnotation = AE;
S.assertUpdateExpression = US;
S.assertUserWhitespacable = QP;
S.assertV8IntrinsicIdentifier = r2;
S.assertVariableDeclaration = VS;
S.assertVariableDeclarator = qS;
S.assertVariance = IE;
S.assertVoidTypeAnnotation = CE;
S.assertWhile = RP;
S.assertWhileStatement = $S;
S.assertWithStatement = KS;
S.assertYieldExpression = mx;
var Yg = fi(), mi = kr;
function x(e, t, r) {
if (!(0, Yg.default)(e, t, r))
  throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
}
function Xg(e, t) {
x("ArrayExpression", e, t);
}
function Hg(e, t) {
x("AssignmentExpression", e, t);
}
function Gg(e, t) {
x("BinaryExpression", e, t);
}
function zg(e, t) {
x("InterpreterDirective", e, t);
}
function Qg(e, t) {
x("Directive", e, t);
}
function Zg(e, t) {
x("DirectiveLiteral", e, t);
}
function eS(e, t) {
x("BlockStatement", e, t);
}
function tS(e, t) {
x("BreakStatement", e, t);
}
function rS(e, t) {
x("CallExpression", e, t);
}
function iS(e, t) {
x("CatchClause", e, t);
}
function sS(e, t) {
x("ConditionalExpression", e, t);
}
function nS(e, t) {
x("ContinueStatement", e, t);
}
function aS(e, t) {
x("DebuggerStatement", e, t);
}
function oS(e, t) {
x("DoWhileStatement", e, t);
}
function uS(e, t) {
x("EmptyStatement", e, t);
}
function lS(e, t) {
x("ExpressionStatement", e, t);
}
function cS(e, t) {
x("File", e, t);
}
function fS(e, t) {
x("ForInStatement", e, t);
}
function pS(e, t) {
x("ForStatement", e, t);
}
function hS(e, t) {
x("FunctionDeclaration", e, t);
}
function dS(e, t) {
x("FunctionExpression", e, t);
}
function mS(e, t) {
x("Identifier", e, t);
}
function yS(e, t) {
x("IfStatement", e, t);
}
function bS(e, t) {
x("LabeledStatement", e, t);
}
function TS(e, t) {
x("StringLiteral", e, t);
}
function gS(e, t) {
x("NumericLiteral", e, t);
}
function SS(e, t) {
x("NullLiteral", e, t);
}
function xS(e, t) {
x("BooleanLiteral", e, t);
}
function ES(e, t) {
x("RegExpLiteral", e, t);
}
function PS(e, t) {
x("LogicalExpression", e, t);
}
function vS(e, t) {
x("MemberExpression", e, t);
}
function AS(e, t) {
x("NewExpression", e, t);
}
function IS(e, t) {
x("Program", e, t);
}
function CS(e, t) {
x("ObjectExpression", e, t);
}
function wS(e, t) {
x("ObjectMethod", e, t);
}
function NS(e, t) {
x("ObjectProperty", e, t);
}
function OS(e, t) {
x("RestElement", e, t);
}
function _S(e, t) {
x("ReturnStatement", e, t);
}
function kS(e, t) {
x("SequenceExpression", e, t);
}
function DS(e, t) {
x("ParenthesizedExpression", e, t);
}
function LS(e, t) {
x("SwitchCase", e, t);
}
function MS(e, t) {
x("SwitchStatement", e, t);
}
function BS(e, t) {
x("ThisExpression", e, t);
}
function FS(e, t) {
x("ThrowStatement", e, t);
}
function jS(e, t) {
x("TryStatement", e, t);
}
function RS(e, t) {
x("UnaryExpression", e, t);
}
function US(e, t) {
x("UpdateExpression", e, t);
}
function VS(e, t) {
x("VariableDeclaration", e, t);
}
function qS(e, t) {
x("VariableDeclarator", e, t);
}
function $S(e, t) {
x("WhileStatement", e, t);
}
function KS(e, t) {
x("WithStatement", e, t);
}
function WS(e, t) {
x("AssignmentPattern", e, t);
}
function JS(e, t) {
x("ArrayPattern", e, t);
}
function YS(e, t) {
x("ArrowFunctionExpression", e, t);
}
function XS(e, t) {
x("ClassBody", e, t);
}
function HS(e, t) {
x("ClassExpression", e, t);
}
function GS(e, t) {
x("ClassDeclaration", e, t);
}
function zS(e, t) {
x("ExportAllDeclaration", e, t);
}
function QS(e, t) {
x("ExportDefaultDeclaration", e, t);
}
function ZS(e, t) {
x("ExportNamedDeclaration", e, t);
}
function ex(e, t) {
x("ExportSpecifier", e, t);
}
function tx(e, t) {
x("ForOfStatement", e, t);
}
function rx(e, t) {
x("ImportDeclaration", e, t);
}
function ix(e, t) {
x("ImportDefaultSpecifier", e, t);
}
function sx(e, t) {
x("ImportNamespaceSpecifier", e, t);
}
function nx(e, t) {
x("ImportSpecifier", e, t);
}
function ax(e, t) {
x("ImportExpression", e, t);
}
function ox(e, t) {
x("MetaProperty", e, t);
}
function ux(e, t) {
x("ClassMethod", e, t);
}
function lx(e, t) {
x("ObjectPattern", e, t);
}
function cx(e, t) {
x("SpreadElement", e, t);
}
function fx(e, t) {
x("Super", e, t);
}
function px(e, t) {
x("TaggedTemplateExpression", e, t);
}
function hx(e, t) {
x("TemplateElement", e, t);
}
function dx(e, t) {
x("TemplateLiteral", e, t);
}
function mx(e, t) {
x("YieldExpression", e, t);
}
function yx(e, t) {
x("AwaitExpression", e, t);
}
function bx(e, t) {
x("Import", e, t);
}
function Tx(e, t) {
x("BigIntLiteral", e, t);
}
function gx(e, t) {
x("ExportNamespaceSpecifier", e, t);
}
function Sx(e, t) {
x("OptionalMemberExpression", e, t);
}
function xx(e, t) {
x("OptionalCallExpression", e, t);
}
function Ex(e, t) {
x("ClassProperty", e, t);
}
function Px(e, t) {
x("ClassAccessorProperty", e, t);
}
function vx(e, t) {
x("ClassPrivateProperty", e, t);
}
function Ax(e, t) {
x("ClassPrivateMethod", e, t);
}
function Ix(e, t) {
x("PrivateName", e, t);
}
function Cx(e, t) {
x("StaticBlock", e, t);
}
function wx(e, t) {
x("AnyTypeAnnotation", e, t);
}
function Nx(e, t) {
x("ArrayTypeAnnotation", e, t);
}
function Ox(e, t) {
x("BooleanTypeAnnotation", e, t);
}
function _x(e, t) {
x("BooleanLiteralTypeAnnotation", e, t);
}
function kx(e, t) {
x("NullLiteralTypeAnnotation", e, t);
}
function Dx(e, t) {
x("ClassImplements", e, t);
}
function Lx(e, t) {
x("DeclareClass", e, t);
}
function Mx(e, t) {
x("DeclareFunction", e, t);
}
function Bx(e, t) {
x("DeclareInterface", e, t);
}
function Fx(e, t) {
x("DeclareModule", e, t);
}
function jx(e, t) {
x("DeclareModuleExports", e, t);
}
function Rx(e, t) {
x("DeclareTypeAlias", e, t);
}
function Ux(e, t) {
x("DeclareOpaqueType", e, t);
}
function Vx(e, t) {
x("DeclareVariable", e, t);
}
function qx(e, t) {
x("DeclareExportDeclaration", e, t);
}
function $x(e, t) {
x("DeclareExportAllDeclaration", e, t);
}
function Kx(e, t) {
x("DeclaredPredicate", e, t);
}
function Wx(e, t) {
x("ExistsTypeAnnotation", e, t);
}
function Jx(e, t) {
x("FunctionTypeAnnotation", e, t);
}
function Yx(e, t) {
x("FunctionTypeParam", e, t);
}
function Xx(e, t) {
x("GenericTypeAnnotation", e, t);
}
function Hx(e, t) {
x("InferredPredicate", e, t);
}
function Gx(e, t) {
x("InterfaceExtends", e, t);
}
function zx(e, t) {
x("InterfaceDeclaration", e, t);
}
function Qx(e, t) {
x("InterfaceTypeAnnotation", e, t);
}
function Zx(e, t) {
x("IntersectionTypeAnnotation", e, t);
}
function eE(e, t) {
x("MixedTypeAnnotation", e, t);
}
function tE(e, t) {
x("EmptyTypeAnnotation", e, t);
}
function rE(e, t) {
x("NullableTypeAnnotation", e, t);
}
function iE(e, t) {
x("NumberLiteralTypeAnnotation", e, t);
}
function sE(e, t) {
x("NumberTypeAnnotation", e, t);
}
function nE(e, t) {
x("ObjectTypeAnnotation", e, t);
}
function aE(e, t) {
x("ObjectTypeInternalSlot", e, t);
}
function oE(e, t) {
x("ObjectTypeCallProperty", e, t);
}
function uE(e, t) {
x("ObjectTypeIndexer", e, t);
}
function lE(e, t) {
x("ObjectTypeProperty", e, t);
}
function cE(e, t) {
x("ObjectTypeSpreadProperty", e, t);
}
function fE(e, t) {
x("OpaqueType", e, t);
}
function pE(e, t) {
x("QualifiedTypeIdentifier", e, t);
}
function hE(e, t) {
x("StringLiteralTypeAnnotation", e, t);
}
function dE(e, t) {
x("StringTypeAnnotation", e, t);
}
function mE(e, t) {
x("SymbolTypeAnnotation", e, t);
}
function yE(e, t) {
x("ThisTypeAnnotation", e, t);
}
function bE(e, t) {
x("TupleTypeAnnotation", e, t);
}
function TE(e, t) {
x("TypeofTypeAnnotation", e, t);
}
function gE(e, t) {
x("TypeAlias", e, t);
}
function SE(e, t) {
x("TypeAnnotation", e, t);
}
function xE(e, t) {
x("TypeCastExpression", e, t);
}
function EE(e, t) {
x("TypeParameter", e, t);
}
function PE(e, t) {
x("TypeParameterDeclaration", e, t);
}
function vE(e, t) {
x("TypeParameterInstantiation", e, t);
}
function AE(e, t) {
x("UnionTypeAnnotation", e, t);
}
function IE(e, t) {
x("Variance", e, t);
}
function CE(e, t) {
x("VoidTypeAnnotation", e, t);
}
function wE(e, t) {
x("EnumDeclaration", e, t);
}
function NE(e, t) {
x("EnumBooleanBody", e, t);
}
function OE(e, t) {
x("EnumNumberBody", e, t);
}
function _E(e, t) {
x("EnumStringBody", e, t);
}
function kE(e, t) {
x("EnumSymbolBody", e, t);
}
function DE(e, t) {
x("EnumBooleanMember", e, t);
}
function LE(e, t) {
x("EnumNumberMember", e, t);
}
function ME(e, t) {
x("EnumStringMember", e, t);
}
function BE(e, t) {
x("EnumDefaultedMember", e, t);
}
function FE(e, t) {
x("IndexedAccessType", e, t);
}
function jE(e, t) {
x("OptionalIndexedAccessType", e, t);
}
function RE(e, t) {
x("JSXAttribute", e, t);
}
function UE(e, t) {
x("JSXClosingElement", e, t);
}
function VE(e, t) {
x("JSXElement", e, t);
}
function qE(e, t) {
x("JSXEmptyExpression", e, t);
}
function $E(e, t) {
x("JSXExpressionContainer", e, t);
}
function KE(e, t) {
x("JSXSpreadChild", e, t);
}
function WE(e, t) {
x("JSXIdentifier", e, t);
}
function JE(e, t) {
x("JSXMemberExpression", e, t);
}
function YE(e, t) {
x("JSXNamespacedName", e, t);
}
function XE(e, t) {
x("JSXOpeningElement", e, t);
}
function HE(e, t) {
x("JSXSpreadAttribute", e, t);
}
function GE(e, t) {
x("JSXText", e, t);
}
function zE(e, t) {
x("JSXFragment", e, t);
}
function QE(e, t) {
x("JSXOpeningFragment", e, t);
}
function ZE(e, t) {
x("JSXClosingFragment", e, t);
}
function e2(e, t) {
x("Noop", e, t);
}
function t2(e, t) {
x("Placeholder", e, t);
}
function r2(e, t) {
x("V8IntrinsicIdentifier", e, t);
}
function i2(e, t) {
x("ArgumentPlaceholder", e, t);
}
function s2(e, t) {
x("BindExpression", e, t);
}
function n2(e, t) {
x("ImportAttribute", e, t);
}
function a2(e, t) {
x("Decorator", e, t);
}
function o2(e, t) {
x("DoExpression", e, t);
}
function u2(e, t) {
x("ExportDefaultSpecifier", e, t);
}
function l2(e, t) {
x("RecordExpression", e, t);
}
function c2(e, t) {
x("TupleExpression", e, t);
}
function f2(e, t) {
x("DecimalLiteral", e, t);
}
function p2(e, t) {
x("ModuleExpression", e, t);
}
function h2(e, t) {
x("TopicReference", e, t);
}
function d2(e, t) {
x("PipelineTopicExpression", e, t);
}
function m2(e, t) {
x("PipelineBareFunction", e, t);
}
function y2(e, t) {
x("PipelinePrimaryTopicReference", e, t);
}
function b2(e, t) {
x("TSParameterProperty", e, t);
}
function T2(e, t) {
x("TSDeclareFunction", e, t);
}
function g2(e, t) {
x("TSDeclareMethod", e, t);
}
function S2(e, t) {
x("TSQualifiedName", e, t);
}
function x2(e, t) {
x("TSCallSignatureDeclaration", e, t);
}
function E2(e, t) {
x("TSConstructSignatureDeclaration", e, t);
}
function P2(e, t) {
x("TSPropertySignature", e, t);
}
function v2(e, t) {
x("TSMethodSignature", e, t);
}
function A2(e, t) {
x("TSIndexSignature", e, t);
}
function I2(e, t) {
x("TSAnyKeyword", e, t);
}
function C2(e, t) {
x("TSBooleanKeyword", e, t);
}
function w2(e, t) {
x("TSBigIntKeyword", e, t);
}
function N2(e, t) {
x("TSIntrinsicKeyword", e, t);
}
function O2(e, t) {
x("TSNeverKeyword", e, t);
}
function _2(e, t) {
x("TSNullKeyword", e, t);
}
function k2(e, t) {
x("TSNumberKeyword", e, t);
}
function D2(e, t) {
x("TSObjectKeyword", e, t);
}
function L2(e, t) {
x("TSStringKeyword", e, t);
}
function M2(e, t) {
x("TSSymbolKeyword", e, t);
}
function B2(e, t) {
x("TSUndefinedKeyword", e, t);
}
function F2(e, t) {
x("TSUnknownKeyword", e, t);
}
function j2(e, t) {
x("TSVoidKeyword", e, t);
}
function R2(e, t) {
x("TSThisType", e, t);
}
function U2(e, t) {
x("TSFunctionType", e, t);
}
function V2(e, t) {
x("TSConstructorType", e, t);
}
function q2(e, t) {
x("TSTypeReference", e, t);
}
function $2(e, t) {
x("TSTypePredicate", e, t);
}
function K2(e, t) {
x("TSTypeQuery", e, t);
}
function W2(e, t) {
x("TSTypeLiteral", e, t);
}
function J2(e, t) {
x("TSArrayType", e, t);
}
function Y2(e, t) {
x("TSTupleType", e, t);
}
function X2(e, t) {
x("TSOptionalType", e, t);
}
function H2(e, t) {
x("TSRestType", e, t);
}
function G2(e, t) {
x("TSNamedTupleMember", e, t);
}
function z2(e, t) {
x("TSUnionType", e, t);
}
function Q2(e, t) {
x("TSIntersectionType", e, t);
}
function Z2(e, t) {
x("TSConditionalType", e, t);
}
function eP(e, t) {
x("TSInferType", e, t);
}
function tP(e, t) {
x("TSParenthesizedType", e, t);
}
function rP(e, t) {
x("TSTypeOperator", e, t);
}
function iP(e, t) {
x("TSIndexedAccessType", e, t);
}
function sP(e, t) {
x("TSMappedType", e, t);
}
function nP(e, t) {
x("TSLiteralType", e, t);
}
function aP(e, t) {
x("TSExpressionWithTypeArguments", e, t);
}
function oP(e, t) {
x("TSInterfaceDeclaration", e, t);
}
function uP(e, t) {
x("TSInterfaceBody", e, t);
}
function lP(e, t) {
x("TSTypeAliasDeclaration", e, t);
}
function cP(e, t) {
x("TSInstantiationExpression", e, t);
}
function fP(e, t) {
x("TSAsExpression", e, t);
}
function pP(e, t) {
x("TSSatisfiesExpression", e, t);
}
function hP(e, t) {
x("TSTypeAssertion", e, t);
}
function dP(e, t) {
x("TSEnumDeclaration", e, t);
}
function mP(e, t) {
x("TSEnumMember", e, t);
}
function yP(e, t) {
x("TSModuleDeclaration", e, t);
}
function bP(e, t) {
x("TSModuleBlock", e, t);
}
function TP(e, t) {
x("TSImportType", e, t);
}
function gP(e, t) {
x("TSImportEqualsDeclaration", e, t);
}
function SP(e, t) {
x("TSExternalModuleReference", e, t);
}
function xP(e, t) {
x("TSNonNullExpression", e, t);
}
function EP(e, t) {
x("TSExportAssignment", e, t);
}
function PP(e, t) {
x("TSNamespaceExportDeclaration", e, t);
}
function vP(e, t) {
x("TSTypeAnnotation", e, t);
}
function AP(e, t) {
x("TSTypeParameterInstantiation", e, t);
}
function IP(e, t) {
x("TSTypeParameterDeclaration", e, t);
}
function CP(e, t) {
x("TSTypeParameter", e, t);
}
function wP(e, t) {
x("Standardized", e, t);
}
function NP(e, t) {
x("Expression", e, t);
}
function OP(e, t) {
x("Binary", e, t);
}
function _P(e, t) {
x("Scopable", e, t);
}
function kP(e, t) {
x("BlockParent", e, t);
}
function DP(e, t) {
x("Block", e, t);
}
function LP(e, t) {
x("Statement", e, t);
}
function MP(e, t) {
x("Terminatorless", e, t);
}
function BP(e, t) {
x("CompletionStatement", e, t);
}
function FP(e, t) {
x("Conditional", e, t);
}
function jP(e, t) {
x("Loop", e, t);
}
function RP(e, t) {
x("While", e, t);
}
function UP(e, t) {
x("ExpressionWrapper", e, t);
}
function VP(e, t) {
x("For", e, t);
}
function qP(e, t) {
x("ForXStatement", e, t);
}
function $P(e, t) {
x("Function", e, t);
}
function KP(e, t) {
x("FunctionParent", e, t);
}
function WP(e, t) {
x("Pureish", e, t);
}
function JP(e, t) {
x("Declaration", e, t);
}
function YP(e, t) {
x("PatternLike", e, t);
}
function XP(e, t) {
x("LVal", e, t);
}
function HP(e, t) {
x("TSEntityName", e, t);
}
function GP(e, t) {
x("Literal", e, t);
}
function zP(e, t) {
x("Immutable", e, t);
}
function QP(e, t) {
x("UserWhitespacable", e, t);
}
function ZP(e, t) {
x("Method", e, t);
}
function ev(e, t) {
x("ObjectMember", e, t);
}
function tv(e, t) {
x("Property", e, t);
}
function rv(e, t) {
x("UnaryLike", e, t);
}
function iv(e, t) {
x("Pattern", e, t);
}
function sv(e, t) {
x("Class", e, t);
}
function nv(e, t) {
x("ImportOrExportDeclaration", e, t);
}
function av(e, t) {
x("ExportDeclaration", e, t);
}
function ov(e, t) {
x("ModuleSpecifier", e, t);
}
function uv(e, t) {
x("Accessor", e, t);
}
function lv(e, t) {
x("Private", e, t);
}
function cv(e, t) {
x("Flow", e, t);
}
function fv(e, t) {
x("FlowType", e, t);
}
function pv(e, t) {
x("FlowBaseAnnotation", e, t);
}
function hv(e, t) {
x("FlowDeclaration", e, t);
}
function dv(e, t) {
x("FlowPredicate", e, t);
}
function mv(e, t) {
x("EnumBody", e, t);
}
function yv(e, t) {
x("EnumMember", e, t);
}
function bv(e, t) {
x("JSX", e, t);
}
function Tv(e, t) {
x("Miscellaneous", e, t);
}
function gv(e, t) {
x("TypeScript", e, t);
}
function Sv(e, t) {
x("TSTypeElement", e, t);
}
function xv(e, t) {
x("TSType", e, t);
}
function Ev(e, t) {
x("TSBaseType", e, t);
}
function Pv(e, t) {
(0, mi.default)("assertNumberLiteral", "assertNumericLiteral"), x("NumberLiteral", e, t);
}
function vv(e, t) {
(0, mi.default)("assertRegexLiteral", "assertRegExpLiteral"), x("RegexLiteral", e, t);
}
function Av(e, t) {
(0, mi.default)("assertRestProperty", "assertRestElement"), x("RestProperty", e, t);
}
function Iv(e, t) {
(0, mi.default)("assertSpreadProperty", "assertSpreadElement"), x("SpreadProperty", e, t);
}
function Cv(e, t) {
(0, mi.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), x("ModuleDeclaration", e, t);
}
var Ur = {}, Vo;
function wv() {
if (Vo) return Ur;
Vo = 1, Object.defineProperty(Ur, "__esModule", {
  value: !0
}), Ur.default = void 0;
var e = Pt();
Ur.default = t;
function t(r) {
  switch (r) {
    case "string":
      return (0, e.stringTypeAnnotation)();
    case "number":
      return (0, e.numberTypeAnnotation)();
    case "undefined":
      return (0, e.voidTypeAnnotation)();
    case "boolean":
      return (0, e.booleanTypeAnnotation)();
    case "function":
      return (0, e.genericTypeAnnotation)((0, e.identifier)("Function"));
    case "object":
      return (0, e.genericTypeAnnotation)((0, e.identifier)("Object"));
    case "symbol":
      return (0, e.genericTypeAnnotation)((0, e.identifier)("Symbol"));
    case "bigint":
      return (0, e.anyTypeAnnotation)();
  }
  throw new Error("Invalid typeof value: " + r);
}
return Ur;
}
var Ri = {}, xs = {};
Object.defineProperty(xs, "__esModule", {
value: !0
});
xs.default = oc;
var zr = T;
function ac(e) {
return (0, zr.isIdentifier)(e) ? e.name : `${e.id.name}.${ac(e.qualification)}`;
}
function oc(e) {
const t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set(), n = [];
for (let a = 0; a < t.length; a++) {
  const o = t[a];
  if (o && !n.includes(o)) {
    if ((0, zr.isAnyTypeAnnotation)(o))
      return [o];
    if ((0, zr.isFlowBaseAnnotation)(o)) {
      i.set(o.type, o);
      continue;
    }
    if ((0, zr.isUnionTypeAnnotation)(o)) {
      s.has(o.types) || (t.push(...o.types), s.add(o.types));
      continue;
    }
    if ((0, zr.isGenericTypeAnnotation)(o)) {
      const u = ac(o.id);
      if (r.has(u)) {
        let l = r.get(u);
        l.typeParameters ? o.typeParameters && (l.typeParameters.params.push(...o.typeParameters.params), l.typeParameters.params = oc(l.typeParameters.params)) : l = o.typeParameters;
      } else
        r.set(u, o);
      continue;
    }
    n.push(o);
  }
}
for (const [, a] of i)
  n.push(a);
for (const [, a] of r)
  n.push(a);
return n;
}
var qo;
function Nv() {
if (qo) return Ri;
qo = 1, Object.defineProperty(Ri, "__esModule", {
  value: !0
}), Ri.default = r;
var e = Pt(), t = xs;
function r(i) {
  const s = (0, t.default)(i);
  return s.length === 1 ? s[0] : (0, e.unionTypeAnnotation)(s);
}
return Ri;
}
var Ui = {}, ua = {};
Object.defineProperty(ua, "__esModule", {
value: !0
});
ua.default = lc;
var Qr = T;
function uc(e) {
return (0, Qr.isIdentifier)(e) ? e.name : `${e.right.name}.${uc(e.left)}`;
}
function lc(e) {
const t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set(), n = [];
for (let a = 0; a < t.length; a++) {
  const o = t[a];
  if (o && !n.includes(o)) {
    if ((0, Qr.isTSAnyKeyword)(o))
      return [o];
    if ((0, Qr.isTSBaseType)(o)) {
      i.set(o.type, o);
      continue;
    }
    if ((0, Qr.isTSUnionType)(o)) {
      s.has(o.types) || (t.push(...o.types), s.add(o.types));
      continue;
    }
    if ((0, Qr.isTSTypeReference)(o) && o.typeParameters) {
      const u = uc(o.typeName);
      if (r.has(u)) {
        let l = r.get(u);
        l.typeParameters ? o.typeParameters && (l.typeParameters.params.push(...o.typeParameters.params), l.typeParameters.params = lc(l.typeParameters.params)) : l = o.typeParameters;
      } else
        r.set(u, o);
      continue;
    }
    n.push(o);
  }
}
for (const [, a] of i)
  n.push(a);
for (const [, a] of r)
  n.push(a);
return n;
}
var $o;
function Ov() {
if ($o) return Ui;
$o = 1, Object.defineProperty(Ui, "__esModule", {
  value: !0
}), Ui.default = i;
var e = Pt(), t = ua, r = T;
function i(s) {
  const n = s.map((o) => (0, r.isTSTypeAnnotation)(o) ? o.typeAnnotation : o), a = (0, t.default)(n);
  return a.length === 1 ? a[0] : (0, e.tsUnionType)(a);
}
return Ui;
}
var an = {}, Ko;
function _v() {
return Ko || (Ko = 1, function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), Object.defineProperty(e, "AnyTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.anyTypeAnnotation;
    }
  }), Object.defineProperty(e, "ArgumentPlaceholder", {
    enumerable: !0,
    get: function() {
      return t.argumentPlaceholder;
    }
  }), Object.defineProperty(e, "ArrayExpression", {
    enumerable: !0,
    get: function() {
      return t.arrayExpression;
    }
  }), Object.defineProperty(e, "ArrayPattern", {
    enumerable: !0,
    get: function() {
      return t.arrayPattern;
    }
  }), Object.defineProperty(e, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.arrayTypeAnnotation;
    }
  }), Object.defineProperty(e, "ArrowFunctionExpression", {
    enumerable: !0,
    get: function() {
      return t.arrowFunctionExpression;
    }
  }), Object.defineProperty(e, "AssignmentExpression", {
    enumerable: !0,
    get: function() {
      return t.assignmentExpression;
    }
  }), Object.defineProperty(e, "AssignmentPattern", {
    enumerable: !0,
    get: function() {
      return t.assignmentPattern;
    }
  }), Object.defineProperty(e, "AwaitExpression", {
    enumerable: !0,
    get: function() {
      return t.awaitExpression;
    }
  }), Object.defineProperty(e, "BigIntLiteral", {
    enumerable: !0,
    get: function() {
      return t.bigIntLiteral;
    }
  }), Object.defineProperty(e, "BinaryExpression", {
    enumerable: !0,
    get: function() {
      return t.binaryExpression;
    }
  }), Object.defineProperty(e, "BindExpression", {
    enumerable: !0,
    get: function() {
      return t.bindExpression;
    }
  }), Object.defineProperty(e, "BlockStatement", {
    enumerable: !0,
    get: function() {
      return t.blockStatement;
    }
  }), Object.defineProperty(e, "BooleanLiteral", {
    enumerable: !0,
    get: function() {
      return t.booleanLiteral;
    }
  }), Object.defineProperty(e, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.booleanLiteralTypeAnnotation;
    }
  }), Object.defineProperty(e, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.booleanTypeAnnotation;
    }
  }), Object.defineProperty(e, "BreakStatement", {
    enumerable: !0,
    get: function() {
      return t.breakStatement;
    }
  }), Object.defineProperty(e, "CallExpression", {
    enumerable: !0,
    get: function() {
      return t.callExpression;
    }
  }), Object.defineProperty(e, "CatchClause", {
    enumerable: !0,
    get: function() {
      return t.catchClause;
    }
  }), Object.defineProperty(e, "ClassAccessorProperty", {
    enumerable: !0,
    get: function() {
      return t.classAccessorProperty;
    }
  }), Object.defineProperty(e, "ClassBody", {
    enumerable: !0,
    get: function() {
      return t.classBody;
    }
  }), Object.defineProperty(e, "ClassDeclaration", {
    enumerable: !0,
    get: function() {
      return t.classDeclaration;
    }
  }), Object.defineProperty(e, "ClassExpression", {
    enumerable: !0,
    get: function() {
      return t.classExpression;
    }
  }), Object.defineProperty(e, "ClassImplements", {
    enumerable: !0,
    get: function() {
      return t.classImplements;
    }
  }), Object.defineProperty(e, "ClassMethod", {
    enumerable: !0,
    get: function() {
      return t.classMethod;
    }
  }), Object.defineProperty(e, "ClassPrivateMethod", {
    enumerable: !0,
    get: function() {
      return t.classPrivateMethod;
    }
  }), Object.defineProperty(e, "ClassPrivateProperty", {
    enumerable: !0,
    get: function() {
      return t.classPrivateProperty;
    }
  }), Object.defineProperty(e, "ClassProperty", {
    enumerable: !0,
    get: function() {
      return t.classProperty;
    }
  }), Object.defineProperty(e, "ConditionalExpression", {
    enumerable: !0,
    get: function() {
      return t.conditionalExpression;
    }
  }), Object.defineProperty(e, "ContinueStatement", {
    enumerable: !0,
    get: function() {
      return t.continueStatement;
    }
  }), Object.defineProperty(e, "DebuggerStatement", {
    enumerable: !0,
    get: function() {
      return t.debuggerStatement;
    }
  }), Object.defineProperty(e, "DecimalLiteral", {
    enumerable: !0,
    get: function() {
      return t.decimalLiteral;
    }
  }), Object.defineProperty(e, "DeclareClass", {
    enumerable: !0,
    get: function() {
      return t.declareClass;
    }
  }), Object.defineProperty(e, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: function() {
      return t.declareExportAllDeclaration;
    }
  }), Object.defineProperty(e, "DeclareExportDeclaration", {
    enumerable: !0,
    get: function() {
      return t.declareExportDeclaration;
    }
  }), Object.defineProperty(e, "DeclareFunction", {
    enumerable: !0,
    get: function() {
      return t.declareFunction;
    }
  }), Object.defineProperty(e, "DeclareInterface", {
    enumerable: !0,
    get: function() {
      return t.declareInterface;
    }
  }), Object.defineProperty(e, "DeclareModule", {
    enumerable: !0,
    get: function() {
      return t.declareModule;
    }
  }), Object.defineProperty(e, "DeclareModuleExports", {
    enumerable: !0,
    get: function() {
      return t.declareModuleExports;
    }
  }), Object.defineProperty(e, "DeclareOpaqueType", {
    enumerable: !0,
    get: function() {
      return t.declareOpaqueType;
    }
  }), Object.defineProperty(e, "DeclareTypeAlias", {
    enumerable: !0,
    get: function() {
      return t.declareTypeAlias;
    }
  }), Object.defineProperty(e, "DeclareVariable", {
    enumerable: !0,
    get: function() {
      return t.declareVariable;
    }
  }), Object.defineProperty(e, "DeclaredPredicate", {
    enumerable: !0,
    get: function() {
      return t.declaredPredicate;
    }
  }), Object.defineProperty(e, "Decorator", {
    enumerable: !0,
    get: function() {
      return t.decorator;
    }
  }), Object.defineProperty(e, "Directive", {
    enumerable: !0,
    get: function() {
      return t.directive;
    }
  }), Object.defineProperty(e, "DirectiveLiteral", {
    enumerable: !0,
    get: function() {
      return t.directiveLiteral;
    }
  }), Object.defineProperty(e, "DoExpression", {
    enumerable: !0,
    get: function() {
      return t.doExpression;
    }
  }), Object.defineProperty(e, "DoWhileStatement", {
    enumerable: !0,
    get: function() {
      return t.doWhileStatement;
    }
  }), Object.defineProperty(e, "EmptyStatement", {
    enumerable: !0,
    get: function() {
      return t.emptyStatement;
    }
  }), Object.defineProperty(e, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.emptyTypeAnnotation;
    }
  }), Object.defineProperty(e, "EnumBooleanBody", {
    enumerable: !0,
    get: function() {
      return t.enumBooleanBody;
    }
  }), Object.defineProperty(e, "EnumBooleanMember", {
    enumerable: !0,
    get: function() {
      return t.enumBooleanMember;
    }
  }), Object.defineProperty(e, "EnumDeclaration", {
    enumerable: !0,
    get: function() {
      return t.enumDeclaration;
    }
  }), Object.defineProperty(e, "EnumDefaultedMember", {
    enumerable: !0,
    get: function() {
      return t.enumDefaultedMember;
    }
  }), Object.defineProperty(e, "EnumNumberBody", {
    enumerable: !0,
    get: function() {
      return t.enumNumberBody;
    }
  }), Object.defineProperty(e, "EnumNumberMember", {
    enumerable: !0,
    get: function() {
      return t.enumNumberMember;
    }
  }), Object.defineProperty(e, "EnumStringBody", {
    enumerable: !0,
    get: function() {
      return t.enumStringBody;
    }
  }), Object.defineProperty(e, "EnumStringMember", {
    enumerable: !0,
    get: function() {
      return t.enumStringMember;
    }
  }), Object.defineProperty(e, "EnumSymbolBody", {
    enumerable: !0,
    get: function() {
      return t.enumSymbolBody;
    }
  }), Object.defineProperty(e, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.existsTypeAnnotation;
    }
  }), Object.defineProperty(e, "ExportAllDeclaration", {
    enumerable: !0,
    get: function() {
      return t.exportAllDeclaration;
    }
  }), Object.defineProperty(e, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: function() {
      return t.exportDefaultDeclaration;
    }
  }), Object.defineProperty(e, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: function() {
      return t.exportDefaultSpecifier;
    }
  }), Object.defineProperty(e, "ExportNamedDeclaration", {
    enumerable: !0,
    get: function() {
      return t.exportNamedDeclaration;
    }
  }), Object.defineProperty(e, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: function() {
      return t.exportNamespaceSpecifier;
    }
  }), Object.defineProperty(e, "ExportSpecifier", {
    enumerable: !0,
    get: function() {
      return t.exportSpecifier;
    }
  }), Object.defineProperty(e, "ExpressionStatement", {
    enumerable: !0,
    get: function() {
      return t.expressionStatement;
    }
  }), Object.defineProperty(e, "File", {
    enumerable: !0,
    get: function() {
      return t.file;
    }
  }), Object.defineProperty(e, "ForInStatement", {
    enumerable: !0,
    get: function() {
      return t.forInStatement;
    }
  }), Object.defineProperty(e, "ForOfStatement", {
    enumerable: !0,
    get: function() {
      return t.forOfStatement;
    }
  }), Object.defineProperty(e, "ForStatement", {
    enumerable: !0,
    get: function() {
      return t.forStatement;
    }
  }), Object.defineProperty(e, "FunctionDeclaration", {
    enumerable: !0,
    get: function() {
      return t.functionDeclaration;
    }
  }), Object.defineProperty(e, "FunctionExpression", {
    enumerable: !0,
    get: function() {
      return t.functionExpression;
    }
  }), Object.defineProperty(e, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.functionTypeAnnotation;
    }
  }), Object.defineProperty(e, "FunctionTypeParam", {
    enumerable: !0,
    get: function() {
      return t.functionTypeParam;
    }
  }), Object.defineProperty(e, "GenericTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.genericTypeAnnotation;
    }
  }), Object.defineProperty(e, "Identifier", {
    enumerable: !0,
    get: function() {
      return t.identifier;
    }
  }), Object.defineProperty(e, "IfStatement", {
    enumerable: !0,
    get: function() {
      return t.ifStatement;
    }
  }), Object.defineProperty(e, "Import", {
    enumerable: !0,
    get: function() {
      return t.import;
    }
  }), Object.defineProperty(e, "ImportAttribute", {
    enumerable: !0,
    get: function() {
      return t.importAttribute;
    }
  }), Object.defineProperty(e, "ImportDeclaration", {
    enumerable: !0,
    get: function() {
      return t.importDeclaration;
    }
  }), Object.defineProperty(e, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: function() {
      return t.importDefaultSpecifier;
    }
  }), Object.defineProperty(e, "ImportExpression", {
    enumerable: !0,
    get: function() {
      return t.importExpression;
    }
  }), Object.defineProperty(e, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: function() {
      return t.importNamespaceSpecifier;
    }
  }), Object.defineProperty(e, "ImportSpecifier", {
    enumerable: !0,
    get: function() {
      return t.importSpecifier;
    }
  }), Object.defineProperty(e, "IndexedAccessType", {
    enumerable: !0,
    get: function() {
      return t.indexedAccessType;
    }
  }), Object.defineProperty(e, "InferredPredicate", {
    enumerable: !0,
    get: function() {
      return t.inferredPredicate;
    }
  }), Object.defineProperty(e, "InterfaceDeclaration", {
    enumerable: !0,
    get: function() {
      return t.interfaceDeclaration;
    }
  }), Object.defineProperty(e, "InterfaceExtends", {
    enumerable: !0,
    get: function() {
      return t.interfaceExtends;
    }
  }), Object.defineProperty(e, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.interfaceTypeAnnotation;
    }
  }), Object.defineProperty(e, "InterpreterDirective", {
    enumerable: !0,
    get: function() {
      return t.interpreterDirective;
    }
  }), Object.defineProperty(e, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.intersectionTypeAnnotation;
    }
  }), Object.defineProperty(e, "JSXAttribute", {
    enumerable: !0,
    get: function() {
      return t.jsxAttribute;
    }
  }), Object.defineProperty(e, "JSXClosingElement", {
    enumerable: !0,
    get: function() {
      return t.jsxClosingElement;
    }
  }), Object.defineProperty(e, "JSXClosingFragment", {
    enumerable: !0,
    get: function() {
      return t.jsxClosingFragment;
    }
  }), Object.defineProperty(e, "JSXElement", {
    enumerable: !0,
    get: function() {
      return t.jsxElement;
    }
  }), Object.defineProperty(e, "JSXEmptyExpression", {
    enumerable: !0,
    get: function() {
      return t.jsxEmptyExpression;
    }
  }), Object.defineProperty(e, "JSXExpressionContainer", {
    enumerable: !0,
    get: function() {
      return t.jsxExpressionContainer;
    }
  }), Object.defineProperty(e, "JSXFragment", {
    enumerable: !0,
    get: function() {
      return t.jsxFragment;
    }
  }), Object.defineProperty(e, "JSXIdentifier", {
    enumerable: !0,
    get: function() {
      return t.jsxIdentifier;
    }
  }), Object.defineProperty(e, "JSXMemberExpression", {
    enumerable: !0,
    get: function() {
      return t.jsxMemberExpression;
    }
  }), Object.defineProperty(e, "JSXNamespacedName", {
    enumerable: !0,
    get: function() {
      return t.jsxNamespacedName;
    }
  }), Object.defineProperty(e, "JSXOpeningElement", {
    enumerable: !0,
    get: function() {
      return t.jsxOpeningElement;
    }
  }), Object.defineProperty(e, "JSXOpeningFragment", {
    enumerable: !0,
    get: function() {
      return t.jsxOpeningFragment;
    }
  }), Object.defineProperty(e, "JSXSpreadAttribute", {
    enumerable: !0,
    get: function() {
      return t.jsxSpreadAttribute;
    }
  }), Object.defineProperty(e, "JSXSpreadChild", {
    enumerable: !0,
    get: function() {
      return t.jsxSpreadChild;
    }
  }), Object.defineProperty(e, "JSXText", {
    enumerable: !0,
    get: function() {
      return t.jsxText;
    }
  }), Object.defineProperty(e, "LabeledStatement", {
    enumerable: !0,
    get: function() {
      return t.labeledStatement;
    }
  }), Object.defineProperty(e, "LogicalExpression", {
    enumerable: !0,
    get: function() {
      return t.logicalExpression;
    }
  }), Object.defineProperty(e, "MemberExpression", {
    enumerable: !0,
    get: function() {
      return t.memberExpression;
    }
  }), Object.defineProperty(e, "MetaProperty", {
    enumerable: !0,
    get: function() {
      return t.metaProperty;
    }
  }), Object.defineProperty(e, "MixedTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.mixedTypeAnnotation;
    }
  }), Object.defineProperty(e, "ModuleExpression", {
    enumerable: !0,
    get: function() {
      return t.moduleExpression;
    }
  }), Object.defineProperty(e, "NewExpression", {
    enumerable: !0,
    get: function() {
      return t.newExpression;
    }
  }), Object.defineProperty(e, "Noop", {
    enumerable: !0,
    get: function() {
      return t.noop;
    }
  }), Object.defineProperty(e, "NullLiteral", {
    enumerable: !0,
    get: function() {
      return t.nullLiteral;
    }
  }), Object.defineProperty(e, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.nullLiteralTypeAnnotation;
    }
  }), Object.defineProperty(e, "NullableTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.nullableTypeAnnotation;
    }
  }), Object.defineProperty(e, "NumberLiteral", {
    enumerable: !0,
    get: function() {
      return t.numberLiteral;
    }
  }), Object.defineProperty(e, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.numberLiteralTypeAnnotation;
    }
  }), Object.defineProperty(e, "NumberTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.numberTypeAnnotation;
    }
  }), Object.defineProperty(e, "NumericLiteral", {
    enumerable: !0,
    get: function() {
      return t.numericLiteral;
    }
  }), Object.defineProperty(e, "ObjectExpression", {
    enumerable: !0,
    get: function() {
      return t.objectExpression;
    }
  }), Object.defineProperty(e, "ObjectMethod", {
    enumerable: !0,
    get: function() {
      return t.objectMethod;
    }
  }), Object.defineProperty(e, "ObjectPattern", {
    enumerable: !0,
    get: function() {
      return t.objectPattern;
    }
  }), Object.defineProperty(e, "ObjectProperty", {
    enumerable: !0,
    get: function() {
      return t.objectProperty;
    }
  }), Object.defineProperty(e, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.objectTypeAnnotation;
    }
  }), Object.defineProperty(e, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: function() {
      return t.objectTypeCallProperty;
    }
  }), Object.defineProperty(e, "ObjectTypeIndexer", {
    enumerable: !0,
    get: function() {
      return t.objectTypeIndexer;
    }
  }), Object.defineProperty(e, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: function() {
      return t.objectTypeInternalSlot;
    }
  }), Object.defineProperty(e, "ObjectTypeProperty", {
    enumerable: !0,
    get: function() {
      return t.objectTypeProperty;
    }
  }), Object.defineProperty(e, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: function() {
      return t.objectTypeSpreadProperty;
    }
  }), Object.defineProperty(e, "OpaqueType", {
    enumerable: !0,
    get: function() {
      return t.opaqueType;
    }
  }), Object.defineProperty(e, "OptionalCallExpression", {
    enumerable: !0,
    get: function() {
      return t.optionalCallExpression;
    }
  }), Object.defineProperty(e, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: function() {
      return t.optionalIndexedAccessType;
    }
  }), Object.defineProperty(e, "OptionalMemberExpression", {
    enumerable: !0,
    get: function() {
      return t.optionalMemberExpression;
    }
  }), Object.defineProperty(e, "ParenthesizedExpression", {
    enumerable: !0,
    get: function() {
      return t.parenthesizedExpression;
    }
  }), Object.defineProperty(e, "PipelineBareFunction", {
    enumerable: !0,
    get: function() {
      return t.pipelineBareFunction;
    }
  }), Object.defineProperty(e, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: function() {
      return t.pipelinePrimaryTopicReference;
    }
  }), Object.defineProperty(e, "PipelineTopicExpression", {
    enumerable: !0,
    get: function() {
      return t.pipelineTopicExpression;
    }
  }), Object.defineProperty(e, "Placeholder", {
    enumerable: !0,
    get: function() {
      return t.placeholder;
    }
  }), Object.defineProperty(e, "PrivateName", {
    enumerable: !0,
    get: function() {
      return t.privateName;
    }
  }), Object.defineProperty(e, "Program", {
    enumerable: !0,
    get: function() {
      return t.program;
    }
  }), Object.defineProperty(e, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: function() {
      return t.qualifiedTypeIdentifier;
    }
  }), Object.defineProperty(e, "RecordExpression", {
    enumerable: !0,
    get: function() {
      return t.recordExpression;
    }
  }), Object.defineProperty(e, "RegExpLiteral", {
    enumerable: !0,
    get: function() {
      return t.regExpLiteral;
    }
  }), Object.defineProperty(e, "RegexLiteral", {
    enumerable: !0,
    get: function() {
      return t.regexLiteral;
    }
  }), Object.defineProperty(e, "RestElement", {
    enumerable: !0,
    get: function() {
      return t.restElement;
    }
  }), Object.defineProperty(e, "RestProperty", {
    enumerable: !0,
    get: function() {
      return t.restProperty;
    }
  }), Object.defineProperty(e, "ReturnStatement", {
    enumerable: !0,
    get: function() {
      return t.returnStatement;
    }
  }), Object.defineProperty(e, "SequenceExpression", {
    enumerable: !0,
    get: function() {
      return t.sequenceExpression;
    }
  }), Object.defineProperty(e, "SpreadElement", {
    enumerable: !0,
    get: function() {
      return t.spreadElement;
    }
  }), Object.defineProperty(e, "SpreadProperty", {
    enumerable: !0,
    get: function() {
      return t.spreadProperty;
    }
  }), Object.defineProperty(e, "StaticBlock", {
    enumerable: !0,
    get: function() {
      return t.staticBlock;
    }
  }), Object.defineProperty(e, "StringLiteral", {
    enumerable: !0,
    get: function() {
      return t.stringLiteral;
    }
  }), Object.defineProperty(e, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.stringLiteralTypeAnnotation;
    }
  }), Object.defineProperty(e, "StringTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.stringTypeAnnotation;
    }
  }), Object.defineProperty(e, "Super", {
    enumerable: !0,
    get: function() {
      return t.super;
    }
  }), Object.defineProperty(e, "SwitchCase", {
    enumerable: !0,
    get: function() {
      return t.switchCase;
    }
  }), Object.defineProperty(e, "SwitchStatement", {
    enumerable: !0,
    get: function() {
      return t.switchStatement;
    }
  }), Object.defineProperty(e, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.symbolTypeAnnotation;
    }
  }), Object.defineProperty(e, "TSAnyKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsAnyKeyword;
    }
  }), Object.defineProperty(e, "TSArrayType", {
    enumerable: !0,
    get: function() {
      return t.tsArrayType;
    }
  }), Object.defineProperty(e, "TSAsExpression", {
    enumerable: !0,
    get: function() {
      return t.tsAsExpression;
    }
  }), Object.defineProperty(e, "TSBigIntKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsBigIntKeyword;
    }
  }), Object.defineProperty(e, "TSBooleanKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsBooleanKeyword;
    }
  }), Object.defineProperty(e, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: function() {
      return t.tsCallSignatureDeclaration;
    }
  }), Object.defineProperty(e, "TSConditionalType", {
    enumerable: !0,
    get: function() {
      return t.tsConditionalType;
    }
  }), Object.defineProperty(e, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: function() {
      return t.tsConstructSignatureDeclaration;
    }
  }), Object.defineProperty(e, "TSConstructorType", {
    enumerable: !0,
    get: function() {
      return t.tsConstructorType;
    }
  }), Object.defineProperty(e, "TSDeclareFunction", {
    enumerable: !0,
    get: function() {
      return t.tsDeclareFunction;
    }
  }), Object.defineProperty(e, "TSDeclareMethod", {
    enumerable: !0,
    get: function() {
      return t.tsDeclareMethod;
    }
  }), Object.defineProperty(e, "TSEnumDeclaration", {
    enumerable: !0,
    get: function() {
      return t.tsEnumDeclaration;
    }
  }), Object.defineProperty(e, "TSEnumMember", {
    enumerable: !0,
    get: function() {
      return t.tsEnumMember;
    }
  }), Object.defineProperty(e, "TSExportAssignment", {
    enumerable: !0,
    get: function() {
      return t.tsExportAssignment;
    }
  }), Object.defineProperty(e, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: function() {
      return t.tsExpressionWithTypeArguments;
    }
  }), Object.defineProperty(e, "TSExternalModuleReference", {
    enumerable: !0,
    get: function() {
      return t.tsExternalModuleReference;
    }
  }), Object.defineProperty(e, "TSFunctionType", {
    enumerable: !0,
    get: function() {
      return t.tsFunctionType;
    }
  }), Object.defineProperty(e, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: function() {
      return t.tsImportEqualsDeclaration;
    }
  }), Object.defineProperty(e, "TSImportType", {
    enumerable: !0,
    get: function() {
      return t.tsImportType;
    }
  }), Object.defineProperty(e, "TSIndexSignature", {
    enumerable: !0,
    get: function() {
      return t.tsIndexSignature;
    }
  }), Object.defineProperty(e, "TSIndexedAccessType", {
    enumerable: !0,
    get: function() {
      return t.tsIndexedAccessType;
    }
  }), Object.defineProperty(e, "TSInferType", {
    enumerable: !0,
    get: function() {
      return t.tsInferType;
    }
  }), Object.defineProperty(e, "TSInstantiationExpression", {
    enumerable: !0,
    get: function() {
      return t.tsInstantiationExpression;
    }
  }), Object.defineProperty(e, "TSInterfaceBody", {
    enumerable: !0,
    get: function() {
      return t.tsInterfaceBody;
    }
  }), Object.defineProperty(e, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: function() {
      return t.tsInterfaceDeclaration;
    }
  }), Object.defineProperty(e, "TSIntersectionType", {
    enumerable: !0,
    get: function() {
      return t.tsIntersectionType;
    }
  }), Object.defineProperty(e, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsIntrinsicKeyword;
    }
  }), Object.defineProperty(e, "TSLiteralType", {
    enumerable: !0,
    get: function() {
      return t.tsLiteralType;
    }
  }), Object.defineProperty(e, "TSMappedType", {
    enumerable: !0,
    get: function() {
      return t.tsMappedType;
    }
  }), Object.defineProperty(e, "TSMethodSignature", {
    enumerable: !0,
    get: function() {
      return t.tsMethodSignature;
    }
  }), Object.defineProperty(e, "TSModuleBlock", {
    enumerable: !0,
    get: function() {
      return t.tsModuleBlock;
    }
  }), Object.defineProperty(e, "TSModuleDeclaration", {
    enumerable: !0,
    get: function() {
      return t.tsModuleDeclaration;
    }
  }), Object.defineProperty(e, "TSNamedTupleMember", {
    enumerable: !0,
    get: function() {
      return t.tsNamedTupleMember;
    }
  }), Object.defineProperty(e, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: function() {
      return t.tsNamespaceExportDeclaration;
    }
  }), Object.defineProperty(e, "TSNeverKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsNeverKeyword;
    }
  }), Object.defineProperty(e, "TSNonNullExpression", {
    enumerable: !0,
    get: function() {
      return t.tsNonNullExpression;
    }
  }), Object.defineProperty(e, "TSNullKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsNullKeyword;
    }
  }), Object.defineProperty(e, "TSNumberKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsNumberKeyword;
    }
  }), Object.defineProperty(e, "TSObjectKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsObjectKeyword;
    }
  }), Object.defineProperty(e, "TSOptionalType", {
    enumerable: !0,
    get: function() {
      return t.tsOptionalType;
    }
  }), Object.defineProperty(e, "TSParameterProperty", {
    enumerable: !0,
    get: function() {
      return t.tsParameterProperty;
    }
  }), Object.defineProperty(e, "TSParenthesizedType", {
    enumerable: !0,
    get: function() {
      return t.tsParenthesizedType;
    }
  }), Object.defineProperty(e, "TSPropertySignature", {
    enumerable: !0,
    get: function() {
      return t.tsPropertySignature;
    }
  }), Object.defineProperty(e, "TSQualifiedName", {
    enumerable: !0,
    get: function() {
      return t.tsQualifiedName;
    }
  }), Object.defineProperty(e, "TSRestType", {
    enumerable: !0,
    get: function() {
      return t.tsRestType;
    }
  }), Object.defineProperty(e, "TSSatisfiesExpression", {
    enumerable: !0,
    get: function() {
      return t.tsSatisfiesExpression;
    }
  }), Object.defineProperty(e, "TSStringKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsStringKeyword;
    }
  }), Object.defineProperty(e, "TSSymbolKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsSymbolKeyword;
    }
  }), Object.defineProperty(e, "TSThisType", {
    enumerable: !0,
    get: function() {
      return t.tsThisType;
    }
  }), Object.defineProperty(e, "TSTupleType", {
    enumerable: !0,
    get: function() {
      return t.tsTupleType;
    }
  }), Object.defineProperty(e, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: function() {
      return t.tsTypeAliasDeclaration;
    }
  }), Object.defineProperty(e, "TSTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.tsTypeAnnotation;
    }
  }), Object.defineProperty(e, "TSTypeAssertion", {
    enumerable: !0,
    get: function() {
      return t.tsTypeAssertion;
    }
  }), Object.defineProperty(e, "TSTypeLiteral", {
    enumerable: !0,
    get: function() {
      return t.tsTypeLiteral;
    }
  }), Object.defineProperty(e, "TSTypeOperator", {
    enumerable: !0,
    get: function() {
      return t.tsTypeOperator;
    }
  }), Object.defineProperty(e, "TSTypeParameter", {
    enumerable: !0,
    get: function() {
      return t.tsTypeParameter;
    }
  }), Object.defineProperty(e, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: function() {
      return t.tsTypeParameterDeclaration;
    }
  }), Object.defineProperty(e, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: function() {
      return t.tsTypeParameterInstantiation;
    }
  }), Object.defineProperty(e, "TSTypePredicate", {
    enumerable: !0,
    get: function() {
      return t.tsTypePredicate;
    }
  }), Object.defineProperty(e, "TSTypeQuery", {
    enumerable: !0,
    get: function() {
      return t.tsTypeQuery;
    }
  }), Object.defineProperty(e, "TSTypeReference", {
    enumerable: !0,
    get: function() {
      return t.tsTypeReference;
    }
  }), Object.defineProperty(e, "TSUndefinedKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsUndefinedKeyword;
    }
  }), Object.defineProperty(e, "TSUnionType", {
    enumerable: !0,
    get: function() {
      return t.tsUnionType;
    }
  }), Object.defineProperty(e, "TSUnknownKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsUnknownKeyword;
    }
  }), Object.defineProperty(e, "TSVoidKeyword", {
    enumerable: !0,
    get: function() {
      return t.tsVoidKeyword;
    }
  }), Object.defineProperty(e, "TaggedTemplateExpression", {
    enumerable: !0,
    get: function() {
      return t.taggedTemplateExpression;
    }
  }), Object.defineProperty(e, "TemplateElement", {
    enumerable: !0,
    get: function() {
      return t.templateElement;
    }
  }), Object.defineProperty(e, "TemplateLiteral", {
    enumerable: !0,
    get: function() {
      return t.templateLiteral;
    }
  }), Object.defineProperty(e, "ThisExpression", {
    enumerable: !0,
    get: function() {
      return t.thisExpression;
    }
  }), Object.defineProperty(e, "ThisTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.thisTypeAnnotation;
    }
  }), Object.defineProperty(e, "ThrowStatement", {
    enumerable: !0,
    get: function() {
      return t.throwStatement;
    }
  }), Object.defineProperty(e, "TopicReference", {
    enumerable: !0,
    get: function() {
      return t.topicReference;
    }
  }), Object.defineProperty(e, "TryStatement", {
    enumerable: !0,
    get: function() {
      return t.tryStatement;
    }
  }), Object.defineProperty(e, "TupleExpression", {
    enumerable: !0,
    get: function() {
      return t.tupleExpression;
    }
  }), Object.defineProperty(e, "TupleTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.tupleTypeAnnotation;
    }
  }), Object.defineProperty(e, "TypeAlias", {
    enumerable: !0,
    get: function() {
      return t.typeAlias;
    }
  }), Object.defineProperty(e, "TypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.typeAnnotation;
    }
  }), Object.defineProperty(e, "TypeCastExpression", {
    enumerable: !0,
    get: function() {
      return t.typeCastExpression;
    }
  }), Object.defineProperty(e, "TypeParameter", {
    enumerable: !0,
    get: function() {
      return t.typeParameter;
    }
  }), Object.defineProperty(e, "TypeParameterDeclaration", {
    enumerable: !0,
    get: function() {
      return t.typeParameterDeclaration;
    }
  }), Object.defineProperty(e, "TypeParameterInstantiation", {
    enumerable: !0,
    get: function() {
      return t.typeParameterInstantiation;
    }
  }), Object.defineProperty(e, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.typeofTypeAnnotation;
    }
  }), Object.defineProperty(e, "UnaryExpression", {
    enumerable: !0,
    get: function() {
      return t.unaryExpression;
    }
  }), Object.defineProperty(e, "UnionTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.unionTypeAnnotation;
    }
  }), Object.defineProperty(e, "UpdateExpression", {
    enumerable: !0,
    get: function() {
      return t.updateExpression;
    }
  }), Object.defineProperty(e, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: function() {
      return t.v8IntrinsicIdentifier;
    }
  }), Object.defineProperty(e, "VariableDeclaration", {
    enumerable: !0,
    get: function() {
      return t.variableDeclaration;
    }
  }), Object.defineProperty(e, "VariableDeclarator", {
    enumerable: !0,
    get: function() {
      return t.variableDeclarator;
    }
  }), Object.defineProperty(e, "Variance", {
    enumerable: !0,
    get: function() {
      return t.variance;
    }
  }), Object.defineProperty(e, "VoidTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return t.voidTypeAnnotation;
    }
  }), Object.defineProperty(e, "WhileStatement", {
    enumerable: !0,
    get: function() {
      return t.whileStatement;
    }
  }), Object.defineProperty(e, "WithStatement", {
    enumerable: !0,
    get: function() {
      return t.withStatement;
    }
  }), Object.defineProperty(e, "YieldExpression", {
    enumerable: !0,
    get: function() {
      return t.yieldExpression;
    }
  });
  var t = Pt();
}(an)), an;
}
var Vi = {}, Wo;
function cc() {
if (Wo) return Vi;
Wo = 1, Object.defineProperty(Vi, "__esModule", {
  value: !0
}), Vi.buildUndefinedNode = t;
var e = Pt();
function t() {
  return (0, e.unaryExpression)("void", (0, e.numericLiteral)(0), !0);
}
return Vi;
}
var Qt = {};
Object.defineProperty(Qt, "__esModule", {
value: !0
});
Qt.default = kv;
var Jo = Dt(), Yo = T;
const {
hasOwn: Rt
} = {
hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
};
function Xo(e, t, r, i) {
return e && typeof e.type == "string" ? fc(e, t, r, i) : e;
}
function Ho(e, t, r, i) {
return Array.isArray(e) ? e.map((s) => Xo(s, t, r, i)) : Xo(e, t, r, i);
}
function kv(e, t = !0, r = !1) {
return fc(e, t, r, /* @__PURE__ */ new Map());
}
function fc(e, t = !0, r = !1, i) {
if (!e) return e;
const {
  type: s
} = e, n = {
  type: e.type
};
if ((0, Yo.isIdentifier)(e))
  n.name = e.name, Rt(e, "optional") && typeof e.optional == "boolean" && (n.optional = e.optional), Rt(e, "typeAnnotation") && (n.typeAnnotation = t ? Ho(e.typeAnnotation, !0, r, i) : e.typeAnnotation);
else if (Rt(Jo.NODE_FIELDS, s))
  for (const a of Object.keys(Jo.NODE_FIELDS[s]))
    Rt(e, a) && (t ? n[a] = (0, Yo.isFile)(e) && a === "comments" ? qi(e.comments, t, r, i) : Ho(e[a], !0, r, i) : n[a] = e[a]);
else
  throw new Error(`Unknown node type: "${s}"`);
return Rt(e, "loc") && (r ? n.loc = null : n.loc = e.loc), Rt(e, "leadingComments") && (n.leadingComments = qi(e.leadingComments, t, r, i)), Rt(e, "innerComments") && (n.innerComments = qi(e.innerComments, t, r, i)), Rt(e, "trailingComments") && (n.trailingComments = qi(e.trailingComments, t, r, i)), Rt(e, "extra") && (n.extra = Object.assign({}, e.extra)), n;
}
function qi(e, t, r, i) {
return !e || !t ? e : e.map((s) => {
  const n = i.get(s);
  if (n) return n;
  const {
    type: a,
    value: o,
    loc: u
  } = s, l = {
    type: a,
    value: o,
    loc: u
  };
  return r && (l.loc = null), i.set(s, l), l;
});
}
var la = {};
Object.defineProperty(la, "__esModule", {
value: !0
});
la.default = Lv;
var Dv = Qt;
function Lv(e) {
return (0, Dv.default)(e, !1);
}
var ca = {};
Object.defineProperty(ca, "__esModule", {
value: !0
});
ca.default = Bv;
var Mv = Qt;
function Bv(e) {
return (0, Mv.default)(e);
}
var fa = {};
Object.defineProperty(fa, "__esModule", {
value: !0
});
fa.default = jv;
var Fv = Qt;
function jv(e) {
return (0, Fv.default)(e, !0, !0);
}
var pa = {};
Object.defineProperty(pa, "__esModule", {
value: !0
});
pa.default = Uv;
var Rv = Qt;
function Uv(e) {
return (0, Rv.default)(e, !1, !0);
}
var ha = {}, Es = {};
Object.defineProperty(Es, "__esModule", {
value: !0
});
Es.default = Vv;
function Vv(e, t, r) {
if (!r || !e) return e;
const i = `${t}Comments`;
return e[i] ? t === "leading" ? e[i] = r.concat(e[i]) : e[i].push(...r) : e[i] = r, e;
}
Object.defineProperty(ha, "__esModule", {
value: !0
});
ha.default = $v;
var qv = Es;
function $v(e, t, r, i) {
return (0, qv.default)(e, t, [{
  type: i ? "CommentLine" : "CommentBlock",
  value: r
}]);
}
var Ps = {}, yi = {};
Object.defineProperty(yi, "__esModule", {
value: !0
});
yi.default = Kv;
function Kv(e, t, r) {
t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
}
Object.defineProperty(Ps, "__esModule", {
value: !0
});
Ps.default = Jv;
var Wv = yi;
function Jv(e, t) {
(0, Wv.default)("innerComments", e, t);
}
var vs = {};
Object.defineProperty(vs, "__esModule", {
value: !0
});
vs.default = Xv;
var Yv = yi;
function Xv(e, t) {
(0, Yv.default)("leadingComments", e, t);
}
var As = {}, Is = {};
Object.defineProperty(Is, "__esModule", {
value: !0
});
Is.default = Gv;
var Hv = yi;
function Gv(e, t) {
(0, Hv.default)("trailingComments", e, t);
}
Object.defineProperty(As, "__esModule", {
value: !0
});
As.default = eA;
var zv = Is, Qv = vs, Zv = Ps;
function eA(e, t) {
return (0, zv.default)(e, t), (0, Qv.default)(e, t), (0, Zv.default)(e, t), e;
}
var da = {};
Object.defineProperty(da, "__esModule", {
value: !0
});
da.default = rA;
var tA = xe;
function rA(e) {
return tA.COMMENT_KEYS.forEach((t) => {
  e[t] = null;
}), e;
}
var z = {};
Object.defineProperty(z, "__esModule", {
value: !0
});
z.WHILE_TYPES = z.USERWHITESPACABLE_TYPES = z.UNARYLIKE_TYPES = z.TYPESCRIPT_TYPES = z.TSTYPE_TYPES = z.TSTYPEELEMENT_TYPES = z.TSENTITYNAME_TYPES = z.TSBASETYPE_TYPES = z.TERMINATORLESS_TYPES = z.STATEMENT_TYPES = z.STANDARDIZED_TYPES = z.SCOPABLE_TYPES = z.PUREISH_TYPES = z.PROPERTY_TYPES = z.PRIVATE_TYPES = z.PATTERN_TYPES = z.PATTERNLIKE_TYPES = z.OBJECTMEMBER_TYPES = z.MODULESPECIFIER_TYPES = z.MODULEDECLARATION_TYPES = z.MISCELLANEOUS_TYPES = z.METHOD_TYPES = z.LVAL_TYPES = z.LOOP_TYPES = z.LITERAL_TYPES = z.JSX_TYPES = z.IMPORTOREXPORTDECLARATION_TYPES = z.IMMUTABLE_TYPES = z.FUNCTION_TYPES = z.FUNCTIONPARENT_TYPES = z.FOR_TYPES = z.FORXSTATEMENT_TYPES = z.FLOW_TYPES = z.FLOWTYPE_TYPES = z.FLOWPREDICATE_TYPES = z.FLOWDECLARATION_TYPES = z.FLOWBASEANNOTATION_TYPES = z.EXPRESSION_TYPES = z.EXPRESSIONWRAPPER_TYPES = z.EXPORTDECLARATION_TYPES = z.ENUMMEMBER_TYPES = z.ENUMBODY_TYPES = z.DECLARATION_TYPES = z.CONDITIONAL_TYPES = z.COMPLETIONSTATEMENT_TYPES = z.CLASS_TYPES = z.BLOCK_TYPES = z.BLOCKPARENT_TYPES = z.BINARY_TYPES = z.ACCESSOR_TYPES = void 0;
var ge = Dt();
z.STANDARDIZED_TYPES = ge.FLIPPED_ALIAS_KEYS.Standardized;
z.EXPRESSION_TYPES = ge.FLIPPED_ALIAS_KEYS.Expression;
z.BINARY_TYPES = ge.FLIPPED_ALIAS_KEYS.Binary;
z.SCOPABLE_TYPES = ge.FLIPPED_ALIAS_KEYS.Scopable;
z.BLOCKPARENT_TYPES = ge.FLIPPED_ALIAS_KEYS.BlockParent;
z.BLOCK_TYPES = ge.FLIPPED_ALIAS_KEYS.Block;
z.STATEMENT_TYPES = ge.FLIPPED_ALIAS_KEYS.Statement;
z.TERMINATORLESS_TYPES = ge.FLIPPED_ALIAS_KEYS.Terminatorless;
z.COMPLETIONSTATEMENT_TYPES = ge.FLIPPED_ALIAS_KEYS.CompletionStatement;
z.CONDITIONAL_TYPES = ge.FLIPPED_ALIAS_KEYS.Conditional;
z.LOOP_TYPES = ge.FLIPPED_ALIAS_KEYS.Loop;
z.WHILE_TYPES = ge.FLIPPED_ALIAS_KEYS.While;
z.EXPRESSIONWRAPPER_TYPES = ge.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
z.FOR_TYPES = ge.FLIPPED_ALIAS_KEYS.For;
z.FORXSTATEMENT_TYPES = ge.FLIPPED_ALIAS_KEYS.ForXStatement;
z.FUNCTION_TYPES = ge.FLIPPED_ALIAS_KEYS.Function;
z.FUNCTIONPARENT_TYPES = ge.FLIPPED_ALIAS_KEYS.FunctionParent;
z.PUREISH_TYPES = ge.FLIPPED_ALIAS_KEYS.Pureish;
z.DECLARATION_TYPES = ge.FLIPPED_ALIAS_KEYS.Declaration;
z.PATTERNLIKE_TYPES = ge.FLIPPED_ALIAS_KEYS.PatternLike;
z.LVAL_TYPES = ge.FLIPPED_ALIAS_KEYS.LVal;
z.TSENTITYNAME_TYPES = ge.FLIPPED_ALIAS_KEYS.TSEntityName;
z.LITERAL_TYPES = ge.FLIPPED_ALIAS_KEYS.Literal;
z.IMMUTABLE_TYPES = ge.FLIPPED_ALIAS_KEYS.Immutable;
z.USERWHITESPACABLE_TYPES = ge.FLIPPED_ALIAS_KEYS.UserWhitespacable;
z.METHOD_TYPES = ge.FLIPPED_ALIAS_KEYS.Method;
z.OBJECTMEMBER_TYPES = ge.FLIPPED_ALIAS_KEYS.ObjectMember;
z.PROPERTY_TYPES = ge.FLIPPED_ALIAS_KEYS.Property;
z.UNARYLIKE_TYPES = ge.FLIPPED_ALIAS_KEYS.UnaryLike;
z.PATTERN_TYPES = ge.FLIPPED_ALIAS_KEYS.Pattern;
z.CLASS_TYPES = ge.FLIPPED_ALIAS_KEYS.Class;
const iA = z.IMPORTOREXPORTDECLARATION_TYPES = ge.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
z.EXPORTDECLARATION_TYPES = ge.FLIPPED_ALIAS_KEYS.ExportDeclaration;
z.MODULESPECIFIER_TYPES = ge.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
z.ACCESSOR_TYPES = ge.FLIPPED_ALIAS_KEYS.Accessor;
z.PRIVATE_TYPES = ge.FLIPPED_ALIAS_KEYS.Private;
z.FLOW_TYPES = ge.FLIPPED_ALIAS_KEYS.Flow;
z.FLOWTYPE_TYPES = ge.FLIPPED_ALIAS_KEYS.FlowType;
z.FLOWBASEANNOTATION_TYPES = ge.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
z.FLOWDECLARATION_TYPES = ge.FLIPPED_ALIAS_KEYS.FlowDeclaration;
z.FLOWPREDICATE_TYPES = ge.FLIPPED_ALIAS_KEYS.FlowPredicate;
z.ENUMBODY_TYPES = ge.FLIPPED_ALIAS_KEYS.EnumBody;
z.ENUMMEMBER_TYPES = ge.FLIPPED_ALIAS_KEYS.EnumMember;
z.JSX_TYPES = ge.FLIPPED_ALIAS_KEYS.JSX;
z.MISCELLANEOUS_TYPES = ge.FLIPPED_ALIAS_KEYS.Miscellaneous;
z.TYPESCRIPT_TYPES = ge.FLIPPED_ALIAS_KEYS.TypeScript;
z.TSTYPEELEMENT_TYPES = ge.FLIPPED_ALIAS_KEYS.TSTypeElement;
z.TSTYPE_TYPES = ge.FLIPPED_ALIAS_KEYS.TSType;
z.TSBASETYPE_TYPES = ge.FLIPPED_ALIAS_KEYS.TSBaseType;
z.MODULEDECLARATION_TYPES = iA;
var $i = {}, Ki = {}, Go;
function pc() {
if (Go) return Ki;
Go = 1, Object.defineProperty(Ki, "__esModule", {
  value: !0
}), Ki.default = r;
var e = T, t = Pt();
function r(i, s) {
  if ((0, e.isBlockStatement)(i))
    return i;
  let n = [];
  return (0, e.isEmptyStatement)(i) ? n = [] : ((0, e.isStatement)(i) || ((0, e.isFunction)(s) ? i = (0, t.returnStatement)(i) : i = (0, t.expressionStatement)(i)), n = [i]), (0, t.blockStatement)(n);
}
return Ki;
}
var zo;
function sA() {
if (zo) return $i;
zo = 1, Object.defineProperty($i, "__esModule", {
  value: !0
}), $i.default = t;
var e = pc();
function t(r, i = "body") {
  const s = (0, e.default)(r[i], r);
  return r[i] = s, s;
}
return $i;
}
var ma = {}, Cs = {};
Object.defineProperty(Cs, "__esModule", {
value: !0
});
Cs.default = oA;
var nA = gr, aA = pi;
function oA(e) {
e = e + "";
let t = "";
for (const r of e)
  t += (0, aA.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(r, i) {
  return i ? i.toUpperCase() : "";
}), (0, nA.default)(t) || (t = `_${t}`), t || "_";
}
Object.defineProperty(ma, "__esModule", {
value: !0
});
ma.default = lA;
var uA = Cs;
function lA(e) {
return e = (0, uA.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
}
var Wi = {}, Qo;
function cA() {
if (Qo) return Wi;
Qo = 1, Object.defineProperty(Wi, "__esModule", {
  value: !0
}), Wi.default = r;
var e = T, t = Pt();
function r(i, s = i.key || i.property) {
  return !i.computed && (0, e.isIdentifier)(s) && (s = (0, t.stringLiteral)(s.name)), s;
}
return Wi;
}
var ws = {};
Object.defineProperty(ws, "__esModule", {
value: !0
});
ws.default = void 0;
var Vr = T;
ws.default = fA;
function fA(e) {
if ((0, Vr.isExpressionStatement)(e) && (e = e.expression), (0, Vr.isExpression)(e))
  return e;
if ((0, Vr.isClass)(e) ? e.type = "ClassExpression" : (0, Vr.isFunction)(e) && (e.type = "FunctionExpression"), !(0, Vr.isExpression)(e))
  throw new Error(`cannot turn ${e.type} to an expression`);
return e;
}
var ya = {}, Ns = {}, Os = {};
Object.defineProperty(Os, "__esModule", {
value: !0
});
Os.default = Mn;
var pA = Dt();
function Mn(e, t, r) {
if (!e) return;
const i = pA.VISITOR_KEYS[e.type];
if (i) {
  r = r || {}, t(e, r);
  for (const s of i) {
    const n = e[s];
    if (Array.isArray(n))
      for (const a of n)
        Mn(a, t, r);
    else
      Mn(n, t, r);
  }
}
}
var _s = {};
Object.defineProperty(_s, "__esModule", {
value: !0
});
_s.default = mA;
var hA = xe;
const hc = ["tokens", "start", "end", "loc", "raw", "rawValue"], dA = [...hA.COMMENT_KEYS, "comments", ...hc];
function mA(e, t = {}) {
const r = t.preserveComments ? hc : dA;
for (const s of r)
  e[s] != null && (e[s] = void 0);
for (const s of Object.keys(e))
  s[0] === "_" && e[s] != null && (e[s] = void 0);
const i = Object.getOwnPropertySymbols(e);
for (const s of i)
  e[s] = null;
}
Object.defineProperty(Ns, "__esModule", {
value: !0
});
Ns.default = TA;
var yA = Os, bA = _s;
function TA(e, t) {
return (0, yA.default)(e, bA.default, t), e;
}
Object.defineProperty(ya, "__esModule", {
value: !0
});
ya.default = mr;
var Zo = T, gA = Qt, SA = Ns;
function mr(e, t = e.key) {
let r;
return e.kind === "method" ? mr.increment() + "" : ((0, Zo.isIdentifier)(t) ? r = t.name : (0, Zo.isStringLiteral)(t) ? r = JSON.stringify(t.value) : r = JSON.stringify((0, SA.default)((0, gA.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
}
mr.uid = 0;
mr.increment = function() {
return mr.uid >= Number.MAX_SAFE_INTEGER ? mr.uid = 0 : mr.uid++;
};
var qr = {}, eu;
function xA() {
if (eu) return qr;
eu = 1, Object.defineProperty(qr, "__esModule", {
  value: !0
}), qr.default = void 0;
var e = T, t = Pt();
qr.default = r;
function r(i, s) {
  if ((0, e.isStatement)(i))
    return i;
  let n = !1, a;
  if ((0, e.isClass)(i))
    n = !0, a = "ClassDeclaration";
  else if ((0, e.isFunction)(i))
    n = !0, a = "FunctionDeclaration";
  else if ((0, e.isAssignmentExpression)(i))
    return (0, t.expressionStatement)(i);
  if (n && !i.id && (a = !1), !a) {
    if (s)
      return !1;
    throw new Error(`cannot turn ${i.type} to a statement`);
  }
  return i.type = a, i;
}
return qr;
}
var $r = {}, tu;
function EA() {
if (tu) return $r;
tu = 1, Object.defineProperty($r, "__esModule", {
  value: !0
}), $r.default = void 0;
var e = gr, t = Pt();
$r.default = n;
const r = Function.call.bind(Object.prototype.toString);
function i(a) {
  return r(a) === "[object RegExp]";
}
function s(a) {
  if (typeof a != "object" || a === null || Object.prototype.toString.call(a) !== "[object Object]")
    return !1;
  const o = Object.getPrototypeOf(a);
  return o === null || Object.getPrototypeOf(o) === null;
}
function n(a) {
  if (a === void 0)
    return (0, t.identifier)("undefined");
  if (a === !0 || a === !1)
    return (0, t.booleanLiteral)(a);
  if (a === null)
    return (0, t.nullLiteral)();
  if (typeof a == "string")
    return (0, t.stringLiteral)(a);
  if (typeof a == "number") {
    let o;
    if (Number.isFinite(a))
      o = (0, t.numericLiteral)(Math.abs(a));
    else {
      let u;
      Number.isNaN(a) ? u = (0, t.numericLiteral)(0) : u = (0, t.numericLiteral)(1), o = (0, t.binaryExpression)("/", u, (0, t.numericLiteral)(0));
    }
    return (a < 0 || Object.is(a, -0)) && (o = (0, t.unaryExpression)("-", o)), o;
  }
  if (i(a)) {
    const o = a.source, u = /\/([a-z]+|)$/.exec(a.toString())[1];
    return (0, t.regExpLiteral)(o, u);
  }
  if (Array.isArray(a))
    return (0, t.arrayExpression)(a.map(n));
  if (s(a)) {
    const o = [];
    for (const u of Object.keys(a)) {
      let l;
      (0, e.default)(u) ? l = (0, t.identifier)(u) : l = (0, t.stringLiteral)(u), o.push((0, t.objectProperty)(l, n(a[u])));
    }
    return (0, t.objectExpression)(o);
  }
  throw new Error("don't know how to turn this value into a node");
}
return $r;
}
var Ji = {}, ru;
function PA() {
if (ru) return Ji;
ru = 1, Object.defineProperty(Ji, "__esModule", {
  value: !0
}), Ji.default = t;
var e = Pt();
function t(r, i, s = !1) {
  return r.object = (0, e.memberExpression)(r.object, r.property, r.computed), r.property = i, r.computed = !!s, r;
}
return Ji;
}
var ba = {};
Object.defineProperty(ba, "__esModule", {
value: !0
});
ba.default = AA;
var iu = xe, vA = As;
function AA(e, t) {
if (!e || !t) return e;
for (const r of iu.INHERIT_KEYS.optional)
  e[r] == null && (e[r] = t[r]);
for (const r of Object.keys(t))
  r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
for (const r of iu.INHERIT_KEYS.force)
  e[r] = t[r];
return (0, vA.default)(e, t), e;
}
var Yi = {}, su;
function IA() {
if (su) return Yi;
su = 1, Object.defineProperty(Yi, "__esModule", {
  value: !0
}), Yi.default = r;
var e = Pt(), t = Ce();
function r(i, s) {
  if ((0, t.isSuper)(i.object))
    throw new Error("Cannot prepend node to super property access (`super.foo`).");
  return i.object = (0, e.memberExpression)(s, i.object), i;
}
return Yi;
}
var Dr = {};
Object.defineProperty(Dr, "__esModule", {
value: !0
});
Dr.default = Ta;
var Ut = T;
function Ta(e, t, r, i) {
const s = [].concat(e), n = /* @__PURE__ */ Object.create(null);
for (; s.length; ) {
  const a = s.shift();
  if (!a || i && ((0, Ut.isAssignmentExpression)(a) || (0, Ut.isUnaryExpression)(a) || (0, Ut.isUpdateExpression)(a)))
    continue;
  if ((0, Ut.isIdentifier)(a)) {
    t ? (n[a.name] = n[a.name] || []).push(a) : n[a.name] = a;
    continue;
  }
  if ((0, Ut.isExportDeclaration)(a) && !(0, Ut.isExportAllDeclaration)(a)) {
    (0, Ut.isDeclaration)(a.declaration) && s.push(a.declaration);
    continue;
  }
  if (r) {
    if ((0, Ut.isFunctionDeclaration)(a)) {
      s.push(a.id);
      continue;
    }
    if ((0, Ut.isFunctionExpression)(a))
      continue;
  }
  const o = Ta.keys[a.type];
  if (o)
    for (let u = 0; u < o.length; u++) {
      const l = o[u], c = a[l];
      c && (Array.isArray(c) ? s.push(...c) : s.push(c));
    }
}
return n;
}
const CA = {
DeclareClass: ["id"],
DeclareFunction: ["id"],
DeclareModule: ["id"],
DeclareVariable: ["id"],
DeclareInterface: ["id"],
DeclareTypeAlias: ["id"],
DeclareOpaqueType: ["id"],
InterfaceDeclaration: ["id"],
TypeAlias: ["id"],
OpaqueType: ["id"],
CatchClause: ["param"],
LabeledStatement: ["label"],
UnaryExpression: ["argument"],
AssignmentExpression: ["left"],
ImportSpecifier: ["local"],
ImportNamespaceSpecifier: ["local"],
ImportDefaultSpecifier: ["local"],
ImportDeclaration: ["specifiers"],
ExportSpecifier: ["exported"],
ExportNamespaceSpecifier: ["exported"],
ExportDefaultSpecifier: ["exported"],
FunctionDeclaration: ["id", "params"],
FunctionExpression: ["id", "params"],
ArrowFunctionExpression: ["params"],
ObjectMethod: ["params"],
ClassMethod: ["params"],
ClassPrivateMethod: ["params"],
ForInStatement: ["left"],
ForOfStatement: ["left"],
ClassDeclaration: ["id"],
ClassExpression: ["id"],
RestElement: ["argument"],
UpdateExpression: ["argument"],
ObjectProperty: ["value"],
AssignmentPattern: ["left"],
ArrayPattern: ["elements"],
ObjectPattern: ["properties"],
VariableDeclaration: ["declarations"],
VariableDeclarator: ["id"]
};
Ta.keys = CA;
var ks = {};
Object.defineProperty(ks, "__esModule", {
value: !0
});
ks.default = void 0;
var wA = Dr;
ks.default = NA;
function NA(e, t) {
return (0, wA.default)(e, t, !0);
}
var ga = {};
Object.defineProperty(ga, "__esModule", {
value: !0
});
ga.default = _A;
var OA = Dt();
function _A(e, t, r) {
typeof t == "function" && (t = {
  enter: t
});
const {
  enter: i,
  exit: s
} = t;
Bn(e, i, s, r, []);
}
function Bn(e, t, r, i, s) {
const n = OA.VISITOR_KEYS[e.type];
if (n) {
  t && t(e, s, i);
  for (const a of n) {
    const o = e[a];
    if (Array.isArray(o))
      for (let u = 0; u < o.length; u++) {
        const l = o[u];
        l && (s.push({
          node: e,
          key: a,
          index: u
        }), Bn(l, t, r, i, s), s.pop());
      }
    else o && (s.push({
      node: e,
      key: a
    }), Bn(o, t, r, i, s), s.pop());
  }
  r && r(e, s, i);
}
}
var Sa = {};
Object.defineProperty(Sa, "__esModule", {
value: !0
});
Sa.default = DA;
var kA = Dr;
function DA(e, t, r) {
if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression")
  return !1;
const i = kA.default.keys[t.type];
if (i)
  for (let s = 0; s < i.length; s++) {
    const n = i[s], a = t[n];
    if (Array.isArray(a)) {
      if (a.includes(e)) return !0;
    } else if (a === e) return !0;
  }
return !1;
}
var xa = {}, Ds = {};
Object.defineProperty(Ds, "__esModule", {
value: !0
});
Ds.default = BA;
var LA = T, MA = xe;
function BA(e) {
return (0, LA.isVariableDeclaration)(e) && (e.kind !== "var" || e[MA.BLOCK_SCOPED_SYMBOL]);
}
Object.defineProperty(xa, "__esModule", {
value: !0
});
xa.default = jA;
var nu = T, FA = Ds;
function jA(e) {
return (0, nu.isFunctionDeclaration)(e) || (0, nu.isClassDeclaration)(e) || (0, FA.default)(e);
}
var Ea = {};
Object.defineProperty(Ea, "__esModule", {
value: !0
});
Ea.default = VA;
var RA = ia(), UA = T;
function VA(e) {
return (0, RA.default)(e.type, "Immutable") ? !0 : (0, UA.isIdentifier)(e) ? e.name === "undefined" : !1;
}
var Pa = {};
Object.defineProperty(Pa, "__esModule", {
value: !0
});
Pa.default = Fn;
var au = Dt();
function Fn(e, t) {
if (typeof e != "object" || typeof t != "object" || e == null || t == null)
  return e === t;
if (e.type !== t.type)
  return !1;
const r = Object.keys(au.NODE_FIELDS[e.type] || e.type), i = au.VISITOR_KEYS[e.type];
for (const s of r) {
  const n = e[s], a = t[s];
  if (typeof n != typeof a)
    return !1;
  if (!(n == null && a == null)) {
    if (n == null || a == null)
      return !1;
    if (Array.isArray(n)) {
      if (!Array.isArray(a) || n.length !== a.length)
        return !1;
      for (let o = 0; o < n.length; o++)
        if (!Fn(n[o], a[o]))
          return !1;
      continue;
    }
    if (typeof n == "object" && !(i != null && i.includes(s))) {
      for (const o of Object.keys(n))
        if (n[o] !== a[o])
          return !1;
      continue;
    }
    if (!Fn(n, a))
      return !1;
  }
}
return !0;
}
var va = {};
Object.defineProperty(va, "__esModule", {
value: !0
});
va.default = qA;
function qA(e, t, r) {
switch (t.type) {
  case "MemberExpression":
  case "OptionalMemberExpression":
    return t.property === e ? !!t.computed : t.object === e;
  case "JSXMemberExpression":
    return t.object === e;
  case "VariableDeclarator":
    return t.init === e;
  case "ArrowFunctionExpression":
    return t.body === e;
  case "PrivateName":
    return !1;
  case "ClassMethod":
  case "ClassPrivateMethod":
  case "ObjectMethod":
    return t.key === e ? !!t.computed : !1;
  case "ObjectProperty":
    return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
  case "ClassProperty":
  case "ClassAccessorProperty":
    return t.key === e ? !!t.computed : !0;
  case "ClassPrivateProperty":
    return t.key !== e;
  case "ClassDeclaration":
  case "ClassExpression":
    return t.superClass === e;
  case "AssignmentExpression":
    return t.right === e;
  case "AssignmentPattern":
    return t.right === e;
  case "LabeledStatement":
    return !1;
  case "CatchClause":
    return !1;
  case "RestElement":
    return !1;
  case "BreakStatement":
  case "ContinueStatement":
    return !1;
  case "FunctionDeclaration":
  case "FunctionExpression":
    return !1;
  case "ExportNamespaceSpecifier":
  case "ExportDefaultSpecifier":
    return !1;
  case "ExportSpecifier":
    return r != null && r.source ? !1 : t.local === e;
  case "ImportDefaultSpecifier":
  case "ImportNamespaceSpecifier":
  case "ImportSpecifier":
    return !1;
  case "ImportAttribute":
    return !1;
  case "JSXAttribute":
    return !1;
  case "ObjectPattern":
  case "ArrayPattern":
    return !1;
  case "MetaProperty":
    return !1;
  case "ObjectTypeProperty":
    return t.key !== e;
  case "TSEnumMember":
    return t.id !== e;
  case "TSPropertySignature":
    return t.key === e ? !!t.computed : !0;
}
return !0;
}
var Aa = {};
Object.defineProperty(Aa, "__esModule", {
value: !0
});
Aa.default = $A;
var fr = T;
function $A(e, t) {
return (0, fr.isBlockStatement)(e) && ((0, fr.isFunction)(t) || (0, fr.isCatchClause)(t)) ? !1 : (0, fr.isPattern)(e) && ((0, fr.isFunction)(t) || (0, fr.isCatchClause)(t)) ? !0 : (0, fr.isScopable)(e);
}
var Ia = {};
Object.defineProperty(Ia, "__esModule", {
value: !0
});
Ia.default = KA;
var ou = T;
function KA(e) {
return (0, ou.isImportDefaultSpecifier)(e) || (0, ou.isIdentifier)(e.imported || e.exported, {
  name: "default"
});
}
var Ca = {};
Object.defineProperty(Ca, "__esModule", {
value: !0
});
Ca.default = YA;
var WA = gr;
const JA = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
function YA(e) {
return (0, WA.default)(e) && !JA.has(e);
}
var wa = {};
Object.defineProperty(wa, "__esModule", {
value: !0
});
wa.default = GA;
var XA = T, HA = xe;
function GA(e) {
return (0, XA.isVariableDeclaration)(e, {
  kind: "var"
}) && !e[HA.BLOCK_SCOPED_SYMBOL];
}
var Xi = {}, Hi = {}, uu;
function zA() {
if (uu) return Hi;
uu = 1, Object.defineProperty(Hi, "__esModule", {
  value: !0
}), Hi.default = n;
var e = Dr, t = T, r = Pt(), i = cc(), s = Qt;
function n(a, o) {
  const u = [];
  let l = !0;
  for (const c of a)
    if ((0, t.isEmptyStatement)(c) || (l = !1), (0, t.isExpression)(c))
      u.push(c);
    else if ((0, t.isExpressionStatement)(c))
      u.push(c.expression);
    else if ((0, t.isVariableDeclaration)(c)) {
      if (c.kind !== "var") return;
      for (const f of c.declarations) {
        const p = (0, e.default)(f);
        for (const h of Object.keys(p))
          o.push({
            kind: c.kind,
            id: (0, s.default)(p[h])
          });
        f.init && u.push((0, r.assignmentExpression)("=", f.id, f.init));
      }
      l = !0;
    } else if ((0, t.isIfStatement)(c)) {
      const f = c.consequent ? n([c.consequent], o) : (0, i.buildUndefinedNode)(), p = c.alternate ? n([c.alternate], o) : (0, i.buildUndefinedNode)();
      if (!f || !p) return;
      u.push((0, r.conditionalExpression)(c.test, f, p));
    } else if ((0, t.isBlockStatement)(c)) {
      const f = n(c.body, o);
      if (!f) return;
      u.push(f);
    } else if ((0, t.isEmptyStatement)(c))
      a.indexOf(c) === 0 && (l = !0);
    else
      return;
  return l && u.push((0, i.buildUndefinedNode)()), u.length === 1 ? u[0] : (0, r.sequenceExpression)(u);
}
return Hi;
}
var lu;
function QA() {
if (lu) return Xi;
lu = 1, Object.defineProperty(Xi, "__esModule", {
  value: !0
}), Xi.default = t;
var e = zA();
function t(r, i) {
  if (!(r != null && r.length)) return;
  const s = [], n = (0, e.default)(r, s);
  if (n) {
    for (const a of s)
      i.push(a);
    return n;
  }
}
return Xi;
}
var cu;
function Ce() {
return cu || (cu = 1, function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(e, "__internal__deprecationWarning", {
    enumerable: !0,
    get: function() {
      return Te.default;
    }
  }), Object.defineProperty(e, "addComment", {
    enumerable: !0,
    get: function() {
      return _.default;
    }
  }), Object.defineProperty(e, "addComments", {
    enumerable: !0,
    get: function() {
      return j.default;
    }
  }), Object.defineProperty(e, "appendToMemberExpression", {
    enumerable: !0,
    get: function() {
      return q.default;
    }
  }), Object.defineProperty(e, "assertNode", {
    enumerable: !0,
    get: function() {
      return n.default;
    }
  }), Object.defineProperty(e, "buildMatchMemberExpression", {
    enumerable: !0,
    get: function() {
      return Se.default;
    }
  }), Object.defineProperty(e, "clone", {
    enumerable: !0,
    get: function() {
      return y.default;
    }
  }), Object.defineProperty(e, "cloneDeep", {
    enumerable: !0,
    get: function() {
      return g.default;
    }
  }), Object.defineProperty(e, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: function() {
      return A.default;
    }
  }), Object.defineProperty(e, "cloneNode", {
    enumerable: !0,
    get: function() {
      return h.default;
    }
  }), Object.defineProperty(e, "cloneWithoutLoc", {
    enumerable: !0,
    get: function() {
      return C.default;
    }
  }), Object.defineProperty(e, "createFlowUnionType", {
    enumerable: !0,
    get: function() {
      return u.default;
    }
  }), Object.defineProperty(e, "createTSUnionType", {
    enumerable: !0,
    get: function() {
      return l.default;
    }
  }), Object.defineProperty(e, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: function() {
      return o.default;
    }
  }), Object.defineProperty(e, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return u.default;
    }
  }), Object.defineProperty(e, "ensureBlock", {
    enumerable: !0,
    get: function() {
      return W.default;
    }
  }), Object.defineProperty(e, "getBindingIdentifiers", {
    enumerable: !0,
    get: function() {
      return pe.default;
    }
  }), Object.defineProperty(e, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: function() {
      return he.default;
    }
  }), Object.defineProperty(e, "inheritInnerComments", {
    enumerable: !0,
    get: function() {
      return G.default;
    }
  }), Object.defineProperty(e, "inheritLeadingComments", {
    enumerable: !0,
    get: function() {
      return fe.default;
    }
  }), Object.defineProperty(e, "inheritTrailingComments", {
    enumerable: !0,
    get: function() {
      return oe.default;
    }
  }), Object.defineProperty(e, "inherits", {
    enumerable: !0,
    get: function() {
      return V.default;
    }
  }), Object.defineProperty(e, "inheritsComments", {
    enumerable: !0,
    get: function() {
      return re.default;
    }
  }), Object.defineProperty(e, "is", {
    enumerable: !0,
    get: function() {
      return ke.default;
    }
  }), Object.defineProperty(e, "isBinding", {
    enumerable: !0,
    get: function() {
      return De.default;
    }
  }), Object.defineProperty(e, "isBlockScoped", {
    enumerable: !0,
    get: function() {
      return Je.default;
    }
  }), Object.defineProperty(e, "isImmutable", {
    enumerable: !0,
    get: function() {
      return it.default;
    }
  }), Object.defineProperty(e, "isLet", {
    enumerable: !0,
    get: function() {
      return ve.default;
    }
  }), Object.defineProperty(e, "isNode", {
    enumerable: !0,
    get: function() {
      return je.default;
    }
  }), Object.defineProperty(e, "isNodesEquivalent", {
    enumerable: !0,
    get: function() {
      return Ie.default;
    }
  }), Object.defineProperty(e, "isPlaceholderType", {
    enumerable: !0,
    get: function() {
      return Ve.default;
    }
  }), Object.defineProperty(e, "isReferenced", {
    enumerable: !0,
    get: function() {
      return ht.default;
    }
  }), Object.defineProperty(e, "isScope", {
    enumerable: !0,
    get: function() {
      return ze.default;
    }
  }), Object.defineProperty(e, "isSpecifierDefault", {
    enumerable: !0,
    get: function() {
      return J.default;
    }
  }), Object.defineProperty(e, "isType", {
    enumerable: !0,
    get: function() {
      return d.default;
    }
  }), Object.defineProperty(e, "isValidES3Identifier", {
    enumerable: !0,
    get: function() {
      return P.default;
    }
  }), Object.defineProperty(e, "isValidIdentifier", {
    enumerable: !0,
    get: function() {
      return N.default;
    }
  }), Object.defineProperty(e, "isVar", {
    enumerable: !0,
    get: function() {
      return M.default;
    }
  }), Object.defineProperty(e, "matchesPattern", {
    enumerable: !0,
    get: function() {
      return Z.default;
    }
  }), Object.defineProperty(e, "prependToMemberExpression", {
    enumerable: !0,
    get: function() {
      return H.default;
    }
  }), e.react = void 0, Object.defineProperty(e, "removeComments", {
    enumerable: !0,
    get: function() {
      return K.default;
    }
  }), Object.defineProperty(e, "removeProperties", {
    enumerable: !0,
    get: function() {
      return ne.default;
    }
  }), Object.defineProperty(e, "removePropertiesDeep", {
    enumerable: !0,
    get: function() {
      return ue.default;
    }
  }), Object.defineProperty(e, "removeTypeDuplicates", {
    enumerable: !0,
    get: function() {
      return qe.default;
    }
  }), Object.defineProperty(e, "shallowEqual", {
    enumerable: !0,
    get: function() {
      return Pe.default;
    }
  }), Object.defineProperty(e, "toBindingIdentifierName", {
    enumerable: !0,
    get: function() {
      return Q.default;
    }
  }), Object.defineProperty(e, "toBlock", {
    enumerable: !0,
    get: function() {
      return U.default;
    }
  }), Object.defineProperty(e, "toComputedKey", {
    enumerable: !0,
    get: function() {
      return L.default;
    }
  }), Object.defineProperty(e, "toExpression", {
    enumerable: !0,
    get: function() {
      return k.default;
    }
  }), Object.defineProperty(e, "toIdentifier", {
    enumerable: !0,
    get: function() {
      return F.default;
    }
  }), Object.defineProperty(e, "toKeyAlias", {
    enumerable: !0,
    get: function() {
      return B.default;
    }
  }), Object.defineProperty(e, "toStatement", {
    enumerable: !0,
    get: function() {
      return O.default;
    }
  }), Object.defineProperty(e, "traverse", {
    enumerable: !0,
    get: function() {
      return Ee.default;
    }
  }), Object.defineProperty(e, "traverseFast", {
    enumerable: !0,
    get: function() {
      return we.default;
    }
  }), Object.defineProperty(e, "validate", {
    enumerable: !0,
    get: function() {
      return ee.default;
    }
  }), Object.defineProperty(e, "valueToNode", {
    enumerable: !0,
    get: function() {
      return D.default;
    }
  });
  var r = ys, i = ra, s = qg(), n = oa, a = S;
  Object.keys(a).forEach(function(Y) {
    Y === "default" || Y === "__esModule" || Object.prototype.hasOwnProperty.call(t, Y) || Y in e && e[Y] === a[Y] || Object.defineProperty(e, Y, {
      enumerable: !0,
      get: function() {
        return a[Y];
      }
    });
  });
  var o = wv(), u = Nv(), l = Ov(), c = Pt();
  Object.keys(c).forEach(function(Y) {
    Y === "default" || Y === "__esModule" || Object.prototype.hasOwnProperty.call(t, Y) || Y in e && e[Y] === c[Y] || Object.defineProperty(e, Y, {
      enumerable: !0,
      get: function() {
        return c[Y];
      }
    });
  });
  var f = _v();
  Object.keys(f).forEach(function(Y) {
    Y === "default" || Y === "__esModule" || Object.prototype.hasOwnProperty.call(t, Y) || Y in e && e[Y] === f[Y] || Object.defineProperty(e, Y, {
      enumerable: !0,
      get: function() {
        return f[Y];
      }
    });
  });
  var p = cc();
  Object.keys(p).forEach(function(Y) {
    Y === "default" || Y === "__esModule" || Object.prototype.hasOwnProperty.call(t, Y) || Y in e && e[Y] === p[Y] || Object.defineProperty(e, Y, {
      enumerable: !0,
      get: function() {
        return p[Y];
      }
    });
  });
  var h = Qt, y = la, g = ca, A = fa, C = pa, _ = ha, j = Es, G = Ps, fe = vs, re = As, oe = Is, K = da, X = z;
  Object.keys(X).forEach(function(Y) {
    Y === "default" || Y === "__esModule" || Object.prototype.hasOwnProperty.call(t, Y) || Y in e && e[Y] === X[Y] || Object.defineProperty(e, Y, {
      enumerable: !0,
      get: function() {
        return X[Y];
      }
    });
  });
  var ie = xe;
  Object.keys(ie).forEach(function(Y) {
    Y === "default" || Y === "__esModule" || Object.prototype.hasOwnProperty.call(t, Y) || Y in e && e[Y] === ie[Y] || Object.defineProperty(e, Y, {
      enumerable: !0,
      get: function() {
        return ie[Y];
      }
    });
  });
  var W = sA(), Q = ma, U = pc(), L = cA(), k = ws, F = Cs, B = ya, O = xA(), D = EA(), R = Dt();
  Object.keys(R).forEach(function(Y) {
    Y === "default" || Y === "__esModule" || Object.prototype.hasOwnProperty.call(t, Y) || Y in e && e[Y] === R[Y] || Object.defineProperty(e, Y, {
      enumerable: !0,
      get: function() {
        return R[Y];
      }
    });
  });
  var q = PA(), V = ba, H = IA(), ne = _s, ue = Ns, qe = xs, pe = Dr, he = ks, Ee = ga;
  Object.keys(Ee).forEach(function(Y) {
    Y === "default" || Y === "__esModule" || Object.prototype.hasOwnProperty.call(t, Y) || Y in e && e[Y] === Ee[Y] || Object.defineProperty(e, Y, {
      enumerable: !0,
      get: function() {
        return Ee[Y];
      }
    });
  });
  var we = Os, Pe = li, ke = fi(), De = Sa, Je = xa, it = Ea, ve = Ds, je = Ss, Ie = Pa, Ve = Yl(), ht = va, ze = Aa, J = Ia, d = ia(), P = Ca, N = gr, M = wa, Z = Ts, ee = aa(), Se = bs, Ae = T;
  Object.keys(Ae).forEach(function(Y) {
    Y === "default" || Y === "__esModule" || Object.prototype.hasOwnProperty.call(t, Y) || Y in e && e[Y] === Ae[Y] || Object.defineProperty(e, Y, {
      enumerable: !0,
      get: function() {
        return Ae[Y];
      }
    });
  });
  var Te = kr;
  e.react = {
    isReactComponent: r.default,
    isCompatTag: i.default,
    buildChildren: s.default
  }, e.toSequenceExpression = QA().default;
}(rn)), rn;
}
Object.defineProperty(rt, "__esModule", {
value: !0
});
rt.isBindingIdentifier = x3;
rt.isBlockScoped = I3;
rt.isExpression = P3;
rt.isFlow = _3;
rt.isForAwaitStatement = L3;
rt.isGenerated = N3;
rt.isPure = O3;
rt.isReferenced = A3;
rt.isReferencedIdentifier = g3;
rt.isReferencedMemberExpression = S3;
rt.isRestProperty = k3;
rt.isScope = v3;
rt.isSpreadProperty = D3;
rt.isStatement = E3;
rt.isUser = w3;
rt.isVar = C3;
var ZA = Ce();
const {
isBinding: e3,
isBlockScoped: t3,
isExportDeclaration: r3,
isExpression: i3,
isFlow: s3,
isForStatement: n3,
isForXStatement: a3,
isIdentifier: dc,
isImportDeclaration: o3,
isImportSpecifier: u3,
isJSXIdentifier: l3,
isJSXMemberExpression: c3,
isMemberExpression: f3,
isRestElement: mc,
isReferenced: Na,
isScope: p3,
isStatement: h3,
isVar: d3,
isVariableDeclaration: m3,
react: y3,
isForOfStatement: b3
} = ZA, {
isCompatTag: T3
} = y3;
function g3(e) {
const {
  node: t,
  parent: r
} = this;
if (!dc(t, e) && !c3(r, e))
  if (l3(t, e)) {
    if (T3(t.name)) return !1;
  } else
    return !1;
return Na(t, r, this.parentPath.parent);
}
function S3() {
const {
  node: e,
  parent: t
} = this;
return f3(e) && Na(e, t);
}
function x3() {
const {
  node: e,
  parent: t
} = this, r = this.parentPath.parent;
return dc(e) && e3(e, t, r);
}
function E3() {
const {
  node: e,
  parent: t
} = this;
return h3(e) ? !(m3(e) && (a3(t, {
  left: e
}) || n3(t, {
  init: e
}))) : !1;
}
function P3() {
return this.isIdentifier() ? this.isReferencedIdentifier() : i3(this.node);
}
function v3() {
return p3(this.node, this.parent);
}
function A3() {
return Na(this.node, this.parent);
}
function I3() {
return t3(this.node);
}
function C3() {
return d3(this.node);
}
function w3() {
return this.node && !!this.node.loc;
}
function N3() {
return !this.isUser();
}
function O3(e) {
return this.scope.isPure(this.node, e);
}
function _3() {
const {
  node: e
} = this;
return s3(e) ? !0 : o3(e) ? e.importKind === "type" || e.importKind === "typeof" : r3(e) ? e.exportKind === "type" : u3(e) ? e.importKind === "type" || e.importKind === "typeof" : !1;
}
function k3() {
var e;
return mc(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectPattern());
}
function D3() {
var e;
return mc(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectExpression());
}
function L3() {
return b3(this.node, {
  await: !0
});
}
rt.isExistentialTypeParam = function() {
throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
}, rt.isNumericLiteralTypeAnnotation = function() {
throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
};
Object.defineProperty(zt, "__esModule", {
value: !0
});
zt.explode = Tc;
zt.isExplodedVisitor = bc;
zt.merge = R3;
zt.verify = gc;
var yc = _e, M3 = rt, B3 = Ce();
const {
DEPRECATED_KEYS: fu,
DEPRECATED_ALIASES: pu,
FLIPPED_ALIAS_KEYS: hu,
TYPES: F3,
__internal__deprecationWarning: du
} = B3;
function j3(e) {
return e in yc;
}
function bc(e) {
return e == null ? void 0 : e._exploded;
}
function Tc(e) {
if (bc(e)) return e;
e._exploded = !0;
for (const t of Object.keys(e)) {
  if (yr(t)) continue;
  const r = t.split("|");
  if (r.length === 1) continue;
  const i = e[t];
  delete e[t];
  for (const s of r)
    e[s] = i;
}
gc(e), delete e.__esModule, U3(e), bu(e);
for (const t of Object.keys(e)) {
  if (yr(t) || !j3(t)) continue;
  const r = e[t];
  for (const s of Object.keys(r))
    r[s] = V3(t, r[s]);
  delete e[t];
  const i = yc[t];
  if (i !== null)
    for (const s of i)
      e[s] ? ii(e[s], r) : e[s] = r;
  else
    ii(e, r);
}
for (const t of Object.keys(e)) {
  if (yr(t)) continue;
  let r = hu[t];
  if (t in fu) {
    const s = fu[t];
    du(t, s, "Visitor "), r = [s];
  } else if (t in pu) {
    const s = pu[t];
    du(t, s, "Visitor "), r = hu[s];
  }
  if (!r) continue;
  const i = e[t];
  delete e[t];
  for (const s of r) {
    const n = e[s];
    n ? ii(n, i) : e[s] = Object.assign({}, i);
  }
}
for (const t of Object.keys(e))
  yr(t) || bu(e[t]);
return e;
}
function gc(e) {
if (!e._verified) {
  if (typeof e == "function")
    throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
  for (const t of Object.keys(e)) {
    if ((t === "enter" || t === "exit") && mu(t, e[t]), yr(t)) continue;
    if (!F3.includes(t))
      throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type`);
    const r = e[t];
    if (typeof r == "object")
      for (const i of Object.keys(r))
        if (i === "enter" || i === "exit")
          mu(`${t}.${i}`, r[i]);
        else
          throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${i}`);
  }
  e._verified = !0;
}
}
function mu(e, t) {
const r = [].concat(t);
for (const i of r)
  if (typeof i != "function")
    throw new TypeError(`Non-function found defined in ${e} with type ${typeof i}`);
}
function R3(e, t = [], r) {
const i = {};
for (let s = 0; s < e.length; s++) {
  const n = Tc(e[s]), a = t[s];
  let o = n;
  (a || r) && (o = yu(o, a, r)), ii(i, o);
  for (const u of Object.keys(n)) {
    if (yr(u)) continue;
    let l = n[u];
    (a || r) && (l = yu(l, a, r));
    const c = i[u] || (i[u] = {});
    ii(c, l);
  }
}
return i;
}
function yu(e, t, r) {
const i = {};
for (const s of ["enter", "exit"]) {
  let n = e[s];
  Array.isArray(n) && (n = n.map(function(a) {
    let o = a;
    return t && (o = function(u) {
      a.call(t, u, t);
    }), r && (o = r(t == null ? void 0 : t.key, s, o)), o !== a && (o.toString = () => a.toString()), o;
  }), i[s] = n);
}
return i;
}
function U3(e) {
for (const t of Object.keys(e)) {
  if (yr(t)) continue;
  const r = e[t];
  typeof r == "function" && (e[t] = {
    enter: r
  });
}
}
function bu(e) {
e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]), e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
}
function V3(e, t) {
const r = `is${e}`, i = M3[r], s = function(n) {
  if (i.call(n))
    return t.apply(this, arguments);
};
return s.toString = () => t.toString(), s;
}
function yr(e) {
return e[0] === "_" || e === "enter" || e === "exit" || e === "shouldSkip" || e === "denylist" || e === "noScope" || e === "skipKeys" || e === "blacklist";
}
function ii(e, t) {
for (const r of ["enter", "exit"])
  t[r] && (e[r] = [].concat(e[r] || [], t[r]));
}
var lt = {};
Object.defineProperty(lt, "__esModule", {
value: !0
});
lt.clear = q3;
lt.clearPath = Sc;
lt.clearScope = xc;
lt.getCachedPaths = $3;
lt.getOrCreateCachedPaths = K3;
lt.scope = lt.path = void 0;
let ls = lt.path = /* @__PURE__ */ new WeakMap();
lt.scope = /* @__PURE__ */ new WeakMap();
function q3() {
Sc(), xc();
}
function Sc() {
lt.path = ls = /* @__PURE__ */ new WeakMap();
}
function xc() {
lt.scope = /* @__PURE__ */ new WeakMap();
}
const jn = Object.freeze({});
function $3(e, t) {
var r, i;
return e = null, (r = ls.get((i = e) != null ? i : jn)) == null ? void 0 : r.get(t);
}
function K3(e, t) {
var r, i;
e = null;
let s = ls.get((r = e) != null ? r : jn);
s || ls.set((i = e) != null ? i : jn, s = /* @__PURE__ */ new WeakMap());
let n = s.get(t);
return n || s.set(t, n = /* @__PURE__ */ new Map()), n;
}
var Gi = {}, Kr = {}, Nt = {}, Rn = { exports: {} }, on, Tu;
function W3() {
if (Tu) return on;
Tu = 1;
var e = 1e3, t = e * 60, r = t * 60, i = r * 24, s = i * 7, n = i * 365.25;
on = function(c, f) {
  f = f || {};
  var p = typeof c;
  if (p === "string" && c.length > 0)
    return a(c);
  if (p === "number" && isFinite(c))
    return f.long ? u(c) : o(c);
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(c)
  );
};
function a(c) {
  if (c = String(c), !(c.length > 100)) {
    var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      c
    );
    if (f) {
      var p = parseFloat(f[1]), h = (f[2] || "ms").toLowerCase();
      switch (h) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return p * n;
        case "weeks":
        case "week":
        case "w":
          return p * s;
        case "days":
        case "day":
        case "d":
          return p * i;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return p * r;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return p * t;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return p * e;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return p;
        default:
          return;
      }
    }
  }
}
function o(c) {
  var f = Math.abs(c);
  return f >= i ? Math.round(c / i) + "d" : f >= r ? Math.round(c / r) + "h" : f >= t ? Math.round(c / t) + "m" : f >= e ? Math.round(c / e) + "s" : c + "ms";
}
function u(c) {
  var f = Math.abs(c);
  return f >= i ? l(c, f, i, "day") : f >= r ? l(c, f, r, "hour") : f >= t ? l(c, f, t, "minute") : f >= e ? l(c, f, e, "second") : c + " ms";
}
function l(c, f, p, h) {
  var y = f >= p * 1.5;
  return Math.round(c / p) + " " + h + (y ? "s" : "");
}
return on;
}
function J3(e) {
r.debug = r, r.default = r, r.coerce = u, r.disable = n, r.enable = s, r.enabled = a, r.humanize = W3(), r.destroy = l, Object.keys(e).forEach((c) => {
  r[c] = e[c];
}), r.names = [], r.skips = [], r.formatters = {};
function t(c) {
  let f = 0;
  for (let p = 0; p < c.length; p++)
    f = (f << 5) - f + c.charCodeAt(p), f |= 0;
  return r.colors[Math.abs(f) % r.colors.length];
}
r.selectColor = t;
function r(c) {
  let f, p = null, h, y;
  function g(...A) {
    if (!g.enabled)
      return;
    const C = g, _ = Number(/* @__PURE__ */ new Date()), j = _ - (f || _);
    C.diff = j, C.prev = f, C.curr = _, f = _, A[0] = r.coerce(A[0]), typeof A[0] != "string" && A.unshift("%O");
    let G = 0;
    A[0] = A[0].replace(/%([a-zA-Z%])/g, (re, oe) => {
      if (re === "%%")
        return "%";
      G++;
      const K = r.formatters[oe];
      if (typeof K == "function") {
        const X = A[G];
        re = K.call(C, X), A.splice(G, 1), G--;
      }
      return re;
    }), r.formatArgs.call(C, A), (C.log || r.log).apply(C, A);
  }
  return g.namespace = c, g.useColors = r.useColors(), g.color = r.selectColor(c), g.extend = i, g.destroy = r.destroy, Object.defineProperty(g, "enabled", {
    enumerable: !0,
    configurable: !1,
    get: () => p !== null ? p : (h !== r.namespaces && (h = r.namespaces, y = r.enabled(c)), y),
    set: (A) => {
      p = A;
    }
  }), typeof r.init == "function" && r.init(g), g;
}
function i(c, f) {
  const p = r(this.namespace + (typeof f > "u" ? ":" : f) + c);
  return p.log = this.log, p;
}
function s(c) {
  r.save(c), r.namespaces = c, r.names = [], r.skips = [];
  let f;
  const p = (typeof c == "string" ? c : "").split(/[\s,]+/), h = p.length;
  for (f = 0; f < h; f++)
    p[f] && (c = p[f].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
}
function n() {
  const c = [
    ...r.names.map(o),
    ...r.skips.map(o).map((f) => "-" + f)
  ].join(",");
  return r.enable(""), c;
}
function a(c) {
  if (c[c.length - 1] === "*")
    return !0;
  let f, p;
  for (f = 0, p = r.skips.length; f < p; f++)
    if (r.skips[f].test(c))
      return !1;
  for (f = 0, p = r.names.length; f < p; f++)
    if (r.names[f].test(c))
      return !0;
  return !1;
}
function o(c) {
  return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
}
function u(c) {
  return c instanceof Error ? c.stack || c.message : c;
}
function l() {
  console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
}
return r.enable(r.load()), r;
}
var Y3 = J3;
(function(e, t) {
t.formatArgs = i, t.save = s, t.load = n, t.useColors = r, t.storage = a(), t.destroy = /* @__PURE__ */ (() => {
  let u = !1;
  return () => {
    u || (u = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
  };
})(), t.colors = [
  "#0000CC",
  "#0000FF",
  "#0033CC",
  "#0033FF",
  "#0066CC",
  "#0066FF",
  "#0099CC",
  "#0099FF",
  "#00CC00",
  "#00CC33",
  "#00CC66",
  "#00CC99",
  "#00CCCC",
  "#00CCFF",
  "#3300CC",
  "#3300FF",
  "#3333CC",
  "#3333FF",
  "#3366CC",
  "#3366FF",
  "#3399CC",
  "#3399FF",
  "#33CC00",
  "#33CC33",
  "#33CC66",
  "#33CC99",
  "#33CCCC",
  "#33CCFF",
  "#6600CC",
  "#6600FF",
  "#6633CC",
  "#6633FF",
  "#66CC00",
  "#66CC33",
  "#9900CC",
  "#9900FF",
  "#9933CC",
  "#9933FF",
  "#99CC00",
  "#99CC33",
  "#CC0000",
  "#CC0033",
  "#CC0066",
  "#CC0099",
  "#CC00CC",
  "#CC00FF",
  "#CC3300",
  "#CC3333",
  "#CC3366",
  "#CC3399",
  "#CC33CC",
  "#CC33FF",
  "#CC6600",
  "#CC6633",
  "#CC9900",
  "#CC9933",
  "#CCCC00",
  "#CCCC33",
  "#FF0000",
  "#FF0033",
  "#FF0066",
  "#FF0099",
  "#FF00CC",
  "#FF00FF",
  "#FF3300",
  "#FF3333",
  "#FF3366",
  "#FF3399",
  "#FF33CC",
  "#FF33FF",
  "#FF6600",
  "#FF6633",
  "#FF9900",
  "#FF9933",
  "#FFCC00",
  "#FFCC33"
];
function r() {
  return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
function i(u) {
  if (u[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + u[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
    return;
  const l = "color: " + this.color;
  u.splice(1, 0, l, "color: inherit");
  let c = 0, f = 0;
  u[0].replace(/%[a-zA-Z%]/g, (p) => {
    p !== "%%" && (c++, p === "%c" && (f = c));
  }), u.splice(f, 0, l);
}
t.log = console.debug || console.log || (() => {
});
function s(u) {
  try {
    u ? t.storage.setItem("debug", u) : t.storage.removeItem("debug");
  } catch {
  }
}
function n() {
  let u;
  try {
    u = t.storage.getItem("debug");
  } catch {
  }
  return !u && typeof process < "u" && "env" in process && (u = process.env.DEBUG), u;
}
function a() {
  try {
    return localStorage;
  } catch {
  }
}
e.exports = Y3(t);
const { formatters: o } = e.exports;
o.j = function(u) {
  try {
    return JSON.stringify(u);
  } catch (l) {
    return "[UnexpectedJSONParseError]: " + l.message;
  }
};
})(Rn, Rn.exports);
var X3 = Rn.exports, Wr = {}, Jr = {}, Oa = {};
Object.defineProperty(Oa, "__esModule", {
value: !0
});
Oa.default = Q3;
var H3 = Ce();
const {
cloneNode: un,
exportNamedDeclaration: gu,
exportSpecifier: Su,
identifier: ln,
variableDeclaration: G3,
variableDeclarator: z3
} = H3;
function Q3(e) {
if (!e.isExportDeclaration() || e.isExportAllDeclaration())
  throw new Error("Only default and named export declarations can be split.");
if (e.isExportDefaultDeclaration()) {
  const n = e.get("declaration"), a = n.isFunctionDeclaration() || n.isClassDeclaration(), o = n.isFunctionExpression() || n.isClassExpression(), u = n.isScope() ? n.scope.parent : n.scope;
  let l = n.node.id, c = !1;
  l ? o && u.hasBinding(l.name) && (c = !0, l = u.generateUidIdentifier(l.name)) : (c = !0, l = u.generateUidIdentifier("default"), (a || o) && (n.node.id = un(l)));
  const f = a ? n.node : G3("var", [z3(un(l), n.node)]), p = gu(null, [Su(un(l), ln("default"))]);
  return e.insertAfter(p), e.replaceWith(f), c && u.registerDeclaration(e), e;
} else if (e.get("specifiers").length > 0)
  throw new Error("It doesn't make sense to split exported specifiers.");
const t = e.get("declaration"), r = t.getOuterBindingIdentifiers(), i = Object.keys(r).map((n) => Su(ln(n), ln(n))), s = gu(null, i);
return e.insertAfter(s), e.replaceWith(t.node), e;
}
var xr = {};
Object.defineProperty(xr, "__esModule", {
value: !0
});
xr.default = void 0;
xr.requeueComputedKeyAndDecorators = Un;
xr.skipAllButComputedKey = function(t) {
t.skip(), t.node.computed && t.context.maybeQueue(t.get("key"));
};
function Un(e) {
const {
  context: t,
  node: r
} = e;
if (r.computed && t.maybeQueue(e.get("key")), r.decorators)
  for (const i of e.get("decorators"))
    t.maybeQueue(i);
}
const Z3 = {
FunctionParent(e) {
  e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && Un(e));
},
Property(e) {
  e.isObjectProperty() || (e.skip(), Un(e));
}
};
xr.default = Z3;
var xu;
function eI() {
if (xu) return Jr;
xu = 1, Object.defineProperty(Jr, "__esModule", {
  value: !0
}), Jr.default = void 0;
var e = Oa, t = Ce(), r = xr, i = lo(), s = zt;
const n = {
  ReferencedIdentifier({
    node: o
  }, u) {
    o.name === u.oldName && (o.name = u.newName);
  },
  Scope(o, u) {
    o.scope.bindingIdentifierEquals(u.oldName, u.binding.identifier) || (o.skip(), o.isMethod() && (0, r.requeueComputedKeyAndDecorators)(o));
  },
  ObjectProperty({
    node: o,
    scope: u
  }, l) {
    const {
      name: c
    } = o.key;
    if (o.shorthand && (c === l.oldName || c === l.newName) && u.getBindingIdentifier(c) === l.binding.identifier) {
      o.shorthand = !1;
      {
        var f;
        (f = o.extra) != null && f.shorthand && (o.extra.shorthand = !1);
      }
    }
  },
  "AssignmentExpression|Declaration|VariableDeclarator"(o, u) {
    if (o.isVariableDeclaration()) return;
    const l = o.getOuterBindingIdentifiers();
    for (const c in l)
      c === u.oldName && (l[c].name = u.newName);
  }
};
class a {
  constructor(u, l, c) {
    this.newName = c, this.oldName = l, this.binding = u;
  }
  maybeConvertFromExportDeclaration(u) {
    const l = u.parentPath;
    if (l.isExportDeclaration()) {
      if (l.isExportDefaultDeclaration()) {
        const {
          declaration: c
        } = l.node;
        if (t.isDeclaration(c) && !c.id)
          return;
      }
      l.isExportAllDeclaration() || (0, e.default)(l);
    }
  }
  maybeConvertFromClassFunctionDeclaration(u) {
    return u;
  }
  maybeConvertFromClassFunctionExpression(u) {
    return u;
  }
  rename() {
    const {
      binding: u,
      oldName: l,
      newName: c
    } = this, {
      scope: f,
      path: p
    } = u, h = p.find((g) => g.isDeclaration() || g.isFunctionExpression() || g.isClassExpression());
    h && h.getOuterBindingIdentifiers()[l] === u.identifier && this.maybeConvertFromExportDeclaration(h);
    const y = arguments[0] || f.block;
    (0, i.traverseNode)(y, (0, s.explode)(n), f, this, f.path, {
      discriminant: !0
    }), arguments[0] || (f.removeOwnBinding(l), f.bindings[c] = u, this.binding.identifier.name = c), h && (this.maybeConvertFromClassFunctionDeclaration(p), this.maybeConvertFromClassFunctionExpression(p));
  }
}
return Jr.default = a, Jr;
}
var Ls = {};
Object.defineProperty(Ls, "__esModule", {
value: !0
});
Ls.default = void 0;
class tI {
constructor({
  identifier: t,
  scope: r,
  path: i,
  kind: s
}) {
  this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = t, this.scope = r, this.path = i, this.kind = s, (s === "var" || s === "hoisted") && rI(i) && this.reassign(i), this.clearValue();
}
deoptValue() {
  this.clearValue(), this.hasDeoptedValue = !0;
}
setValue(t) {
  this.hasDeoptedValue || (this.hasValue = !0, this.value = t);
}
clearValue() {
  this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
}
reassign(t) {
  this.constant = !1, !this.constantViolations.includes(t) && this.constantViolations.push(t);
}
reference(t) {
  this.referencePaths.includes(t) || (this.referenced = !0, this.references++, this.referencePaths.push(t));
}
dereference() {
  this.references--, this.referenced = !!this.references;
}
}
Ls.default = tI;
function rI(e) {
for (let {
  parentPath: t,
  key: r
} = e; t; {
  parentPath: t,
  key: r
} = t) {
  if (t.isFunctionParent()) return !1;
  if (t.isWhile() || t.isForXStatement() || t.isForStatement() && r === "body")
    return !0;
}
return !1;
}
const iI = {
Array: !1,
ArrayBuffer: !1,
Atomics: !1,
BigInt: !1,
BigInt64Array: !1,
BigUint64Array: !1,
Boolean: !1,
constructor: !1,
DataView: !1,
Date: !1,
decodeURI: !1,
decodeURIComponent: !1,
encodeURI: !1,
encodeURIComponent: !1,
Error: !1,
escape: !1,
eval: !1,
EvalError: !1,
Float32Array: !1,
Float64Array: !1,
Function: !1,
globalThis: !1,
hasOwnProperty: !1,
Infinity: !1,
Int16Array: !1,
Int32Array: !1,
Int8Array: !1,
isFinite: !1,
isNaN: !1,
isPrototypeOf: !1,
JSON: !1,
Map: !1,
Math: !1,
NaN: !1,
Number: !1,
Object: !1,
parseFloat: !1,
parseInt: !1,
Promise: !1,
propertyIsEnumerable: !1,
Proxy: !1,
RangeError: !1,
ReferenceError: !1,
Reflect: !1,
RegExp: !1,
Set: !1,
SharedArrayBuffer: !1,
String: !1,
Symbol: !1,
SyntaxError: !1,
toLocaleString: !1,
toString: !1,
TypeError: !1,
Uint16Array: !1,
Uint32Array: !1,
Uint8Array: !1,
Uint8ClampedArray: !1,
undefined: !1,
unescape: !1,
URIError: !1,
valueOf: !1,
WeakMap: !1,
WeakSet: !1
}, sI = {
Array: !1,
Boolean: !1,
constructor: !1,
Date: !1,
decodeURI: !1,
decodeURIComponent: !1,
encodeURI: !1,
encodeURIComponent: !1,
Error: !1,
escape: !1,
eval: !1,
EvalError: !1,
Function: !1,
hasOwnProperty: !1,
Infinity: !1,
isFinite: !1,
isNaN: !1,
isPrototypeOf: !1,
JSON: !1,
Math: !1,
NaN: !1,
Number: !1,
Object: !1,
parseFloat: !1,
parseInt: !1,
propertyIsEnumerable: !1,
RangeError: !1,
ReferenceError: !1,
RegExp: !1,
String: !1,
SyntaxError: !1,
toLocaleString: !1,
toString: !1,
TypeError: !1,
undefined: !1,
unescape: !1,
URIError: !1,
valueOf: !1
}, nI = {
Array: !1,
ArrayBuffer: !1,
Boolean: !1,
constructor: !1,
DataView: !1,
Date: !1,
decodeURI: !1,
decodeURIComponent: !1,
encodeURI: !1,
encodeURIComponent: !1,
Error: !1,
escape: !1,
eval: !1,
EvalError: !1,
Float32Array: !1,
Float64Array: !1,
Function: !1,
hasOwnProperty: !1,
Infinity: !1,
Int16Array: !1,
Int32Array: !1,
Int8Array: !1,
isFinite: !1,
isNaN: !1,
isPrototypeOf: !1,
JSON: !1,
Map: !1,
Math: !1,
NaN: !1,
Number: !1,
Object: !1,
parseFloat: !1,
parseInt: !1,
Promise: !1,
propertyIsEnumerable: !1,
Proxy: !1,
RangeError: !1,
ReferenceError: !1,
Reflect: !1,
RegExp: !1,
Set: !1,
String: !1,
Symbol: !1,
SyntaxError: !1,
toLocaleString: !1,
toString: !1,
TypeError: !1,
Uint16Array: !1,
Uint32Array: !1,
Uint8Array: !1,
Uint8ClampedArray: !1,
undefined: !1,
unescape: !1,
URIError: !1,
valueOf: !1,
WeakMap: !1,
WeakSet: !1
}, aI = {
Array: !1,
ArrayBuffer: !1,
Atomics: !1,
Boolean: !1,
constructor: !1,
DataView: !1,
Date: !1,
decodeURI: !1,
decodeURIComponent: !1,
encodeURI: !1,
encodeURIComponent: !1,
Error: !1,
escape: !1,
eval: !1,
EvalError: !1,
Float32Array: !1,
Float64Array: !1,
Function: !1,
hasOwnProperty: !1,
Infinity: !1,
Int16Array: !1,
Int32Array: !1,
Int8Array: !1,
isFinite: !1,
isNaN: !1,
isPrototypeOf: !1,
JSON: !1,
Map: !1,
Math: !1,
NaN: !1,
Number: !1,
Object: !1,
parseFloat: !1,
parseInt: !1,
Promise: !1,
propertyIsEnumerable: !1,
Proxy: !1,
RangeError: !1,
ReferenceError: !1,
Reflect: !1,
RegExp: !1,
Set: !1,
SharedArrayBuffer: !1,
String: !1,
Symbol: !1,
SyntaxError: !1,
toLocaleString: !1,
toString: !1,
TypeError: !1,
Uint16Array: !1,
Uint32Array: !1,
Uint8Array: !1,
Uint8ClampedArray: !1,
undefined: !1,
unescape: !1,
URIError: !1,
valueOf: !1,
WeakMap: !1,
WeakSet: !1
}, oI = {
AbortController: !1,
AbortSignal: !1,
addEventListener: !1,
alert: !1,
AnalyserNode: !1,
Animation: !1,
AnimationEffectReadOnly: !1,
AnimationEffectTiming: !1,
AnimationEffectTimingReadOnly: !1,
AnimationEvent: !1,
AnimationPlaybackEvent: !1,
AnimationTimeline: !1,
applicationCache: !1,
ApplicationCache: !1,
ApplicationCacheErrorEvent: !1,
atob: !1,
Attr: !1,
Audio: !1,
AudioBuffer: !1,
AudioBufferSourceNode: !1,
AudioContext: !1,
AudioDestinationNode: !1,
AudioListener: !1,
AudioNode: !1,
AudioParam: !1,
AudioProcessingEvent: !1,
AudioScheduledSourceNode: !1,
"AudioWorkletGlobalScope ": !1,
AudioWorkletNode: !1,
AudioWorkletProcessor: !1,
BarProp: !1,
BaseAudioContext: !1,
BatteryManager: !1,
BeforeUnloadEvent: !1,
BiquadFilterNode: !1,
Blob: !1,
BlobEvent: !1,
blur: !1,
BroadcastChannel: !1,
btoa: !1,
BudgetService: !1,
ByteLengthQueuingStrategy: !1,
Cache: !1,
caches: !1,
CacheStorage: !1,
cancelAnimationFrame: !1,
cancelIdleCallback: !1,
CanvasCaptureMediaStreamTrack: !1,
CanvasGradient: !1,
CanvasPattern: !1,
CanvasRenderingContext2D: !1,
ChannelMergerNode: !1,
ChannelSplitterNode: !1,
CharacterData: !1,
clearInterval: !1,
clearTimeout: !1,
clientInformation: !1,
ClipboardEvent: !1,
close: !1,
closed: !1,
CloseEvent: !1,
Comment: !1,
CompositionEvent: !1,
confirm: !1,
console: !1,
ConstantSourceNode: !1,
ConvolverNode: !1,
CountQueuingStrategy: !1,
createImageBitmap: !1,
Credential: !1,
CredentialsContainer: !1,
crypto: !1,
Crypto: !1,
CryptoKey: !1,
CSS: !1,
CSSConditionRule: !1,
CSSFontFaceRule: !1,
CSSGroupingRule: !1,
CSSImportRule: !1,
CSSKeyframeRule: !1,
CSSKeyframesRule: !1,
CSSMediaRule: !1,
CSSNamespaceRule: !1,
CSSPageRule: !1,
CSSRule: !1,
CSSRuleList: !1,
CSSStyleDeclaration: !1,
CSSStyleRule: !1,
CSSStyleSheet: !1,
CSSSupportsRule: !1,
CustomElementRegistry: !1,
customElements: !1,
CustomEvent: !1,
DataTransfer: !1,
DataTransferItem: !1,
DataTransferItemList: !1,
defaultstatus: !1,
defaultStatus: !1,
DelayNode: !1,
DeviceMotionEvent: !1,
DeviceOrientationEvent: !1,
devicePixelRatio: !1,
dispatchEvent: !1,
document: !1,
Document: !1,
DocumentFragment: !1,
DocumentType: !1,
DOMError: !1,
DOMException: !1,
DOMImplementation: !1,
DOMMatrix: !1,
DOMMatrixReadOnly: !1,
DOMParser: !1,
DOMPoint: !1,
DOMPointReadOnly: !1,
DOMQuad: !1,
DOMRect: !1,
DOMRectReadOnly: !1,
DOMStringList: !1,
DOMStringMap: !1,
DOMTokenList: !1,
DragEvent: !1,
DynamicsCompressorNode: !1,
Element: !1,
ErrorEvent: !1,
event: !1,
Event: !1,
EventSource: !1,
EventTarget: !1,
external: !1,
fetch: !1,
File: !1,
FileList: !1,
FileReader: !1,
find: !1,
focus: !1,
FocusEvent: !1,
FontFace: !1,
FontFaceSetLoadEvent: !1,
FormData: !1,
frameElement: !1,
frames: !1,
GainNode: !1,
Gamepad: !1,
GamepadButton: !1,
GamepadEvent: !1,
getComputedStyle: !1,
getSelection: !1,
HashChangeEvent: !1,
Headers: !1,
history: !1,
History: !1,
HTMLAllCollection: !1,
HTMLAnchorElement: !1,
HTMLAreaElement: !1,
HTMLAudioElement: !1,
HTMLBaseElement: !1,
HTMLBodyElement: !1,
HTMLBRElement: !1,
HTMLButtonElement: !1,
HTMLCanvasElement: !1,
HTMLCollection: !1,
HTMLContentElement: !1,
HTMLDataElement: !1,
HTMLDataListElement: !1,
HTMLDetailsElement: !1,
HTMLDialogElement: !1,
HTMLDirectoryElement: !1,
HTMLDivElement: !1,
HTMLDListElement: !1,
HTMLDocument: !1,
HTMLElement: !1,
HTMLEmbedElement: !1,
HTMLFieldSetElement: !1,
HTMLFontElement: !1,
HTMLFormControlsCollection: !1,
HTMLFormElement: !1,
HTMLFrameElement: !1,
HTMLFrameSetElement: !1,
HTMLHeadElement: !1,
HTMLHeadingElement: !1,
HTMLHRElement: !1,
HTMLHtmlElement: !1,
HTMLIFrameElement: !1,
HTMLImageElement: !1,
HTMLInputElement: !1,
HTMLLabelElement: !1,
HTMLLegendElement: !1,
HTMLLIElement: !1,
HTMLLinkElement: !1,
HTMLMapElement: !1,
HTMLMarqueeElement: !1,
HTMLMediaElement: !1,
HTMLMenuElement: !1,
HTMLMetaElement: !1,
HTMLMeterElement: !1,
HTMLModElement: !1,
HTMLObjectElement: !1,
HTMLOListElement: !1,
HTMLOptGroupElement: !1,
HTMLOptionElement: !1,
HTMLOptionsCollection: !1,
HTMLOutputElement: !1,
HTMLParagraphElement: !1,
HTMLParamElement: !1,
HTMLPictureElement: !1,
HTMLPreElement: !1,
HTMLProgressElement: !1,
HTMLQuoteElement: !1,
HTMLScriptElement: !1,
HTMLSelectElement: !1,
HTMLShadowElement: !1,
HTMLSlotElement: !1,
HTMLSourceElement: !1,
HTMLSpanElement: !1,
HTMLStyleElement: !1,
HTMLTableCaptionElement: !1,
HTMLTableCellElement: !1,
HTMLTableColElement: !1,
HTMLTableElement: !1,
HTMLTableRowElement: !1,
HTMLTableSectionElement: !1,
HTMLTemplateElement: !1,
HTMLTextAreaElement: !1,
HTMLTimeElement: !1,
HTMLTitleElement: !1,
HTMLTrackElement: !1,
HTMLUListElement: !1,
HTMLUnknownElement: !1,
HTMLVideoElement: !1,
IDBCursor: !1,
IDBCursorWithValue: !1,
IDBDatabase: !1,
IDBFactory: !1,
IDBIndex: !1,
IDBKeyRange: !1,
IDBObjectStore: !1,
IDBOpenDBRequest: !1,
IDBRequest: !1,
IDBTransaction: !1,
IDBVersionChangeEvent: !1,
IdleDeadline: !1,
IIRFilterNode: !1,
Image: !1,
ImageBitmap: !1,
ImageBitmapRenderingContext: !1,
ImageCapture: !1,
ImageData: !1,
indexedDB: !1,
innerHeight: !1,
innerWidth: !1,
InputEvent: !1,
IntersectionObserver: !1,
IntersectionObserverEntry: !1,
Intl: !1,
isSecureContext: !1,
KeyboardEvent: !1,
KeyframeEffect: !1,
KeyframeEffectReadOnly: !1,
length: !1,
localStorage: !1,
location: !0,
Location: !1,
locationbar: !1,
matchMedia: !1,
MediaDeviceInfo: !1,
MediaDevices: !1,
MediaElementAudioSourceNode: !1,
MediaEncryptedEvent: !1,
MediaError: !1,
MediaKeyMessageEvent: !1,
MediaKeySession: !1,
MediaKeyStatusMap: !1,
MediaKeySystemAccess: !1,
MediaList: !1,
MediaQueryList: !1,
MediaQueryListEvent: !1,
MediaRecorder: !1,
MediaSettingsRange: !1,
MediaSource: !1,
MediaStream: !1,
MediaStreamAudioDestinationNode: !1,
MediaStreamAudioSourceNode: !1,
MediaStreamEvent: !1,
MediaStreamTrack: !1,
MediaStreamTrackEvent: !1,
menubar: !1,
MessageChannel: !1,
MessageEvent: !1,
MessagePort: !1,
MIDIAccess: !1,
MIDIConnectionEvent: !1,
MIDIInput: !1,
MIDIInputMap: !1,
MIDIMessageEvent: !1,
MIDIOutput: !1,
MIDIOutputMap: !1,
MIDIPort: !1,
MimeType: !1,
MimeTypeArray: !1,
MouseEvent: !1,
moveBy: !1,
moveTo: !1,
MutationEvent: !1,
MutationObserver: !1,
MutationRecord: !1,
name: !1,
NamedNodeMap: !1,
NavigationPreloadManager: !1,
navigator: !1,
Navigator: !1,
NetworkInformation: !1,
Node: !1,
NodeFilter: !1,
NodeIterator: !1,
NodeList: !1,
Notification: !1,
OfflineAudioCompletionEvent: !1,
OfflineAudioContext: !1,
offscreenBuffering: !1,
OffscreenCanvas: !0,
onabort: !0,
onafterprint: !0,
onanimationend: !0,
onanimationiteration: !0,
onanimationstart: !0,
onappinstalled: !0,
onauxclick: !0,
onbeforeinstallprompt: !0,
onbeforeprint: !0,
onbeforeunload: !0,
onblur: !0,
oncancel: !0,
oncanplay: !0,
oncanplaythrough: !0,
onchange: !0,
onclick: !0,
onclose: !0,
oncontextmenu: !0,
oncuechange: !0,
ondblclick: !0,
ondevicemotion: !0,
ondeviceorientation: !0,
ondeviceorientationabsolute: !0,
ondrag: !0,
ondragend: !0,
ondragenter: !0,
ondragleave: !0,
ondragover: !0,
ondragstart: !0,
ondrop: !0,
ondurationchange: !0,
onemptied: !0,
onended: !0,
onerror: !0,
onfocus: !0,
ongotpointercapture: !0,
onhashchange: !0,
oninput: !0,
oninvalid: !0,
onkeydown: !0,
onkeypress: !0,
onkeyup: !0,
onlanguagechange: !0,
onload: !0,
onloadeddata: !0,
onloadedmetadata: !0,
onloadstart: !0,
onlostpointercapture: !0,
onmessage: !0,
onmessageerror: !0,
onmousedown: !0,
onmouseenter: !0,
onmouseleave: !0,
onmousemove: !0,
onmouseout: !0,
onmouseover: !0,
onmouseup: !0,
onmousewheel: !0,
onoffline: !0,
ononline: !0,
onpagehide: !0,
onpageshow: !0,
onpause: !0,
onplay: !0,
onplaying: !0,
onpointercancel: !0,
onpointerdown: !0,
onpointerenter: !0,
onpointerleave: !0,
onpointermove: !0,
onpointerout: !0,
onpointerover: !0,
onpointerup: !0,
onpopstate: !0,
onprogress: !0,
onratechange: !0,
onrejectionhandled: !0,
onreset: !0,
onresize: !0,
onscroll: !0,
onsearch: !0,
onseeked: !0,
onseeking: !0,
onselect: !0,
onstalled: !0,
onstorage: !0,
onsubmit: !0,
onsuspend: !0,
ontimeupdate: !0,
ontoggle: !0,
ontransitionend: !0,
onunhandledrejection: !0,
onunload: !0,
onvolumechange: !0,
onwaiting: !0,
onwheel: !0,
open: !1,
openDatabase: !1,
opener: !1,
Option: !1,
origin: !1,
OscillatorNode: !1,
outerHeight: !1,
outerWidth: !1,
PageTransitionEvent: !1,
pageXOffset: !1,
pageYOffset: !1,
PannerNode: !1,
parent: !1,
Path2D: !1,
PaymentAddress: !1,
PaymentRequest: !1,
PaymentRequestUpdateEvent: !1,
PaymentResponse: !1,
performance: !1,
Performance: !1,
PerformanceEntry: !1,
PerformanceLongTaskTiming: !1,
PerformanceMark: !1,
PerformanceMeasure: !1,
PerformanceNavigation: !1,
PerformanceNavigationTiming: !1,
PerformanceObserver: !1,
PerformanceObserverEntryList: !1,
PerformancePaintTiming: !1,
PerformanceResourceTiming: !1,
PerformanceTiming: !1,
PeriodicWave: !1,
Permissions: !1,
PermissionStatus: !1,
personalbar: !1,
PhotoCapabilities: !1,
Plugin: !1,
PluginArray: !1,
PointerEvent: !1,
PopStateEvent: !1,
postMessage: !1,
Presentation: !1,
PresentationAvailability: !1,
PresentationConnection: !1,
PresentationConnectionAvailableEvent: !1,
PresentationConnectionCloseEvent: !1,
PresentationConnectionList: !1,
PresentationReceiver: !1,
PresentationRequest: !1,
print: !1,
ProcessingInstruction: !1,
ProgressEvent: !1,
PromiseRejectionEvent: !1,
prompt: !1,
PushManager: !1,
PushSubscription: !1,
PushSubscriptionOptions: !1,
queueMicrotask: !1,
RadioNodeList: !1,
Range: !1,
ReadableStream: !1,
registerProcessor: !1,
RemotePlayback: !1,
removeEventListener: !1,
Request: !1,
requestAnimationFrame: !1,
requestIdleCallback: !1,
resizeBy: !1,
ResizeObserver: !1,
ResizeObserverEntry: !1,
resizeTo: !1,
Response: !1,
RTCCertificate: !1,
RTCDataChannel: !1,
RTCDataChannelEvent: !1,
RTCDtlsTransport: !1,
RTCIceCandidate: !1,
RTCIceGatherer: !1,
RTCIceTransport: !1,
RTCPeerConnection: !1,
RTCPeerConnectionIceEvent: !1,
RTCRtpContributingSource: !1,
RTCRtpReceiver: !1,
RTCRtpSender: !1,
RTCSctpTransport: !1,
RTCSessionDescription: !1,
RTCStatsReport: !1,
RTCTrackEvent: !1,
screen: !1,
Screen: !1,
screenLeft: !1,
ScreenOrientation: !1,
screenTop: !1,
screenX: !1,
screenY: !1,
ScriptProcessorNode: !1,
scroll: !1,
scrollbars: !1,
scrollBy: !1,
scrollTo: !1,
scrollX: !1,
scrollY: !1,
SecurityPolicyViolationEvent: !1,
Selection: !1,
self: !1,
ServiceWorker: !1,
ServiceWorkerContainer: !1,
ServiceWorkerRegistration: !1,
sessionStorage: !1,
setInterval: !1,
setTimeout: !1,
ShadowRoot: !1,
SharedWorker: !1,
SourceBuffer: !1,
SourceBufferList: !1,
speechSynthesis: !1,
SpeechSynthesisEvent: !1,
SpeechSynthesisUtterance: !1,
StaticRange: !1,
status: !1,
statusbar: !1,
StereoPannerNode: !1,
stop: !1,
Storage: !1,
StorageEvent: !1,
StorageManager: !1,
styleMedia: !1,
StyleSheet: !1,
StyleSheetList: !1,
SubtleCrypto: !1,
SVGAElement: !1,
SVGAngle: !1,
SVGAnimatedAngle: !1,
SVGAnimatedBoolean: !1,
SVGAnimatedEnumeration: !1,
SVGAnimatedInteger: !1,
SVGAnimatedLength: !1,
SVGAnimatedLengthList: !1,
SVGAnimatedNumber: !1,
SVGAnimatedNumberList: !1,
SVGAnimatedPreserveAspectRatio: !1,
SVGAnimatedRect: !1,
SVGAnimatedString: !1,
SVGAnimatedTransformList: !1,
SVGAnimateElement: !1,
SVGAnimateMotionElement: !1,
SVGAnimateTransformElement: !1,
SVGAnimationElement: !1,
SVGCircleElement: !1,
SVGClipPathElement: !1,
SVGComponentTransferFunctionElement: !1,
SVGDefsElement: !1,
SVGDescElement: !1,
SVGDiscardElement: !1,
SVGElement: !1,
SVGEllipseElement: !1,
SVGFEBlendElement: !1,
SVGFEColorMatrixElement: !1,
SVGFEComponentTransferElement: !1,
SVGFECompositeElement: !1,
SVGFEConvolveMatrixElement: !1,
SVGFEDiffuseLightingElement: !1,
SVGFEDisplacementMapElement: !1,
SVGFEDistantLightElement: !1,
SVGFEDropShadowElement: !1,
SVGFEFloodElement: !1,
SVGFEFuncAElement: !1,
SVGFEFuncBElement: !1,
SVGFEFuncGElement: !1,
SVGFEFuncRElement: !1,
SVGFEGaussianBlurElement: !1,
SVGFEImageElement: !1,
SVGFEMergeElement: !1,
SVGFEMergeNodeElement: !1,
SVGFEMorphologyElement: !1,
SVGFEOffsetElement: !1,
SVGFEPointLightElement: !1,
SVGFESpecularLightingElement: !1,
SVGFESpotLightElement: !1,
SVGFETileElement: !1,
SVGFETurbulenceElement: !1,
SVGFilterElement: !1,
SVGForeignObjectElement: !1,
SVGGElement: !1,
SVGGeometryElement: !1,
SVGGradientElement: !1,
SVGGraphicsElement: !1,
SVGImageElement: !1,
SVGLength: !1,
SVGLengthList: !1,
SVGLinearGradientElement: !1,
SVGLineElement: !1,
SVGMarkerElement: !1,
SVGMaskElement: !1,
SVGMatrix: !1,
SVGMetadataElement: !1,
SVGMPathElement: !1,
SVGNumber: !1,
SVGNumberList: !1,
SVGPathElement: !1,
SVGPatternElement: !1,
SVGPoint: !1,
SVGPointList: !1,
SVGPolygonElement: !1,
SVGPolylineElement: !1,
SVGPreserveAspectRatio: !1,
SVGRadialGradientElement: !1,
SVGRect: !1,
SVGRectElement: !1,
SVGScriptElement: !1,
SVGSetElement: !1,
SVGStopElement: !1,
SVGStringList: !1,
SVGStyleElement: !1,
SVGSVGElement: !1,
SVGSwitchElement: !1,
SVGSymbolElement: !1,
SVGTextContentElement: !1,
SVGTextElement: !1,
SVGTextPathElement: !1,
SVGTextPositioningElement: !1,
SVGTitleElement: !1,
SVGTransform: !1,
SVGTransformList: !1,
SVGTSpanElement: !1,
SVGUnitTypes: !1,
SVGUseElement: !1,
SVGViewElement: !1,
TaskAttributionTiming: !1,
Text: !1,
TextDecoder: !1,
TextEncoder: !1,
TextEvent: !1,
TextMetrics: !1,
TextTrack: !1,
TextTrackCue: !1,
TextTrackCueList: !1,
TextTrackList: !1,
TimeRanges: !1,
toolbar: !1,
top: !1,
Touch: !1,
TouchEvent: !1,
TouchList: !1,
TrackEvent: !1,
TransitionEvent: !1,
TreeWalker: !1,
UIEvent: !1,
URL: !1,
URLSearchParams: !1,
ValidityState: !1,
visualViewport: !1,
VisualViewport: !1,
VTTCue: !1,
WaveShaperNode: !1,
WebAssembly: !1,
WebGL2RenderingContext: !1,
WebGLActiveInfo: !1,
WebGLBuffer: !1,
WebGLContextEvent: !1,
WebGLFramebuffer: !1,
WebGLProgram: !1,
WebGLQuery: !1,
WebGLRenderbuffer: !1,
WebGLRenderingContext: !1,
WebGLSampler: !1,
WebGLShader: !1,
WebGLShaderPrecisionFormat: !1,
WebGLSync: !1,
WebGLTexture: !1,
WebGLTransformFeedback: !1,
WebGLUniformLocation: !1,
WebGLVertexArrayObject: !1,
WebSocket: !1,
WheelEvent: !1,
window: !1,
Window: !1,
Worker: !1,
WritableStream: !1,
XMLDocument: !1,
XMLHttpRequest: !1,
XMLHttpRequestEventTarget: !1,
XMLHttpRequestUpload: !1,
XMLSerializer: !1,
XPathEvaluator: !1,
XPathExpression: !1,
XPathResult: !1,
XSLTProcessor: !1
}, uI = {
addEventListener: !1,
applicationCache: !1,
atob: !1,
Blob: !1,
BroadcastChannel: !1,
btoa: !1,
Cache: !1,
caches: !1,
clearInterval: !1,
clearTimeout: !1,
close: !0,
console: !1,
fetch: !1,
FileReaderSync: !1,
FormData: !1,
Headers: !1,
IDBCursor: !1,
IDBCursorWithValue: !1,
IDBDatabase: !1,
IDBFactory: !1,
IDBIndex: !1,
IDBKeyRange: !1,
IDBObjectStore: !1,
IDBOpenDBRequest: !1,
IDBRequest: !1,
IDBTransaction: !1,
IDBVersionChangeEvent: !1,
ImageData: !1,
importScripts: !0,
indexedDB: !1,
location: !1,
MessageChannel: !1,
MessagePort: !1,
name: !1,
navigator: !1,
Notification: !1,
onclose: !0,
onconnect: !0,
onerror: !0,
onlanguagechange: !0,
onmessage: !0,
onoffline: !0,
ononline: !0,
onrejectionhandled: !0,
onunhandledrejection: !0,
performance: !1,
Performance: !1,
PerformanceEntry: !1,
PerformanceMark: !1,
PerformanceMeasure: !1,
PerformanceNavigation: !1,
PerformanceResourceTiming: !1,
PerformanceTiming: !1,
postMessage: !0,
Promise: !1,
queueMicrotask: !1,
removeEventListener: !1,
Request: !1,
Response: !1,
self: !0,
ServiceWorkerRegistration: !1,
setInterval: !1,
setTimeout: !1,
TextDecoder: !1,
TextEncoder: !1,
URL: !1,
URLSearchParams: !1,
WebSocket: !1,
Worker: !1,
WorkerGlobalScope: !1,
XMLHttpRequest: !1
}, lI = {
__dirname: !1,
__filename: !1,
Buffer: !1,
clearImmediate: !1,
clearInterval: !1,
clearTimeout: !1,
console: !1,
exports: !0,
global: !1,
Intl: !1,
module: !1,
process: !1,
queueMicrotask: !1,
require: !1,
setImmediate: !1,
setInterval: !1,
setTimeout: !1,
TextDecoder: !1,
TextEncoder: !1,
URL: !1,
URLSearchParams: !1
}, cI = {
exports: !0,
global: !1,
module: !1,
require: !1
}, fI = {
define: !1,
require: !1
}, pI = {
after: !1,
afterEach: !1,
before: !1,
beforeEach: !1,
context: !1,
describe: !1,
it: !1,
mocha: !1,
run: !1,
setup: !1,
specify: !1,
suite: !1,
suiteSetup: !1,
suiteTeardown: !1,
teardown: !1,
test: !1,
xcontext: !1,
xdescribe: !1,
xit: !1,
xspecify: !1
}, hI = {
afterAll: !1,
afterEach: !1,
beforeAll: !1,
beforeEach: !1,
describe: !1,
expect: !1,
fail: !1,
fdescribe: !1,
fit: !1,
it: !1,
jasmine: !1,
pending: !1,
runs: !1,
spyOn: !1,
spyOnProperty: !1,
waits: !1,
waitsFor: !1,
xdescribe: !1,
xit: !1
}, dI = {
afterAll: !1,
afterEach: !1,
beforeAll: !1,
beforeEach: !1,
describe: !1,
expect: !1,
fdescribe: !1,
fit: !1,
it: !1,
jest: !1,
pit: !1,
require: !1,
test: !1,
xdescribe: !1,
xit: !1,
xtest: !1
}, mI = {
asyncTest: !1,
deepEqual: !1,
equal: !1,
expect: !1,
module: !1,
notDeepEqual: !1,
notEqual: !1,
notOk: !1,
notPropEqual: !1,
notStrictEqual: !1,
ok: !1,
propEqual: !1,
QUnit: !1,
raises: !1,
start: !1,
stop: !1,
strictEqual: !1,
test: !1,
throws: !1
}, yI = {
console: !0,
exports: !0,
phantom: !0,
require: !0,
WebPage: !0
}, bI = {
emit: !1,
exports: !1,
getRow: !1,
log: !1,
module: !1,
provides: !1,
require: !1,
respond: !1,
send: !1,
start: !1,
sum: !1
}, TI = {
defineClass: !1,
deserialize: !1,
gc: !1,
help: !1,
importClass: !1,
importPackage: !1,
java: !1,
load: !1,
loadClass: !1,
Packages: !1,
print: !1,
quit: !1,
readFile: !1,
readUrl: !1,
runCommand: !1,
seal: !1,
serialize: !1,
spawn: !1,
sync: !1,
toint32: !1,
version: !1
}, gI = {
__DIR__: !1,
__FILE__: !1,
__LINE__: !1,
com: !1,
edu: !1,
exit: !1,
java: !1,
Java: !1,
javafx: !1,
JavaImporter: !1,
javax: !1,
JSAdapter: !1,
load: !1,
loadWithNewGlobal: !1,
org: !1,
Packages: !1,
print: !1,
quit: !1
}, SI = {
ActiveXObject: !0,
Enumerator: !0,
GetObject: !0,
ScriptEngine: !0,
ScriptEngineBuildVersion: !0,
ScriptEngineMajorVersion: !0,
ScriptEngineMinorVersion: !0,
VBArray: !0,
WScript: !0,
WSH: !0,
XDomainRequest: !0
}, xI = {
$: !1,
jQuery: !1
}, EI = {
YAHOO: !1,
YAHOO_config: !1,
YUI: !1,
YUI_config: !1
}, PI = {
cat: !1,
cd: !1,
chmod: !1,
config: !1,
cp: !1,
dirs: !1,
echo: !1,
env: !1,
error: !1,
exec: !1,
exit: !1,
find: !1,
grep: !1,
ln: !1,
ls: !1,
mkdir: !1,
mv: !1,
popd: !1,
pushd: !1,
pwd: !1,
rm: !1,
sed: !1,
set: !1,
target: !1,
tempdir: !1,
test: !1,
touch: !1,
which: !1
}, vI = {
$: !1,
$$: !1,
$A: !1,
$break: !1,
$continue: !1,
$F: !1,
$H: !1,
$R: !1,
$w: !1,
Abstract: !1,
Ajax: !1,
Autocompleter: !1,
Builder: !1,
Class: !1,
Control: !1,
Draggable: !1,
Draggables: !1,
Droppables: !1,
Effect: !1,
Element: !1,
Enumerable: !1,
Event: !1,
Field: !1,
Form: !1,
Hash: !1,
Insertion: !1,
ObjectRange: !1,
PeriodicalExecuter: !1,
Position: !1,
Prototype: !1,
Scriptaculous: !1,
Selector: !1,
Sortable: !1,
SortableObserver: !1,
Sound: !1,
Template: !1,
Toggle: !1,
Try: !1
}, AI = {
_: !1,
$: !1,
Accounts: !1,
AccountsClient: !1,
AccountsCommon: !1,
AccountsServer: !1,
App: !1,
Assets: !1,
Blaze: !1,
check: !1,
Cordova: !1,
DDP: !1,
DDPRateLimiter: !1,
DDPServer: !1,
Deps: !1,
EJSON: !1,
Email: !1,
HTTP: !1,
Log: !1,
Match: !1,
Meteor: !1,
Mongo: !1,
MongoInternals: !1,
Npm: !1,
Package: !1,
Plugin: !1,
process: !1,
Random: !1,
ReactiveDict: !1,
ReactiveVar: !1,
Router: !1,
ServiceConfiguration: !1,
Session: !1,
share: !1,
Spacebars: !1,
Template: !1,
Tinytest: !1,
Tracker: !1,
UI: !1,
Utils: !1,
WebApp: !1,
WebAppInternals: !1
}, II = {
_isWindows: !1,
_rand: !1,
BulkWriteResult: !1,
cat: !1,
cd: !1,
connect: !1,
db: !1,
getHostName: !1,
getMemInfo: !1,
hostname: !1,
ISODate: !1,
listFiles: !1,
load: !1,
ls: !1,
md5sumFile: !1,
mkdir: !1,
Mongo: !1,
NumberInt: !1,
NumberLong: !1,
ObjectId: !1,
PlanCache: !1,
print: !1,
printjson: !1,
pwd: !1,
quit: !1,
removeFile: !1,
rs: !1,
sh: !1,
UUID: !1,
version: !1,
WriteResult: !1
}, CI = {
$: !1,
Application: !1,
Automation: !1,
console: !1,
delay: !1,
Library: !1,
ObjC: !1,
ObjectSpecifier: !1,
Path: !1,
Progress: !1,
Ref: !1
}, wI = {
addEventListener: !1,
applicationCache: !1,
atob: !1,
Blob: !1,
BroadcastChannel: !1,
btoa: !1,
Cache: !1,
caches: !1,
CacheStorage: !1,
clearInterval: !1,
clearTimeout: !1,
Client: !1,
clients: !1,
Clients: !1,
close: !0,
console: !1,
ExtendableEvent: !1,
ExtendableMessageEvent: !1,
fetch: !1,
FetchEvent: !1,
FileReaderSync: !1,
FormData: !1,
Headers: !1,
IDBCursor: !1,
IDBCursorWithValue: !1,
IDBDatabase: !1,
IDBFactory: !1,
IDBIndex: !1,
IDBKeyRange: !1,
IDBObjectStore: !1,
IDBOpenDBRequest: !1,
IDBRequest: !1,
IDBTransaction: !1,
IDBVersionChangeEvent: !1,
ImageData: !1,
importScripts: !1,
indexedDB: !1,
location: !1,
MessageChannel: !1,
MessagePort: !1,
name: !1,
navigator: !1,
Notification: !1,
onclose: !0,
onconnect: !0,
onerror: !0,
onfetch: !0,
oninstall: !0,
onlanguagechange: !0,
onmessage: !0,
onmessageerror: !0,
onnotificationclick: !0,
onnotificationclose: !0,
onoffline: !0,
ononline: !0,
onpush: !0,
onpushsubscriptionchange: !0,
onrejectionhandled: !0,
onsync: !0,
onunhandledrejection: !0,
performance: !1,
Performance: !1,
PerformanceEntry: !1,
PerformanceMark: !1,
PerformanceMeasure: !1,
PerformanceNavigation: !1,
PerformanceResourceTiming: !1,
PerformanceTiming: !1,
postMessage: !0,
Promise: !1,
queueMicrotask: !1,
registration: !1,
removeEventListener: !1,
Request: !1,
Response: !1,
self: !1,
ServiceWorker: !1,
ServiceWorkerContainer: !1,
ServiceWorkerGlobalScope: !1,
ServiceWorkerMessageEvent: !1,
ServiceWorkerRegistration: !1,
setInterval: !1,
setTimeout: !1,
skipWaiting: !1,
TextDecoder: !1,
TextEncoder: !1,
URL: !1,
URLSearchParams: !1,
WebSocket: !1,
WindowClient: !1,
Worker: !1,
WorkerGlobalScope: !1,
XMLHttpRequest: !1
}, NI = {
advanceClock: !1,
fakeClearInterval: !1,
fakeClearTimeout: !1,
fakeSetInterval: !1,
fakeSetTimeout: !1,
resetTimeouts: !1,
waitsForPromise: !1
}, OI = {
andThen: !1,
click: !1,
currentPath: !1,
currentRouteName: !1,
currentURL: !1,
fillIn: !1,
find: !1,
findAll: !1,
findWithAssert: !1,
keyEvent: !1,
pauseTest: !1,
resumeTest: !1,
triggerEvent: !1,
visit: !1,
wait: !1
}, _I = {
$: !1,
$$: !1,
browser: !1,
by: !1,
By: !1,
DartObject: !1,
element: !1,
protractor: !1
}, kI = {
browser: !1,
chrome: !1,
opr: !1
}, DI = {
cloneInto: !1,
createObjectIn: !1,
exportFunction: !1,
GM: !1,
GM_addStyle: !1,
GM_deleteValue: !1,
GM_getResourceText: !1,
GM_getResourceURL: !1,
GM_getValue: !1,
GM_info: !1,
GM_listValues: !1,
GM_log: !1,
GM_openInTab: !1,
GM_registerMenuCommand: !1,
GM_setClipboard: !1,
GM_setValue: !1,
GM_xmlhttpRequest: !1,
unsafeWindow: !1
}, LI = {
$: !1,
$_: !1,
$$: !1,
$0: !1,
$1: !1,
$2: !1,
$3: !1,
$4: !1,
$x: !1,
chrome: !1,
clear: !1,
copy: !1,
debug: !1,
dir: !1,
dirxml: !1,
getEventListeners: !1,
inspect: !1,
keys: !1,
monitor: !1,
monitorEvents: !1,
profile: !1,
profileEnd: !1,
queryObjects: !1,
table: !1,
undebug: !1,
unmonitor: !1,
unmonitorEvents: !1,
values: !1
}, MI = {
builtin: iI,
es5: sI,
es2015: nI,
es2017: aI,
browser: oI,
worker: uI,
node: lI,
commonjs: cI,
amd: fI,
mocha: pI,
jasmine: hI,
jest: dI,
qunit: mI,
phantomjs: yI,
couch: bI,
rhino: TI,
nashorn: gI,
wsh: SI,
jquery: xI,
yui: EI,
shelljs: PI,
prototypejs: vI,
meteor: AI,
mongo: II,
applescript: CI,
serviceworker: wI,
atomtest: NI,
embertest: OI,
protractor: _I,
"shared-node-browser": {
  clearInterval: !1,
  clearTimeout: !1,
  console: !1,
  setInterval: !1,
  setTimeout: !1,
  URL: !1,
  URLSearchParams: !1
},
webextensions: kI,
greasemonkey: DI,
devtools: LI
};
var BI = MI, Eu;
function Ec() {
if (Eu) return Wr;
Eu = 1, Object.defineProperty(Wr, "__esModule", {
  value: !0
}), Wr.default = void 0;
var e = eI(), t = zs(), r = Ls, i = BI, s = Ce(), n = s, a = lt, o = zt;
const {
  NOT_LOCAL_BINDING: u,
  callExpression: l,
  cloneNode: c,
  getBindingIdentifiers: f,
  identifier: p,
  isArrayExpression: h,
  isBinary: y,
  isCallExpression: g,
  isClass: A,
  isClassBody: C,
  isClassDeclaration: _,
  isExportAllDeclaration: j,
  isExportDefaultDeclaration: G,
  isExportNamedDeclaration: fe,
  isFunctionDeclaration: re,
  isIdentifier: oe,
  isImportDeclaration: K,
  isLiteral: X,
  isMemberExpression: ie,
  isMethod: W,
  isModuleSpecifier: Q,
  isNullLiteral: U,
  isObjectExpression: L,
  isProperty: k,
  isPureish: F,
  isRegExpLiteral: B,
  isSuper: O,
  isTaggedTemplateExpression: D,
  isTemplateLiteral: R,
  isThisExpression: q,
  isUnaryExpression: V,
  isVariableDeclaration: H,
  matchesPattern: ne,
  memberExpression: ue,
  numericLiteral: qe,
  toIdentifier: pe,
  variableDeclaration: he,
  variableDeclarator: Ee,
  isRecordExpression: we,
  isTupleExpression: Pe,
  isObjectProperty: ke,
  isTopicReference: De,
  isMetaProperty: Je,
  isPrivateName: it,
  isExportDeclaration: ve,
  buildUndefinedNode: je
} = s;
function Ie(J, d) {
  switch (J == null ? void 0 : J.type) {
    default:
      if (K(J) || ve(J)) {
        var P;
        if ((j(J) || fe(J) || K(J)) && J.source)
          Ie(J.source, d);
        else if ((fe(J) || K(J)) && (P = J.specifiers) != null && P.length)
          for (const N of J.specifiers) Ie(N, d);
        else (G(J) || fe(J)) && J.declaration && Ie(J.declaration, d);
      } else Q(J) ? Ie(J.local, d) : X(J) && !U(J) && !B(J) && !R(J) && d.push(J.value);
      break;
    case "MemberExpression":
    case "OptionalMemberExpression":
    case "JSXMemberExpression":
      Ie(J.object, d), Ie(J.property, d);
      break;
    case "Identifier":
    case "JSXIdentifier":
      d.push(J.name);
      break;
    case "CallExpression":
    case "OptionalCallExpression":
    case "NewExpression":
      Ie(J.callee, d);
      break;
    case "ObjectExpression":
    case "ObjectPattern":
      for (const N of J.properties)
        Ie(N, d);
      break;
    case "SpreadElement":
    case "RestElement":
      Ie(J.argument, d);
      break;
    case "ObjectProperty":
    case "ObjectMethod":
    case "ClassProperty":
    case "ClassMethod":
    case "ClassPrivateProperty":
    case "ClassPrivateMethod":
      Ie(J.key, d);
      break;
    case "ThisExpression":
      d.push("this");
      break;
    case "Super":
      d.push("super");
      break;
    case "Import":
      d.push("import");
      break;
    case "DoExpression":
      d.push("do");
      break;
    case "YieldExpression":
      d.push("yield"), Ie(J.argument, d);
      break;
    case "AwaitExpression":
      d.push("await"), Ie(J.argument, d);
      break;
    case "AssignmentExpression":
      Ie(J.left, d);
      break;
    case "VariableDeclarator":
      Ie(J.id, d);
      break;
    case "FunctionExpression":
    case "FunctionDeclaration":
    case "ClassExpression":
    case "ClassDeclaration":
      Ie(J.id, d);
      break;
    case "PrivateName":
      Ie(J.id, d);
      break;
    case "ParenthesizedExpression":
      Ie(J.expression, d);
      break;
    case "UnaryExpression":
    case "UpdateExpression":
      Ie(J.argument, d);
      break;
    case "MetaProperty":
      Ie(J.meta, d), Ie(J.property, d);
      break;
    case "JSXElement":
      Ie(J.openingElement, d);
      break;
    case "JSXOpeningElement":
      Ie(J.name, d);
      break;
    case "JSXFragment":
      Ie(J.openingFragment, d);
      break;
    case "JSXOpeningFragment":
      d.push("Fragment");
      break;
    case "JSXNamespacedName":
      Ie(J.namespace, d), Ie(J.name, d);
      break;
  }
}
const Ve = {
  ForStatement(J) {
    const d = J.get("init");
    if (d.isVar()) {
      const {
        scope: P
      } = J;
      (P.getFunctionParent() || P.getProgramParent()).registerBinding("var", d);
    }
  },
  Declaration(J) {
    if (J.isBlockScoped() || J.isImportDeclaration() || J.isExportDeclaration()) return;
    (J.scope.getFunctionParent() || J.scope.getProgramParent()).registerDeclaration(J);
  },
  ImportDeclaration(J) {
    J.scope.getBlockParent().registerDeclaration(J);
  },
  ReferencedIdentifier(J, d) {
    d.references.push(J);
  },
  ForXStatement(J, d) {
    const P = J.get("left");
    if (P.isPattern() || P.isIdentifier())
      d.constantViolations.push(J);
    else if (P.isVar()) {
      const {
        scope: N
      } = J;
      (N.getFunctionParent() || N.getProgramParent()).registerBinding("var", P);
    }
  },
  ExportDeclaration: {
    exit(J) {
      const {
        node: d,
        scope: P
      } = J;
      if (j(d)) return;
      const N = d.declaration;
      if (_(N) || re(N)) {
        const M = N.id;
        if (!M) return;
        const Z = P.getBinding(M.name);
        Z == null || Z.reference(J);
      } else if (H(N))
        for (const M of N.declarations)
          for (const Z of Object.keys(f(M))) {
            const ee = P.getBinding(Z);
            ee == null || ee.reference(J);
          }
    }
  },
  LabeledStatement(J) {
    J.scope.getBlockParent().registerDeclaration(J);
  },
  AssignmentExpression(J, d) {
    d.assignments.push(J);
  },
  UpdateExpression(J, d) {
    d.constantViolations.push(J);
  },
  UnaryExpression(J, d) {
    J.node.operator === "delete" && d.constantViolations.push(J);
  },
  BlockScoped(J) {
    let d = J.scope;
    if (d.path === J && (d = d.parent), d.getBlockParent().registerDeclaration(J), J.isClassDeclaration() && J.node.id) {
      const M = J.node.id.name;
      J.scope.bindings[M] = J.scope.parent.getBinding(M);
    }
  },
  CatchClause(J) {
    J.scope.registerBinding("let", J);
  },
  Function(J) {
    const d = J.get("params");
    for (const P of d)
      J.scope.registerBinding("param", P);
    J.isFunctionExpression() && J.has("id") && !J.get("id").node[u] && J.scope.registerBinding("local", J.get("id"), J);
  },
  ClassExpression(J) {
    J.has("id") && !J.get("id").node[u] && J.scope.registerBinding("local", J.get("id"), J);
  },
  TSTypeAnnotation(J) {
    J.skip();
  }
};
let ht = 0;
class ze {
  constructor(d) {
    this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
    const {
      node: P
    } = d, N = a.scope.get(P);
    if ((N == null ? void 0 : N.path) === d)
      return N;
    a.scope.set(P, this), this.uid = ht++, this.block = P, this.path = d, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
  }
  get parent() {
    var d;
    let P, N = this.path;
    do {
      var M;
      const Z = N.key === "key" || N.listKey === "decorators";
      N = N.parentPath, Z && N.isMethod() && (N = N.parentPath), (M = N) != null && M.isScope() && (P = N);
    } while (N && !P);
    return (d = P) == null ? void 0 : d.scope;
  }
  get parentBlock() {
    return this.path.parent;
  }
  get hub() {
    return this.path.hub;
  }
  traverse(d, P, N) {
    (0, t.default)(d, P, this, N, this.path);
  }
  generateDeclaredUidIdentifier(d) {
    const P = this.generateUidIdentifier(d);
    return this.push({
      id: P
    }), c(P);
  }
  generateUidIdentifier(d) {
    return p(this.generateUid(d));
  }
  generateUid(d = "temp") {
    d = pe(d).replace(/^_+/, "").replace(/[0-9]+$/g, "");
    let P, N = 1;
    do
      P = this._generateUid(d, N), N++;
    while (this.hasLabel(P) || this.hasBinding(P) || this.hasGlobal(P) || this.hasReference(P));
    const M = this.getProgramParent();
    return M.references[P] = !0, M.uids[P] = !0, P;
  }
  _generateUid(d, P) {
    let N = d;
    return P > 1 && (N += P), `_${N}`;
  }
  generateUidBasedOnNode(d, P) {
    const N = [];
    Ie(d, N);
    let M = N.join("$");
    return M = M.replace(/^_/, "") || P || "ref", this.generateUid(M.slice(0, 20));
  }
  generateUidIdentifierBasedOnNode(d, P) {
    return p(this.generateUidBasedOnNode(d, P));
  }
  isStatic(d) {
    if (q(d) || O(d) || De(d))
      return !0;
    if (oe(d)) {
      const P = this.getBinding(d.name);
      return P ? P.constant : this.hasBinding(d.name);
    }
    return !1;
  }
  maybeGenerateMemoised(d, P) {
    if (this.isStatic(d))
      return null;
    {
      const N = this.generateUidIdentifierBasedOnNode(d);
      return P ? N : (this.push({
        id: N
      }), c(N));
    }
  }
  checkBlockScopedCollisions(d, P, N, M) {
    if (P === "param" || d.kind === "local") return;
    if (P === "let" || d.kind === "let" || d.kind === "const" || d.kind === "module" || d.kind === "param" && P === "const")
      throw this.hub.buildError(M, `Duplicate declaration "${N}"`, TypeError);
  }
  rename(d, P) {
    const N = this.getBinding(d);
    N && (P || (P = this.generateUidIdentifier(d).name), new e.default(N, d, P).rename(arguments[2]));
  }
  _renameFromMap(d, P, N, M) {
    d[P] && (d[N] = M, d[P] = null);
  }
  dump() {
    const d = "-".repeat(60);
    console.log(d);
    let P = this;
    do {
      console.log("#", P.block.type);
      for (const N of Object.keys(P.bindings)) {
        const M = P.bindings[N];
        console.log(" -", N, {
          constant: M.constant,
          references: M.references,
          violations: M.constantViolations.length,
          kind: M.kind
        });
      }
    } while (P = P.parent);
    console.log(d);
  }
  toArray(d, P, N) {
    if (oe(d)) {
      const ee = this.getBinding(d.name);
      if (ee != null && ee.constant && ee.path.isGenericType("Array"))
        return d;
    }
    if (h(d))
      return d;
    if (oe(d, {
      name: "arguments"
    }))
      return l(ue(ue(ue(p("Array"), p("prototype")), p("slice")), p("call")), [d]);
    let M;
    const Z = [d];
    return P === !0 ? M = "toConsumableArray" : typeof P == "number" ? (Z.push(qe(P)), M = "slicedToArray") : M = "toArray", N && (Z.unshift(this.hub.addHelper(M)), M = "maybeArrayLike"), l(this.hub.addHelper(M), Z);
  }
  hasLabel(d) {
    return !!this.getLabel(d);
  }
  getLabel(d) {
    return this.labels.get(d);
  }
  registerLabel(d) {
    this.labels.set(d.node.label.name, d);
  }
  registerDeclaration(d) {
    if (d.isLabeledStatement())
      this.registerLabel(d);
    else if (d.isFunctionDeclaration())
      this.registerBinding("hoisted", d.get("id"), d);
    else if (d.isVariableDeclaration()) {
      const P = d.get("declarations"), {
        kind: N
      } = d.node;
      for (const M of P)
        this.registerBinding(N === "using" || N === "await using" ? "const" : N, M);
    } else if (d.isClassDeclaration()) {
      if (d.node.declare) return;
      this.registerBinding("let", d);
    } else if (d.isImportDeclaration()) {
      const P = d.node.importKind === "type" || d.node.importKind === "typeof", N = d.get("specifiers");
      for (const M of N) {
        const Z = P || M.isImportSpecifier() && (M.node.importKind === "type" || M.node.importKind === "typeof");
        this.registerBinding(Z ? "unknown" : "module", M);
      }
    } else if (d.isExportDeclaration()) {
      const P = d.get("declaration");
      (P.isClassDeclaration() || P.isFunctionDeclaration() || P.isVariableDeclaration()) && this.registerDeclaration(P);
    } else
      this.registerBinding("unknown", d);
  }
  buildUndefinedNode() {
    return je();
  }
  registerConstantViolation(d) {
    const P = d.getBindingIdentifiers();
    for (const M of Object.keys(P)) {
      var N;
      (N = this.getBinding(M)) == null || N.reassign(d);
    }
  }
  registerBinding(d, P, N = P) {
    if (!d) throw new ReferenceError("no `kind`");
    if (P.isVariableDeclaration()) {
      const ee = P.get("declarations");
      for (const Se of ee)
        this.registerBinding(d, Se);
      return;
    }
    const M = this.getProgramParent(), Z = P.getOuterBindingIdentifiers(!0);
    for (const ee of Object.keys(Z)) {
      M.references[ee] = !0;
      for (const Se of Z[ee]) {
        const Ae = this.getOwnBinding(ee);
        if (Ae) {
          if (Ae.identifier === Se) continue;
          this.checkBlockScopedCollisions(Ae, d, ee, Se);
        }
        Ae ? Ae.reassign(N) : this.bindings[ee] = new r.default({
          identifier: Se,
          scope: this,
          path: N,
          kind: d
        });
      }
    }
  }
  addGlobal(d) {
    this.globals[d.name] = d;
  }
  hasUid(d) {
    let P = this;
    do
      if (P.uids[d]) return !0;
    while (P = P.parent);
    return !1;
  }
  hasGlobal(d) {
    let P = this;
    do
      if (P.globals[d]) return !0;
    while (P = P.parent);
    return !1;
  }
  hasReference(d) {
    return !!this.getProgramParent().references[d];
  }
  isPure(d, P) {
    if (oe(d)) {
      const ee = this.getBinding(d.name);
      return ee ? P ? ee.constant : !0 : !1;
    } else {
      if (q(d) || Je(d) || De(d) || it(d))
        return !0;
      if (A(d)) {
        var N;
        return d.superClass && !this.isPure(d.superClass, P) || ((N = d.decorators) == null ? void 0 : N.length) > 0 ? !1 : this.isPure(d.body, P);
      } else if (C(d)) {
        for (const ee of d.body)
          if (!this.isPure(ee, P)) return !1;
        return !0;
      } else {
        if (y(d))
          return this.isPure(d.left, P) && this.isPure(d.right, P);
        if (h(d) || Pe(d)) {
          for (const ee of d.elements)
            if (ee !== null && !this.isPure(ee, P)) return !1;
          return !0;
        } else if (L(d) || we(d)) {
          for (const ee of d.properties)
            if (!this.isPure(ee, P)) return !1;
          return !0;
        } else if (W(d)) {
          var M;
          return !(d.computed && !this.isPure(d.key, P) || ((M = d.decorators) == null ? void 0 : M.length) > 0);
        } else if (k(d)) {
          var Z;
          return !(d.computed && !this.isPure(d.key, P) || ((Z = d.decorators) == null ? void 0 : Z.length) > 0 || (ke(d) || d.static) && d.value !== null && !this.isPure(d.value, P));
        } else {
          if (V(d))
            return this.isPure(d.argument, P);
          if (R(d)) {
            for (const ee of d.expressions)
              if (!this.isPure(ee, P)) return !1;
            return !0;
          } else return D(d) ? ne(d.tag, "String.raw") && !this.hasBinding("String", {
            noGlobals: !0
          }) && this.isPure(d.quasi, P) : ie(d) ? !d.computed && oe(d.object) && d.object.name === "Symbol" && oe(d.property) && d.property.name !== "for" && !this.hasBinding("Symbol", {
            noGlobals: !0
          }) : g(d) ? ne(d.callee, "Symbol.for") && !this.hasBinding("Symbol", {
            noGlobals: !0
          }) && d.arguments.length === 1 && n.isStringLiteral(d.arguments[0]) : F(d);
        }
      }
    }
  }
  setData(d, P) {
    return this.data[d] = P;
  }
  getData(d) {
    let P = this;
    do {
      const N = P.data[d];
      if (N != null) return N;
    } while (P = P.parent);
  }
  removeData(d) {
    let P = this;
    do
      P.data[d] != null && (P.data[d] = null);
    while (P = P.parent);
  }
  init() {
    this.inited || (this.inited = !0, this.crawl());
  }
  crawl() {
    const d = this.path;
    this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
    const P = this.getProgramParent();
    if (P.crawling) return;
    const N = {
      references: [],
      constantViolations: [],
      assignments: []
    };
    if (this.crawling = !0, d.type !== "Program" && (0, o.isExplodedVisitor)(Ve)) {
      for (const Z of Ve.enter)
        Z.call(N, d, N);
      const M = Ve[d.type];
      if (M)
        for (const Z of M.enter)
          Z.call(N, d, N);
    }
    d.traverse(Ve, N), this.crawling = !1;
    for (const M of N.assignments) {
      const Z = M.getBindingIdentifiers();
      for (const ee of Object.keys(Z))
        M.scope.getBinding(ee) || P.addGlobal(Z[ee]);
      M.scope.registerConstantViolation(M);
    }
    for (const M of N.references) {
      const Z = M.scope.getBinding(M.node.name);
      Z ? Z.reference(M) : P.addGlobal(M.node);
    }
    for (const M of N.constantViolations)
      M.scope.registerConstantViolation(M);
  }
  push(d) {
    let P = this.path;
    P.isPattern() ? P = this.getPatternParent().path : !P.isBlockStatement() && !P.isProgram() && (P = this.getBlockParent().path), P.isSwitchStatement() && (P = (this.getFunctionParent() || this.getProgramParent()).path);
    const {
      init: N,
      unique: M,
      kind: Z = "var",
      id: ee
    } = d;
    if (!N && !M && (Z === "var" || Z === "let") && P.isFunction() && !P.node.name && g(P.parent, {
      callee: P.node
    }) && P.parent.arguments.length <= P.node.params.length && oe(ee)) {
      P.pushContainer("params", ee), P.scope.registerBinding("param", P.get("params")[P.node.params.length - 1]);
      return;
    }
    (P.isLoop() || P.isCatchClause() || P.isFunction()) && (P.ensureBlock(), P = P.get("body"));
    const Se = d._blockHoist == null ? 2 : d._blockHoist, Ae = `declaration:${Z}:${Se}`;
    let Te = !M && P.getData(Ae);
    if (!Te) {
      const Ke = he(Z, []);
      Ke._blockHoist = Se, [Te] = P.unshiftContainer("body", [Ke]), M || P.setData(Ae, Te);
    }
    const Y = Ee(ee, N), st = Te.node.declarations.push(Y);
    P.scope.registerBinding(Z, Te.get("declarations")[st - 1]);
  }
  getProgramParent() {
    let d = this;
    do
      if (d.path.isProgram())
        return d;
    while (d = d.parent);
    throw new Error("Couldn't find a Program");
  }
  getFunctionParent() {
    let d = this;
    do
      if (d.path.isFunctionParent())
        return d;
    while (d = d.parent);
    return null;
  }
  getBlockParent() {
    let d = this;
    do
      if (d.path.isBlockParent())
        return d;
    while (d = d.parent);
    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
  }
  getPatternParent() {
    let d = this;
    do
      if (!d.path.isPattern())
        return d.getBlockParent();
    while (d = d.parent.parent);
    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
  }
  getAllBindings() {
    const d = /* @__PURE__ */ Object.create(null);
    let P = this;
    do {
      for (const N of Object.keys(P.bindings))
        N in d || (d[N] = P.bindings[N]);
      P = P.parent;
    } while (P);
    return d;
  }
  getAllBindingsOfKind(...d) {
    const P = /* @__PURE__ */ Object.create(null);
    for (const N of d) {
      let M = this;
      do {
        for (const Z of Object.keys(M.bindings)) {
          const ee = M.bindings[Z];
          ee.kind === N && (P[Z] = ee);
        }
        M = M.parent;
      } while (M);
    }
    return P;
  }
  bindingIdentifierEquals(d, P) {
    return this.getBindingIdentifier(d) === P;
  }
  getBinding(d) {
    let P = this, N;
    do {
      const Z = P.getOwnBinding(d);
      if (Z) {
        var M;
        if (!((M = N) != null && M.isPattern() && Z.kind !== "param" && Z.kind !== "local")) return Z;
      } else if (!Z && d === "arguments" && P.path.isFunction() && !P.path.isArrowFunctionExpression())
        break;
      N = P.path;
    } while (P = P.parent);
  }
  getOwnBinding(d) {
    return this.bindings[d];
  }
  getBindingIdentifier(d) {
    var P;
    return (P = this.getBinding(d)) == null ? void 0 : P.identifier;
  }
  getOwnBindingIdentifier(d) {
    const P = this.bindings[d];
    return P == null ? void 0 : P.identifier;
  }
  hasOwnBinding(d) {
    return !!this.getOwnBinding(d);
  }
  hasBinding(d, P) {
    if (!d) return !1;
    let N = this;
    do
      if (N.hasOwnBinding(d))
        return !0;
    while (N = N.parent);
    let M, Z;
    return typeof P == "object" ? (M = P.noGlobals, Z = P.noUids) : typeof P == "boolean" && (M = P), !!(!Z && this.hasUid(d) || !M && ze.globals.includes(d) || !M && ze.contextVariables.includes(d));
  }
  parentHasBinding(d, P) {
    var N;
    return (N = this.parent) == null ? void 0 : N.hasBinding(d, P);
  }
  moveBindingTo(d, P) {
    const N = this.getBinding(d);
    N && (N.scope.removeOwnBinding(d), N.scope = P, P.bindings[d] = N);
  }
  removeOwnBinding(d) {
    delete this.bindings[d];
  }
  removeBinding(d) {
    var P;
    (P = this.getBinding(d)) == null || P.scope.removeOwnBinding(d);
    let N = this;
    do
      N.uids[d] && (N.uids[d] = !1);
    while (N = N.parent);
  }
}
return Wr.default = ze, ze.globals = Object.keys(i.builtin), ze.contextVariables = ["arguments", "undefined", "Infinity", "NaN"], Wr;
}
var Ms = {}, Bs = {}, Vn = { exports: {} }, zi = { exports: {} }, Pu;
function FI() {
return Pu || (Pu = 1, function(e, t) {
  (function(r, i) {
    i(t);
  })(Tr, function(r) {
    class i {
      constructor() {
        this._indexes = { __proto__: null }, this.array = [];
      }
    }
    function s(l) {
      return l;
    }
    function n(l, c) {
      return l._indexes[c];
    }
    function a(l, c) {
      const f = n(l, c);
      if (f !== void 0)
        return f;
      const { array: p, _indexes: h } = l, y = p.push(c);
      return h[c] = y - 1;
    }
    function o(l) {
      const { array: c, _indexes: f } = l;
      if (c.length === 0)
        return;
      const p = c.pop();
      f[p] = void 0;
    }
    function u(l, c) {
      const f = n(l, c);
      if (f === void 0)
        return;
      const { array: p, _indexes: h } = l;
      for (let y = f + 1; y < p.length; y++) {
        const g = p[y];
        p[y - 1] = g, h[g]--;
      }
      h[c] = void 0, p.pop();
    }
    r.SetArray = i, r.get = n, r.pop = o, r.put = a, r.remove = u, Object.defineProperty(r, "__esModule", { value: !0 });
  });
}(zi, zi.exports)), zi.exports;
}
var Qi = { exports: {} }, vu;
function Pc() {
return vu || (vu = 1, function(e, t) {
  (function(r, i) {
    i(t);
  })(Tr, function(r) {
    const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = new Uint8Array(64), o = new Uint8Array(128);
    for (let W = 0; W < n.length; W++) {
      const Q = n.charCodeAt(W);
      a[W] = Q, o[Q] = W;
    }
    function u(W, Q) {
      let U = 0, L = 0, k = 0;
      do {
        const B = W.next();
        k = o[B], U |= (k & 31) << L, L += 5;
      } while (k & 32);
      const F = U & 1;
      return U >>>= 1, F && (U = -2147483648 | -U), Q + U;
    }
    function l(W, Q, U) {
      let L = Q - U;
      L = L < 0 ? -L << 1 | 1 : L << 1;
      do {
        let k = L & 31;
        L >>>= 5, L > 0 && (k |= 32), W.write(a[k]);
      } while (L > 0);
      return Q;
    }
    function c(W, Q) {
      return W.pos >= Q ? !1 : W.peek() !== 44;
    }
    const f = 1024 * 16, p = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
      decode(W) {
        return Buffer.from(W.buffer, W.byteOffset, W.byteLength).toString();
      }
    } : {
      decode(W) {
        let Q = "";
        for (let U = 0; U < W.length; U++)
          Q += String.fromCharCode(W[U]);
        return Q;
      }
    };
    class h {
      constructor() {
        this.pos = 0, this.out = "", this.buffer = new Uint8Array(f);
      }
      write(Q) {
        const { buffer: U } = this;
        U[this.pos++] = Q, this.pos === f && (this.out += p.decode(U), this.pos = 0);
      }
      flush() {
        const { buffer: Q, out: U, pos: L } = this;
        return L > 0 ? U + p.decode(Q.subarray(0, L)) : U;
      }
    }
    class y {
      constructor(Q) {
        this.pos = 0, this.buffer = Q;
      }
      next() {
        return this.buffer.charCodeAt(this.pos++);
      }
      peek() {
        return this.buffer.charCodeAt(this.pos);
      }
      indexOf(Q) {
        const { buffer: U, pos: L } = this, k = U.indexOf(Q, L);
        return k === -1 ? U.length : k;
      }
    }
    const g = [];
    function A(W) {
      const { length: Q } = W, U = new y(W), L = [], k = [];
      let F = 0;
      for (; U.pos < Q; U.pos++) {
        F = u(U, F);
        const B = u(U, 0);
        if (!c(U, Q)) {
          const H = k.pop();
          H[2] = F, H[3] = B;
          continue;
        }
        const O = u(U, 0), q = u(U, 0) & 1 ? [F, B, 0, 0, O, u(U, 0)] : [F, B, 0, 0, O];
        let V = g;
        if (c(U, Q)) {
          V = [];
          do {
            const H = u(U, 0);
            V.push(H);
          } while (c(U, Q));
        }
        q.vars = V, L.push(q), k.push(q);
      }
      return L;
    }
    function C(W) {
      const Q = new h();
      for (let U = 0; U < W.length; )
        U = _(W, U, Q, [0]);
      return Q.flush();
    }
    function _(W, Q, U, L) {
      const k = W[Q], { 0: F, 1: B, 2: O, 3: D, 4: R, vars: q } = k;
      Q > 0 && U.write(44), L[0] = l(U, F, L[0]), l(U, B, 0), l(U, R, 0);
      const V = k.length === 6 ? 1 : 0;
      l(U, V, 0), k.length === 6 && l(U, k[5], 0);
      for (const H of q)
        l(U, H, 0);
      for (Q++; Q < W.length; ) {
        const H = W[Q], { 0: ne, 1: ue } = H;
        if (ne > O || ne === O && ue >= D)
          break;
        Q = _(W, Q, U, L);
      }
      return U.write(44), L[0] = l(U, O, L[0]), l(U, D, 0), Q;
    }
    function j(W) {
      const { length: Q } = W, U = new y(W), L = [], k = [];
      let F = 0, B = 0, O = 0, D = 0, R = 0, q = 0, V = 0, H = 0;
      do {
        const ne = U.indexOf(";");
        let ue = 0;
        for (; U.pos < ne; U.pos++) {
          if (ue = u(U, ue), !c(U, ne)) {
            const De = k.pop();
            De[2] = F, De[3] = ue;
            continue;
          }
          const qe = u(U, 0), pe = qe & 1, he = qe & 2, Ee = qe & 4;
          let we = null, Pe = g, ke;
          if (pe) {
            const De = u(U, B);
            O = u(U, B === De ? O : 0), B = De, ke = [F, ue, 0, 0, De, O];
          } else
            ke = [F, ue, 0, 0];
          if (ke.isScope = !!Ee, he) {
            const De = D, Je = R;
            D = u(U, D);
            const it = De === D;
            R = u(U, it ? R : 0), q = u(U, it && Je === R ? q : 0), we = [D, R, q];
          }
          if (ke.callsite = we, c(U, ne)) {
            Pe = [];
            do {
              V = F, H = ue;
              const De = u(U, 0);
              let Je;
              if (De < -1) {
                Je = [[u(U, 0)]];
                for (let it = -1; it > De; it--) {
                  const ve = V;
                  V = u(U, V), H = u(U, V === ve ? H : 0);
                  const je = u(U, 0);
                  Je.push([je, V, H]);
                }
              } else
                Je = [[De]];
              Pe.push(Je);
            } while (c(U, ne));
          }
          ke.bindings = Pe, L.push(ke), k.push(ke);
        }
        F++, U.pos = ne + 1;
      } while (U.pos < Q);
      return L;
    }
    function G(W) {
      if (W.length === 0)
        return "";
      const Q = new h();
      for (let U = 0; U < W.length; )
        U = fe(W, U, Q, [0, 0, 0, 0, 0, 0, 0]);
      return Q.flush();
    }
    function fe(W, Q, U, L) {
      const k = W[Q], { 0: F, 1: B, 2: O, 3: D, isScope: R, callsite: q, bindings: V } = k;
      L[0] < F ? (re(U, L[0], F), L[0] = F, L[1] = 0) : Q > 0 && U.write(44), L[1] = l(U, k[1], L[1]);
      const H = (k.length === 6 ? 1 : 0) | (q ? 2 : 0) | (R ? 4 : 0);
      if (l(U, H, 0), k.length === 6) {
        const { 4: ne, 5: ue } = k;
        ne !== L[2] && (L[3] = 0), L[2] = l(U, ne, L[2]), L[3] = l(U, ue, L[3]);
      }
      if (q) {
        const { 0: ne, 1: ue, 2: qe } = k.callsite;
        ne !== L[4] ? (L[5] = 0, L[6] = 0) : ue !== L[5] && (L[6] = 0), L[4] = l(U, ne, L[4]), L[5] = l(U, ue, L[5]), L[6] = l(U, qe, L[6]);
      }
      if (V)
        for (const ne of V) {
          ne.length > 1 && l(U, -ne.length, 0);
          const ue = ne[0][0];
          l(U, ue, 0);
          let qe = F, pe = B;
          for (let he = 1; he < ne.length; he++) {
            const Ee = ne[he];
            qe = l(U, Ee[1], qe), pe = l(U, Ee[2], pe), l(U, Ee[0], 0);
          }
        }
      for (Q++; Q < W.length; ) {
        const ne = W[Q], { 0: ue, 1: qe } = ne;
        if (ue > O || ue === O && qe >= D)
          break;
        Q = fe(W, Q, U, L);
      }
      return L[0] < O ? (re(U, L[0], O), L[0] = O, L[1] = 0) : U.write(44), L[1] = l(U, D, L[1]), Q;
    }
    function re(W, Q, U) {
      do
        W.write(59);
      while (++Q < U);
    }
    function oe(W) {
      const { length: Q } = W, U = new y(W), L = [];
      let k = 0, F = 0, B = 0, O = 0, D = 0;
      do {
        const R = U.indexOf(";"), q = [];
        let V = !0, H = 0;
        for (k = 0; U.pos < R; ) {
          let ne;
          k = u(U, k), k < H && (V = !1), H = k, c(U, R) ? (F = u(U, F), B = u(U, B), O = u(U, O), c(U, R) ? (D = u(U, D), ne = [k, F, B, O, D]) : ne = [k, F, B, O]) : ne = [k], q.push(ne), U.pos++;
        }
        V || K(q), L.push(q), U.pos = R + 1;
      } while (U.pos <= Q);
      return L;
    }
    function K(W) {
      W.sort(X);
    }
    function X(W, Q) {
      return W[0] - Q[0];
    }
    function ie(W) {
      const Q = new h();
      let U = 0, L = 0, k = 0, F = 0;
      for (let B = 0; B < W.length; B++) {
        const O = W[B];
        if (B > 0 && Q.write(59), O.length === 0)
          continue;
        let D = 0;
        for (let R = 0; R < O.length; R++) {
          const q = O[R];
          R > 0 && Q.write(44), D = l(Q, q[0], D), q.length !== 1 && (U = l(Q, q[1], U), L = l(Q, q[2], L), k = l(Q, q[3], k), q.length !== 4 && (F = l(Q, q[4], F)));
        }
      }
      return Q.flush();
    }
    r.decode = oe, r.decodeGeneratedRanges = j, r.decodeOriginalScopes = A, r.encode = ie, r.encodeGeneratedRanges = G, r.encodeOriginalScopes = C, Object.defineProperty(r, "__esModule", { value: !0 });
  });
}(Qi, Qi.exports)), Qi.exports;
}
var qn = { exports: {} }, cn = { exports: {} }, Au;
function jI() {
return Au || (Au = 1, function(e, t) {
  (function(r, i) {
    e.exports = i();
  })(Tr, function() {
    const r = /^[\w+.-]+:\/\//, i = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, s = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    function n(_) {
      return r.test(_);
    }
    function a(_) {
      return _.startsWith("//");
    }
    function o(_) {
      return _.startsWith("/");
    }
    function u(_) {
      return _.startsWith("file:");
    }
    function l(_) {
      return /^[.?#]/.test(_);
    }
    function c(_) {
      const j = i.exec(_);
      return p(j[1], j[2] || "", j[3], j[4] || "", j[5] || "/", j[6] || "", j[7] || "");
    }
    function f(_) {
      const j = s.exec(_), G = j[2];
      return p("file:", "", j[1] || "", "", o(G) ? G : "/" + G, j[3] || "", j[4] || "");
    }
    function p(_, j, G, fe, re, oe, K) {
      return {
        scheme: _,
        user: j,
        host: G,
        port: fe,
        path: re,
        query: oe,
        hash: K,
        type: 7
      };
    }
    function h(_) {
      if (a(_)) {
        const G = c("http:" + _);
        return G.scheme = "", G.type = 6, G;
      }
      if (o(_)) {
        const G = c("http://foo.com" + _);
        return G.scheme = "", G.host = "", G.type = 5, G;
      }
      if (u(_))
        return f(_);
      if (n(_))
        return c(_);
      const j = c("http://foo.com/" + _);
      return j.scheme = "", j.host = "", j.type = _ ? _.startsWith("?") ? 3 : _.startsWith("#") ? 2 : 4 : 1, j;
    }
    function y(_) {
      if (_.endsWith("/.."))
        return _;
      const j = _.lastIndexOf("/");
      return _.slice(0, j + 1);
    }
    function g(_, j) {
      A(j, j.type), _.path === "/" ? _.path = j.path : _.path = y(j.path) + _.path;
    }
    function A(_, j) {
      const G = j <= 4, fe = _.path.split("/");
      let re = 1, oe = 0, K = !1;
      for (let ie = 1; ie < fe.length; ie++) {
        const W = fe[ie];
        if (!W) {
          K = !0;
          continue;
        }
        if (K = !1, W !== ".") {
          if (W === "..") {
            oe ? (K = !0, oe--, re--) : G && (fe[re++] = W);
            continue;
          }
          fe[re++] = W, oe++;
        }
      }
      let X = "";
      for (let ie = 1; ie < re; ie++)
        X += "/" + fe[ie];
      (!X || K && !X.endsWith("/..")) && (X += "/"), _.path = X;
    }
    function C(_, j) {
      if (!_ && !j)
        return "";
      const G = h(_);
      let fe = G.type;
      if (j && fe !== 7) {
        const oe = h(j), K = oe.type;
        switch (fe) {
          case 1:
            G.hash = oe.hash;
          case 2:
            G.query = oe.query;
          case 3:
          case 4:
            g(G, oe);
          case 5:
            G.user = oe.user, G.host = oe.host, G.port = oe.port;
          case 6:
            G.scheme = oe.scheme;
        }
        K > fe && (fe = K);
      }
      A(G, fe);
      const re = G.query + G.hash;
      switch (fe) {
        case 2:
        case 3:
          return re;
        case 4: {
          const oe = G.path.slice(1);
          return oe ? l(j || _) && !l(oe) ? "./" + oe + re : oe + re : re || ".";
        }
        case 5:
          return G.path + re;
        default:
          return G.scheme + "//" + G.user + G.host + G.port + G.path + re;
      }
    }
    return C;
  });
}(cn)), cn.exports;
}
(function(e, t) {
(function(r, i) {
  i(t, Pc(), jI());
})(Tr, function(r, i, s) {
  function n(d, P) {
    return P && !P.endsWith("/") && (P += "/"), s(d, P);
  }
  function a(d) {
    if (!d)
      return "";
    const P = d.lastIndexOf("/");
    return d.slice(0, P + 1);
  }
  const o = 0, u = 1, l = 2, c = 3, f = 4, p = 1, h = 2;
  function y(d, P) {
    const N = g(d, 0);
    if (N === d.length)
      return d;
    P || (d = d.slice());
    for (let M = N; M < d.length; M = g(d, M + 1))
      d[M] = C(d[M], P);
    return d;
  }
  function g(d, P) {
    for (let N = P; N < d.length; N++)
      if (!A(d[N]))
        return N;
    return d.length;
  }
  function A(d) {
    for (let P = 1; P < d.length; P++)
      if (d[P][o] < d[P - 1][o])
        return !1;
    return !0;
  }
  function C(d, P) {
    return P || (d = d.slice()), d.sort(_);
  }
  function _(d, P) {
    return d[o] - P[o];
  }
  let j = !1;
  function G(d, P, N, M) {
    for (; N <= M; ) {
      const Z = N + (M - N >> 1), ee = d[Z][o] - P;
      if (ee === 0)
        return j = !0, Z;
      ee < 0 ? N = Z + 1 : M = Z - 1;
    }
    return j = !1, N - 1;
  }
  function fe(d, P, N) {
    for (let M = N + 1; M < d.length && d[M][o] === P; N = M++)
      ;
    return N;
  }
  function re(d, P, N) {
    for (let M = N - 1; M >= 0 && d[M][o] === P; N = M--)
      ;
    return N;
  }
  function oe() {
    return {
      lastKey: -1,
      lastNeedle: -1,
      lastIndex: -1
    };
  }
  function K(d, P, N, M) {
    const { lastKey: Z, lastNeedle: ee, lastIndex: Se } = N;
    let Ae = 0, Te = d.length - 1;
    if (M === Z) {
      if (P === ee)
        return j = Se !== -1 && d[Se][o] === P, Se;
      P >= ee ? Ae = Se === -1 ? 0 : Se : Te = Se;
    }
    return N.lastKey = M, N.lastNeedle = P, N.lastIndex = G(d, P, Ae, Te);
  }
  function X(d, P) {
    const N = P.map(W);
    for (let M = 0; M < d.length; M++) {
      const Z = d[M];
      for (let ee = 0; ee < Z.length; ee++) {
        const Se = Z[ee];
        if (Se.length === 1)
          continue;
        const Ae = Se[u], Te = Se[l], Y = Se[c], st = N[Ae], Ke = st[Te] || (st[Te] = []), Ye = P[Ae];
        let nt = fe(Ke, Y, K(Ke, Y, Ye, Te));
        Ye.lastIndex = ++nt, ie(Ke, nt, [Y, M, Se[o]]);
      }
    }
    return N;
  }
  function ie(d, P, N) {
    for (let M = d.length; M > P; M--)
      d[M] = d[M - 1];
    d[P] = N;
  }
  function W() {
    return { __proto__: null };
  }
  const Q = function(d, P) {
    const N = U(d);
    if (!("sections" in N))
      return new V(N, P);
    const M = [], Z = [], ee = [], Se = [], Ae = [];
    L(N, P, M, Z, ee, Se, Ae, 0, 0, 1 / 0, 1 / 0);
    const Te = {
      version: 3,
      file: N.file,
      names: Se,
      sources: Z,
      sourcesContent: ee,
      mappings: M,
      ignoreList: Ae
    };
    return Je(Te);
  };
  function U(d) {
    return typeof d == "string" ? JSON.parse(d) : d;
  }
  function L(d, P, N, M, Z, ee, Se, Ae, Te, Y, st) {
    const { sections: Ke } = d;
    for (let Ye = 0; Ye < Ke.length; Ye++) {
      const { map: nt, offset: St } = Ke[Ye];
      let v = Y, de = st;
      if (Ye + 1 < Ke.length) {
        const Re = Ke[Ye + 1].offset;
        v = Math.min(Y, Ae + Re.line), v === Y ? de = Math.min(st, Te + Re.column) : v < Y && (de = Te + Re.column);
      }
      k(nt, P, N, M, Z, ee, Se, Ae + St.line, Te + St.column, v, de);
    }
  }
  function k(d, P, N, M, Z, ee, Se, Ae, Te, Y, st) {
    const Ke = U(d);
    if ("sections" in Ke)
      return L(...arguments);
    const Ye = new V(Ke, P), nt = M.length, St = ee.length, v = ue(Ye), { resolvedSources: de, sourcesContent: Re, ignoreList: At } = Ye;
    if (F(M, de), F(ee, Ye.names), Re)
      F(Z, Re);
    else
      for (let xt = 0; xt < de.length; xt++)
        Z.push(null);
    if (At)
      for (let xt = 0; xt < At.length; xt++)
        Se.push(At[xt] + nt);
    for (let xt = 0; xt < v.length; xt++) {
      const Br = Ae + xt;
      if (Br > Y)
        return;
      const Ii = B(N, Br), Qs = xt === 0 ? Te : 0, Ci = v[xt];
      for (let Fr = 0; Fr < Ci.length; Fr++) {
        const Ft = Ci[Fr], Ar = Qs + Ft[o];
        if (Br === Y && Ar >= st)
          return;
        if (Ft.length === 1) {
          Ii.push([Ar]);
          continue;
        }
        const wi = nt + Ft[u], Ni = Ft[l], Oi = Ft[c];
        Ii.push(Ft.length === 4 ? [Ar, wi, Ni, Oi] : [Ar, wi, Ni, Oi, St + Ft[f]]);
      }
    }
  }
  function F(d, P) {
    for (let N = 0; N < P.length; N++)
      d.push(P[N]);
  }
  function B(d, P) {
    for (let N = d.length; N <= P; N++)
      d[N] = [];
    return d[P];
  }
  const O = "`line` must be greater than 0 (lines start at line 1)", D = "`column` must be greater than or equal to 0 (columns start at column 0)", R = -1, q = 1;
  class V {
    constructor(P, N) {
      const M = typeof P == "string";
      if (!M && P._decodedMemo)
        return P;
      const Z = M ? JSON.parse(P) : P, { version: ee, file: Se, names: Ae, sourceRoot: Te, sources: Y, sourcesContent: st } = Z;
      this.version = ee, this.file = Se, this.names = Ae || [], this.sourceRoot = Te, this.sources = Y, this.sourcesContent = st, this.ignoreList = Z.ignoreList || Z.x_google_ignoreList || void 0;
      const Ke = n(Te || "", a(N));
      this.resolvedSources = Y.map((nt) => n(nt || "", Ke));
      const { mappings: Ye } = Z;
      typeof Ye == "string" ? (this._encoded = Ye, this._decoded = void 0) : (this._encoded = void 0, this._decoded = y(Ye, M)), this._decodedMemo = oe(), this._bySources = void 0, this._bySourceMemos = void 0;
    }
  }
  function H(d) {
    return d;
  }
  function ne(d) {
    var P, N;
    return (P = (N = d)._encoded) !== null && P !== void 0 ? P : N._encoded = i.encode(d._decoded);
  }
  function ue(d) {
    var P;
    return (P = d)._decoded || (P._decoded = i.decode(d._encoded));
  }
  function qe(d, P, N) {
    const M = ue(d);
    if (P >= M.length)
      return null;
    const Z = M[P], ee = ht(Z, d._decodedMemo, P, N, q);
    return ee === -1 ? null : Z[ee];
  }
  function pe(d, P) {
    let { line: N, column: M, bias: Z } = P;
    if (N--, N < 0)
      throw new Error(O);
    if (M < 0)
      throw new Error(D);
    const ee = ue(d);
    if (N >= ee.length)
      return Ie(null, null, null, null);
    const Se = ee[N], Ae = ht(Se, d._decodedMemo, N, M, Z || q);
    if (Ae === -1)
      return Ie(null, null, null, null);
    const Te = Se[Ae];
    if (Te.length === 1)
      return Ie(null, null, null, null);
    const { names: Y, resolvedSources: st } = d;
    return Ie(st[Te[u]], Te[l] + 1, Te[c], Te.length === 5 ? Y[Te[f]] : null);
  }
  function he(d, P) {
    const { source: N, line: M, column: Z, bias: ee } = P;
    return J(d, N, M, Z, ee || q, !1);
  }
  function Ee(d, P) {
    const { source: N, line: M, column: Z, bias: ee } = P;
    return J(d, N, M, Z, ee || R, !0);
  }
  function we(d, P) {
    const N = ue(d), { names: M, resolvedSources: Z } = d;
    for (let ee = 0; ee < N.length; ee++) {
      const Se = N[ee];
      for (let Ae = 0; Ae < Se.length; Ae++) {
        const Te = Se[Ae], Y = ee + 1, st = Te[0];
        let Ke = null, Ye = null, nt = null, St = null;
        Te.length !== 1 && (Ke = Z[Te[1]], Ye = Te[2] + 1, nt = Te[3]), Te.length === 5 && (St = M[Te[4]]), P({
          generatedLine: Y,
          generatedColumn: st,
          source: Ke,
          originalLine: Ye,
          originalColumn: nt,
          name: St
        });
      }
    }
  }
  function Pe(d, P) {
    const { sources: N, resolvedSources: M } = d;
    let Z = N.indexOf(P);
    return Z === -1 && (Z = M.indexOf(P)), Z;
  }
  function ke(d, P) {
    const { sourcesContent: N } = d;
    if (N == null)
      return null;
    const M = Pe(d, P);
    return M === -1 ? null : N[M];
  }
  function De(d, P) {
    const { ignoreList: N } = d;
    if (N == null)
      return !1;
    const M = Pe(d, P);
    return M === -1 ? !1 : N.includes(M);
  }
  function Je(d, P) {
    const N = new V(je(d, []), P);
    return N._decoded = d.mappings, N;
  }
  function it(d) {
    return je(d, ue(d));
  }
  function ve(d) {
    return je(d, ne(d));
  }
  function je(d, P) {
    return {
      version: d.version,
      file: d.file,
      names: d.names,
      sourceRoot: d.sourceRoot,
      sources: d.sources,
      sourcesContent: d.sourcesContent,
      mappings: P,
      ignoreList: d.ignoreList || d.x_google_ignoreList
    };
  }
  function Ie(d, P, N, M) {
    return { source: d, line: P, column: N, name: M };
  }
  function Ve(d, P) {
    return { line: d, column: P };
  }
  function ht(d, P, N, M, Z) {
    let ee = K(d, M, P, N);
    return j ? ee = (Z === R ? fe : re)(d, M, ee) : Z === R && ee++, ee === -1 || ee === d.length ? -1 : ee;
  }
  function ze(d, P, N, M, Z) {
    let ee = ht(d, P, N, M, q);
    if (!j && Z === R && ee++, ee === -1 || ee === d.length)
      return [];
    const Se = j ? M : d[ee][o];
    j || (ee = re(d, Se, ee));
    const Ae = fe(d, Se, ee), Te = [];
    for (; ee <= Ae; ee++) {
      const Y = d[ee];
      Te.push(Ve(Y[p] + 1, Y[h]));
    }
    return Te;
  }
  function J(d, P, N, M, Z, ee) {
    var Se;
    if (N--, N < 0)
      throw new Error(O);
    if (M < 0)
      throw new Error(D);
    const { sources: Ae, resolvedSources: Te } = d;
    let Y = Ae.indexOf(P);
    if (Y === -1 && (Y = Te.indexOf(P)), Y === -1)
      return ee ? [] : Ve(null, null);
    const Ke = ((Se = d)._bySources || (Se._bySources = X(ue(d), d._bySourceMemos = Ae.map(oe))))[Y][N];
    if (Ke == null)
      return ee ? [] : Ve(null, null);
    const Ye = d._bySourceMemos[Y];
    if (ee)
      return ze(Ke, Ye, N, M, Z);
    const nt = ht(Ke, Ye, N, M, Z);
    if (nt === -1)
      return Ve(null, null);
    const St = Ke[nt];
    return Ve(St[p] + 1, St[h]);
  }
  r.AnyMap = Q, r.GREATEST_LOWER_BOUND = q, r.LEAST_UPPER_BOUND = R, r.TraceMap = V, r.allGeneratedPositionsFor = Ee, r.decodedMap = it, r.decodedMappings = ue, r.eachMapping = we, r.encodedMap = ve, r.encodedMappings = ne, r.generatedPositionFor = he, r.isIgnored = De, r.originalPositionFor = pe, r.presortedDecodedMap = Je, r.sourceContentFor = ke, r.traceSegment = qe;
});
})(qn, qn.exports);
var vc = qn.exports;
(function(e, t) {
(function(r, i) {
  i(t, FI(), Pc(), vc);
})(Tr, function(r, i, s, n) {
  class p {
    constructor({ file: O, sourceRoot: D } = {}) {
      this._names = new i.SetArray(), this._sources = new i.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = O, this.sourceRoot = D, this._ignoreList = new i.SetArray();
    }
  }
  function h(B) {
    return B;
  }
  function y(B, O, D, R, q, V, H, ne) {
    return K(!1, B, O, D, R, q, V, H, ne);
  }
  function g(B, O) {
    return F(!1, B, O);
  }
  const A = (B, O, D, R, q, V, H, ne) => K(!0, B, O, D, R, q, V, H, ne), C = (B, O) => F(!0, B, O);
  function _(B, O, D) {
    const { _sources: R, _sourcesContent: q } = B, V = i.put(R, O);
    q[V] = D;
  }
  function j(B, O, D = !0) {
    const { _sources: R, _sourcesContent: q, _ignoreList: V } = B, H = i.put(R, O);
    H === q.length && (q[H] = null), D ? i.put(V, H) : i.remove(V, H);
  }
  function G(B) {
    const { _mappings: O, _sources: D, _sourcesContent: R, _names: q, _ignoreList: V } = B;
    return Q(O), {
      version: 3,
      file: B.file || void 0,
      names: q.array,
      sourceRoot: B.sourceRoot || void 0,
      sources: D.array,
      sourcesContent: R,
      mappings: O,
      ignoreList: V.array
    };
  }
  function fe(B) {
    const O = G(B);
    return Object.assign(Object.assign({}, O), { mappings: s.encode(O.mappings) });
  }
  function re(B) {
    const O = new n.TraceMap(B), D = new p({ file: O.file, sourceRoot: O.sourceRoot });
    return U(D._names, O.names), U(D._sources, O.sources), D._sourcesContent = O.sourcesContent || O.sources.map(() => null), D._mappings = n.decodedMappings(O), O.ignoreList && U(D._ignoreList, O.ignoreList), D;
  }
  function oe(B) {
    const O = [], { _mappings: D, _sources: R, _names: q } = B;
    for (let V = 0; V < D.length; V++) {
      const H = D[V];
      for (let ne = 0; ne < H.length; ne++) {
        const ue = H[ne], qe = { line: V + 1, column: ue[0] };
        let pe, he, Ee;
        ue.length !== 1 && (pe = R.array[ue[1]], he = { line: ue[2] + 1, column: ue[3] }, ue.length === 5 && (Ee = q.array[ue[4]])), O.push({ generated: qe, source: pe, original: he, name: Ee });
      }
    }
    return O;
  }
  function K(B, O, D, R, q, V, H, ne, ue) {
    const { _mappings: qe, _sources: pe, _sourcesContent: he, _names: Ee } = O, we = X(qe, D), Pe = ie(we, R);
    if (!q)
      return B && L(we, Pe) ? void 0 : W(we, Pe, [R]);
    const ke = i.put(pe, q), De = ne ? i.put(Ee, ne) : -1;
    if (ke === he.length && (he[ke] = ue ?? null), !(B && k(we, Pe, ke, V, H, De)))
      return W(we, Pe, ne ? [R, ke, V, H, De] : [R, ke, V, H]);
  }
  function X(B, O) {
    for (let D = B.length; D <= O; D++)
      B[D] = [];
    return B[O];
  }
  function ie(B, O) {
    let D = B.length;
    for (let R = D - 1; R >= 0; D = R--) {
      const q = B[R];
      if (O >= q[0])
        break;
    }
    return D;
  }
  function W(B, O, D) {
    for (let R = B.length; R > O; R--)
      B[R] = B[R - 1];
    B[O] = D;
  }
  function Q(B) {
    const { length: O } = B;
    let D = O;
    for (let R = D - 1; R >= 0 && !(B[R].length > 0); D = R, R--)
      ;
    D < O && (B.length = D);
  }
  function U(B, O) {
    for (let D = 0; D < O.length; D++)
      i.put(B, O[D]);
  }
  function L(B, O) {
    return O === 0 ? !0 : B[O - 1].length === 1;
  }
  function k(B, O, D, R, q, V) {
    if (O === 0)
      return !1;
    const H = B[O - 1];
    return H.length === 1 ? !1 : D === H[1] && R === H[2] && q === H[3] && V === (H.length === 5 ? H[4] : -1);
  }
  function F(B, O, D) {
    const { generated: R, source: q, original: V, name: H, content: ne } = D;
    return q ? K(B, O, R.line - 1, R.column, q, V.line - 1, V.column, H, ne) : K(B, O, R.line - 1, R.column, null, null, null, null, null);
  }
  r.GenMapping = p, r.addMapping = g, r.addSegment = y, r.allMappings = oe, r.fromMap = re, r.maybeAddMapping = C, r.maybeAddSegment = A, r.setIgnore = j, r.setSourceContent = _, r.toDecodedMap = G, r.toEncodedMap = fe, Object.defineProperty(r, "__esModule", { value: !0 });
});
})(Vn, Vn.exports);
var RI = Vn.exports;
Object.defineProperty(Bs, "__esModule", {
value: !0
});
Bs.default = void 0;
var er = RI, fn = vc;
class UI {
constructor(t, r) {
  var i;
  this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
  const s = this._map = new er.GenMapping({
    sourceRoot: t.sourceRoot
  });
  if (this._sourceFileName = (i = t.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
    this._inputMap = new fn.TraceMap(t.inputSourceMap);
    const a = this._inputMap.resolvedSources;
    if (a.length)
      for (let o = 0; o < a.length; o++) {
        var n;
        (0, er.setSourceContent)(s, a[o], (n = this._inputMap.sourcesContent) == null ? void 0 : n[o]);
      }
  }
  if (typeof r == "string" && !t.inputSourceMap)
    (0, er.setSourceContent)(s, this._sourceFileName, r);
  else if (typeof r == "object")
    for (const a of Object.keys(r))
      (0, er.setSourceContent)(s, a.replace(/\\/g, "/"), r[a]);
}
get() {
  return (0, er.toEncodedMap)(this._map);
}
getDecoded() {
  return (0, er.toDecodedMap)(this._map);
}
getRawMappings() {
  return this._rawMappings || (this._rawMappings = (0, er.allMappings)(this._map));
}
mark(t, r, i, s, n, a) {
  var o;
  this._rawMappings = void 0;
  let u;
  if (r != null)
    if (this._inputMap) {
      if (u = (0, fn.originalPositionFor)(this._inputMap, {
        line: r,
        column: i
      }), !u.name && n) {
        const l = (0, fn.originalPositionFor)(this._inputMap, n);
        l.name && (s = l.name);
      }
    } else
      u = {
        source: (a == null ? void 0 : a.replace(/\\/g, "/")) || this._sourceFileName,
        line: r,
        column: i
      };
  (0, er.maybeAddMapping)(this._map, {
    name: s,
    generated: t,
    source: (o = u) == null ? void 0 : o.source,
    original: u
  });
}
}
Bs.default = UI;
var Fs = {}, js = {};
Object.defineProperty(js, "__esModule", {
value: !0
});
js.default = void 0;
let VI = class {
constructor(t, r) {
  this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
    line: 1,
    column: 0
  }, this._sourcePosition = {
    identifierName: void 0,
    identifierNamePos: void 0,
    line: void 0,
    column: void 0,
    filename: void 0
  }, this._map = t, this._indentChar = r;
  for (let i = 0; i < 64; i++)
    this._fastIndentations.push(r.repeat(i));
  this._allocQueue();
}
_allocQueue() {
  const t = this._queue;
  for (let r = 0; r < 16; r++)
    t.push({
      char: 0,
      repeat: 1,
      line: void 0,
      column: void 0,
      identifierName: void 0,
      identifierNamePos: void 0,
      filename: ""
    });
}
_pushQueue(t, r, i, s, n) {
  const a = this._queueCursor;
  a === this._queue.length && this._allocQueue();
  const o = this._queue[a];
  o.char = t, o.repeat = r, o.line = i, o.column = s, o.filename = n, this._queueCursor++;
}
_popQueue() {
  if (this._queueCursor === 0)
    throw new Error("Cannot pop from empty queue");
  return this._queue[--this._queueCursor];
}
get() {
  this._flush();
  const t = this._map, r = {
    code: (this._buf + this._str).trimRight(),
    decodedMap: t == null ? void 0 : t.getDecoded(),
    get __mergedMap() {
      return this.map;
    },
    get map() {
      const i = t ? t.get() : null;
      return r.map = i, i;
    },
    set map(i) {
      Object.defineProperty(r, "map", {
        value: i,
        writable: !0
      });
    },
    get rawMappings() {
      const i = t == null ? void 0 : t.getRawMappings();
      return r.rawMappings = i, i;
    },
    set rawMappings(i) {
      Object.defineProperty(r, "rawMappings", {
        value: i,
        writable: !0
      });
    }
  };
  return r;
}
append(t, r) {
  this._flush(), this._append(t, this._sourcePosition, r);
}
appendChar(t) {
  this._flush(), this._appendChar(t, 1, this._sourcePosition);
}
queue(t) {
  if (t === 10)
    for (; this._queueCursor !== 0; ) {
      const i = this._queue[this._queueCursor - 1].char;
      if (i !== 32 && i !== 9)
        break;
      this._queueCursor--;
    }
  const r = this._sourcePosition;
  this._pushQueue(t, 1, r.line, r.column, r.filename);
}
queueIndentation(t) {
  t !== 0 && this._pushQueue(-1, t, void 0, void 0, void 0);
}
_flush() {
  const t = this._queueCursor, r = this._queue;
  for (let i = 0; i < t; i++) {
    const s = r[i];
    this._appendChar(s.char, s.repeat, s);
  }
  this._queueCursor = 0;
}
_appendChar(t, r, i) {
  if (this._last = t, t === -1) {
    const s = this._fastIndentations[r];
    s !== void 0 ? this._str += s : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
  } else
    this._str += r > 1 ? String.fromCharCode(t).repeat(r) : String.fromCharCode(t);
  t !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += r) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
}
_append(t, r, i) {
  const s = t.length, n = this._position;
  if (this._last = t.charCodeAt(s - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount = 0) : this._str += t, !i && !this._map) {
    n.column += s;
    return;
  }
  const {
    column: a,
    identifierName: o,
    identifierNamePos: u,
    filename: l
  } = r;
  let c = r.line;
  (o != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
  let f = t.indexOf(`
`), p = 0;
  for (f !== 0 && this._mark(c, a, o, u, l); f !== -1; )
    n.line++, n.column = 0, p = f + 1, p < s && c !== void 0 && this._mark(++c, 0, null, null, l), f = t.indexOf(`
`, p);
  n.column += s - p;
}
_mark(t, r, i, s, n) {
  var a;
  (a = this._map) == null || a.mark(this._position, t, r, i, s, n);
}
removeTrailingNewline() {
  const t = this._queueCursor;
  t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
}
removeLastSemicolon() {
  const t = this._queueCursor;
  t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
}
getLastChar() {
  const t = this._queueCursor;
  return t !== 0 ? this._queue[t - 1].char : this._last;
}
getNewlineCount() {
  const t = this._queueCursor;
  let r = 0;
  if (t === 0) return this._last === 10 ? 1 : 0;
  for (let i = t - 1; i >= 0 && this._queue[i].char === 10; i--)
    r++;
  return r === t && this._last === 10 ? r + 1 : r;
}
endsWithCharAndNewline() {
  const t = this._queue, r = this._queueCursor;
  if (r !== 0)
    return t[r - 1].char !== 10 ? void 0 : r > 1 ? t[r - 2].char : this._last;
}
hasContent() {
  return this._queueCursor !== 0 || !!this._last;
}
exactSource(t, r) {
  if (!this._map) {
    r();
    return;
  }
  this.source("start", t);
  const i = t.identifierName, s = this._sourcePosition;
  i && (this._canMarkIdName = !1, s.identifierName = i), r(), i && (this._canMarkIdName = !0, s.identifierName = void 0, s.identifierNamePos = void 0), this.source("end", t);
}
source(t, r) {
  this._map && this._normalizePosition(t, r, 0);
}
sourceWithOffset(t, r, i) {
  this._map && this._normalizePosition(t, r, i);
}
_normalizePosition(t, r, i) {
  const s = r[t], n = this._sourcePosition;
  s && (n.line = s.line, n.column = Math.max(s.column + i, 0), n.filename = r.filename);
}
getCurrentColumn() {
  const t = this._queue, r = this._queueCursor;
  let i = -1, s = 0;
  for (let n = 0; n < r; n++) {
    const a = t[n];
    a.char === 10 && (i = s), s += a.repeat;
  }
  return i === -1 ? this._position.column + s : s - 1 - i;
}
getCurrentLine() {
  let t = 0;
  const r = this._queue;
  for (let i = 0; i < this._queueCursor; i++)
    r[i].char === 10 && t++;
  return this._position.line + t;
}
};
js.default = VI;
var Lr = {}, Rs = {};
Object.defineProperty(Rs, "__esModule", {
value: !0
});
Rs.nodes = void 0;
var qI = Ce();
const {
FLIPPED_ALIAS_KEYS: $I,
isArrayExpression: KI,
isAssignmentExpression: Ac,
isBinary: Ic,
isBlockStatement: WI,
isCallExpression: Cc,
isFunction: Zr,
isIdentifier: cs,
isLiteral: JI,
isMemberExpression: _a,
isObjectExpression: YI,
isOptionalCallExpression: XI,
isOptionalMemberExpression: HI,
isStringLiteral: GI
} = qI;
function wr(e, t) {
return e && (_a(e) || HI(e) ? (wr(e.object, t), e.computed && wr(e.property, t)) : Ic(e) || Ac(e) ? (wr(e.left, t), wr(e.right, t)) : Cc(e) || XI(e) ? (t.hasCall = !0, wr(e.callee, t)) : Zr(e) ? t.hasFunction = !0 : cs(e) && (t.hasHelper = t.hasHelper || e.callee && Yt(e.callee))), t;
}
function Iu(e) {
return wr(e, {
  hasCall: !1,
  hasFunction: !1,
  hasHelper: !1
});
}
function Yt(e) {
return e ? _a(e) ? Yt(e.object) || Yt(e.property) : cs(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : Cc(e) ? Yt(e.callee) : Ic(e) || Ac(e) ? cs(e.left) && Yt(e.left) || Yt(e.right) : !1 : !1;
}
function zI(e) {
return JI(e) || YI(e) || KI(e) || cs(e) || _a(e);
}
const br = Rs.nodes = {
AssignmentExpression(e) {
  const t = Iu(e.right);
  if (t.hasCall && t.hasHelper || t.hasFunction)
    return t.hasFunction ? 3 : 2;
},
SwitchCase(e, t) {
  return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
},
LogicalExpression(e) {
  if (Zr(e.left) || Zr(e.right))
    return 2;
},
Literal(e) {
  if (GI(e) && e.value === "use strict")
    return 2;
},
CallExpression(e) {
  if (Zr(e.callee) || Yt(e))
    return 3;
},
OptionalCallExpression(e) {
  if (Zr(e.callee))
    return 3;
},
VariableDeclaration(e) {
  for (let t = 0; t < e.declarations.length; t++) {
    const r = e.declarations[t];
    let i = Yt(r.id) && !zI(r.init);
    if (!i && r.init) {
      const s = Iu(r.init);
      i = Yt(r.init) && s.hasCall || s.hasFunction;
    }
    if (i)
      return 3;
  }
},
IfStatement(e) {
  if (WI(e.consequent))
    return 3;
}
};
br.ObjectProperty = br.ObjectTypeProperty = br.ObjectMethod = function(e, t) {
if (t.properties[0] === e)
  return 1;
};
br.ObjectTypeCallProperty = function(e, t) {
var r;
if (t.callProperties[0] === e && !((r = t.properties) != null && r.length))
  return 1;
};
br.ObjectTypeIndexer = function(e, t) {
var r, i;
if (t.indexers[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length))
  return 1;
};
br.ObjectTypeInternalSlot = function(e, t) {
var r, i, s;
if (t.internalSlots[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length) && !((s = t.indexers) != null && s.length))
  return 1;
};
[["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([e, t]) {
[e].concat($I[e] || []).forEach(function(r) {
  const i = t ? 3 : 0;
  br[r] = () => i;
});
});
var Fe = {};
Object.defineProperty(Fe, "__esModule", {
value: !0
});
Fe.ArrowFunctionExpression = IC;
Fe.AssignmentExpression = wC;
Fe.Binary = dC;
Fe.BinaryExpression = xC;
Fe.ClassExpression = vC;
Fe.ConditionalExpression = Da;
Fe.DoExpression = hC;
Fe.FunctionExpression = AC;
Fe.FunctionTypeAnnotation = cC;
Fe.Identifier = OC;
Fe.LogicalExpression = NC;
Fe.NullableTypeAnnotation = lC;
Fe.ObjectExpression = pC;
Fe.OptionalIndexedAccessType = yC;
Fe.OptionalCallExpression = Fe.OptionalMemberExpression = CC;
Fe.SequenceExpression = EC;
Fe.TSTypeAssertion = Fe.TSSatisfiesExpression = Fe.TSAsExpression = bC;
Fe.TSInferType = gC;
Fe.TSInstantiationExpression = SC;
Fe.TSIntersectionType = Fe.TSUnionType = TC;
Fe.UnaryLike = Nc;
Fe.IntersectionTypeAnnotation = Fe.UnionTypeAnnotation = mC;
Fe.UpdateExpression = fC;
Fe.AwaitExpression = Fe.YieldExpression = PC;
var QI = Ce();
const {
isArrayTypeAnnotation: ZI,
isArrowFunctionExpression: eC,
isBinaryExpression: tC,
isCallExpression: rC,
isExportDeclaration: iC,
isForOfStatement: sC,
isIndexedAccessType: nC,
isMemberExpression: wc,
isObjectPattern: aC,
isOptionalMemberExpression: oC,
isYieldExpression: uC
} = QI, Cu = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
function ka(e) {
return e === "TSAsExpression" || e === "TSSatisfiesExpression" || e === "TSTypeAssertion";
}
const Us = (e, t) => {
const r = t.type;
return (r === "ClassDeclaration" || r === "ClassExpression") && t.superClass === e;
}, bi = (e, t) => {
const r = t.type;
return (r === "MemberExpression" || r === "OptionalMemberExpression") && t.object === e || (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression") && t.callee === e || r === "TaggedTemplateExpression" && t.tag === e || r === "TSNonNullExpression";
};
function lC(e, t) {
return ZI(t);
}
function cC(e, t, r) {
if (r.length < 3) return;
const i = t.type;
return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || i === "TypeAnnotation" && eC(r[r.length - 3]);
}
function fC(e, t) {
return bi(e, t) || Us(e, t);
}
function pC(e, t, r) {
return Ti(r, 3);
}
function hC(e, t, r) {
return !e.async && Ti(r, 1);
}
function dC(e, t) {
const r = t.type;
if (e.operator === "**" && r === "BinaryExpression" && t.operator === "**")
  return t.left === e;
if (Us(e, t) || bi(e, t) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
  return !0;
if (r === "BinaryExpression" || r === "LogicalExpression") {
  const i = Cu.get(t.operator), s = Cu.get(e.operator);
  if (i === s && t.right === e && r !== "LogicalExpression" || i > s)
    return !0;
}
}
function mC(e, t) {
const r = t.type;
return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
}
function yC(e, t) {
return nC(t) && t.objectType === e;
}
function bC() {
return !0;
}
function TC(e, t) {
const r = t.type;
return r === "TSArrayType" || r === "TSOptionalType" || r === "TSIntersectionType" || r === "TSUnionType" || r === "TSRestType";
}
function gC(e, t) {
const r = t.type;
return r === "TSArrayType" || r === "TSOptionalType";
}
function SC(e, t) {
const r = t.type;
return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!t.typeParameters;
}
function xC(e, t, r, i) {
return e.operator === "in" && i;
}
function EC(e, t) {
const r = t.type;
return !(r === "ForStatement" || r === "ThrowStatement" || r === "ReturnStatement" || r === "IfStatement" && t.test === e || r === "WhileStatement" && t.test === e || r === "ForInStatement" && t.right === e || r === "SwitchStatement" && t.discriminant === e || r === "ExpressionStatement" && t.expression === e);
}
function PC(e, t) {
const r = t.type;
return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || bi(e, t) || r === "AwaitExpression" && uC(e) || r === "ConditionalExpression" && e === t.test || Us(e, t) || ka(r);
}
function vC(e, t, r) {
return Ti(r, 5);
}
function Nc(e, t) {
return bi(e, t) || tC(t) && t.operator === "**" && t.left === e || Us(e, t);
}
function AC(e, t, r) {
return Ti(r, 5);
}
function IC(e, t) {
return iC(t) || Da(e, t);
}
function Da(e, t) {
const r = t.type;
return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalExpression" && t.test === e || r === "AwaitExpression" || ka(r) ? !0 : Nc(e, t);
}
function CC(e, t) {
return rC(t) && t.callee === e || wc(t) && t.object === e;
}
function wC(e, t) {
return aC(e.left) ? !0 : Da(e, t);
}
function NC(e, t) {
const r = t.type;
if (ka(r)) return !0;
if (r !== "LogicalExpression") return !1;
switch (e.operator) {
  case "||":
    return t.operator === "??" || t.operator === "&&";
  case "&&":
    return t.operator === "??";
  case "??":
    return t.operator !== "??";
}
}
function OC(e, t, r) {
var i;
const s = t.type;
if ((i = e.extra) != null && i.parenthesized && s === "AssignmentExpression" && t.left === e) {
  const n = t.right.type;
  if ((n === "FunctionExpression" || n === "ClassExpression") && t.right.id == null)
    return !0;
}
if (e.name === "let") {
  const n = wc(t, {
    object: e,
    computed: !0
  }) || oC(t, {
    object: e,
    computed: !0,
    optional: !1
  });
  return Ti(r, n ? 57 : 32);
}
return e.name === "async" && sC(t, {
  left: e,
  await: !1
});
}
function Ti(e, t) {
const r = t & 1, i = t & 2, s = t & 4, n = t & 8, a = t & 16, o = t & 32;
let u = e.length - 1;
if (u <= 0) return;
let l = e[u];
u--;
let c = e[u];
for (; u >= 0; ) {
  const f = c.type;
  if (r && f === "ExpressionStatement" && c.expression === l || s && f === "ExportDefaultDeclaration" && l === c.declaration || i && f === "ArrowFunctionExpression" && c.body === l || n && f === "ForStatement" && c.init === l || a && f === "ForInStatement" && c.left === l || o && f === "ForOfStatement" && c.left === l)
    return !0;
  if (u > 0 && (bi(l, c) && f !== "NewExpression" || f === "SequenceExpression" && c.expressions[0] === l || f === "UpdateExpression" && !c.prefix || f === "ConditionalExpression" && c.test === l || (f === "BinaryExpression" || f === "LogicalExpression") && c.left === l || f === "AssignmentExpression" && c.left === l))
    l = c, u--, c = e[u];
  else
    return !1;
}
return !1;
}
Object.defineProperty(Lr, "__esModule", {
value: !0
});
Lr.needsParens = KC;
Lr.needsWhitespace = La;
Lr.needsWhitespaceAfter = $C;
Lr.needsWhitespaceBefore = qC;
var _C = Rs, kC = Fe, DC = Ce();
const {
FLIPPED_ALIAS_KEYS: LC,
isCallExpression: Oc,
isDecorator: MC,
isExpressionStatement: BC,
isMemberExpression: FC,
isNewExpression: jC,
isParenthesizedExpression: RC
} = DC;
function _c(e) {
const t = /* @__PURE__ */ new Map();
function r(i, s) {
  const n = t.get(i);
  t.set(i, n ? function(a, o, u, l) {
    var c;
    return (c = n(a, o, u, l)) != null ? c : s(a, o, u, l);
  } : s);
}
for (const i of Object.keys(e)) {
  const s = LC[i];
  if (s)
    for (const n of s)
      r(n, e[i]);
  else
    r(i, e[i]);
}
return t;
}
const UC = _c(kC), VC = _c(_C.nodes);
function kc(e) {
return Oc(e) ? !0 : FC(e) && kc(e.object);
}
function La(e, t, r) {
var i;
if (!e) return !1;
BC(e) && (e = e.expression);
const s = (i = VC.get(e.type)) == null ? void 0 : i(e, t);
return typeof s == "number" ? (s & r) !== 0 : !1;
}
function qC(e, t) {
return La(e, t, 1);
}
function $C(e, t) {
return La(e, t, 2);
}
function KC(e, t, r, i) {
var s;
return t ? jC(t) && t.callee === e && kc(e) ? !0 : MC(t) ? !$n(e) && !(Oc(e) && $n(e.callee)) && !RC(e) : (s = UC.get(e.type)) == null ? void 0 : s(e, t, r, i) : !1;
}
function $n(e) {
switch (e.type) {
  case "Identifier":
    return !0;
  case "MemberExpression":
    return !e.computed && e.property.type === "Identifier" && $n(e.object);
  default:
    return !1;
}
}
var Dc = {}, gi = {};
Object.defineProperty(gi, "__esModule", {
value: !0
});
gi.TaggedTemplateExpression = WC;
gi.TemplateElement = JC;
gi.TemplateLiteral = YC;
function WC(e) {
this.print(e.tag, e), this.print(e.typeParameters, e), this.print(e.quasi, e);
}
function JC() {
throw new Error("TemplateElement printing is handled in TemplateLiteral");
}
function YC(e) {
const t = e.quasis;
let r = "`";
for (let i = 0; i < t.length; i++)
  r += t[i].value.raw, i + 1 < t.length && (this.token(r + "${", !0), this.print(e.expressions[i], e), r = "}");
this.token(r + "`", !0);
}
var Ue = {};
Object.defineProperty(Ue, "__esModule", {
value: !0
});
Ue.LogicalExpression = Ue.BinaryExpression = Ue.AssignmentExpression = bw;
Ue.AssignmentPattern = yw;
Ue.AwaitExpression = pw;
Ue.BindExpression = Tw;
Ue.CallExpression = cw;
Ue.ConditionalExpression = tw;
Ue.Decorator = ow;
Ue.DoExpression = QC;
Ue.EmptyStatement = dw;
Ue.ExpressionStatement = mw;
Ue.Import = fw;
Ue.MemberExpression = gw;
Ue.MetaProperty = Sw;
Ue.ModuleExpression = Pw;
Ue.NewExpression = rw;
Ue.OptionalCallExpression = lw;
Ue.OptionalMemberExpression = uw;
Ue.ParenthesizedExpression = ZC;
Ue.PrivateName = xw;
Ue.SequenceExpression = iw;
Ue.Super = nw;
Ue.ThisExpression = sw;
Ue.UnaryExpression = zC;
Ue.UpdateExpression = ew;
Ue.V8IntrinsicIdentifier = Ew;
Ue.YieldExpression = hw;
Ue._shouldPrintDecoratorsBeforeExport = aw;
var XC = Ce();
const {
isCallExpression: HC,
isLiteral: Lc,
isMemberExpression: Ma,
isNewExpression: GC
} = XC;
function zC(e) {
const {
  operator: t
} = e;
t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument, e);
}
function QC(e) {
e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body, e);
}
function ZC(e) {
this.tokenChar(40), this.print(e.expression, e), this.rightParens(e);
}
function ew(e) {
e.prefix ? (this.token(e.operator), this.print(e.argument, e)) : (this.printTerminatorless(e.argument, e, !0), this.token(e.operator));
}
function tw(e) {
this.print(e.test, e), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent, e), this.space(), this.tokenChar(58), this.space(), this.print(e.alternate, e);
}
function rw(e, t) {
if (this.word("new"), this.space(), this.print(e.callee, e), this.format.minified && e.arguments.length === 0 && !e.optional && !HC(t, {
  callee: e
}) && !Ma(t) && !GC(t))
  return;
this.print(e.typeArguments, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.tokenChar(40);
const r = this.enterForStatementInit(!1);
this.printList(e.arguments, e), r(), this.rightParens(e);
}
function iw(e) {
this.printList(e.expressions, e);
}
function sw() {
this.word("this");
}
function nw() {
this.word("super");
}
function aw(e) {
return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start === e.declaration.start;
}
function ow(e) {
this.tokenChar(64), this.print(e.expression, e), this.newline();
}
function uw(e) {
let {
  computed: t
} = e;
const {
  optional: r,
  property: i
} = e;
if (this.print(e.object, e), !t && Ma(i))
  throw new TypeError("Got a MemberExpression for MemberExpression property");
Lc(i) && typeof i.value == "number" && (t = !0), r && this.token("?."), t ? (this.tokenChar(91), this.print(i, e), this.tokenChar(93)) : (r || this.tokenChar(46), this.print(i, e));
}
function lw(e) {
this.print(e.callee, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.print(e.typeArguments, e), this.tokenChar(40);
const t = this.enterForStatementInit(!1);
this.printList(e.arguments, e), t(), this.rightParens(e);
}
function cw(e) {
this.print(e.callee, e), this.print(e.typeArguments, e), this.print(e.typeParameters, e), this.tokenChar(40);
const t = this.enterForStatementInit(!1);
this.printList(e.arguments, e), t(), this.rightParens(e);
}
function fw() {
this.word("import");
}
function pw(e) {
this.word("await"), e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
}
function hw(e) {
this.word("yield", !0), e.delegate ? (this.tokenChar(42), e.argument && (this.space(), this.print(e.argument, e))) : e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
}
function dw() {
this.semicolon(!0);
}
function mw(e) {
this.print(e.expression, e), this.semicolon();
}
function yw(e) {
this.print(e.left, e), e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation, e), this.space(), this.tokenChar(61), this.space(), this.print(e.right, e);
}
function bw(e) {
this.print(e.left, e), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) : this.token(e.operator), this.space(), this.print(e.right, e);
}
function Tw(e) {
this.print(e.object, e), this.token("::"), this.print(e.callee, e);
}
function gw(e) {
if (this.print(e.object, e), !e.computed && Ma(e.property))
  throw new TypeError("Got a MemberExpression for MemberExpression property");
let t = e.computed;
if (Lc(e.property) && typeof e.property.value == "number" && (t = !0), t) {
  const r = this.enterForStatementInit(!1);
  this.tokenChar(91), this.print(e.property, e), this.tokenChar(93), r();
} else
  this.tokenChar(46), this.print(e.property, e);
}
function Sw(e) {
this.print(e.meta, e), this.tokenChar(46), this.print(e.property, e);
}
function xw(e) {
this.tokenChar(35), this.print(e.id, e);
}
function Ew(e) {
this.tokenChar(37), this.word(e.name);
}
function Pw(e) {
this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
const {
  body: t
} = e;
(t.body.length || t.directives.length) && this.newline(), this.print(t, e), this.dedent(), this.rightBrace(e);
}
var Ze = {};
Object.defineProperty(Ze, "__esModule", {
value: !0
});
Ze.BreakStatement = Dw;
Ze.CatchClause = Rw;
Ze.ContinueStatement = Lw;
Ze.DebuggerStatement = qw;
Ze.DoWhileStatement = kw;
Ze.ForOfStatement = Ze.ForInStatement = void 0;
Ze.ForStatement = Ow;
Ze.IfStatement = Nw;
Ze.LabeledStatement = Fw;
Ze.ReturnStatement = Mw;
Ze.SwitchCase = Vw;
Ze.SwitchStatement = Uw;
Ze.ThrowStatement = Bw;
Ze.TryStatement = jw;
Ze.VariableDeclaration = $w;
Ze.VariableDeclarator = Kw;
Ze.WhileStatement = _w;
Ze.WithStatement = ww;
var vw = Ce();
const {
isFor: wu,
isForStatement: Aw,
isIfStatement: Iw,
isStatement: Cw
} = vw;
function ww(e) {
this.word("with"), this.space(), this.tokenChar(40), this.print(e.object, e), this.tokenChar(41), this.printBlock(e);
}
function Nw(e) {
this.word("if"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.space();
const t = e.alternate && Iw(Mc(e.consequent));
t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent, e), t && (this.dedent(), this.newline(), this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(e.alternate, e));
}
function Mc(e) {
const {
  body: t
} = e;
return Cw(t) === !1 ? e : Mc(t);
}
function Ow(e) {
this.word("for"), this.space(), this.tokenChar(40);
{
  const t = this.enterForStatementInit(!0);
  this.print(e.init, e), t();
}
this.tokenChar(59), e.test && (this.space(), this.print(e.test, e)), this.tokenChar(59), e.update && (this.space(), this.print(e.update, e)), this.tokenChar(41), this.printBlock(e);
}
function _w(e) {
this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.printBlock(e);
}
function Bc(e) {
this.word("for"), this.space();
const t = e.type === "ForOfStatement";
t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
{
  const r = t ? null : this.enterForStatementInit(!0);
  this.print(e.left, e), r == null || r();
}
this.space(), this.word(t ? "of" : "in"), this.space(), this.print(e.right, e), this.tokenChar(41), this.printBlock(e);
}
Ze.ForInStatement = Bc;
Ze.ForOfStatement = Bc;
function kw(e) {
this.word("do"), this.space(), this.print(e.body, e), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.semicolon();
}
function Vs(e, t, r, i) {
t && (e.space(), e.printTerminatorless(t, r, i)), e.semicolon();
}
function Dw(e) {
this.word("break"), Vs(this, e.label, e, !0);
}
function Lw(e) {
this.word("continue"), Vs(this, e.label, e, !0);
}
function Mw(e) {
this.word("return"), Vs(this, e.argument, e, !1);
}
function Bw(e) {
this.word("throw"), Vs(this, e.argument, e, !1);
}
function Fw(e) {
this.print(e.label, e), this.tokenChar(58), this.space(), this.print(e.body, e);
}
function jw(e) {
this.word("try"), this.space(), this.print(e.block, e), this.space(), e.handlers ? this.print(e.handlers[0], e) : this.print(e.handler, e), e.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e.finalizer, e));
}
function Rw(e) {
this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param, e), this.print(e.param.typeAnnotation, e), this.tokenChar(41), this.space()), this.print(e.body, e);
}
function Uw(e) {
this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant, e), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(e.cases, e, {
  indent: !0,
  addNewlines(t, r) {
    if (!t && e.cases[e.cases.length - 1] === r) return -1;
  }
}), this.rightBrace(e);
}
function Vw(e) {
e.test ? (this.word("case"), this.space(), this.print(e.test, e), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.length && (this.newline(), this.printSequence(e.consequent, e, {
  indent: !0
}));
}
function qw() {
this.word("debugger"), this.semicolon();
}
function $w(e, t) {
e.declare && (this.word("declare"), this.space());
const {
  kind: r
} = e;
r === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(r, r === "using"), this.space();
let i = !1;
if (!wu(t))
  for (const s of e.declarations)
    s.init && (i = !0);
if (this.printList(e.declarations, e, {
  separator: i ? function() {
    this.tokenChar(44), this.newline();
  } : void 0,
  indent: e.declarations.length > 1
}), wu(t)) {
  if (Aw(t)) {
    if (t.init === e) return;
  } else if (t.left === e) return;
}
this.semicolon();
}
function Kw(e) {
this.print(e.id, e), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation, e), e.init && (this.space(), this.tokenChar(61), this.space(), this.print(e.init, e));
}
var Ct = {};
Object.defineProperty(Ct, "__esModule", {
value: !0
});
Ct.ClassAccessorProperty = zw;
Ct.ClassBody = Hw;
Ct.ClassExpression = Ct.ClassDeclaration = Xw;
Ct.ClassMethod = Zw;
Ct.ClassPrivateMethod = e6;
Ct.ClassPrivateProperty = Qw;
Ct.ClassProperty = Gw;
Ct.StaticBlock = r6;
Ct._classMethodHead = t6;
var Ww = Ce();
const {
isExportDefaultDeclaration: Jw,
isExportNamedDeclaration: Yw
} = Ww;
function Xw(e, t) {
(!(Jw(t) || Yw(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators, e), e.declare && (this.word("declare"), this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id, e)), this.print(e.typeParameters, e), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass, e), this.print(e.superTypeParameters, e)), e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e)), this.space(), this.print(e.body, e);
}
function Hw(e) {
if (this.tokenChar(123), e.body.length === 0)
  this.tokenChar(125);
else {
  this.newline();
  const t = this.enterForStatementInit(!1);
  this.printSequence(e.body, e, {
    indent: !0
  }), t(), this.endsWith(10) || this.newline(), this.rightBrace(e);
}
}
function Gw(e) {
var t;
this.printJoin(e.decorators, e);
const r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function zw(e) {
var t;
this.printJoin(e.decorators, e);
const r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function Qw(e) {
this.printJoin(e.decorators, e), e.static && (this.word("static"), this.space()), this.print(e.key, e), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function Zw(e) {
this._classMethodHead(e), this.space(), this.print(e.body, e);
}
function e6(e) {
this._classMethodHead(e), this.space(), this.print(e.body, e);
}
function t6(e) {
var t;
this.printJoin(e.decorators, e);
const r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this._methodHead(e);
}
function r6(e) {
this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(e.body, e, {
  indent: !0
}), this.rightBrace(e));
}
var kt = {};
Object.defineProperty(kt, "__esModule", {
value: !0
});
kt.ArrowFunctionExpression = p6;
kt.FunctionDeclaration = kt.FunctionExpression = f6;
kt._functionHead = c6;
kt._methodHead = u6;
kt._param = o6;
kt._parameters = a6;
kt._params = n6;
kt._predicate = l6;
var i6 = Ce();
const {
isIdentifier: s6
} = i6;
function n6(e, t, r) {
this.print(e.typeParameters, e);
const i = d6.call(this, t, r);
i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(e.params, e), this.tokenChar(41);
const s = e.type === "ArrowFunctionExpression";
this.print(e.returnType, e, s), this._noLineTerminator = s;
}
function a6(e, t) {
const r = this.enterForStatementInit(!1), i = e.length;
for (let s = 0; s < i; s++)
  this._param(e[s], t), s < e.length - 1 && (this.tokenChar(44), this.space());
r();
}
function o6(e, t) {
this.printJoin(e.decorators, e), this.print(e, t), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
}
function u6(e) {
const t = e.kind, r = e.key;
(t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t === "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(r, e), this.tokenChar(93)) : this.print(r, e), e.optional && this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key, void 0);
}
function l6(e, t) {
e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, e, t));
}
function c6(e, t) {
e.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), e.generator && (this._endsWithInnerRaw = !1, this.tokenChar(42)), this.space(), e.id && this.print(e.id, e), this._params(e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(e);
}
function f6(e, t) {
this._functionHead(e, t), this.space(), this.print(e.body, e);
}
function p6(e, t) {
e.async && (this.word("async", !0), this.space());
let r;
!this.format.retainLines && e.params.length === 1 && s6(r = e.params[0]) && !h6(e, r) ? this.print(r, e, !0) : this._params(e, void 0, t), this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(e.body, e);
}
function h6(e, t) {
var r, i;
return !!(e.typeParameters || e.returnType || e.predicate || t.typeAnnotation || t.optional || (r = t.leadingComments) != null && r.length || (i = t.trailingComments) != null && i.length);
}
function d6(e, t) {
let r = e;
if (!r && t) {
  const u = t.type;
  u === "VariableDeclarator" ? r = t.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = t.left : u === "ObjectProperty" || u === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (r = t.key) : (u === "ClassPrivateProperty" || u === "ClassAccessorProperty") && (r = t.key);
}
if (!r) return;
let i;
if (r.type === "Identifier") {
  var s, n;
  i = {
    pos: (s = r.loc) == null ? void 0 : s.start,
    name: ((n = r.loc) == null ? void 0 : n.identifierName) || r.name
  };
} else if (r.type === "PrivateName") {
  var a;
  i = {
    pos: (a = r.loc) == null ? void 0 : a.start,
    name: "#" + r.id.name
  };
} else if (r.type === "StringLiteral") {
  var o;
  i = {
    pos: (o = r.loc) == null ? void 0 : o.start,
    name: r.value
  };
}
return i;
}
var dt = {};
Object.defineProperty(dt, "__esModule", {
value: !0
});
dt.ExportAllDeclaration = C6;
dt.ExportDefaultDeclaration = N6;
dt.ExportDefaultSpecifier = P6;
dt.ExportNamedDeclaration = w6;
dt.ExportNamespaceSpecifier = A6;
dt.ExportSpecifier = v6;
dt.ImportAttribute = _6;
dt.ImportDeclaration = O6;
dt.ImportDefaultSpecifier = E6;
dt.ImportExpression = D6;
dt.ImportNamespaceSpecifier = k6;
dt.ImportSpecifier = x6;
dt._printAttributes = I6;
var m6 = Ce();
const {
isClassDeclaration: y6,
isExportDefaultSpecifier: b6,
isExportNamespaceSpecifier: T6,
isImportDefaultSpecifier: g6,
isImportNamespaceSpecifier: S6,
isStatement: Fc
} = m6;
function x6(e) {
(e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported, e), e.local && e.local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local, e));
}
function E6(e) {
this.print(e.local, e);
}
function P6(e) {
this.print(e.exported, e);
}
function v6(e) {
e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local, e), e.exported && e.local.name !== e.exported.name && (this.space(), this.word("as"), this.space(), this.print(e.exported, e));
}
function A6(e) {
this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported, e);
}
let Nu = !1;
function I6(e) {
const {
  importAttributesKeyword: t
} = this.format, {
  attributes: r,
  assertions: i
} = e;
r && !t && !Nu && (Nu = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
const s = t === "assert" || !t && i;
if (this.word(s ? "assert" : "with"), this.space(), !s && t !== "with") {
  this.printList(r || i, e);
  return;
}
this.tokenChar(123), this.space(), this.printList(r || i, e), this.space(), this.tokenChar(125);
}
function C6(e) {
var t, r;
this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
}
function jc(e, t) {
y6(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators, t);
}
function w6(e) {
if (jc(this, e), this.word("export"), this.space(), e.declaration) {
  const i = e.declaration;
  this.print(i, e), Fc(i) || this.semicolon();
} else {
  e.exportKind === "type" && (this.word("type"), this.space());
  const i = e.specifiers.slice(0);
  let s = !1;
  for (; ; ) {
    const n = i[0];
    if (b6(n) || T6(n))
      s = !0, this.print(i.shift(), e), i.length && (this.tokenChar(44), this.space());
    else
      break;
  }
  if ((i.length || !i.length && !s) && (this.tokenChar(123), i.length && (this.space(), this.printList(i, e), this.space()), this.tokenChar(125)), e.source) {
    var t, r;
    this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e);
  }
  this.semicolon();
}
}
function N6(e) {
jc(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
const t = e.declaration;
this.print(t, e), Fc(t) || this.semicolon();
}
function O6(e) {
var t, r;
this.word("import"), this.space();
const i = e.importKind === "type" || e.importKind === "typeof";
i ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module ? (this.noIndentInnerCommentsHere(), this.word("module"), this.space()) : e.phase && (this.noIndentInnerCommentsHere(), this.word(e.phase), this.space());
const s = e.specifiers.slice(0), n = !!s.length;
for (; n; ) {
  const a = s[0];
  if (g6(a) || S6(a))
    this.print(s.shift(), e), s.length && (this.tokenChar(44), this.space());
  else
    break;
}
s.length ? (this.tokenChar(123), this.space(), this.printList(s, e), this.space(), this.tokenChar(125)) : i && !n && (this.tokenChar(123), this.tokenChar(125)), (n || i) && (this.space(), this.word("from"), this.space()), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
}
function _6(e) {
this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
}
function k6(e) {
this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local, e);
}
function D6(e) {
this.word("import"), e.phase && (this.tokenChar(46), this.word(e.phase)), this.tokenChar(40), this.print(e.source, e), e.options != null && (this.tokenChar(44), this.space(), this.print(e.options, e)), this.tokenChar(41);
}
var Xe = {};
const Rc = {}, L6 = Rc.hasOwnProperty, Uc = (e, t) => {
for (const r in e)
  L6.call(e, r) && t(r, e[r]);
}, M6 = (e, t) => (t && Uc(t, (r, i) => {
e[r] = i;
}), e), B6 = (e, t) => {
const r = e.length;
let i = -1;
for (; ++i < r; )
  t(e[i]);
}, Si = Rc.toString, F6 = Array.isArray, j6 = Buffer.isBuffer, R6 = (e) => Si.call(e) == "[object Object]", U6 = (e) => typeof e == "string" || Si.call(e) == "[object String]", V6 = (e) => typeof e == "number" || Si.call(e) == "[object Number]", q6 = (e) => typeof e == "function", $6 = (e) => Si.call(e) == "[object Map]", K6 = (e) => Si.call(e) == "[object Set]", W6 = {
'"': '\\"',
"'": "\\'",
"\\": "\\\\",
"\b": "\\b",
"\f": "\\f",
"\n": "\\n",
"\r": "\\r",
"	": "\\t"
// `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
// '\v': '\\x0B'
}, J6 = /["'\\\b\f\n\r\t]/, Y6 = /[0-9]/, X6 = /[ !#-&\(-\[\]-_a-~]/, sr = (e, t) => {
const r = () => {
  l = u, ++t.indentLevel, u = t.indent.repeat(t.indentLevel);
}, i = {
  escapeEverything: !1,
  minimal: !1,
  isScriptContext: !1,
  quotes: "single",
  wrap: !1,
  es6: !1,
  json: !1,
  compact: !0,
  lowercaseHex: !1,
  numbers: "decimal",
  indent: "	",
  indentLevel: 0,
  __inline1__: !1,
  __inline2__: !1
}, s = t && t.json;
s && (i.quotes = "double", i.wrap = !0), t = M6(i, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes = "single");
const n = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'", a = t.compact, o = t.lowercaseHex;
let u = t.indent.repeat(t.indentLevel), l = "";
const c = t.__inline1__, f = t.__inline2__, p = a ? "" : `
`;
let h, y = !0;
const g = t.numbers == "binary", A = t.numbers == "octal", C = t.numbers == "decimal", _ = t.numbers == "hexadecimal";
if (s && e && q6(e.toJSON) && (e = e.toJSON()), !U6(e)) {
  if ($6(e))
    return e.size == 0 ? "new Map()" : (a || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + sr(Array.from(e), t) + ")");
  if (K6(e))
    return e.size == 0 ? "new Set()" : "new Set(" + sr(Array.from(e), t) + ")";
  if (j6(e))
    return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + sr(Array.from(e), t) + ")";
  if (F6(e))
    return h = [], t.wrap = !0, c && (t.__inline1__ = !1, t.__inline2__ = !0), f || r(), B6(e, (re) => {
      y = !1, f && (t.__inline2__ = !1), h.push(
        (a || f ? "" : u) + sr(re, t)
      );
    }), y ? "[]" : f ? "[" + h.join(", ") + "]" : "[" + p + h.join("," + p) + p + (a ? "" : l) + "]";
  if (V6(e)) {
    if (s)
      return JSON.stringify(e);
    if (C)
      return String(e);
    if (_) {
      let re = e.toString(16);
      return o || (re = re.toUpperCase()), "0x" + re;
    }
    if (g)
      return "0b" + e.toString(2);
    if (A)
      return "0o" + e.toString(8);
  } else return R6(e) ? (h = [], t.wrap = !0, r(), Uc(e, (re, oe) => {
    y = !1, h.push(
      (a ? "" : u) + sr(re, t) + ":" + (a ? "" : " ") + sr(oe, t)
    );
  }), y ? "{}" : "{" + p + h.join("," + p) + p + (a ? "" : l) + "}") : s ? JSON.stringify(e) || "null" : String(e);
}
const j = e;
let G = -1;
const fe = j.length;
for (h = ""; ++G < fe; ) {
  const re = j.charAt(G);
  if (t.es6) {
    const W = j.charCodeAt(G);
    if (
      // check if it’s the start of a surrogate pair
      W >= 55296 && W <= 56319 && // high surrogate
      fe > G + 1
    ) {
      const Q = j.charCodeAt(G + 1);
      if (Q >= 56320 && Q <= 57343) {
        let L = ((W - 55296) * 1024 + Q - 56320 + 65536).toString(16);
        o || (L = L.toUpperCase()), h += "\\u{" + L + "}", ++G;
        continue;
      }
    }
  }
  if (!t.escapeEverything) {
    if (X6.test(re)) {
      h += re;
      continue;
    }
    if (re == '"') {
      h += n == re ? '\\"' : re;
      continue;
    }
    if (re == "`") {
      h += n == re ? "\\`" : re;
      continue;
    }
    if (re == "'") {
      h += n == re ? "\\'" : re;
      continue;
    }
  }
  if (re == "\0" && !s && !Y6.test(j.charAt(G + 1))) {
    h += "\\0";
    continue;
  }
  if (J6.test(re)) {
    h += W6[re];
    continue;
  }
  const oe = re.charCodeAt(0);
  if (t.minimal && oe != 8232 && oe != 8233) {
    h += re;
    continue;
  }
  let K = oe.toString(16);
  o || (K = K.toUpperCase());
  const X = K.length > 2 || s, ie = "\\" + (X ? "u" : "x") + ("0000" + K).slice(X ? -4 : -2);
  h += ie;
}
return t.wrap && (h = n + h + n), n == "`" && (h = h.replace(/\$\{/g, "\\${")), t.isScriptContext ? h.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, s ? "\\u003C!--" : "\\x3C!--") : h;
};
sr.version = "2.5.2";
var H6 = sr;
Object.defineProperty(Xe, "__esModule", {
value: !0
});
Xe.ArgumentPlaceholder = Z6;
Xe.ArrayPattern = Xe.ArrayExpression = sN;
Xe.BigIntLiteral = pN;
Xe.BooleanLiteral = uN;
Xe.DecimalLiteral = hN;
Xe.Identifier = Q6;
Xe.NullLiteral = lN;
Xe.NumericLiteral = cN;
Xe.ObjectPattern = Xe.ObjectExpression = tN;
Xe.ObjectMethod = rN;
Xe.ObjectProperty = iN;
Xe.PipelineBareFunction = yN;
Xe.PipelinePrimaryTopicReference = bN;
Xe.PipelineTopicExpression = mN;
Xe.RecordExpression = nN;
Xe.RegExpLiteral = oN;
Xe.SpreadElement = Xe.RestElement = eN;
Xe.StringLiteral = fN;
Xe.TopicReference = dN;
Xe.TupleExpression = aN;
var G6 = Ce(), Vc = H6;
const {
isAssignmentPattern: z6,
isIdentifier: pn
} = G6;
function Q6(e) {
var t;
this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(e.name);
}
function Z6() {
this.tokenChar(63);
}
function eN(e) {
this.token("..."), this.print(e.argument, e);
}
function tN(e) {
const t = e.properties;
if (this.tokenChar(123), t.length) {
  const r = this.enterForStatementInit(!1);
  this.space(), this.printList(t, e, {
    indent: !0,
    statement: !0
  }), this.space(), r();
}
this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
}
function rN(e) {
this.printJoin(e.decorators, e), this._methodHead(e), this.space(), this.print(e.body, e);
}
function iN(e) {
if (this.printJoin(e.decorators, e), e.computed)
  this.tokenChar(91), this.print(e.key, e), this.tokenChar(93);
else {
  if (z6(e.value) && pn(e.key) && e.key.name === e.value.left.name) {
    this.print(e.value, e);
    return;
  }
  if (this.print(e.key, e), e.shorthand && pn(e.key) && pn(e.value) && e.key.name === e.value.name)
    return;
}
this.tokenChar(58), this.space(), this.print(e.value, e);
}
function sN(e) {
const t = e.elements, r = t.length;
this.tokenChar(91);
const i = this.enterForStatementInit(!1);
for (let s = 0; s < t.length; s++) {
  const n = t[s];
  n ? (s > 0 && this.space(), this.print(n, e), s < r - 1 && this.tokenChar(44)) : this.tokenChar(44);
}
i(), this.tokenChar(93);
}
function nN(e) {
const t = e.properties;
let r, i;
if (this.format.recordAndTupleSyntaxType === "bar")
  r = "{|", i = "|}";
else {
  if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
    throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
  r = "#{", i = "}";
}
this.token(r), t.length && (this.space(), this.printList(t, e, {
  indent: !0,
  statement: !0
}), this.space()), this.token(i);
}
function aN(e) {
const t = e.elements, r = t.length;
let i, s;
if (this.format.recordAndTupleSyntaxType === "bar")
  i = "[|", s = "|]";
else if (this.format.recordAndTupleSyntaxType === "hash")
  i = "#[", s = "]";
else
  throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
this.token(i);
for (let n = 0; n < t.length; n++) {
  const a = t[n];
  a && (n > 0 && this.space(), this.print(a, e), n < r - 1 && this.tokenChar(44));
}
this.token(s);
}
function oN(e) {
this.word(`/${e.pattern}/${e.flags}`);
}
function uN(e) {
this.word(e.value ? "true" : "false");
}
function lN() {
this.word("null");
}
function cN(e) {
const t = this.getPossibleRaw(e), r = this.format.jsescOption, i = e.value, s = i + "";
r.numbers ? this.number(Vc(i, r), i) : t == null ? this.number(s, i) : this.format.minified ? this.number(t.length < s.length ? t : s, i) : this.number(t, i);
}
function fN(e) {
const t = this.getPossibleRaw(e);
if (!this.format.minified && t !== void 0) {
  this.token(t);
  return;
}
const r = Vc(e.value, this.format.jsescOption);
this.token(r);
}
function pN(e) {
const t = this.getPossibleRaw(e);
if (!this.format.minified && t !== void 0) {
  this.word(t);
  return;
}
this.word(e.value + "n");
}
function hN(e) {
const t = this.getPossibleRaw(e);
if (!this.format.minified && t !== void 0) {
  this.word(t);
  return;
}
this.word(e.value + "m");
}
const Ou = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
function dN() {
const {
  topicToken: e
} = this.format;
if (Ou.has(e))
  this.token(e);
else {
  const t = JSON.stringify(e), r = Array.from(Ou, (i) => JSON.stringify(i));
  throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${t} received instead).`);
}
}
function mN(e) {
this.print(e.expression, e);
}
function yN(e) {
this.print(e.callee, e);
}
function bN() {
this.tokenChar(35);
}
var qc = {};
(function(e) {
Object.defineProperty(e, "__esModule", {
  value: !0
}), e.AnyTypeAnnotation = a, e.ArrayTypeAnnotation = o, e.BooleanLiteralTypeAnnotation = l, e.BooleanTypeAnnotation = u, e.DeclareClass = f, e.DeclareExportAllDeclaration = re, e.DeclareExportDeclaration = fe, e.DeclareFunction = p, e.DeclareInterface = g, e.DeclareModule = A, e.DeclareModuleExports = C, e.DeclareOpaqueType = j, e.DeclareTypeAlias = _, e.DeclareVariable = G, e.DeclaredPredicate = y, e.EmptyTypeAnnotation = Pe, e.EnumBooleanBody = ie, e.EnumBooleanMember = F, e.EnumDeclaration = oe, e.EnumDefaultedMember = L, e.EnumNumberBody = W, e.EnumNumberMember = B, e.EnumStringBody = Q, e.EnumStringMember = O, e.EnumSymbolBody = U, e.ExistsTypeAnnotation = R, e.FunctionTypeAnnotation = q, e.FunctionTypeParam = V, e.IndexedAccessType = nt, e.InferredPredicate = h, e.InterfaceDeclaration = qe, e.GenericTypeAnnotation = e.ClassImplements = e.InterfaceExtends = H, e.InterfaceTypeAnnotation = he, e.IntersectionTypeAnnotation = Ee, e.MixedTypeAnnotation = we, e.NullLiteralTypeAnnotation = c, e.NullableTypeAnnotation = ke, Object.defineProperty(e, "NumberLiteralTypeAnnotation", {
  enumerable: !0,
  get: function() {
    return i.NumericLiteral;
  }
}), e.NumberTypeAnnotation = De, e.ObjectTypeAnnotation = d, e.ObjectTypeCallProperty = N, e.ObjectTypeIndexer = M, e.ObjectTypeInternalSlot = P, e.ObjectTypeProperty = Z, e.ObjectTypeSpreadProperty = ee, e.OpaqueType = J, e.OptionalIndexedAccessType = St, e.QualifiedTypeIdentifier = Se, Object.defineProperty(e, "StringLiteralTypeAnnotation", {
  enumerable: !0,
  get: function() {
    return i.StringLiteral;
  }
}), e.StringTypeAnnotation = Je, e.SymbolTypeAnnotation = Ae, e.ThisTypeAnnotation = it, e.TupleTypeAnnotation = ve, e.TypeAlias = Ie, e.TypeAnnotation = Ve, e.TypeCastExpression = st, e.TypeParameter = ze, e.TypeParameterDeclaration = e.TypeParameterInstantiation = ht, e.TypeofTypeAnnotation = je, e.UnionTypeAnnotation = Y, e.Variance = Ke, e.VoidTypeAnnotation = Ye, e._interfaceish = ne, e._variance = ue;
var t = Ce(), r = dt, i = Xe;
const {
  isDeclareExportDeclaration: s,
  isStatement: n
} = t;
function a() {
  this.word("any");
}
function o(v) {
  this.print(v.elementType, v, !0), this.tokenChar(91), this.tokenChar(93);
}
function u() {
  this.word("boolean");
}
function l(v) {
  this.word(v.value ? "true" : "false");
}
function c() {
  this.word("null");
}
function f(v, de) {
  s(de) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(v);
}
function p(v, de) {
  s(de) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(v.id, v), this.print(v.id.typeAnnotation.typeAnnotation, v), v.predicate && (this.space(), this.print(v.predicate, v)), this.semicolon();
}
function h() {
  this.tokenChar(37), this.word("checks");
}
function y(v) {
  this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(v.value, v), this.tokenChar(41);
}
function g(v) {
  this.word("declare"), this.space(), this.InterfaceDeclaration(v);
}
function A(v) {
  this.word("declare"), this.space(), this.word("module"), this.space(), this.print(v.id, v), this.space(), this.print(v.body, v);
}
function C(v) {
  this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(v.typeAnnotation, v);
}
function _(v) {
  this.word("declare"), this.space(), this.TypeAlias(v);
}
function j(v, de) {
  s(de) || (this.word("declare"), this.space()), this.OpaqueType(v);
}
function G(v, de) {
  s(de) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(v.id, v), this.print(v.id.typeAnnotation, v), this.semicolon();
}
function fe(v) {
  this.word("declare"), this.space(), this.word("export"), this.space(), v.default && (this.word("default"), this.space()), D.call(this, v);
}
function re(v) {
  this.word("declare"), this.space(), r.ExportAllDeclaration.call(this, v);
}
function oe(v) {
  const {
    id: de,
    body: Re
  } = v;
  this.word("enum"), this.space(), this.print(de, v), this.print(Re, v);
}
function K(v, de, Re) {
  Re && (v.space(), v.word("of"), v.space(), v.word(de)), v.space();
}
function X(v, de) {
  const {
    members: Re
  } = de;
  v.token("{"), v.indent(), v.newline();
  for (const At of Re)
    v.print(At, de), v.newline();
  de.hasUnknownMembers && (v.token("..."), v.newline()), v.dedent(), v.token("}");
}
function ie(v) {
  const {
    explicitType: de
  } = v;
  K(this, "boolean", de), X(this, v);
}
function W(v) {
  const {
    explicitType: de
  } = v;
  K(this, "number", de), X(this, v);
}
function Q(v) {
  const {
    explicitType: de
  } = v;
  K(this, "string", de), X(this, v);
}
function U(v) {
  K(this, "symbol", !0), X(this, v);
}
function L(v) {
  const {
    id: de
  } = v;
  this.print(de, v), this.tokenChar(44);
}
function k(v, de) {
  const {
    id: Re,
    init: At
  } = de;
  v.print(Re, de), v.space(), v.token("="), v.space(), v.print(At, de), v.token(",");
}
function F(v) {
  k(this, v);
}
function B(v) {
  k(this, v);
}
function O(v) {
  k(this, v);
}
function D(v) {
  if (v.declaration) {
    const de = v.declaration;
    this.print(de, v), n(de) || this.semicolon();
  } else
    this.tokenChar(123), v.specifiers.length && (this.space(), this.printList(v.specifiers, v), this.space()), this.tokenChar(125), v.source && (this.space(), this.word("from"), this.space(), this.print(v.source, v)), this.semicolon();
}
function R() {
  this.tokenChar(42);
}
function q(v, de) {
  this.print(v.typeParameters, v), this.tokenChar(40), v.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(v.this.typeAnnotation, v), (v.params.length || v.rest) && (this.tokenChar(44), this.space())), this.printList(v.params, v), v.rest && (v.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(v.rest, v)), this.tokenChar(41);
  const Re = de == null ? void 0 : de.type;
  Re != null && (Re === "ObjectTypeCallProperty" || Re === "ObjectTypeInternalSlot" || Re === "DeclareFunction" || Re === "ObjectTypeProperty" && de.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(v.returnType, v);
}
function V(v) {
  this.print(v.name, v), v.optional && this.tokenChar(63), v.name && (this.tokenChar(58), this.space()), this.print(v.typeAnnotation, v);
}
function H(v) {
  this.print(v.id, v), this.print(v.typeParameters, v, !0);
}
function ne(v) {
  var de;
  if (this.print(v.id, v), this.print(v.typeParameters, v), (de = v.extends) != null && de.length && (this.space(), this.word("extends"), this.space(), this.printList(v.extends, v)), v.type === "DeclareClass") {
    var Re, At;
    (Re = v.mixins) != null && Re.length && (this.space(), this.word("mixins"), this.space(), this.printList(v.mixins, v)), (At = v.implements) != null && At.length && (this.space(), this.word("implements"), this.space(), this.printList(v.implements, v));
  }
  this.space(), this.print(v.body, v);
}
function ue(v) {
  var de;
  const Re = (de = v.variance) == null ? void 0 : de.kind;
  Re != null && (Re === "plus" ? this.tokenChar(43) : Re === "minus" && this.tokenChar(45));
}
function qe(v) {
  this.word("interface"), this.space(), this._interfaceish(v);
}
function pe() {
  this.space(), this.tokenChar(38), this.space();
}
function he(v) {
  var de;
  this.word("interface"), (de = v.extends) != null && de.length && (this.space(), this.word("extends"), this.space(), this.printList(v.extends, v)), this.space(), this.print(v.body, v);
}
function Ee(v) {
  this.printJoin(v.types, v, {
    separator: pe
  });
}
function we() {
  this.word("mixed");
}
function Pe() {
  this.word("empty");
}
function ke(v) {
  this.tokenChar(63), this.print(v.typeAnnotation, v);
}
function De() {
  this.word("number");
}
function Je() {
  this.word("string");
}
function it() {
  this.word("this");
}
function ve(v) {
  this.tokenChar(91), this.printList(v.types, v), this.tokenChar(93);
}
function je(v) {
  this.word("typeof"), this.space(), this.print(v.argument, v);
}
function Ie(v) {
  this.word("type"), this.space(), this.print(v.id, v), this.print(v.typeParameters, v), this.space(), this.tokenChar(61), this.space(), this.print(v.right, v), this.semicolon();
}
function Ve(v) {
  this.tokenChar(58), this.space(), v.optional && this.tokenChar(63), this.print(v.typeAnnotation, v);
}
function ht(v) {
  this.tokenChar(60), this.printList(v.params, v, {}), this.tokenChar(62);
}
function ze(v) {
  this._variance(v), this.word(v.name), v.bound && this.print(v.bound, v), v.default && (this.space(), this.tokenChar(61), this.space(), this.print(v.default, v));
}
function J(v) {
  this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(v.id, v), this.print(v.typeParameters, v), v.supertype && (this.tokenChar(58), this.space(), this.print(v.supertype, v)), v.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(v.impltype, v)), this.semicolon();
}
function d(v) {
  v.exact ? this.token("{|") : this.tokenChar(123);
  const de = [...v.properties, ...v.callProperties || [], ...v.indexers || [], ...v.internalSlots || []];
  de.length && (this.newline(), this.space(), this.printJoin(de, v, {
    addNewlines(Re) {
      if (Re && !de[0]) return 1;
    },
    indent: !0,
    statement: !0,
    iterator: () => {
      (de.length !== 1 || v.inexact) && (this.tokenChar(44), this.space());
    }
  }), this.space()), v.inexact && (this.indent(), this.token("..."), de.length && this.newline(), this.dedent()), v.exact ? this.token("|}") : this.tokenChar(125);
}
function P(v) {
  v.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(v.id, v), this.tokenChar(93), this.tokenChar(93), v.optional && this.tokenChar(63), v.method || (this.tokenChar(58), this.space()), this.print(v.value, v);
}
function N(v) {
  v.static && (this.word("static"), this.space()), this.print(v.value, v);
}
function M(v) {
  v.static && (this.word("static"), this.space()), this._variance(v), this.tokenChar(91), v.id && (this.print(v.id, v), this.tokenChar(58), this.space()), this.print(v.key, v), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(v.value, v);
}
function Z(v) {
  v.proto && (this.word("proto"), this.space()), v.static && (this.word("static"), this.space()), (v.kind === "get" || v.kind === "set") && (this.word(v.kind), this.space()), this._variance(v), this.print(v.key, v), v.optional && this.tokenChar(63), v.method || (this.tokenChar(58), this.space()), this.print(v.value, v);
}
function ee(v) {
  this.token("..."), this.print(v.argument, v);
}
function Se(v) {
  this.print(v.qualification, v), this.tokenChar(46), this.print(v.id, v);
}
function Ae() {
  this.word("symbol");
}
function Te() {
  this.space(), this.tokenChar(124), this.space();
}
function Y(v) {
  this.printJoin(v.types, v, {
    separator: Te
  });
}
function st(v) {
  this.tokenChar(40), this.print(v.expression, v), this.print(v.typeAnnotation, v), this.tokenChar(41);
}
function Ke(v) {
  v.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
}
function Ye() {
  this.word("void");
}
function nt(v) {
  this.print(v.objectType, v, !0), this.tokenChar(91), this.print(v.indexType, v), this.tokenChar(93);
}
function St(v) {
  this.print(v.objectType, v), v.optional && this.token("?."), this.tokenChar(91), this.print(v.indexType, v), this.tokenChar(93);
}
})(qc);
var Zt = {};
Object.defineProperty(Zt, "__esModule", {
value: !0
});
Zt.BlockStatement = SN;
Zt.Directive = xN;
Zt.DirectiveLiteral = vN;
Zt.File = TN;
Zt.InterpreterDirective = AN;
Zt.Placeholder = IN;
Zt.Program = gN;
function TN(e) {
e.program && this.print(e.program.interpreter, e), this.print(e.program, e);
}
function gN(e) {
var t;
this.noIndentInnerCommentsHere(), this.printInnerComments();
const r = (t = e.directives) == null ? void 0 : t.length;
if (r) {
  var i;
  const s = e.body.length ? 2 : 1;
  this.printSequence(e.directives, e, {
    trailingCommentsLineOffset: s
  }), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(s);
}
this.printSequence(e.body, e);
}
function SN(e) {
var t;
this.tokenChar(123);
const r = (t = e.directives) == null ? void 0 : t.length;
if (r) {
  var i;
  const n = e.body.length ? 2 : 1;
  this.printSequence(e.directives, e, {
    indent: !0,
    trailingCommentsLineOffset: n
  }), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(n);
}
const s = this.enterForStatementInit(!1);
this.printSequence(e.body, e, {
  indent: !0
}), s(), this.rightBrace(e);
}
function xN(e) {
this.print(e.value, e), this.semicolon();
}
const EN = /(?:^|[^\\])(?:\\\\)*'/, PN = /(?:^|[^\\])(?:\\\\)*"/;
function vN(e) {
const t = this.getPossibleRaw(e);
if (!this.format.minified && t !== void 0) {
  this.token(t);
  return;
}
const {
  value: r
} = e;
if (!PN.test(r))
  this.token(`"${r}"`);
else if (!EN.test(r))
  this.token(`'${r}'`);
else
  throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
}
function AN(e) {
this.token(`#!${e.value}`), this.newline(1, !0);
}
function IN(e) {
this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
}
var pt = {};
Object.defineProperty(pt, "__esModule", {
value: !0
});
pt.JSXAttribute = CN;
pt.JSXClosingElement = jN;
pt.JSXClosingFragment = qN;
pt.JSXElement = MN;
pt.JSXEmptyExpression = RN;
pt.JSXExpressionContainer = kN;
pt.JSXFragment = UN;
pt.JSXIdentifier = wN;
pt.JSXMemberExpression = ON;
pt.JSXNamespacedName = NN;
pt.JSXOpeningElement = FN;
pt.JSXOpeningFragment = VN;
pt.JSXSpreadAttribute = _N;
pt.JSXSpreadChild = DN;
pt.JSXText = LN;
function CN(e) {
this.print(e.name, e), e.value && (this.tokenChar(61), this.print(e.value, e));
}
function wN(e) {
this.word(e.name);
}
function NN(e) {
this.print(e.namespace, e), this.tokenChar(58), this.print(e.name, e);
}
function ON(e) {
this.print(e.object, e), this.tokenChar(46), this.print(e.property, e);
}
function _N(e) {
this.tokenChar(123), this.token("..."), this.print(e.argument, e), this.tokenChar(125);
}
function kN(e) {
this.tokenChar(123), this.print(e.expression, e), this.tokenChar(125);
}
function DN(e) {
this.tokenChar(123), this.token("..."), this.print(e.expression, e), this.tokenChar(125);
}
function LN(e) {
const t = this.getPossibleRaw(e);
t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
}
function MN(e) {
const t = e.openingElement;
if (this.print(t, e), !t.selfClosing) {
  this.indent();
  for (const r of e.children)
    this.print(r, e);
  this.dedent(), this.print(e.closingElement, e);
}
}
function BN() {
this.space();
}
function FN(e) {
this.tokenChar(60), this.print(e.name, e), this.print(e.typeParameters, e), e.attributes.length > 0 && (this.space(), this.printJoin(e.attributes, e, {
  separator: BN
})), e.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
}
function jN(e) {
this.token("</"), this.print(e.name, e), this.tokenChar(62);
}
function RN() {
this.printInnerComments();
}
function UN(e) {
this.print(e.openingFragment, e), this.indent();
for (const t of e.children)
  this.print(t, e);
this.dedent(), this.print(e.closingFragment, e);
}
function VN() {
this.tokenChar(60), this.tokenChar(62);
}
function qN() {
this.token("</"), this.tokenChar(62);
}
var ae = {};
Object.defineProperty(ae, "__esModule", {
value: !0
});
ae.TSAnyKeyword = rO;
ae.TSArrayType = vO;
ae.TSSatisfiesExpression = ae.TSAsExpression = qO;
ae.TSBigIntKeyword = iO;
ae.TSBooleanKeyword = oO;
ae.TSCallSignatureDeclaration = GN;
ae.TSConditionalType = _O;
ae.TSConstructSignatureDeclaration = zN;
ae.TSConstructorType = bO;
ae.TSDeclareFunction = YN;
ae.TSDeclareMethod = XN;
ae.TSEnumDeclaration = WO;
ae.TSEnumMember = JO;
ae.TSExportAssignment = ZO;
ae.TSExpressionWithTypeArguments = jO;
ae.TSExternalModuleReference = zO;
ae.TSFunctionType = yO;
ae.TSImportEqualsDeclaration = GO;
ae.TSImportType = HO;
ae.TSIndexSignature = tO;
ae.TSIndexedAccessType = MO;
ae.TSInferType = kO;
ae.TSInstantiationExpression = KO;
ae.TSInterfaceBody = UO;
ae.TSInterfaceDeclaration = RO;
ae.TSIntersectionType = OO;
ae.TSIntrinsicKeyword = dO;
ae.TSLiteralType = FO;
ae.TSMappedType = BO;
ae.TSMethodSignature = eO;
ae.TSModuleBlock = XO;
ae.TSModuleDeclaration = YO;
ae.TSNamedTupleMember = wO;
ae.TSNamespaceExportDeclaration = e4;
ae.TSNeverKeyword = hO;
ae.TSNonNullExpression = QO;
ae.TSNullKeyword = pO;
ae.TSNumberKeyword = nO;
ae.TSObjectKeyword = aO;
ae.TSOptionalType = IO;
ae.TSParameterProperty = JN;
ae.TSParenthesizedType = DO;
ae.TSPropertySignature = QN;
ae.TSQualifiedName = HN;
ae.TSRestType = CO;
ae.TSStringKeyword = uO;
ae.TSSymbolKeyword = lO;
ae.TSThisType = mO;
ae.TSTupleType = AO;
ae.TSTypeAliasDeclaration = VO;
ae.TSTypeAnnotation = $N;
ae.TSTypeAssertion = $O;
ae.TSTypeLiteral = EO;
ae.TSTypeOperator = LO;
ae.TSTypeParameter = WN;
ae.TSTypeParameterDeclaration = ae.TSTypeParameterInstantiation = KN;
ae.TSTypePredicate = SO;
ae.TSTypeQuery = xO;
ae.TSTypeReference = gO;
ae.TSUndefinedKeyword = fO;
ae.TSUnionType = NO;
ae.TSUnknownKeyword = sO;
ae.TSVoidKeyword = cO;
ae.tsPrintClassMemberModifiers = r4;
ae.tsPrintFunctionOrConstructorType = TO;
ae.tsPrintPropertyOrMethodName = ZN;
ae.tsPrintSignatureDeclarationBase = t4;
ae.tsPrintTypeLiteralOrInterfaceBody = PO;
function $N(e) {
this.tokenChar(58), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
}
function KN(e, t) {
this.tokenChar(60), this.printList(e.params, e, {}), t.type === "ArrowFunctionExpression" && e.params.length === 1 && this.tokenChar(44), this.tokenChar(62);
}
function WN(e) {
e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.word(e.name), e.constraint && (this.space(), this.word("extends"), this.space(), this.print(e.constraint, e)), e.default && (this.space(), this.tokenChar(61), this.space(), this.print(e.default, e));
}
function JN(e) {
e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
}
function YN(e, t) {
e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.tokenChar(59);
}
function XN(e) {
this._classMethodHead(e), this.tokenChar(59);
}
function HN(e) {
this.print(e.left, e), this.tokenChar(46), this.print(e.right, e);
}
function GN(e) {
this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function zN(e) {
this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function QN(e) {
const {
  readonly: t
} = e;
t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation, e), this.tokenChar(59);
}
function ZN(e) {
e.computed && this.tokenChar(91), this.print(e.key, e), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
}
function eO(e) {
const {
  kind: t
} = e;
(t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function tO(e) {
const {
  readonly: t,
  static: r
} = e;
r && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters, e), this.tokenChar(93), this.print(e.typeAnnotation, e), this.tokenChar(59);
}
function rO() {
this.word("any");
}
function iO() {
this.word("bigint");
}
function sO() {
this.word("unknown");
}
function nO() {
this.word("number");
}
function aO() {
this.word("object");
}
function oO() {
this.word("boolean");
}
function uO() {
this.word("string");
}
function lO() {
this.word("symbol");
}
function cO() {
this.word("void");
}
function fO() {
this.word("undefined");
}
function pO() {
this.word("null");
}
function hO() {
this.word("never");
}
function dO() {
this.word("intrinsic");
}
function mO() {
this.word("this");
}
function yO(e) {
this.tsPrintFunctionOrConstructorType(e);
}
function bO(e) {
e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
}
function TO(e) {
const {
  typeParameters: t
} = e, r = e.parameters;
this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41), this.space(), this.token("=>"), this.space();
const i = e.typeAnnotation;
this.print(i.typeAnnotation, e);
}
function gO(e) {
this.print(e.typeName, e, !0), this.print(e.typeParameters, e, !0);
}
function SO(e) {
e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(e.typeAnnotation.typeAnnotation));
}
function xO(e) {
this.word("typeof"), this.space(), this.print(e.exprName), e.typeParameters && this.print(e.typeParameters, e);
}
function EO(e) {
this.tsPrintTypeLiteralOrInterfaceBody(e.members, e);
}
function PO(e, t) {
Ba(this, e, t);
}
function Ba(e, t, r) {
if (e.token("{"), t.length) {
  e.indent(), e.newline();
  for (const i of t)
    e.print(i, r), e.newline();
  e.dedent();
}
e.rightBrace(r);
}
function vO(e) {
this.print(e.elementType, e, !0), this.token("[]");
}
function AO(e) {
this.tokenChar(91), this.printList(e.elementTypes, e), this.tokenChar(93);
}
function IO(e) {
this.print(e.typeAnnotation, e), this.tokenChar(63);
}
function CO(e) {
this.token("..."), this.print(e.typeAnnotation, e);
}
function wO(e) {
this.print(e.label, e), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType, e);
}
function NO(e) {
$c(this, e, "|");
}
function OO(e) {
$c(this, e, "&");
}
function $c(e, t, r) {
e.printJoin(t.types, t, {
  separator() {
    this.space(), this.token(r), this.space();
  }
});
}
function _O(e) {
this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
}
function kO(e) {
this.token("infer"), this.space(), this.print(e.typeParameter);
}
function DO(e) {
this.tokenChar(40), this.print(e.typeAnnotation, e), this.tokenChar(41);
}
function LO(e) {
this.word(e.operator), this.space(), this.print(e.typeAnnotation, e);
}
function MO(e) {
this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
}
function BO(e) {
const {
  nameType: t,
  optional: r,
  readonly: i,
  typeParameter: s,
  typeAnnotation: n
} = e;
this.tokenChar(123), this.space(), i && (_u(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(s.name), this.space(), this.word("in"), this.space(), this.print(s.constraint, s), t && (this.space(), this.word("as"), this.space(), this.print(t, e)), this.tokenChar(93), r && (_u(this, r), this.tokenChar(63)), n && (this.tokenChar(58), this.space(), this.print(n, e)), this.space(), this.tokenChar(125);
}
function _u(e, t) {
t !== !0 && e.token(t);
}
function FO(e) {
this.print(e.literal, e);
}
function jO(e) {
this.print(e.expression, e), this.print(e.typeParameters, e);
}
function RO(e) {
const {
  declare: t,
  id: r,
  typeParameters: i,
  extends: s,
  body: n
} = e;
t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r, e), this.print(i, e), s != null && s.length && (this.space(), this.word("extends"), this.space(), this.printList(s, e)), this.space(), this.print(n, e);
}
function UO(e) {
this.tsPrintTypeLiteralOrInterfaceBody(e.body, e);
}
function VO(e) {
const {
  declare: t,
  id: r,
  typeParameters: i,
  typeAnnotation: s
} = e;
t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r, e), this.print(i, e), this.space(), this.tokenChar(61), this.space(), this.print(s, e), this.tokenChar(59);
}
function qO(e) {
var t;
const {
  type: r,
  expression: i,
  typeAnnotation: s
} = e, n = !!((t = i.trailingComments) != null && t.length);
this.print(i, e, !0, void 0, n), this.space(), this.word(r === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(s, e);
}
function $O(e) {
const {
  typeAnnotation: t,
  expression: r
} = e;
this.tokenChar(60), this.print(t, e), this.tokenChar(62), this.space(), this.print(r, e);
}
function KO(e) {
this.print(e.expression, e), this.print(e.typeParameters, e);
}
function WO(e) {
const {
  declare: t,
  const: r,
  id: i,
  members: s
} = e;
t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i, e), this.space(), Ba(this, s, e);
}
function JO(e) {
const {
  id: t,
  initializer: r
} = e;
this.print(t, e), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, e)), this.tokenChar(44);
}
function YO(e) {
const {
  declare: t,
  id: r
} = e;
if (t && (this.word("declare"), this.space()), e.global || (this.word(r.type === "Identifier" ? "namespace" : "module"), this.space()), this.print(r, e), !e.body) {
  this.tokenChar(59);
  return;
}
let i = e.body;
for (; i.type === "TSModuleDeclaration"; )
  this.tokenChar(46), this.print(i.id, i), i = i.body;
this.space(), this.print(i, e);
}
function XO(e) {
Ba(this, e.body, e);
}
function HO(e) {
const {
  argument: t,
  qualifier: r,
  typeParameters: i
} = e;
this.word("import"), this.tokenChar(40), this.print(t, e), this.tokenChar(41), r && (this.tokenChar(46), this.print(r, e)), i && this.print(i, e);
}
function GO(e) {
const {
  isExport: t,
  id: r,
  moduleReference: i
} = e;
t && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r, e), this.space(), this.tokenChar(61), this.space(), this.print(i, e), this.tokenChar(59);
}
function zO(e) {
this.token("require("), this.print(e.expression, e), this.tokenChar(41);
}
function QO(e) {
this.print(e.expression, e), this.tokenChar(33);
}
function ZO(e) {
this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression, e), this.tokenChar(59);
}
function e4(e) {
this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id, e);
}
function t4(e) {
const {
  typeParameters: t
} = e, r = e.parameters;
this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41);
const i = e.typeAnnotation;
this.print(i, e);
}
function r4(e) {
const t = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
t && e.declare && (this.word("declare"), this.space()), e.accessibility && (this.word(e.accessibility), this.space()), e.static && (this.word("static"), this.space()), e.override && (this.word("override"), this.space()), e.abstract && (this.word("abstract"), this.space()), t && e.readonly && (this.word("readonly"), this.space());
}
(function(e) {
Object.defineProperty(e, "__esModule", {
  value: !0
});
var t = gi;
Object.keys(t).forEach(function(p) {
  p === "default" || p === "__esModule" || p in e && e[p] === t[p] || Object.defineProperty(e, p, {
    enumerable: !0,
    get: function() {
      return t[p];
    }
  });
});
var r = Ue;
Object.keys(r).forEach(function(p) {
  p === "default" || p === "__esModule" || p in e && e[p] === r[p] || Object.defineProperty(e, p, {
    enumerable: !0,
    get: function() {
      return r[p];
    }
  });
});
var i = Ze;
Object.keys(i).forEach(function(p) {
  p === "default" || p === "__esModule" || p in e && e[p] === i[p] || Object.defineProperty(e, p, {
    enumerable: !0,
    get: function() {
      return i[p];
    }
  });
});
var s = Ct;
Object.keys(s).forEach(function(p) {
  p === "default" || p === "__esModule" || p in e && e[p] === s[p] || Object.defineProperty(e, p, {
    enumerable: !0,
    get: function() {
      return s[p];
    }
  });
});
var n = kt;
Object.keys(n).forEach(function(p) {
  p === "default" || p === "__esModule" || p in e && e[p] === n[p] || Object.defineProperty(e, p, {
    enumerable: !0,
    get: function() {
      return n[p];
    }
  });
});
var a = dt;
Object.keys(a).forEach(function(p) {
  p === "default" || p === "__esModule" || p in e && e[p] === a[p] || Object.defineProperty(e, p, {
    enumerable: !0,
    get: function() {
      return a[p];
    }
  });
});
var o = Xe;
Object.keys(o).forEach(function(p) {
  p === "default" || p === "__esModule" || p in e && e[p] === o[p] || Object.defineProperty(e, p, {
    enumerable: !0,
    get: function() {
      return o[p];
    }
  });
});
var u = qc;
Object.keys(u).forEach(function(p) {
  p === "default" || p === "__esModule" || p in e && e[p] === u[p] || Object.defineProperty(e, p, {
    enumerable: !0,
    get: function() {
      return u[p];
    }
  });
});
var l = Zt;
Object.keys(l).forEach(function(p) {
  p === "default" || p === "__esModule" || p in e && e[p] === l[p] || Object.defineProperty(e, p, {
    enumerable: !0,
    get: function() {
      return l[p];
    }
  });
});
var c = pt;
Object.keys(c).forEach(function(p) {
  p === "default" || p === "__esModule" || p in e && e[p] === c[p] || Object.defineProperty(e, p, {
    enumerable: !0,
    get: function() {
      return c[p];
    }
  });
});
var f = ae;
Object.keys(f).forEach(function(p) {
  p === "default" || p === "__esModule" || p in e && e[p] === f[p] || Object.defineProperty(e, p, {
    enumerable: !0,
    get: function() {
      return f[p];
    }
  });
});
})(Dc);
Object.defineProperty(Fs, "__esModule", {
value: !0
});
Fs.default = void 0;
var i4 = js, s4 = Lr, n4 = Ce(), a4 = Dc;
const {
isFunction: o4,
isStatement: u4,
isClassBody: l4,
isTSInterfaceBody: c4,
isTSEnumDeclaration: f4
} = n4, p4 = /e/i, h4 = /\.0+$/, ku = /[\n\r\u2028\u2029]/, d4 = /[\n\r\u2028\u2029]|\*\//, {
needsParens: m4
} = s4;
class Fa {
constructor(t, r) {
  this.inForStatementInit = !1, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState = null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = t, this._indentRepeat = t.indent.style.length, this._inputMap = r == null ? void 0 : r._inputMap, this._buf = new i4.default(r, t.indent.style[0]);
}
enterForStatementInit(t) {
  const r = this.inForStatementInit;
  return r === t ? () => {
  } : (this.inForStatementInit = t, () => {
    this.inForStatementInit = r;
  });
}
generate(t) {
  return this.print(t), this._maybeAddAuxComment(), this._buf.get();
}
indent() {
  this.format.compact || this.format.concise || this._indent++;
}
dedent() {
  this.format.compact || this.format.concise || this._indent--;
}
semicolon(t = !1) {
  this._maybeAddAuxComment(), t ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
}
rightBrace(t) {
  this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
}
rightParens(t) {
  this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
}
space(t = !1) {
  if (!this.format.compact) {
    if (t)
      this._space();
    else if (this._buf.hasContent()) {
      const r = this.getLastChar();
      r !== 32 && r !== 10 && this._space();
    }
  }
}
word(t, r = !1) {
  this._maybePrintInnerComments(), (this._endsWithWord || t.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator = r;
}
number(t, r) {
  function i(s) {
    if (s.length > 2 && s.charCodeAt(0) === 48) {
      const n = s.charCodeAt(1);
      return n === 98 || n === 111 || n === 120;
    }
    return !1;
  }
  this.word(t), this._endsWithInteger = Number.isInteger(r) && !i(t) && !p4.test(t) && !h4.test(t) && t.charCodeAt(t.length - 1) !== 46;
}
token(t, r = !1) {
  this._maybePrintInnerComments();
  const i = this.getLastChar(), s = t.charCodeAt(0);
  (i === 33 && (t === "--" || s === 61) || s === 43 && i === 43 || s === 45 && i === 45 || s === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(t, r), this._noLineTerminator = !1;
}
tokenChar(t) {
  this._maybePrintInnerComments();
  const r = this.getLastChar();
  (t === 43 && r === 43 || t === 45 && r === 45 || t === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(t), this._noLineTerminator = !1;
}
newline(t = 1, r) {
  if (!(t <= 0)) {
    if (!r) {
      if (this.format.retainLines || this.format.compact) return;
      if (this.format.concise) {
        this.space();
        return;
      }
    }
    t > 2 && (t = 2), t -= this._buf.getNewlineCount();
    for (let i = 0; i < t; i++)
      this._newline();
  }
}
endsWith(t) {
  return this.getLastChar() === t;
}
getLastChar() {
  return this._buf.getLastChar();
}
endsWithCharAndNewline() {
  return this._buf.endsWithCharAndNewline();
}
removeTrailingNewline() {
  this._buf.removeTrailingNewline();
}
exactSource(t, r) {
  if (!t) {
    r();
    return;
  }
  this._catchUp("start", t), this._buf.exactSource(t, r);
}
source(t, r) {
  r && (this._catchUp(t, r), this._buf.source(t, r));
}
sourceWithOffset(t, r, i) {
  r && (this._catchUp(t, r), this._buf.sourceWithOffset(t, r, i));
}
sourceIdentifierName(t, r) {
  if (!this._buf._canMarkIdName) return;
  const i = this._buf._sourcePosition;
  i.identifierNamePos = r, i.identifierName = t;
}
_space() {
  this._queue(32);
}
_newline() {
  this._queue(10);
}
_append(t, r) {
  this._maybeAddParen(t), this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, r), this._endsWithWord = !1, this._endsWithInteger = !1;
}
_appendChar(t) {
  this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1;
}
_queue(t) {
  this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
}
_maybeIndent(t) {
  this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
}
_shouldIndent(t) {
  if (this._indent && t !== 10 && this.endsWith(10))
    return !0;
}
_maybeAddParenChar(t) {
  const r = this._parenPushNewlineState;
  if (r && t !== 32) {
    if (t !== 10) {
      this._parenPushNewlineState = null;
      return;
    }
    this.tokenChar(40), this.indent(), r.printed = !0;
  }
}
_maybeAddParen(t) {
  const r = this._parenPushNewlineState;
  if (!r) return;
  const i = t.length;
  let s;
  for (s = 0; s < i && t.charCodeAt(s) === 32; s++) ;
  if (s === i)
    return;
  const n = t.charCodeAt(s);
  if (n !== 10) {
    if (n !== 47 || s + 1 === i) {
      this._parenPushNewlineState = null;
      return;
    }
    const a = t.charCodeAt(s + 1);
    if (a === 42)
      return;
    if (a !== 47) {
      this._parenPushNewlineState = null;
      return;
    }
  }
  this.tokenChar(40), this.indent(), r.printed = !0;
}
catchUp(t) {
  if (!this.format.retainLines) return;
  const r = t - this._buf.getCurrentLine();
  for (let i = 0; i < r; i++)
    this._newline();
}
_catchUp(t, r) {
  var i;
  if (!this.format.retainLines) return;
  const s = r == null || (i = r[t]) == null ? void 0 : i.line;
  if (s != null) {
    const n = s - this._buf.getCurrentLine();
    for (let a = 0; a < n; a++)
      this._newline();
  }
}
_getIndent() {
  return this._indentRepeat * this._indent;
}
printTerminatorless(t, r, i) {
  if (i)
    this._noLineTerminator = !0, this.print(t, r);
  else {
    const s = {
      printed: !1
    };
    this._parenPushNewlineState = s, this.print(t, r), s.printed && (this.dedent(), this.newline(), this.tokenChar(41));
  }
}
print(t, r, i, s, n) {
  var a, o;
  if (!t) return;
  this._endsWithInnerRaw = !1;
  const u = t.type, l = this.format, c = l.concise;
  t._compact && (l.concise = !0);
  const f = this[u];
  if (f === void 0)
    throw new ReferenceError(`unknown node of type ${JSON.stringify(u)} with constructor ${JSON.stringify(t.constructor.name)}`);
  this._printStack.push(t);
  const p = this._insideAux;
  this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !p);
  const h = (a = t.extra) == null ? void 0 : a.parenthesized;
  let y = n || h && l.retainFunctionParens && u === "FunctionExpression" || m4(t, r, this._printStack, this.inForStatementInit);
  if (!y && h && (o = t.leadingComments) != null && o.length && t.leadingComments[0].type === "CommentBlock")
    switch (r == null ? void 0 : r.type) {
      case "ExpressionStatement":
      case "VariableDeclarator":
      case "AssignmentExpression":
      case "ReturnStatement":
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        if (r.callee !== t) break;
      default:
        y = !0;
    }
  let g;
  y && (this.tokenChar(40), this._endsWithInnerRaw = !1, g = this.enterForStatementInit(!1)), this._lastCommentLine = 0, this._printLeadingComments(t, r);
  const A = u === "Program" || u === "File" ? null : t.loc;
  this.exactSource(A, f.bind(this, t, r)), y ? (this._printTrailingComments(t, r), this.tokenChar(41), this._noLineTerminator = i, g()) : i && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(t, r)) : this._printTrailingComments(t, r, s), this._printStack.pop(), l.concise = c, this._insideAux = p, this._endsWithInnerRaw = !1;
}
_maybeAddAuxComment(t) {
  t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
}
_printAuxBeforeComment() {
  if (this._printAuxAfterOnNextUserNode) return;
  this._printAuxAfterOnNextUserNode = !0;
  const t = this.format.auxiliaryCommentBefore;
  t && this._printComment({
    type: "CommentBlock",
    value: t
  }, 0);
}
_printAuxAfterComment() {
  if (!this._printAuxAfterOnNextUserNode) return;
  this._printAuxAfterOnNextUserNode = !1;
  const t = this.format.auxiliaryCommentAfter;
  t && this._printComment({
    type: "CommentBlock",
    value: t
  }, 0);
}
getPossibleRaw(t) {
  const r = t.extra;
  if ((r == null ? void 0 : r.raw) != null && r.rawValue != null && t.value === r.rawValue)
    return r.raw;
}
printJoin(t, r, i = {}) {
  if (!(t != null && t.length)) return;
  let {
    indent: s
  } = i;
  if (s == null && this.format.retainLines) {
    var n;
    const f = (n = t[0].loc) == null ? void 0 : n.start.line;
    f != null && f !== this._buf.getCurrentLine() && (s = !0);
  }
  s && this.indent();
  const a = {
    addNewlines: i.addNewlines,
    nextNodeStartLine: 0
  }, o = i.separator ? i.separator.bind(this) : null, u = t.length;
  for (let f = 0; f < u; f++) {
    const p = t[f];
    if (p && (i.statement && this._printNewline(f === 0, a), this.print(p, r, void 0, i.trailingCommentsLineOffset || 0), i.iterator == null || i.iterator(p, f), f < u - 1 && (o == null || o()), i.statement)) {
      var l;
      if ((l = p.trailingComments) != null && l.length || (this._lastCommentLine = 0), f + 1 === u)
        this.newline(1);
      else {
        var c;
        const h = t[f + 1];
        a.nextNodeStartLine = ((c = h.loc) == null ? void 0 : c.start.line) || 0, this._printNewline(!0, a);
      }
    }
  }
  s && this.dedent();
}
printAndIndentOnComments(t, r) {
  const i = t.leadingComments && t.leadingComments.length > 0;
  i && this.indent(), this.print(t, r), i && this.dedent();
}
printBlock(t) {
  const r = t.body;
  r.type !== "EmptyStatement" && this.space(), this.print(r, t);
}
_printTrailingComments(t, r, i) {
  const {
    innerComments: s,
    trailingComments: n
  } = t;
  s != null && s.length && this._printComments(2, s, t, r, i), n != null && n.length && this._printComments(2, n, t, r, i);
}
_printLeadingComments(t, r) {
  const i = t.leadingComments;
  i != null && i.length && this._printComments(0, i, t, r);
}
_maybePrintInnerComments() {
  this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
}
printInnerComments() {
  const t = this._printStack[this._printStack.length - 1], r = t.innerComments;
  if (!(r != null && r.length)) return;
  const i = this.endsWith(32), s = this._indentInnerComments, n = this._printedComments.size;
  s && this.indent(), this._printComments(1, r, t), i && n !== this._printedComments.size && this.space(), s && this.dedent();
}
noIndentInnerCommentsHere() {
  this._indentInnerComments = !1;
}
printSequence(t, r, i = {}) {
  var s;
  i.statement = !0, (s = i.indent) != null || (i.indent = !1), this.printJoin(t, r, i);
}
printList(t, r, i = {}) {
  i.separator == null && (i.separator = y4), this.printJoin(t, r, i);
}
_printNewline(t, r) {
  const i = this.format;
  if (i.retainLines || i.compact) return;
  if (i.concise) {
    this.space();
    return;
  }
  if (!t)
    return;
  const s = r.nextNodeStartLine, n = this._lastCommentLine;
  if (s > 0 && n > 0) {
    const a = s - n;
    if (a >= 0) {
      this.newline(a || 1);
      return;
    }
  }
  this._buf.hasContent() && this.newline(1);
}
_shouldPrintComment(t) {
  return t.ignore || this._printedComments.has(t) ? 0 : this._noLineTerminator && d4.test(t.value) ? 2 : (this._printedComments.add(t), this.format.shouldPrintComment(t.value) ? 1 : 0);
}
_printComment(t, r) {
  const i = this._noLineTerminator, s = t.type === "CommentBlock", n = s && r !== 1 && !this._noLineTerminator;
  n && this._buf.hasContent() && r !== 2 && this.newline(1);
  const a = this.getLastChar();
  a !== 91 && a !== 123 && this.space();
  let o;
  if (s) {
    const {
      _parenPushNewlineState: l
    } = this;
    if ((l == null ? void 0 : l.printed) === !1 && ku.test(t.value) && (this.tokenChar(40), this.indent(), l.printed = !0), o = `/*${t.value}*/`, this.format.indent.adjustMultilineComment) {
      var u;
      const c = (u = t.loc) == null ? void 0 : u.start.column;
      if (c) {
        const f = new RegExp("\\n\\s{1," + c + "}", "g");
        o = o.replace(f, `
`);
      }
      if (this.format.concise)
        o = o.replace(/\n(?!$)/g, `
`);
      else {
        let f = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
        (this._shouldIndent(47) || this.format.retainLines) && (f += this._getIndent()), o = o.replace(/\n(?!$)/g, `
${" ".repeat(f)}`);
      }
    }
  } else i ? o = `/*${t.value}*/` : o = `//${t.value}`;
  this.endsWith(47) && this._space(), this.source("start", t.loc), this._append(o, s), !s && !i && this.newline(1, !0), n && r !== 3 && this.newline(1);
}
_printComments(t, r, i, s, n = 0) {
  const a = i.loc, o = r.length;
  let u = !!a;
  const l = u ? a.start.line : 0, c = u ? a.end.line : 0;
  let f = 0, p = 0;
  const h = this._noLineTerminator ? function() {
  } : this.newline.bind(this);
  for (let y = 0; y < o; y++) {
    const g = r[y], A = this._shouldPrintComment(g);
    if (A === 2) {
      u = !1;
      break;
    }
    if (u && g.loc && A === 1) {
      const C = g.loc.start.line, _ = g.loc.end.line;
      if (t === 0) {
        let j = 0;
        y === 0 ? this._buf.hasContent() && (g.type === "CommentLine" || C !== _) && (j = p = 1) : j = C - f, f = _, h(j), this._printComment(g, 1), y + 1 === o && (h(Math.max(l - f, p)), f = l);
      } else if (t === 1) {
        const j = C - (y === 0 ? l : f);
        f = _, h(j), this._printComment(g, 1), y + 1 === o && (h(Math.min(1, c - f)), f = c);
      } else {
        const j = C - (y === 0 ? c - n : f);
        f = _, h(j), this._printComment(g, 1);
      }
    } else {
      if (u = !1, A !== 1)
        continue;
      if (o === 1) {
        const C = g.loc ? g.loc.start.line === g.loc.end.line : !ku.test(g.value), _ = C && !u4(i) && !l4(s) && !c4(s) && !f4(s);
        t === 0 ? this._printComment(g, _ && i.type !== "ObjectExpression" || C && o4(s, {
          body: i
        }) ? 1 : 0) : _ && t === 2 ? this._printComment(g, 1) : this._printComment(g, 0);
      } else t === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterfaceBody" ? this._printComment(g, y === 0 ? 2 : y === o - 1 ? 3 : 0) : this._printComment(g, 0);
    }
  }
  t === 2 && u && f && (this._lastCommentLine = f);
}
}
Object.assign(Fa.prototype, a4);
Fa.prototype.Noop = function() {
};
Fs.default = Fa;
function y4() {
this.tokenChar(44), this.space();
}
Object.defineProperty(Ms, "__esModule", {
value: !0
});
var b4 = Ms.default = T4, Kc = Bs, Wc = Fs;
function Jc(e, t) {
const r = {
  auxiliaryCommentBefore: t.auxiliaryCommentBefore,
  auxiliaryCommentAfter: t.auxiliaryCommentAfter,
  shouldPrintComment: t.shouldPrintComment,
  retainLines: t.retainLines,
  retainFunctionParens: t.retainFunctionParens,
  comments: t.comments == null || t.comments,
  compact: t.compact,
  minified: t.minified,
  concise: t.concise,
  indent: {
    adjustMultilineComment: !0,
    style: "  "
  },
  jsescOption: Object.assign({
    quotes: "double",
    wrap: !0,
    minimal: !1
  }, t.jsescOption),
  topicToken: t.topicToken,
  importAttributesKeyword: t.importAttributesKeyword
};
{
  var i;
  r.decoratorsBeforeExport = t.decoratorsBeforeExport, r.jsescOption.json = t.jsonCompatibleStrings, r.recordAndTupleSyntaxType = (i = t.recordAndTupleSyntaxType) != null ? i : "hash";
}
r.minified ? (r.compact = !0, r.shouldPrintComment = r.shouldPrintComment || (() => r.comments)) : r.shouldPrintComment = r.shouldPrintComment || ((o) => r.comments || o.includes("@license") || o.includes("@preserve")), r.compact === "auto" && (r.compact = typeof e == "string" && e.length > 5e5, r.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds the max of 500KB.`)), r.compact && (r.indent.adjustMultilineComment = !1);
const {
  auxiliaryCommentBefore: s,
  auxiliaryCommentAfter: n,
  shouldPrintComment: a
} = r;
return s && !a(s) && (r.auxiliaryCommentBefore = void 0), n && !a(n) && (r.auxiliaryCommentAfter = void 0), r;
}
Ms.CodeGenerator = class {
constructor(t, r = {}, i) {
  this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = t, this._format = Jc(i, r), this._map = r.sourceMaps ? new Kc.default(r, i) : null;
}
generate() {
  return new Wc.default(this._format, this._map).generate(this._ast);
}
};
function T4(e, t = {}, r) {
const i = Jc(r, t), s = t.sourceMaps ? new Kc.default(t, r) : null;
return new Wc.default(i, s).generate(e);
}
var wt = {};
Object.defineProperty(wt, "__esModule", {
value: !0
});
wt.find = E4;
wt.findParent = x4;
wt.getAncestry = C4;
wt.getDeepestCommonAncestorFrom = I4;
wt.getEarliestCommonAncestorFrom = A4;
wt.getFunctionParent = P4;
wt.getStatementParent = v4;
wt.inType = O4;
wt.isAncestor = w4;
wt.isDescendant = N4;
var g4 = Ce();
const {
VISITOR_KEYS: S4
} = g4;
function x4(e) {
let t = this;
for (; t = t.parentPath; )
  if (e(t)) return t;
return null;
}
function E4(e) {
let t = this;
do
  if (e(t)) return t;
while (t = t.parentPath);
return null;
}
function P4() {
return this.findParent((e) => e.isFunction());
}
function v4() {
let e = this;
do {
  if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
    break;
  e = e.parentPath;
} while (e);
if (e && (e.isProgram() || e.isFile()))
  throw new Error("File/Program node, we can't possibly find a statement parent to this");
return e;
}
function A4(e) {
return this.getDeepestCommonAncestorFrom(e, function(t, r, i) {
  let s;
  const n = S4[t.type];
  for (const a of i) {
    const o = a[r + 1];
    if (!s) {
      s = o;
      continue;
    }
    if (o.listKey && s.listKey === o.listKey && o.key < s.key) {
      s = o;
      continue;
    }
    const u = n.indexOf(s.parentKey), l = n.indexOf(o.parentKey);
    u > l && (s = o);
  }
  return s;
});
}
function I4(e, t) {
if (!e.length)
  return this;
if (e.length === 1)
  return e[0];
let r = 1 / 0, i, s;
const n = e.map((o) => {
  const u = [];
  do
    u.unshift(o);
  while ((o = o.parentPath) && o !== this);
  return u.length < r && (r = u.length), u;
}), a = n[0];
e: for (let o = 0; o < r; o++) {
  const u = a[o];
  for (const l of n)
    if (l[o] !== u)
      break e;
  i = o, s = u;
}
if (s)
  return t ? t(s, i, n) : s;
throw new Error("Couldn't find intersection");
}
function C4() {
let e = this;
const t = [];
do
  t.push(e);
while (e = e.parentPath);
return t;
}
function w4(e) {
return e.isDescendant(this);
}
function N4(e) {
return !!this.findParent((t) => t === e);
}
function O4(...e) {
let t = this;
for (; t; ) {
  for (const r of e)
    if (t.node.type === r) return !0;
  t = t.parentPath;
}
return !1;
}
var lr = {}, Yc = {}, ja = {}, qs = {};
Object.defineProperty(qs, "__esModule", {
value: !0
});
qs.createUnionType = M4;
var _4 = Ce();
const {
createFlowUnionType: Du,
createTSUnionType: Lu,
createUnionTypeAnnotation: k4,
isFlowType: D4,
isTSType: L4
} = _4;
function M4(e) {
{
  if (e.every((t) => D4(t)))
    return Du ? Du(e) : k4(e);
  if (e.every((t) => L4(t)) && Lu)
    return Lu(e);
}
}
Object.defineProperty(ja, "__esModule", {
value: !0
});
ja.default = U4;
var B4 = Ce(), Xc = qs;
const {
BOOLEAN_NUMBER_BINARY_OPERATORS: F4,
createTypeAnnotationBasedOnTypeof: j4,
numberTypeAnnotation: Hc,
voidTypeAnnotation: R4
} = B4;
function U4(e) {
if (!this.isReferenced()) return;
const t = this.scope.getBinding(e.name);
if (t)
  return t.identifier.typeAnnotation ? t.identifier.typeAnnotation : V4(t, this, e.name);
if (e.name === "undefined")
  return R4();
if (e.name === "NaN" || e.name === "Infinity")
  return Hc();
e.name;
}
function V4(e, t, r) {
const i = [], s = [];
let n = Mu(e, t, s);
const a = Gc(e, t, r);
if (a) {
  const o = Mu(e, a.ifStatement);
  n = n.filter((u) => !o.includes(u)), i.push(a.typeAnnotation);
}
if (n.length) {
  n.push(...s);
  for (const o of n)
    i.push(o.getTypeAnnotation());
}
if (i.length)
  return (0, Xc.createUnionType)(i);
}
function Mu(e, t, r) {
const i = e.constantViolations.slice();
return i.unshift(e.path), i.filter((s) => {
  s = s.resolve();
  const n = s._guessExecutionStatusRelativeTo(t);
  return r && n === "unknown" && r.push(s), n === "before";
});
}
function q4(e, t) {
const r = t.node.operator, i = t.get("right").resolve(), s = t.get("left").resolve();
let n;
if (s.isIdentifier({
  name: e
}) ? n = i : i.isIdentifier({
  name: e
}) && (n = s), n)
  return r === "===" ? n.getTypeAnnotation() : F4.includes(r) ? Hc() : void 0;
if (r !== "===" && r !== "==") return;
let a, o;
if (s.isUnaryExpression({
  operator: "typeof"
}) ? (a = s, o = i) : i.isUnaryExpression({
  operator: "typeof"
}) && (a = i, o = s), !a || !a.get("argument").isIdentifier({
  name: e
}) || (o = o.resolve(), !o.isLiteral())) return;
const u = o.node.value;
if (typeof u == "string")
  return j4(u);
}
function $4(e, t, r) {
let i;
for (; i = t.parentPath; ) {
  if (i.isIfStatement() || i.isConditionalExpression())
    return t.key === "test" ? void 0 : i;
  if (i.isFunction() && i.parentPath.scope.getBinding(r) !== e)
    return;
  t = i;
}
}
function Gc(e, t, r) {
const i = $4(e, t, r);
if (!i) return;
const n = [i.get("test")], a = [];
for (let o = 0; o < n.length; o++) {
  const u = n[o];
  if (u.isLogicalExpression())
    u.node.operator === "&&" && (n.push(u.get("left")), n.push(u.get("right")));
  else if (u.isBinaryExpression()) {
    const l = q4(r, u);
    l && a.push(l);
  }
}
return a.length ? {
  typeAnnotation: (0, Xc.createUnionType)(a),
  ifStatement: i
} : Gc(e, i, r);
}
(function(e) {
Object.defineProperty(e, "__esModule", {
  value: !0
}), e.ArrayExpression = qe, e.AssignmentExpression = O, e.BinaryExpression = U, e.BooleanLiteral = V, e.CallExpression = De, e.ConditionalExpression = k, e.ClassDeclaration = e.ClassExpression = e.FunctionDeclaration = e.ArrowFunctionExpression = e.FunctionExpression = he, Object.defineProperty(e, "Identifier", {
  enumerable: !0,
  get: function() {
    return r.default;
  }
}), e.LogicalExpression = L, e.NewExpression = ie, e.NullLiteral = H, e.NumericLiteral = q, e.ObjectExpression = ue, e.ParenthesizedExpression = B, e.RegExpLiteral = ne, e.RestElement = pe, e.SequenceExpression = F, e.StringLiteral = R, e.TSAsExpression = K, e.TSNonNullExpression = X, e.TaggedTemplateExpression = Je, e.TemplateLiteral = W, e.TypeCastExpression = oe, e.UnaryExpression = Q, e.UpdateExpression = D, e.VariableDeclarator = re;
var t = Ce(), r = ja, i = qs;
const {
  BOOLEAN_BINARY_OPERATORS: s,
  BOOLEAN_UNARY_OPERATORS: n,
  NUMBER_BINARY_OPERATORS: a,
  NUMBER_UNARY_OPERATORS: o,
  STRING_UNARY_OPERATORS: u,
  anyTypeAnnotation: l,
  arrayTypeAnnotation: c,
  booleanTypeAnnotation: f,
  buildMatchMemberExpression: p,
  genericTypeAnnotation: h,
  identifier: y,
  nullLiteralTypeAnnotation: g,
  numberTypeAnnotation: A,
  stringTypeAnnotation: C,
  tupleTypeAnnotation: _,
  unionTypeAnnotation: j,
  voidTypeAnnotation: G,
  isIdentifier: fe
} = t;
function re() {
  if (this.get("id").isIdentifier())
    return this.get("init").getTypeAnnotation();
}
function oe(ve) {
  return ve.typeAnnotation;
}
oe.validParent = !0;
function K(ve) {
  return ve.typeAnnotation;
}
K.validParent = !0;
function X() {
  return this.get("expression").getTypeAnnotation();
}
function ie(ve) {
  if (ve.callee.type === "Identifier")
    return h(ve.callee);
}
function W() {
  return C();
}
function Q(ve) {
  const je = ve.operator;
  if (je === "void")
    return G();
  if (o.includes(je))
    return A();
  if (u.includes(je))
    return C();
  if (n.includes(je))
    return f();
}
function U(ve) {
  const je = ve.operator;
  if (a.includes(je))
    return A();
  if (s.includes(je))
    return f();
  if (je === "+") {
    const Ie = this.get("right"), Ve = this.get("left");
    return Ve.isBaseType("number") && Ie.isBaseType("number") ? A() : Ve.isBaseType("string") || Ie.isBaseType("string") ? C() : j([C(), A()]);
  }
}
function L() {
  const ve = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
  return (0, i.createUnionType)(ve);
}
function k() {
  const ve = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
  return (0, i.createUnionType)(ve);
}
function F() {
  return this.get("expressions").pop().getTypeAnnotation();
}
function B() {
  return this.get("expression").getTypeAnnotation();
}
function O() {
  return this.get("right").getTypeAnnotation();
}
function D(ve) {
  const je = ve.operator;
  if (je === "++" || je === "--")
    return A();
}
function R() {
  return C();
}
function q() {
  return A();
}
function V() {
  return f();
}
function H() {
  return g();
}
function ne() {
  return h(y("RegExp"));
}
function ue() {
  return h(y("Object"));
}
function qe() {
  return h(y("Array"));
}
function pe() {
  return qe();
}
pe.validParent = !0;
function he() {
  return h(y("Function"));
}
const Ee = p("Array.from"), we = p("Object.keys"), Pe = p("Object.values"), ke = p("Object.entries");
function De() {
  const {
    callee: ve
  } = this.node;
  return we(ve) ? c(C()) : Ee(ve) || Pe(ve) || fe(ve, {
    name: "Array"
  }) ? c(l()) : ke(ve) ? c(_([C(), l()])) : it(this.get("callee"));
}
function Je() {
  return it(this.get("tag"));
}
function it(ve) {
  if (ve = ve.resolve(), ve.isFunction()) {
    const {
      node: je
    } = ve;
    if (je.async)
      return je.generator ? h(y("AsyncIterator")) : h(y("Promise"));
    if (je.generator)
      return h(y("Iterator"));
    if (ve.node.returnType)
      return ve.node.returnType;
  }
}
})(Yc);
Object.defineProperty(lr, "__esModule", {
value: !0
});
lr._getTypeAnnotation = Qc;
lr.baseTypeStrictlyMatches = f8;
lr.couldBeBaseType = c8;
lr.getTypeAnnotation = u8;
lr.isBaseType = l8;
lr.isGenericType = p8;
var Bu = Yc, K4 = Ce();
const {
anyTypeAnnotation: zc,
isAnyTypeAnnotation: fs,
isArrayTypeAnnotation: W4,
isBooleanTypeAnnotation: J4,
isEmptyTypeAnnotation: Y4,
isFlowBaseAnnotation: X4,
isGenericTypeAnnotation: H4,
isIdentifier: Fu,
isMixedTypeAnnotation: G4,
isNumberTypeAnnotation: z4,
isStringTypeAnnotation: Q4,
isTSArrayType: Z4,
isTSTypeAnnotation: e8,
isTSTypeReference: t8,
isTupleTypeAnnotation: r8,
isTypeAnnotation: i8,
isUnionTypeAnnotation: s8,
isVoidTypeAnnotation: n8,
stringTypeAnnotation: a8,
voidTypeAnnotation: o8
} = K4;
function u8() {
let e = this.getData("typeAnnotation");
return e != null || (e = Qc.call(this) || zc(), (i8(e) || e8(e)) && (e = e.typeAnnotation), this.setData("typeAnnotation", e)), e;
}
const hn = /* @__PURE__ */ new WeakSet();
function Qc() {
const e = this.node;
if (!e)
  if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
    const r = this.parentPath.parentPath, i = r.parentPath;
    return r.key === "left" && i.isForInStatement() ? a8() : r.key === "left" && i.isForOfStatement() ? zc() : o8();
  } else
    return;
if (e.typeAnnotation)
  return e.typeAnnotation;
if (!hn.has(e)) {
  hn.add(e);
  try {
    var t;
    let r = Bu[e.type];
    if (r)
      return r.call(this, e);
    if (r = Bu[this.parentPath.type], (t = r) != null && t.validParent)
      return this.parentPath.getTypeAnnotation();
  } finally {
    hn.delete(e);
  }
}
}
function l8(e, t) {
return Kn(e, this.getTypeAnnotation(), t);
}
function Kn(e, t, r) {
if (e === "string")
  return Q4(t);
if (e === "number")
  return z4(t);
if (e === "boolean")
  return J4(t);
if (e === "any")
  return fs(t);
if (e === "mixed")
  return G4(t);
if (e === "empty")
  return Y4(t);
if (e === "void")
  return n8(t);
if (r)
  return !1;
throw new Error(`Unknown base type ${e}`);
}
function c8(e) {
const t = this.getTypeAnnotation();
if (fs(t)) return !0;
if (s8(t)) {
  for (const r of t.types)
    if (fs(r) || Kn(e, r, !0))
      return !0;
  return !1;
} else
  return Kn(e, t, !0);
}
function f8(e) {
const t = this.getTypeAnnotation(), r = e.getTypeAnnotation();
return !fs(t) && X4(t) ? r.type === t.type : !1;
}
function p8(e) {
const t = this.getTypeAnnotation();
return e === "Array" && (Z4(t) || W4(t) || r8(t)) ? !0 : H4(t) && Fu(t.id, {
  name: e
}) || t8(t) && Fu(t.typeName, {
  name: e
});
}
var Vt = {}, xi = {}, Ei = {}, $s = {};
Object.defineProperty($s, "__esModule", {
value: !0
});
$s.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
$s.matchToToken = function(e) {
var t = { type: "invalid", value: e[0], closed: void 0 };
return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) : e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "whitespace"), t;
};
var Ra = { exports: {} }, He = String, Zc = function() {
return { isColorSupported: !1, reset: He, bold: He, dim: He, italic: He, underline: He, inverse: He, hidden: He, strikethrough: He, black: He, red: He, green: He, yellow: He, blue: He, magenta: He, cyan: He, white: He, gray: He, bgBlack: He, bgRed: He, bgGreen: He, bgYellow: He, bgBlue: He, bgMagenta: He, bgCyan: He, bgWhite: He };
};
Ra.exports = Zc();
Ra.exports.createColors = Zc;
var ef = Ra.exports, dn = { exports: {} }, mn, ju;
function h8() {
if (ju) return mn;
ju = 1;
var e = /[|\\{}()[\]^$+*?.]/g;
return mn = function(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(e, "\\$&");
}, mn;
}
var is = { exports: {} }, yn = { exports: {} }, bn, Ru;
function d8() {
return Ru || (Ru = 1, bn = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}), bn;
}
var Uu;
function tf() {
if (Uu) return yn.exports;
Uu = 1;
var e = d8(), t = {};
for (var r in e)
  e.hasOwnProperty(r) && (t[e[r]] = r);
var i = yn.exports = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
for (var s in i)
  if (i.hasOwnProperty(s)) {
    if (!("channels" in i[s]))
      throw new Error("missing channels property: " + s);
    if (!("labels" in i[s]))
      throw new Error("missing channel labels property: " + s);
    if (i[s].labels.length !== i[s].channels)
      throw new Error("channel and label counts mismatch: " + s);
    var n = i[s].channels, a = i[s].labels;
    delete i[s].channels, delete i[s].labels, Object.defineProperty(i[s], "channels", { value: n }), Object.defineProperty(i[s], "labels", { value: a });
  }
i.rgb.hsl = function(u) {
  var l = u[0] / 255, c = u[1] / 255, f = u[2] / 255, p = Math.min(l, c, f), h = Math.max(l, c, f), y = h - p, g, A, C;
  return h === p ? g = 0 : l === h ? g = (c - f) / y : c === h ? g = 2 + (f - l) / y : f === h && (g = 4 + (l - c) / y), g = Math.min(g * 60, 360), g < 0 && (g += 360), C = (p + h) / 2, h === p ? A = 0 : C <= 0.5 ? A = y / (h + p) : A = y / (2 - h - p), [g, A * 100, C * 100];
}, i.rgb.hsv = function(u) {
  var l, c, f, p, h, y = u[0] / 255, g = u[1] / 255, A = u[2] / 255, C = Math.max(y, g, A), _ = C - Math.min(y, g, A), j = function(G) {
    return (C - G) / 6 / _ + 1 / 2;
  };
  return _ === 0 ? p = h = 0 : (h = _ / C, l = j(y), c = j(g), f = j(A), y === C ? p = f - c : g === C ? p = 1 / 3 + l - f : A === C && (p = 2 / 3 + c - l), p < 0 ? p += 1 : p > 1 && (p -= 1)), [
    p * 360,
    h * 100,
    C * 100
  ];
}, i.rgb.hwb = function(u) {
  var l = u[0], c = u[1], f = u[2], p = i.rgb.hsl(u)[0], h = 1 / 255 * Math.min(l, Math.min(c, f));
  return f = 1 - 1 / 255 * Math.max(l, Math.max(c, f)), [p, h * 100, f * 100];
}, i.rgb.cmyk = function(u) {
  var l = u[0] / 255, c = u[1] / 255, f = u[2] / 255, p, h, y, g;
  return g = Math.min(1 - l, 1 - c, 1 - f), p = (1 - l - g) / (1 - g) || 0, h = (1 - c - g) / (1 - g) || 0, y = (1 - f - g) / (1 - g) || 0, [p * 100, h * 100, y * 100, g * 100];
};
function o(u, l) {
  return Math.pow(u[0] - l[0], 2) + Math.pow(u[1] - l[1], 2) + Math.pow(u[2] - l[2], 2);
}
return i.rgb.keyword = function(u) {
  var l = t[u];
  if (l)
    return l;
  var c = 1 / 0, f;
  for (var p in e)
    if (e.hasOwnProperty(p)) {
      var h = e[p], y = o(u, h);
      y < c && (c = y, f = p);
    }
  return f;
}, i.keyword.rgb = function(u) {
  return e[u];
}, i.rgb.xyz = function(u) {
  var l = u[0] / 255, c = u[1] / 255, f = u[2] / 255;
  l = l > 0.04045 ? Math.pow((l + 0.055) / 1.055, 2.4) : l / 12.92, c = c > 0.04045 ? Math.pow((c + 0.055) / 1.055, 2.4) : c / 12.92, f = f > 0.04045 ? Math.pow((f + 0.055) / 1.055, 2.4) : f / 12.92;
  var p = l * 0.4124 + c * 0.3576 + f * 0.1805, h = l * 0.2126 + c * 0.7152 + f * 0.0722, y = l * 0.0193 + c * 0.1192 + f * 0.9505;
  return [p * 100, h * 100, y * 100];
}, i.rgb.lab = function(u) {
  var l = i.rgb.xyz(u), c = l[0], f = l[1], p = l[2], h, y, g;
  return c /= 95.047, f /= 100, p /= 108.883, c = c > 8856e-6 ? Math.pow(c, 1 / 3) : 7.787 * c + 16 / 116, f = f > 8856e-6 ? Math.pow(f, 1 / 3) : 7.787 * f + 16 / 116, p = p > 8856e-6 ? Math.pow(p, 1 / 3) : 7.787 * p + 16 / 116, h = 116 * f - 16, y = 500 * (c - f), g = 200 * (f - p), [h, y, g];
}, i.hsl.rgb = function(u) {
  var l = u[0] / 360, c = u[1] / 100, f = u[2] / 100, p, h, y, g, A;
  if (c === 0)
    return A = f * 255, [A, A, A];
  f < 0.5 ? h = f * (1 + c) : h = f + c - f * c, p = 2 * f - h, g = [0, 0, 0];
  for (var C = 0; C < 3; C++)
    y = l + 1 / 3 * -(C - 1), y < 0 && y++, y > 1 && y--, 6 * y < 1 ? A = p + (h - p) * 6 * y : 2 * y < 1 ? A = h : 3 * y < 2 ? A = p + (h - p) * (2 / 3 - y) * 6 : A = p, g[C] = A * 255;
  return g;
}, i.hsl.hsv = function(u) {
  var l = u[0], c = u[1] / 100, f = u[2] / 100, p = c, h = Math.max(f, 0.01), y, g;
  return f *= 2, c *= f <= 1 ? f : 2 - f, p *= h <= 1 ? h : 2 - h, g = (f + c) / 2, y = f === 0 ? 2 * p / (h + p) : 2 * c / (f + c), [l, y * 100, g * 100];
}, i.hsv.rgb = function(u) {
  var l = u[0] / 60, c = u[1] / 100, f = u[2] / 100, p = Math.floor(l) % 6, h = l - Math.floor(l), y = 255 * f * (1 - c), g = 255 * f * (1 - c * h), A = 255 * f * (1 - c * (1 - h));
  switch (f *= 255, p) {
    case 0:
      return [f, A, y];
    case 1:
      return [g, f, y];
    case 2:
      return [y, f, A];
    case 3:
      return [y, g, f];
    case 4:
      return [A, y, f];
    case 5:
      return [f, y, g];
  }
}, i.hsv.hsl = function(u) {
  var l = u[0], c = u[1] / 100, f = u[2] / 100, p = Math.max(f, 0.01), h, y, g;
  return g = (2 - c) * f, h = (2 - c) * p, y = c * p, y /= h <= 1 ? h : 2 - h, y = y || 0, g /= 2, [l, y * 100, g * 100];
}, i.hwb.rgb = function(u) {
  var l = u[0] / 360, c = u[1] / 100, f = u[2] / 100, p = c + f, h, y, g, A;
  p > 1 && (c /= p, f /= p), h = Math.floor(6 * l), y = 1 - f, g = 6 * l - h, h & 1 && (g = 1 - g), A = c + g * (y - c);
  var C, _, j;
  switch (h) {
    default:
    case 6:
    case 0:
      C = y, _ = A, j = c;
      break;
    case 1:
      C = A, _ = y, j = c;
      break;
    case 2:
      C = c, _ = y, j = A;
      break;
    case 3:
      C = c, _ = A, j = y;
      break;
    case 4:
      C = A, _ = c, j = y;
      break;
    case 5:
      C = y, _ = c, j = A;
      break;
  }
  return [C * 255, _ * 255, j * 255];
}, i.cmyk.rgb = function(u) {
  var l = u[0] / 100, c = u[1] / 100, f = u[2] / 100, p = u[3] / 100, h, y, g;
  return h = 1 - Math.min(1, l * (1 - p) + p), y = 1 - Math.min(1, c * (1 - p) + p), g = 1 - Math.min(1, f * (1 - p) + p), [h * 255, y * 255, g * 255];
}, i.xyz.rgb = function(u) {
  var l = u[0] / 100, c = u[1] / 100, f = u[2] / 100, p, h, y;
  return p = l * 3.2406 + c * -1.5372 + f * -0.4986, h = l * -0.9689 + c * 1.8758 + f * 0.0415, y = l * 0.0557 + c * -0.204 + f * 1.057, p = p > 31308e-7 ? 1.055 * Math.pow(p, 1 / 2.4) - 0.055 : p * 12.92, h = h > 31308e-7 ? 1.055 * Math.pow(h, 1 / 2.4) - 0.055 : h * 12.92, y = y > 31308e-7 ? 1.055 * Math.pow(y, 1 / 2.4) - 0.055 : y * 12.92, p = Math.min(Math.max(0, p), 1), h = Math.min(Math.max(0, h), 1), y = Math.min(Math.max(0, y), 1), [p * 255, h * 255, y * 255];
}, i.xyz.lab = function(u) {
  var l = u[0], c = u[1], f = u[2], p, h, y;
  return l /= 95.047, c /= 100, f /= 108.883, l = l > 8856e-6 ? Math.pow(l, 1 / 3) : 7.787 * l + 16 / 116, c = c > 8856e-6 ? Math.pow(c, 1 / 3) : 7.787 * c + 16 / 116, f = f > 8856e-6 ? Math.pow(f, 1 / 3) : 7.787 * f + 16 / 116, p = 116 * c - 16, h = 500 * (l - c), y = 200 * (c - f), [p, h, y];
}, i.lab.xyz = function(u) {
  var l = u[0], c = u[1], f = u[2], p, h, y;
  h = (l + 16) / 116, p = c / 500 + h, y = h - f / 200;
  var g = Math.pow(h, 3), A = Math.pow(p, 3), C = Math.pow(y, 3);
  return h = g > 8856e-6 ? g : (h - 16 / 116) / 7.787, p = A > 8856e-6 ? A : (p - 16 / 116) / 7.787, y = C > 8856e-6 ? C : (y - 16 / 116) / 7.787, p *= 95.047, h *= 100, y *= 108.883, [p, h, y];
}, i.lab.lch = function(u) {
  var l = u[0], c = u[1], f = u[2], p, h, y;
  return p = Math.atan2(f, c), h = p * 360 / 2 / Math.PI, h < 0 && (h += 360), y = Math.sqrt(c * c + f * f), [l, y, h];
}, i.lch.lab = function(u) {
  var l = u[0], c = u[1], f = u[2], p, h, y;
  return y = f / 360 * 2 * Math.PI, p = c * Math.cos(y), h = c * Math.sin(y), [l, p, h];
}, i.rgb.ansi16 = function(u) {
  var l = u[0], c = u[1], f = u[2], p = 1 in arguments ? arguments[1] : i.rgb.hsv(u)[2];
  if (p = Math.round(p / 50), p === 0)
    return 30;
  var h = 30 + (Math.round(f / 255) << 2 | Math.round(c / 255) << 1 | Math.round(l / 255));
  return p === 2 && (h += 60), h;
}, i.hsv.ansi16 = function(u) {
  return i.rgb.ansi16(i.hsv.rgb(u), u[2]);
}, i.rgb.ansi256 = function(u) {
  var l = u[0], c = u[1], f = u[2];
  if (l === c && c === f)
    return l < 8 ? 16 : l > 248 ? 231 : Math.round((l - 8) / 247 * 24) + 232;
  var p = 16 + 36 * Math.round(l / 255 * 5) + 6 * Math.round(c / 255 * 5) + Math.round(f / 255 * 5);
  return p;
}, i.ansi16.rgb = function(u) {
  var l = u % 10;
  if (l === 0 || l === 7)
    return u > 50 && (l += 3.5), l = l / 10.5 * 255, [l, l, l];
  var c = (~~(u > 50) + 1) * 0.5, f = (l & 1) * c * 255, p = (l >> 1 & 1) * c * 255, h = (l >> 2 & 1) * c * 255;
  return [f, p, h];
}, i.ansi256.rgb = function(u) {
  if (u >= 232) {
    var l = (u - 232) * 10 + 8;
    return [l, l, l];
  }
  u -= 16;
  var c, f = Math.floor(u / 36) / 5 * 255, p = Math.floor((c = u % 36) / 6) / 5 * 255, h = c % 6 / 5 * 255;
  return [f, p, h];
}, i.rgb.hex = function(u) {
  var l = ((Math.round(u[0]) & 255) << 16) + ((Math.round(u[1]) & 255) << 8) + (Math.round(u[2]) & 255), c = l.toString(16).toUpperCase();
  return "000000".substring(c.length) + c;
}, i.hex.rgb = function(u) {
  var l = u.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!l)
    return [0, 0, 0];
  var c = l[0];
  l[0].length === 3 && (c = c.split("").map(function(g) {
    return g + g;
  }).join(""));
  var f = parseInt(c, 16), p = f >> 16 & 255, h = f >> 8 & 255, y = f & 255;
  return [p, h, y];
}, i.rgb.hcg = function(u) {
  var l = u[0] / 255, c = u[1] / 255, f = u[2] / 255, p = Math.max(Math.max(l, c), f), h = Math.min(Math.min(l, c), f), y = p - h, g, A;
  return y < 1 ? g = h / (1 - y) : g = 0, y <= 0 ? A = 0 : p === l ? A = (c - f) / y % 6 : p === c ? A = 2 + (f - l) / y : A = 4 + (l - c) / y + 4, A /= 6, A %= 1, [A * 360, y * 100, g * 100];
}, i.hsl.hcg = function(u) {
  var l = u[1] / 100, c = u[2] / 100, f = 1, p = 0;
  return c < 0.5 ? f = 2 * l * c : f = 2 * l * (1 - c), f < 1 && (p = (c - 0.5 * f) / (1 - f)), [u[0], f * 100, p * 100];
}, i.hsv.hcg = function(u) {
  var l = u[1] / 100, c = u[2] / 100, f = l * c, p = 0;
  return f < 1 && (p = (c - f) / (1 - f)), [u[0], f * 100, p * 100];
}, i.hcg.rgb = function(u) {
  var l = u[0] / 360, c = u[1] / 100, f = u[2] / 100;
  if (c === 0)
    return [f * 255, f * 255, f * 255];
  var p = [0, 0, 0], h = l % 1 * 6, y = h % 1, g = 1 - y, A = 0;
  switch (Math.floor(h)) {
    case 0:
      p[0] = 1, p[1] = y, p[2] = 0;
      break;
    case 1:
      p[0] = g, p[1] = 1, p[2] = 0;
      break;
    case 2:
      p[0] = 0, p[1] = 1, p[2] = y;
      break;
    case 3:
      p[0] = 0, p[1] = g, p[2] = 1;
      break;
    case 4:
      p[0] = y, p[1] = 0, p[2] = 1;
      break;
    default:
      p[0] = 1, p[1] = 0, p[2] = g;
  }
  return A = (1 - c) * f, [
    (c * p[0] + A) * 255,
    (c * p[1] + A) * 255,
    (c * p[2] + A) * 255
  ];
}, i.hcg.hsv = function(u) {
  var l = u[1] / 100, c = u[2] / 100, f = l + c * (1 - l), p = 0;
  return f > 0 && (p = l / f), [u[0], p * 100, f * 100];
}, i.hcg.hsl = function(u) {
  var l = u[1] / 100, c = u[2] / 100, f = c * (1 - l) + 0.5 * l, p = 0;
  return f > 0 && f < 0.5 ? p = l / (2 * f) : f >= 0.5 && f < 1 && (p = l / (2 * (1 - f))), [u[0], p * 100, f * 100];
}, i.hcg.hwb = function(u) {
  var l = u[1] / 100, c = u[2] / 100, f = l + c * (1 - l);
  return [u[0], (f - l) * 100, (1 - f) * 100];
}, i.hwb.hcg = function(u) {
  var l = u[1] / 100, c = u[2] / 100, f = 1 - c, p = f - l, h = 0;
  return p < 1 && (h = (f - p) / (1 - p)), [u[0], p * 100, h * 100];
}, i.apple.rgb = function(u) {
  return [u[0] / 65535 * 255, u[1] / 65535 * 255, u[2] / 65535 * 255];
}, i.rgb.apple = function(u) {
  return [u[0] / 255 * 65535, u[1] / 255 * 65535, u[2] / 255 * 65535];
}, i.gray.rgb = function(u) {
  return [u[0] / 100 * 255, u[0] / 100 * 255, u[0] / 100 * 255];
}, i.gray.hsl = i.gray.hsv = function(u) {
  return [0, 0, u[0]];
}, i.gray.hwb = function(u) {
  return [0, 100, u[0]];
}, i.gray.cmyk = function(u) {
  return [0, 0, 0, u[0]];
}, i.gray.lab = function(u) {
  return [u[0], 0, 0];
}, i.gray.hex = function(u) {
  var l = Math.round(u[0] / 100 * 255) & 255, c = (l << 16) + (l << 8) + l, f = c.toString(16).toUpperCase();
  return "000000".substring(f.length) + f;
}, i.rgb.gray = function(u) {
  var l = (u[0] + u[1] + u[2]) / 3;
  return [l / 255 * 100];
}, yn.exports;
}
var Tn, Vu;
function m8() {
if (Vu) return Tn;
Vu = 1;
var e = tf();
function t() {
  for (var n = {}, a = Object.keys(e), o = a.length, u = 0; u < o; u++)
    n[a[u]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return n;
}
function r(n) {
  var a = t(), o = [n];
  for (a[n].distance = 0; o.length; )
    for (var u = o.pop(), l = Object.keys(e[u]), c = l.length, f = 0; f < c; f++) {
      var p = l[f], h = a[p];
      h.distance === -1 && (h.distance = a[u].distance + 1, h.parent = u, o.unshift(p));
    }
  return a;
}
function i(n, a) {
  return function(o) {
    return a(n(o));
  };
}
function s(n, a) {
  for (var o = [a[n].parent, n], u = e[a[n].parent][n], l = a[n].parent; a[l].parent; )
    o.unshift(a[l].parent), u = i(e[a[l].parent][l], u), l = a[l].parent;
  return u.conversion = o, u;
}
return Tn = function(n) {
  for (var a = r(n), o = {}, u = Object.keys(a), l = u.length, c = 0; c < l; c++) {
    var f = u[c], p = a[f];
    p.parent !== null && (o[f] = s(f, a));
  }
  return o;
}, Tn;
}
var gn, qu;
function y8() {
if (qu) return gn;
qu = 1;
var e = tf(), t = m8(), r = {}, i = Object.keys(e);
function s(a) {
  var o = function(u) {
    return u == null ? u : (arguments.length > 1 && (u = Array.prototype.slice.call(arguments)), a(u));
  };
  return "conversion" in a && (o.conversion = a.conversion), o;
}
function n(a) {
  var o = function(u) {
    if (u == null)
      return u;
    arguments.length > 1 && (u = Array.prototype.slice.call(arguments));
    var l = a(u);
    if (typeof l == "object")
      for (var c = l.length, f = 0; f < c; f++)
        l[f] = Math.round(l[f]);
    return l;
  };
  return "conversion" in a && (o.conversion = a.conversion), o;
}
return i.forEach(function(a) {
  r[a] = {}, Object.defineProperty(r[a], "channels", { value: e[a].channels }), Object.defineProperty(r[a], "labels", { value: e[a].labels });
  var o = t(a), u = Object.keys(o);
  u.forEach(function(l) {
    var c = o[l];
    r[a][l] = n(c), r[a][l].raw = s(c);
  });
}), gn = r, gn;
}
is.exports;
var $u;
function b8() {
return $u || ($u = 1, function(e) {
  const t = y8(), r = (a, o) => function() {
    return `\x1B[${a.apply(t, arguments) + o}m`;
  }, i = (a, o) => function() {
    const u = a.apply(t, arguments);
    return `\x1B[${38 + o};5;${u}m`;
  }, s = (a, o) => function() {
    const u = a.apply(t, arguments);
    return `\x1B[${38 + o};2;${u[0]};${u[1]};${u[2]}m`;
  };
  function n() {
    const a = /* @__PURE__ */ new Map(), o = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    o.color.grey = o.color.gray;
    for (const c of Object.keys(o)) {
      const f = o[c];
      for (const p of Object.keys(f)) {
        const h = f[p];
        o[p] = {
          open: `\x1B[${h[0]}m`,
          close: `\x1B[${h[1]}m`
        }, f[p] = o[p], a.set(h[0], h[1]);
      }
      Object.defineProperty(o, c, {
        value: f,
        enumerable: !1
      }), Object.defineProperty(o, "codes", {
        value: a,
        enumerable: !1
      });
    }
    const u = (c) => c, l = (c, f, p) => [c, f, p];
    o.color.close = "\x1B[39m", o.bgColor.close = "\x1B[49m", o.color.ansi = {
      ansi: r(u, 0)
    }, o.color.ansi256 = {
      ansi256: i(u, 0)
    }, o.color.ansi16m = {
      rgb: s(l, 0)
    }, o.bgColor.ansi = {
      ansi: r(u, 10)
    }, o.bgColor.ansi256 = {
      ansi256: i(u, 10)
    }, o.bgColor.ansi16m = {
      rgb: s(l, 10)
    };
    for (let c of Object.keys(t)) {
      if (typeof t[c] != "object")
        continue;
      const f = t[c];
      c === "ansi16" && (c = "ansi"), "ansi16" in f && (o.color.ansi[c] = r(f.ansi16, 0), o.bgColor.ansi[c] = r(f.ansi16, 10)), "ansi256" in f && (o.color.ansi256[c] = i(f.ansi256, 0), o.bgColor.ansi256[c] = i(f.ansi256, 10)), "rgb" in f && (o.color.ansi16m[c] = s(f.rgb, 0), o.bgColor.ansi16m[c] = s(f.rgb, 10));
    }
    return o;
  }
  Object.defineProperty(e, "exports", {
    enumerable: !0,
    get: n
  });
}(is)), is.exports;
}
var Sn, Ku;
function T8() {
return Ku || (Ku = 1, Sn = {
  stdout: !1,
  stderr: !1
}), Sn;
}
var xn, Wu;
function g8() {
if (Wu) return xn;
Wu = 1;
const e = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, t = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, r = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, i = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, s = /* @__PURE__ */ new Map([
  ["n", `
`],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", "\x1B"],
  ["a", "\x07"]
]);
function n(l) {
  return l[0] === "u" && l.length === 5 || l[0] === "x" && l.length === 3 ? String.fromCharCode(parseInt(l.slice(1), 16)) : s.get(l) || l;
}
function a(l, c) {
  const f = [], p = c.trim().split(/\s*,\s*/g);
  let h;
  for (const y of p)
    if (!isNaN(y))
      f.push(Number(y));
    else if (h = y.match(r))
      f.push(h[2].replace(i, (g, A, C) => A ? n(A) : C));
    else
      throw new Error(`Invalid Chalk template style argument: ${y} (in style '${l}')`);
  return f;
}
function o(l) {
  t.lastIndex = 0;
  const c = [];
  let f;
  for (; (f = t.exec(l)) !== null; ) {
    const p = f[1];
    if (f[2]) {
      const h = a(p, f[2]);
      c.push([p].concat(h));
    } else
      c.push([p]);
  }
  return c;
}
function u(l, c) {
  const f = {};
  for (const h of c)
    for (const y of h.styles)
      f[y[0]] = h.inverse ? null : y.slice(1);
  let p = l;
  for (const h of Object.keys(f))
    if (Array.isArray(f[h])) {
      if (!(h in p))
        throw new Error(`Unknown Chalk style: ${h}`);
      f[h].length > 0 ? p = p[h].apply(p, f[h]) : p = p[h];
    }
  return p;
}
return xn = (l, c) => {
  const f = [], p = [];
  let h = [];
  if (c.replace(e, (y, g, A, C, _, j) => {
    if (g)
      h.push(n(g));
    else if (C) {
      const G = h.join("");
      h = [], p.push(f.length === 0 ? G : u(l, f)(G)), f.push({ inverse: A, styles: o(C) });
    } else if (_) {
      if (f.length === 0)
        throw new Error("Found extraneous } in Chalk template literal");
      p.push(u(l, f)(h.join(""))), h = [], f.pop();
    } else
      h.push(j);
  }), p.push(h.join("")), f.length > 0) {
    const y = `Chalk template literal is missing ${f.length} closing bracket${f.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(y);
  }
  return p.join("");
}, xn;
}
var Ju;
function S8() {
return Ju || (Ju = 1, function(e) {
  const t = h8(), r = b8(), i = T8().stdout, s = g8(), n = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm"), a = ["ansi", "ansi", "ansi256", "ansi16m"], o = /* @__PURE__ */ new Set(["gray"]), u = /* @__PURE__ */ Object.create(null);
  function l(g, A) {
    A = A || {};
    const C = i ? i.level : 0;
    g.level = A.level === void 0 ? C : A.level, g.enabled = "enabled" in A ? A.enabled : g.level > 0;
  }
  function c(g) {
    if (!this || !(this instanceof c) || this.template) {
      const A = {};
      return l(A, g), A.template = function() {
        const C = [].slice.call(arguments);
        return y.apply(null, [A.template].concat(C));
      }, Object.setPrototypeOf(A, c.prototype), Object.setPrototypeOf(A.template, A), A.template.constructor = c, A.template;
    }
    l(this, g);
  }
  n && (r.blue.open = "\x1B[94m");
  for (const g of Object.keys(r))
    r[g].closeRe = new RegExp(t(r[g].close), "g"), u[g] = {
      get() {
        const A = r[g];
        return p.call(this, this._styles ? this._styles.concat(A) : [A], this._empty, g);
      }
    };
  u.visible = {
    get() {
      return p.call(this, this._styles || [], !0, "visible");
    }
  }, r.color.closeRe = new RegExp(t(r.color.close), "g");
  for (const g of Object.keys(r.color.ansi))
    o.has(g) || (u[g] = {
      get() {
        const A = this.level;
        return function() {
          const _ = {
            open: r.color[a[A]][g].apply(null, arguments),
            close: r.color.close,
            closeRe: r.color.closeRe
          };
          return p.call(this, this._styles ? this._styles.concat(_) : [_], this._empty, g);
        };
      }
    });
  r.bgColor.closeRe = new RegExp(t(r.bgColor.close), "g");
  for (const g of Object.keys(r.bgColor.ansi)) {
    if (o.has(g))
      continue;
    const A = "bg" + g[0].toUpperCase() + g.slice(1);
    u[A] = {
      get() {
        const C = this.level;
        return function() {
          const j = {
            open: r.bgColor[a[C]][g].apply(null, arguments),
            close: r.bgColor.close,
            closeRe: r.bgColor.closeRe
          };
          return p.call(this, this._styles ? this._styles.concat(j) : [j], this._empty, g);
        };
      }
    };
  }
  const f = Object.defineProperties(() => {
  }, u);
  function p(g, A, C) {
    const _ = function() {
      return h.apply(_, arguments);
    };
    _._styles = g, _._empty = A;
    const j = this;
    return Object.defineProperty(_, "level", {
      enumerable: !0,
      get() {
        return j.level;
      },
      set(G) {
        j.level = G;
      }
    }), Object.defineProperty(_, "enabled", {
      enumerable: !0,
      get() {
        return j.enabled;
      },
      set(G) {
        j.enabled = G;
      }
    }), _.hasGrey = this.hasGrey || C === "gray" || C === "grey", _.__proto__ = f, _;
  }
  function h() {
    const g = arguments, A = g.length;
    let C = String(arguments[0]);
    if (A === 0)
      return "";
    if (A > 1)
      for (let j = 1; j < A; j++)
        C += " " + g[j];
    if (!this.enabled || this.level <= 0 || !C)
      return this._empty ? "" : C;
    const _ = r.dim.open;
    n && this.hasGrey && (r.dim.open = "");
    for (const j of this._styles.slice().reverse())
      C = j.open + C.replace(j.closeRe, j.open) + j.close, C = C.replace(/\r?\n/g, `${j.close}$&${j.open}`);
    return r.dim.open = _, C;
  }
  function y(g, A) {
    if (!Array.isArray(A))
      return [].slice.call(arguments, 1).join(" ");
    const C = [].slice.call(arguments, 2), _ = [A.raw[0]];
    for (let j = 1; j < A.length; j++)
      _.push(String(C[j - 1]).replace(/[{}\\]/g, "\\$&")), _.push(String(A.raw[j]));
    return s(g, _.join(""));
  }
  Object.defineProperties(c.prototype, u), e.exports = c(), e.exports.supportsColor = i, e.exports.default = e.exports;
}(dn)), dn.exports;
}
Object.defineProperty(Ei, "__esModule", {
value: !0
});
Ei.default = w8;
Ei.shouldHighlight = af;
var Yu = $s, Xu = pi, Wn = x8(ef, !0);
function rf(e) {
if (typeof WeakMap != "function") return null;
var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
return (rf = function(i) {
  return i ? r : t;
})(e);
}
function x8(e, t) {
if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
var r = rf(t);
if (r && r.has(e)) return r.get(e);
var i = { __proto__: null }, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
for (var n in e) if (n !== "default" && {}.hasOwnProperty.call(e, n)) {
  var a = s ? Object.getOwnPropertyDescriptor(e, n) : null;
  a && (a.get || a.set) ? Object.defineProperty(i, n, a) : i[n] = e[n];
}
return i.default = e, r && r.set(e, i), i;
}
const sf = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Wn.createColors)(!1) : Wn.default, Hu = (e, t) => (r) => e(t(r)), E8 = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
function P8(e) {
return {
  keyword: e.cyan,
  capitalized: e.yellow,
  jsxIdentifier: e.yellow,
  punctuator: e.yellow,
  number: e.magenta,
  string: e.green,
  regex: e.magenta,
  comment: e.gray,
  invalid: Hu(Hu(e.white, e.bgRed), e.bold)
};
}
const v8 = /\r\n|[\n\r\u2028\u2029]/, A8 = /^[()[\]{}]$/;
let nf;
{
const e = /^[a-z][\w-]*$/i, t = function(r, i, s) {
  if (r.type === "name") {
    if ((0, Xu.isKeyword)(r.value) || (0, Xu.isStrictReservedWord)(r.value, !0) || E8.has(r.value))
      return "keyword";
    if (e.test(r.value) && (s[i - 1] === "<" || s.slice(i - 2, i) === "</"))
      return "jsxIdentifier";
    if (r.value[0] !== r.value[0].toLowerCase())
      return "capitalized";
  }
  return r.type === "punctuator" && A8.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punctuator" : r.type;
};
nf = function* (r) {
  let i;
  for (; i = Yu.default.exec(r); ) {
    const s = Yu.matchToToken(i);
    yield {
      type: t(s, i.index, r),
      value: s.value
    };
  }
};
}
function I8(e, t) {
let r = "";
for (const {
  type: i,
  value: s
} of nf(t)) {
  const n = e[i];
  n ? r += s.split(v8).map((a) => n(a)).join(`
`) : r += s;
}
return r;
}
function af(e) {
return sf.isColorSupported || e.forceColor;
}
let En;
function C8(e) {
if (e) {
  var t;
  return (t = En) != null || (En = (0, Wn.createColors)(!0)), En;
}
return sf;
}
function w8(e, t = {}) {
if (e !== "" && af(t)) {
  const r = P8(C8(t.forceColor));
  return I8(r, e);
} else
  return e;
}
{
let e, t;
Ei.getChalk = ({
  forceColor: r
}) => {
  var i;
  if ((i = e) != null || (e = S8()), r) {
    var s;
    return (s = t) != null || (t = new e.constructor({
      enabled: !0,
      level: 1
    })), t;
  }
  return e;
};
}
Object.defineProperty(xi, "__esModule", {
value: !0
});
xi.codeFrameColumns = uf;
xi.default = L8;
var Gu = Ei, Jn = N8(ef, !0);
function of(e) {
if (typeof WeakMap != "function") return null;
var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
return (of = function(i) {
  return i ? r : t;
})(e);
}
function N8(e, t) {
if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
var r = of(t);
if (r && r.has(e)) return r.get(e);
var i = { __proto__: null }, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
for (var n in e) if (n !== "default" && {}.hasOwnProperty.call(e, n)) {
  var a = s ? Object.getOwnPropertyDescriptor(e, n) : null;
  a && (a.get || a.set) ? Object.defineProperty(i, n, a) : i[n] = e[n];
}
return i.default = e, r && r.set(e, i), i;
}
const O8 = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Jn.createColors)(!1) : Jn.default, zu = (e, t) => (r) => e(t(r));
let Pn;
function _8(e) {
if (e) {
  var t;
  return (t = Pn) != null || (Pn = (0, Jn.createColors)(!0)), Pn;
}
return O8;
}
let Qu = !1;
function k8(e) {
return {
  gutter: e.gray,
  marker: zu(e.red, e.bold),
  message: zu(e.red, e.bold)
};
}
const Zu = /\r\n|[\n\r\u2028\u2029]/;
function D8(e, t, r) {
const i = Object.assign({
  column: 0,
  line: -1
}, e.start), s = Object.assign({}, i, e.end), {
  linesAbove: n = 2,
  linesBelow: a = 3
} = r || {}, o = i.line, u = i.column, l = s.line, c = s.column;
let f = Math.max(o - (n + 1), 0), p = Math.min(t.length, l + a);
o === -1 && (f = 0), l === -1 && (p = t.length);
const h = l - o, y = {};
if (h)
  for (let g = 0; g <= h; g++) {
    const A = g + o;
    if (!u)
      y[A] = !0;
    else if (g === 0) {
      const C = t[A - 1].length;
      y[A] = [u, C - u + 1];
    } else if (g === h)
      y[A] = [0, c];
    else {
      const C = t[A - g].length;
      y[A] = [0, C];
    }
  }
else
  u === c ? u ? y[o] = [u, 0] : y[o] = !0 : y[o] = [u, c - u];
return {
  start: f,
  end: p,
  markerLines: y
};
}
function uf(e, t, r = {}) {
const i = (r.highlightCode || r.forceColor) && (0, Gu.shouldHighlight)(r), s = _8(r.forceColor), n = k8(s), a = (g, A) => i ? g(A) : A, o = e.split(Zu), {
  start: u,
  end: l,
  markerLines: c
} = D8(t, o, r), f = t.start && typeof t.start.column == "number", p = String(l).length;
let y = (i ? (0, Gu.default)(e, r) : e).split(Zu, l).slice(u, l).map((g, A) => {
  const C = u + 1 + A, j = ` ${` ${C}`.slice(-p)} |`, G = c[C], fe = !c[C + 1];
  if (G) {
    let re = "";
    if (Array.isArray(G)) {
      const oe = g.slice(0, Math.max(G[0] - 1, 0)).replace(/[^\t]/g, " "), K = G[1] || 1;
      re = [`
`, a(n.gutter, j.replace(/\d/g, " ")), " ", oe, a(n.marker, "^").repeat(K)].join(""), fe && r.message && (re += " " + a(n.message, r.message));
    }
    return [a(n.marker, ">"), a(n.gutter, j), g.length > 0 ? ` ${g}` : "", re].join("");
  } else
    return ` ${a(n.gutter, j)}${g.length > 0 ? ` ${g}` : ""}`;
}).join(`
`);
return r.message && !f && (y = `${" ".repeat(p + 1)}${r.message}
${y}`), i ? s.reset(y) : y;
}
function L8(e, t, r, i = {}) {
if (!Qu) {
  Qu = !0;
  const n = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
  if (process.emitWarning)
    process.emitWarning(n, "DeprecationWarning");
  else {
    const a = new Error(n);
    a.name = "DeprecationWarning", console.warn(new Error(n));
  }
}
return r = Math.max(r, 0), uf(e, {
  start: {
    column: r,
    line: t
  }
}, i);
}
var vt = {}, Ks = {};
Object.defineProperty(Ks, "__esModule", {
value: !0
});
Ks.default = void 0;
var lf = Ce(), M8 = lf;
const {
react: B8
} = lf, {
cloneNode: F8,
jsxExpressionContainer: j8,
variableDeclaration: R8,
variableDeclarator: U8
} = M8, V8 = {
ReferencedIdentifier(e, t) {
  if (e.isJSXIdentifier() && B8.isCompatTag(e.node.name) && !e.parentPath.isJSXMemberExpression())
    return;
  if (e.node.name === "this") {
    let i = e.scope;
    do
      if (i.path.isFunction() && !i.path.isArrowFunctionExpression())
        break;
    while (i = i.parent);
    i && t.breakOnScopePaths.push(i.path);
  }
  const r = e.scope.getBinding(e.node.name);
  if (r) {
    for (const i of r.constantViolations)
      if (i.scope !== r.path.scope) {
        t.mutableBinding = !0, e.stop();
        return;
      }
    r === t.scope.getBinding(e.node.name) && (t.bindings[e.node.name] = r);
  }
}
};
class q8 {
constructor(t, r) {
  this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], this.scope = r, this.path = t, this.attachAfter = !1;
}
isCompatibleScope(t) {
  for (const r of Object.keys(this.bindings)) {
    const i = this.bindings[r];
    if (!t.bindingIdentifierEquals(r, i.identifier))
      return !1;
  }
  return !0;
}
getCompatibleScopes() {
  let t = this.path.scope;
  do {
    if (this.isCompatibleScope(t))
      this.scopes.push(t);
    else
      break;
    if (this.breakOnScopePaths.includes(t.path))
      break;
  } while (t = t.parent);
}
getAttachmentPath() {
  let t = this._getAttachmentPath();
  if (!t) return;
  let r = t.scope;
  if (r.path === t && (r = t.scope.parent), r.path.isProgram() || r.path.isFunction())
    for (const i of Object.keys(this.bindings)) {
      if (!r.hasOwnBinding(i)) continue;
      const s = this.bindings[i];
      if (s.kind === "param" || s.path.parentKey === "params")
        continue;
      if (this.getAttachmentParentForPath(s.path).key >= t.key) {
        this.attachAfter = !0, t = s.path;
        for (const a of s.constantViolations)
          this.getAttachmentParentForPath(a).key > t.key && (t = a);
      }
    }
  return t;
}
_getAttachmentPath() {
  const r = this.scopes.pop();
  if (r) {
    if (r.path.isFunction())
      if (this.hasOwnParamBindings(r)) {
        if (this.scope === r) return;
        const i = r.path.get("body").get("body");
        for (let s = 0; s < i.length; s++)
          if (!i[s].node._blockHoist)
            return i[s];
      } else
        return this.getNextScopeAttachmentParent();
    else if (r.path.isProgram())
      return this.getNextScopeAttachmentParent();
  }
}
getNextScopeAttachmentParent() {
  const t = this.scopes.pop();
  if (t) return this.getAttachmentParentForPath(t.path);
}
getAttachmentParentForPath(t) {
  do
    if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
      return t;
  while (t = t.parentPath);
}
hasOwnParamBindings(t) {
  for (const r of Object.keys(this.bindings)) {
    if (!t.hasOwnBinding(r)) continue;
    const i = this.bindings[r];
    if (i.kind === "param" && i.constant) return !0;
  }
  return !1;
}
run() {
  if (this.path.traverse(V8, this), this.mutableBinding) return;
  this.getCompatibleScopes();
  const t = this.getAttachmentPath();
  if (!t || t.getFunctionParent() === this.path.getFunctionParent()) return;
  let r = t.scope.generateUidIdentifier("ref");
  const i = U8(r, this.path.node), s = this.attachAfter ? "insertAfter" : "insertBefore", [n] = t[s]([t.isVariableDeclarator() ? i : R8("var", [i])]), a = this.path.parentPath;
  return a.isJSXElement() && this.path.container === a.node.children && (r = j8(r)), this.path.replaceWith(F8(r)), t.isVariableDeclarator() ? n.get("init") : n.get("declarations.0.init");
}
}
Ks.default = q8;
var Qe = {}, qt = {}, Ws = {};
Object.defineProperty(Ws, "__esModule", {
value: !0
});
Ws.hooks = void 0;
Ws.hooks = [function(e, t) {
if (e.key === "test" && (t.isWhile() || t.isSwitchCase()) || e.key === "declaration" && t.isExportDeclaration() || e.key === "body" && t.isLabeledStatement() || e.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e.key === "expression" && t.isExpressionStatement())
  return t.remove(), !0;
}, function(e, t) {
if (t.isSequenceExpression() && t.node.expressions.length === 1)
  return t.replaceWith(t.node.expressions[0]), !0;
}, function(e, t) {
if (t.isBinary())
  return e.key === "left" ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
}, function(e, t) {
if (t.isIfStatement() && e.key === "consequent" || e.key === "body" && (t.isLoop() || t.isArrowFunctionExpression()))
  return e.replaceWith({
    type: "BlockStatement",
    body: []
  }), !0;
}];
var el;
function Ua() {
if (el) return qt;
el = 1, Object.defineProperty(qt, "__esModule", {
  value: !0
}), qt._assertUnremoved = f, qt._callRemovalHooks = u, qt._markRemoved = c, qt._remove = l, qt._removeFromScope = o, qt.remove = a;
var e = Ws, t = lt, r = kf(), i = vr(), s = Ce();
const {
  getBindingIdentifiers: n
} = s;
function a() {
  var p;
  if (f.call(this), this.resync(), (p = this.opts) != null && p.noScope || o.call(this), u.call(this)) {
    c.call(this);
    return;
  }
  this.shareCommentsWithSiblings(), l.call(this), c.call(this);
}
function o() {
  const p = n(this.node, !1, !1, !0);
  Object.keys(p).forEach((h) => this.scope.removeBinding(h));
}
function u() {
  if (this.parentPath) {
    for (const p of e.hooks)
      if (p(this, this.parentPath)) return !0;
  }
}
function l() {
  Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : r._replaceWith.call(this, null);
}
function c() {
  this._traverseFlags |= i.SHOULD_SKIP | i.REMOVED, this.parent && (0, t.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
}
function f() {
  if (this.removed)
    throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
}
return qt;
}
var tl;
function cf() {
if (tl) return Qe;
tl = 1, Object.defineProperty(Qe, "__esModule", {
  value: !0
}), Qe._call = s, Qe._getQueueContexts = oe, Qe._resyncKey = g, Qe._resyncList = A, Qe._resyncParent = y, Qe._resyncRemoved = C, Qe.call = i, Qe.isBlacklisted = Qe.isDenylisted = n, Qe.popContext = _, Qe.pushContext = j, Qe.requeue = re, Qe.resync = h, Qe.setContext = p, Qe.setKey = fe, Qe.setScope = f, Qe.setup = G, Qe.skip = u, Qe.skipKey = l, Qe.stop = c, Qe.visit = o;
var e = lo(), t = vr(), r = Ua();
function i(K) {
  const X = this.opts;
  if (this.debug(K), this.node && s.call(this, X[K]))
    return !0;
  if (this.node) {
    var ie;
    return s.call(this, (ie = X[this.node.type]) == null ? void 0 : ie[K]);
  }
  return !1;
}
function s(K) {
  if (!K) return !1;
  for (const X of K) {
    if (!X) continue;
    const ie = this.node;
    if (!ie) return !0;
    const W = X.call(this.state, this, this.state);
    if (W && typeof W == "object" && typeof W.then == "function")
      throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
    if (W)
      throw new Error(`Unexpected return value from visitor method ${X}`);
    if (this.node !== ie || this._traverseFlags > 0) return !0;
  }
  return !1;
}
function n() {
  var K;
  const X = (K = this.opts.denylist) != null ? K : this.opts.blacklist;
  return X && X.indexOf(this.node.type) > -1;
}
function a(K, X) {
  K.context !== X && (K.context = X, K.state = X.state, K.opts = X.opts);
}
function o() {
  var K, X;
  if (!this.node || this.isDenylisted() || (K = (X = this.opts).shouldSkip) != null && K.call(X, this))
    return !1;
  const ie = this.context;
  return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (a(this, ie), this.debug("Recursing into..."), this.shouldStop = (0, e.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), a(this, ie), this.call("exit"), this.shouldStop);
}
function u() {
  this.shouldSkip = !0;
}
function l(K) {
  this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[K] = !0;
}
function c() {
  this._traverseFlags |= t.SHOULD_SKIP | t.SHOULD_STOP;
}
function f() {
  var K, X;
  if ((K = this.opts) != null && K.noScope) return;
  let ie = this.parentPath;
  ((this.key === "key" || this.listKey === "decorators") && ie.isMethod() || this.key === "discriminant" && ie.isSwitchStatement()) && (ie = ie.parentPath);
  let W;
  for (; ie && !W; ) {
    var Q;
    if ((Q = ie.opts) != null && Q.noScope) return;
    W = ie.scope, ie = ie.parentPath;
  }
  this.scope = this.getScope(W), (X = this.scope) == null || X.init();
}
function p(K) {
  return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, K && (this.context = K, this.state = K.state, this.opts = K.opts), this.setScope(), this;
}
function h() {
  this.removed || (y.call(this), A.call(this), g.call(this));
}
function y() {
  this.parentPath && (this.parent = this.parentPath.node);
}
function g() {
  if (this.container && this.node !== this.container[this.key]) {
    if (Array.isArray(this.container)) {
      for (let K = 0; K < this.container.length; K++)
        if (this.container[K] === this.node) {
          this.setKey(K);
          return;
        }
    } else
      for (const K of Object.keys(this.container))
        if (this.container[K] === this.node) {
          this.setKey(K);
          return;
        }
    this.key = null;
  }
}
function A() {
  if (!this.parent || !this.inList) return;
  const K = this.parent[this.listKey];
  this.container !== K && (this.container = K || null);
}
function C() {
  (this.key == null || !this.container || this.container[this.key] !== this.node) && r._markRemoved.call(this);
}
function _() {
  this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
}
function j(K) {
  this.contexts.push(K), this.setContext(K);
}
function G(K, X, ie, W) {
  this.listKey = ie, this.container = X, this.parentPath = K || this.parentPath, this.setKey(W);
}
function fe(K) {
  var X;
  this.key = K, this.node = this.container[this.key], this.type = (X = this.node) == null ? void 0 : X.type;
}
function re(K = this) {
  if (K.removed) return;
  const X = this.contexts;
  for (const ie of X)
    ie.maybeQueue(K);
}
function oe() {
  let K = this, X = this.contexts;
  for (; !X.length && (K = K.parentPath, !!K); )
    X = K.contexts;
  return X;
}
return Qe;
}
var rl;
function ff() {
if (rl) return vt;
rl = 1, Object.defineProperty(vt, "__esModule", {
  value: !0
}), vt._containerInsert = re, vt._containerInsertAfter = K, vt._containerInsertBefore = oe, vt._verifyNodeList = L, vt.hoist = B, vt.insertAfter = Q, vt.insertBefore = fe, vt.pushContainer = F, vt.unshiftContainer = k, vt.updateSiblingKeys = U;
var e = lt, t = Ks, r = vr(), i = cf(), s = Ua(), n = Ce();
const {
  arrowFunctionExpression: a,
  assertExpression: o,
  assignmentExpression: u,
  blockStatement: l,
  callExpression: c,
  cloneNode: f,
  expressionStatement: p,
  isAssignmentExpression: h,
  isCallExpression: y,
  isExportNamedDeclaration: g,
  isExpression: A,
  isIdentifier: C,
  isSequenceExpression: _,
  isSuper: j,
  thisExpression: G
} = n;
function fe(O) {
  s._assertUnremoved.call(this);
  const D = L.call(this, O), {
    parentPath: R,
    parent: q
  } = this;
  if (R.isExpressionStatement() || R.isLabeledStatement() || g(q) || R.isExportDefaultDeclaration() && this.isDeclaration())
    return R.insertBefore(D);
  if (this.isNodeType("Expression") && !this.isJSXElement() || R.isForStatement() && this.key === "init")
    return this.node && D.push(this.node), this.replaceExpressionWithStatements(D);
  if (Array.isArray(this.container))
    return oe.call(this, D);
  if (this.isStatementOrBlock()) {
    const V = this.node, H = V && (!this.isExpressionStatement() || V.expression != null);
    return this.replaceWith(l(H ? [V] : [])), this.unshiftContainer("body", D);
  } else
    throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
}
function re(O, D) {
  this.updateSiblingKeys(O, D.length);
  const R = [];
  this.container.splice(O, 0, ...D);
  for (let H = 0; H < D.length; H++) {
    var q;
    const ne = O + H, ue = this.getSibling(ne);
    R.push(ue), (q = this.context) != null && q.queue && ue.pushContext(this.context);
  }
  const V = i._getQueueContexts.call(this);
  for (const H of R) {
    H.setScope(), H.debug("Inserted.");
    for (const ne of V)
      ne.maybeQueue(H, !0);
  }
  return R;
}
function oe(O) {
  return re.call(this, this.key, O);
}
function K(O) {
  return re.call(this, this.key + 1, O);
}
const X = (O) => O[O.length - 1];
function ie(O) {
  return _(O.parent) && (X(O.parent.expressions) !== O.node || ie(O.parentPath));
}
function W(O, D) {
  if (!h(O) || !C(O.left))
    return !1;
  const R = D.getBlockParent();
  return R.hasOwnBinding(O.left.name) && R.getOwnBinding(O.left.name).constantViolations.length <= 1;
}
function Q(O) {
  if (s._assertUnremoved.call(this), this.isSequenceExpression())
    return X(this.get("expressions")).insertAfter(O);
  const D = L.call(this, O), {
    parentPath: R,
    parent: q
  } = this;
  if (R.isExpressionStatement() || R.isLabeledStatement() || g(q) || R.isExportDefaultDeclaration() && this.isDeclaration())
    return R.insertAfter(D.map((V) => A(V) ? p(V) : V));
  if (this.isNodeType("Expression") && !this.isJSXElement() && !R.isJSXElement() || R.isForStatement() && this.key === "init") {
    const V = this;
    if (V.node) {
      const H = V.node;
      let {
        scope: ne
      } = this;
      if (ne.path.isPattern())
        return o(H), V.replaceWith(c(a([], H), [])), V.get("callee.body").insertAfter(D), [V];
      if (ie(V))
        D.unshift(H);
      else if (y(H) && j(H.callee))
        D.unshift(H), D.push(G());
      else if (W(H, ne))
        D.unshift(H), D.push(f(H.left));
      else if (ne.isPure(H, !0))
        D.push(H);
      else {
        R.isMethod({
          computed: !0,
          key: H
        }) && (ne = ne.parent);
        const ue = ne.generateDeclaredUidIdentifier();
        D.unshift(p(u("=", f(ue), H))), D.push(p(f(ue)));
      }
    }
    return this.replaceExpressionWithStatements(D);
  } else {
    if (Array.isArray(this.container))
      return K.call(this, D);
    if (this.isStatementOrBlock()) {
      const V = this.node, H = V && (!this.isExpressionStatement() || V.expression != null);
      return this.replaceWith(l(H ? [V] : [])), this.pushContainer("body", D);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
}
function U(O, D) {
  if (!this.parent) return;
  const R = (0, e.getCachedPaths)(this.hub, this.parent) || [];
  for (const [, q] of R)
    typeof q.key == "number" && q.key >= O && (q.key += D);
}
function L(O) {
  if (!O)
    return [];
  Array.isArray(O) || (O = [O]);
  for (let D = 0; D < O.length; D++) {
    const R = O[D];
    let q;
    if (R ? typeof R != "object" ? q = "contains a non-object node" : R.type ? R instanceof r.default && (q = "has a NodePath when it expected a raw object") : q = "without a type" : q = "has falsy node", q) {
      const V = Array.isArray(R) ? "array" : typeof R;
      throw new Error(`Node list ${q} with the index of ${D} and type of ${V}`);
    }
  }
  return O;
}
function k(O, D) {
  s._assertUnremoved.call(this), D = L.call(this, D);
  const R = r.default.get({
    parentPath: this,
    parent: this.node,
    container: this.node[O],
    listKey: O,
    key: 0
  }).setContext(this.context);
  return oe.call(R, D);
}
function F(O, D) {
  s._assertUnremoved.call(this);
  const R = L.call(this, D), q = this.node[O];
  return r.default.get({
    parentPath: this,
    parent: this.node,
    container: q,
    listKey: O,
    key: q.length
  }).setContext(this.context).replaceWithMultiple(R);
}
function B(O = this.scope) {
  return new t.default(this, O).run();
}
return vt;
}
var Mr = {};
Object.defineProperty(Mr, "__esModule", {
value: !0
});
function pf(e, t) {
if (e == null) return {};
var r = {}, i = Object.keys(e), s, n;
for (n = 0; n < i.length; n++)
  s = i[n], !(t.indexOf(s) >= 0) && (r[s] = e[s]);
return r;
}
class ar {
constructor(t, r, i) {
  this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = i;
}
}
class ps {
constructor(t, r) {
  this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
}
}
function gt(e, t) {
const {
  line: r,
  column: i,
  index: s
} = e;
return new ar(r, i + t, s + t);
}
const il = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
var $8 = {
ImportMetaOutsideModule: {
  message: `import.meta may appear only with 'sourceType: "module"'`,
  code: il
},
ImportOutsideModule: {
  message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
  code: il
}
};
const sl = {
ArrayPattern: "array destructuring pattern",
AssignmentExpression: "assignment expression",
AssignmentPattern: "assignment expression",
ArrowFunctionExpression: "arrow function expression",
ConditionalExpression: "conditional expression",
CatchClause: "catch clause",
ForOfStatement: "for-of statement",
ForInStatement: "for-in statement",
ForStatement: "for-loop",
FormalParameters: "function parameter list",
Identifier: "identifier",
ImportSpecifier: "import specifier",
ImportDefaultSpecifier: "import default specifier",
ImportNamespaceSpecifier: "import namespace specifier",
ObjectPattern: "object destructuring pattern",
ParenthesizedExpression: "parenthesized expression",
RestElement: "rest element",
UpdateExpression: {
  true: "prefix operation",
  false: "postfix operation"
},
VariableDeclarator: "variable declaration",
YieldExpression: "yield expression"
}, ss = (e) => e.type === "UpdateExpression" ? sl.UpdateExpression[`${e.prefix}`] : sl[e.type];
var K8 = {
AccessorIsGenerator: ({
  kind: e
}) => `A ${e}ter cannot be a generator.`,
ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
BadGetterArity: "A 'get' accessor must not have any formal parameters.",
BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
ConstructorClassField: "Classes may not have a field named 'constructor'.",
ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
ConstructorIsAccessor: "Class constructor may not be an accessor.",
ConstructorIsAsync: "Constructor can't be an async function.",
ConstructorIsGenerator: "Constructor can't be a generator.",
DeclarationMissingInitializer: ({
  kind: e
}) => `Missing initializer in ${e} declaration.`,
DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
DecoratorStaticBlock: "Decorators can't be used with a static block.",
DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
DeletePrivateField: "Deleting a private field is not allowed.",
DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
DuplicateConstructor: "Duplicate constructor in the same class.",
DuplicateDefaultExport: "Only one default export allowed per module.",
DuplicateExport: ({
  exportName: e
}) => `\`${e}\` has already been exported. Exported identifiers must be unique.`,
DuplicateProto: "Redefinition of __proto__ property.",
DuplicateRegExpFlags: "Duplicate regular expression flag.",
DynamicImportPhaseRequiresImportExpressions: ({
  phase: e
}) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`,
ElementAfterRest: "Rest element must be last element.",
EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
ExportBindingIsString: ({
  localName: e,
  exportName: t
}) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`,
ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
ForInOfLoopInitializer: ({
  type: e
}) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
ForInUsing: "For-in loop may not start with 'using' declaration.",
ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
IllegalBreakContinue: ({
  type: e
}) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`,
IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
IllegalReturn: "'return' outside of function.",
ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
ImportBindingIsString: ({
  importName: e
}) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`,
ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
ImportCallArity: ({
  maxArgumentCount: e
}) => `\`import()\` requires exactly ${e === 1 ? "one argument" : "one or two arguments"}.`,
ImportCallNotNewExpression: "Cannot use new with import(...).",
ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
InvalidBigIntLiteral: "Invalid BigIntLiteral.",
InvalidCodePoint: "Code point out of bounds.",
InvalidCoverInitializedName: "Invalid shorthand property initializer.",
InvalidDecimal: "Invalid decimal.",
InvalidDigit: ({
  radix: e
}) => `Expected number in radix ${e}.`,
InvalidEscapeSequence: "Bad character escape sequence.",
InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
InvalidEscapedReservedWord: ({
  reservedWord: e
}) => `Escape sequence in keyword ${e}.`,
InvalidIdentifier: ({
  identifierName: e
}) => `Invalid identifier ${e}.`,
InvalidLhs: ({
  ancestor: e
}) => `Invalid left-hand side in ${ss(e)}.`,
InvalidLhsBinding: ({
  ancestor: e
}) => `Binding invalid left-hand side in ${ss(e)}.`,
InvalidLhsOptionalChaining: ({
  ancestor: e
}) => `Invalid optional chaining in the left-hand side of ${ss(e)}.`,
InvalidNumber: "Invalid number.",
InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
InvalidOrUnexpectedToken: ({
  unexpected: e
}) => `Unexpected character '${e}'.`,
InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
InvalidPrivateFieldResolution: ({
  identifierName: e
}) => `Private name #${e} is not defined.`,
InvalidPropertyBindingPattern: "Binding member expression.",
InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
LabelRedeclaration: ({
  labelName: e
}) => `Label '${e}' is already declared.`,
LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
MalformedRegExpFlags: "Invalid regular expression flag.",
MissingClassName: "A class name is required.",
MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
MissingSemicolon: "Missing semicolon.",
MissingPlugin: ({
  missingPlugin: e
}) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
MissingOneOfPlugins: ({
  missingPlugin: e
}) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
ModuleAttributesWithDuplicateKeys: ({
  key: e
}) => `Duplicate key "${e}" is not allowed in module attributes.`,
ModuleExportNameHasLoneSurrogate: ({
  surrogateCharCode: e
}) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`,
ModuleExportUndefined: ({
  localName: e
}) => `Export '${e}' is not defined.`,
MultipleDefaultsInSwitch: "Multiple default clauses.",
NewlineAfterThrow: "Illegal newline after throw.",
NoCatchOrFinally: "Missing catch or finally clause.",
NumberIdentifier: "Identifier directly after number.",
NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
ParamDupe: "Argument name clash.",
PatternHasAccessor: "Object pattern can't contain getter or setter.",
PatternHasMethod: "Object pattern can't contain methods.",
PrivateInExpectedIn: ({
  identifierName: e
}) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`,
PrivateNameRedeclaration: ({
  identifierName: e
}) => `Duplicate private name #${e}.`,
RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
RecordNoProto: "'__proto__' is not allowed in Record expressions.",
RestTrailingComma: "Unexpected trailing comma after rest element.",
SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
StaticPrototype: "Classes may not have static property named prototype.",
SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
SuperPrivateField: "Private fields can't be accessed on super.",
TrailingDecorator: "Decorators must be attached to a class element.",
TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
UnexpectedKeyword: ({
  keyword: e
}) => `Unexpected keyword '${e}'.`,
UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
UnexpectedPrivateField: "Unexpected private name.",
UnexpectedReservedWord: ({
  reservedWord: e
}) => `Unexpected reserved word '${e}'.`,
UnexpectedSuper: "'super' is only allowed in object methods and classes.",
UnexpectedToken: ({
  expected: e,
  unexpected: t
}) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`,
UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
UnsupportedBind: "Binding should be performed on object property.",
UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
UnsupportedMetaProperty: ({
  target: e,
  onlyValidPropertyName: t
}) => `The only valid meta property for ${e} is ${e}.${t}.`,
UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
UnterminatedComment: "Unterminated comment.",
UnterminatedRegExp: "Unterminated regular expression.",
UnterminatedString: "Unterminated string constant.",
UnterminatedTemplate: "Unterminated template.",
UsingDeclarationExport: "Using declaration cannot be exported.",
UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
VarRedeclaration: ({
  identifierName: e
}) => `Identifier '${e}' has already been declared.`,
YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
YieldInParameter: "Yield expression is not allowed in formal parameters.",
ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
}, W8 = {
StrictDelete: "Deleting local variable in strict mode.",
StrictEvalArguments: ({
  referenceName: e
}) => `Assigning to '${e}' in strict mode.`,
StrictEvalArgumentsBinding: ({
  bindingName: e
}) => `Binding '${e}' in strict mode.`,
StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
StrictWith: "'with' in strict mode."
};
const J8 = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
var Y8 = {
PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
PipeTopicUnconfiguredToken: ({
  token: e
}) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`,
PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
PipeUnparenthesizedBody: ({
  type: e
}) => `Hack-style pipe body cannot be an unparenthesized ${ss({
  type: e
})}; please wrap it in parentheses.`,
PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
};
const X8 = ["toMessage"], H8 = ["message"];
function nl(e, t, r) {
Object.defineProperty(e, t, {
  enumerable: !1,
  configurable: !0,
  value: r
});
}
function G8(e) {
let {
  toMessage: t
} = e, r = pf(e, X8);
return function i(s, n) {
  const a = new SyntaxError();
  return Object.assign(a, r, {
    loc: s,
    pos: s.index
  }), "missingPlugin" in n && Object.assign(a, {
    missingPlugin: n.missingPlugin
  }), nl(a, "clone", function(u = {}) {
    var l;
    const {
      line: c,
      column: f,
      index: p
    } = (l = u.loc) != null ? l : s;
    return i(new ar(c, f, p), Object.assign({}, n, u.details));
  }), nl(a, "details", n), Object.defineProperty(a, "message", {
    configurable: !0,
    get() {
      const o = `${t(n)} (${s.line}:${s.column})`;
      return this.message = o, o;
    },
    set(o) {
      Object.defineProperty(this, "message", {
        value: o,
        writable: !0
      });
    }
  }), a;
};
}
function Ht(e, t) {
if (Array.isArray(e))
  return (i) => Ht(i, e[0]);
const r = {};
for (const i of Object.keys(e)) {
  const s = e[i], n = typeof s == "string" ? {
    message: () => s
  } : typeof s == "function" ? {
    message: s
  } : s, {
    message: a
  } = n, o = pf(n, H8), u = typeof a == "string" ? () => a : a;
  r[i] = G8(Object.assign({
    code: "BABEL_PARSER_SYNTAX_ERROR",
    reasonCode: i,
    toMessage: u
  }, t ? {
    syntaxPlugin: t
  } : {}, o));
}
return r;
}
const w = Object.assign({}, Ht($8), Ht(K8), Ht(W8), Ht`pipelineOperator`(Y8)), {
defineProperty: z8
} = Object, al = (e, t) => {
e && z8(e, t, {
  enumerable: !1,
  value: e[t]
});
};
function Yr(e) {
return al(e.loc.start, "index"), al(e.loc.end, "index"), e;
}
var Q8 = (e) => class extends e {
parse() {
  const r = Yr(super.parse());
  return this.options.tokens && (r.tokens = r.tokens.map(Yr)), r;
}
parseRegExpLiteral({
  pattern: r,
  flags: i
}) {
  let s = null;
  try {
    s = new RegExp(r, i);
  } catch {
  }
  const n = this.estreeParseLiteral(s);
  return n.regex = {
    pattern: r,
    flags: i
  }, n;
}
parseBigIntLiteral(r) {
  let i;
  try {
    i = BigInt(r);
  } catch {
    i = null;
  }
  const s = this.estreeParseLiteral(i);
  return s.bigint = String(s.value || r), s;
}
parseDecimalLiteral(r) {
  const s = this.estreeParseLiteral(null);
  return s.decimal = String(s.value || r), s;
}
estreeParseLiteral(r) {
  return this.parseLiteral(r, "Literal");
}
parseStringLiteral(r) {
  return this.estreeParseLiteral(r);
}
parseNumericLiteral(r) {
  return this.estreeParseLiteral(r);
}
parseNullLiteral() {
  return this.estreeParseLiteral(null);
}
parseBooleanLiteral(r) {
  return this.estreeParseLiteral(r);
}
directiveToStmt(r) {
  const i = r.value;
  delete r.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
  const s = r;
  return s.type = "ExpressionStatement", s.expression = i, s.directive = i.extra.rawValue, delete i.extra, s;
}
initFunction(r, i) {
  super.initFunction(r, i), r.expression = !1;
}
checkDeclaration(r) {
  r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
}
getObjectOrClassMethodParams(r) {
  return r.value.params;
}
isValidDirective(r) {
  var i;
  return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((i = r.expression.extra) != null && i.parenthesized);
}
parseBlockBody(r, i, s, n, a) {
  super.parseBlockBody(r, i, s, n, a);
  const o = r.directives.map((u) => this.directiveToStmt(u));
  r.body = o.concat(r.body), delete r.directives;
}
pushClassMethod(r, i, s, n, a, o) {
  this.parseMethod(i, s, n, a, o, "ClassMethod", !0), i.typeParameters && (i.value.typeParameters = i.typeParameters, delete i.typeParameters), r.body.push(i);
}
parsePrivateName() {
  const r = super.parsePrivateName();
  return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
}
convertPrivateNameToPrivateIdentifier(r) {
  const i = super.getPrivateNameSV(r);
  return r = r, delete r.id, r.name = i, r.type = "PrivateIdentifier", r;
}
isPrivateName(r) {
  return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
}
getPrivateNameSV(r) {
  return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
}
parseLiteral(r, i) {
  const s = super.parseLiteral(r, i);
  return s.raw = s.extra.raw, delete s.extra, s;
}
parseFunctionBody(r, i, s = !1) {
  super.parseFunctionBody(r, i, s), r.expression = r.body.type !== "BlockStatement";
}
parseMethod(r, i, s, n, a, o, u = !1) {
  let l = this.startNode();
  return l.kind = r.kind, l = super.parseMethod(l, i, s, n, a, o, u), l.type = "FunctionExpression", delete l.kind, r.value = l, o === "ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
}
nameIsConstructor(r) {
  return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
}
parseClassProperty(...r) {
  const i = super.parseClassProperty(...r);
  return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
}
parseClassPrivateProperty(...r) {
  const i = super.parseClassPrivateProperty(...r);
  return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
}
parseObjectMethod(r, i, s, n, a) {
  const o = super.parseObjectMethod(r, i, s, n, a);
  return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = !1), o;
}
parseObjectProperty(r, i, s, n) {
  const a = super.parseObjectProperty(r, i, s, n);
  return a && (a.kind = "init", a.type = "Property"), a;
}
isValidLVal(r, i, s) {
  return r === "Property" ? "value" : super.isValidLVal(r, i, s);
}
isAssignable(r, i) {
  return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, i) : super.isAssignable(r, i);
}
toAssignable(r, i = !1) {
  if (r != null && this.isObjectProperty(r)) {
    const {
      key: s,
      value: n
    } = r;
    this.isPrivateName(s) && this.classScope.usePrivateName(this.getPrivateNameSV(s), s.loc.start), this.toAssignable(n, i);
  } else
    super.toAssignable(r, i);
}
toAssignableObjectExpressionProp(r, i, s) {
  r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(w.PatternHasAccessor, r.key) : r.type === "Property" && r.method ? this.raise(w.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, i, s);
}
finishCallExpression(r, i) {
  const s = super.finishCallExpression(r, i);
  if (s.callee.type === "Import") {
    if (s.type = "ImportExpression", s.source = s.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
      var n, a;
      s.options = (n = s.arguments[1]) != null ? n : null, s.attributes = (a = s.arguments[1]) != null ? a : null;
    }
    delete s.arguments, delete s.callee;
  }
  return s;
}
toReferencedArguments(r) {
  r.type !== "ImportExpression" && super.toReferencedArguments(r);
}
parseExport(r, i) {
  const s = this.state.lastTokStartLoc, n = super.parseExport(r, i);
  switch (n.type) {
    case "ExportAllDeclaration":
      n.exported = null;
      break;
    case "ExportNamedDeclaration":
      n.specifiers.length === 1 && n.specifiers[0].type === "ExportNamespaceSpecifier" && (n.type = "ExportAllDeclaration", n.exported = n.specifiers[0].exported, delete n.specifiers);
    case "ExportDefaultDeclaration":
      {
        var a;
        const {
          declaration: o
        } = n;
        (o == null ? void 0 : o.type) === "ClassDeclaration" && ((a = o.decorators) == null ? void 0 : a.length) > 0 && o.start === n.start && this.resetStartLocation(n, s);
      }
      break;
  }
  return n;
}
parseSubscript(r, i, s, n) {
  const a = super.parseSubscript(r, i, s, n);
  if (n.optionalChainMember) {
    if ((a.type === "OptionalMemberExpression" || a.type === "OptionalCallExpression") && (a.type = a.type.substring(8)), n.stop) {
      const o = this.startNodeAtNode(a);
      return o.expression = a, this.finishNode(o, "ChainExpression");
    }
  } else (a.type === "MemberExpression" || a.type === "CallExpression") && (a.optional = !1);
  return a;
}
isOptionalMemberExpression(r) {
  return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
}
hasPropertyAsPrivateName(r) {
  return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
}
isObjectProperty(r) {
  return r.type === "Property" && r.kind === "init" && !r.method;
}
isObjectMethod(r) {
  return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
}
finishNodeAt(r, i, s) {
  return Yr(super.finishNodeAt(r, i, s));
}
resetStartLocation(r, i) {
  super.resetStartLocation(r, i), Yr(r);
}
resetEndLocation(r, i = this.state.lastTokEndLoc) {
  super.resetEndLocation(r, i), Yr(r);
}
};
class ei {
constructor(t, r) {
  this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
}
}
const $e = {
brace: new ei("{"),
j_oTag: new ei("<tag"),
j_cTag: new ei("</tag"),
j_expr: new ei("<tag>...</tag>", !0)
};
$e.template = new ei("`", !0);
const Oe = !0, se = !0, vn = !0, Xr = !0, tr = !0, Z8 = !0;
class hf {
constructor(t, r = {}) {
  this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.updateContext = null;
}
}
const Va = /* @__PURE__ */ new Map();
function Me(e, t = {}) {
t.keyword = e;
const r = me(e, t);
return Va.set(e, r), r;
}
function yt(e, t) {
return me(e, {
  beforeExpr: Oe,
  binop: t
});
}
let si = -1;
const Jt = [], qa = [], $a = [], Ka = [], Wa = [], Ja = [];
function me(e, t = {}) {
var r, i, s, n;
return ++si, qa.push(e), $a.push((r = t.binop) != null ? r : -1), Ka.push((i = t.beforeExpr) != null ? i : !1), Wa.push((s = t.startsExpr) != null ? s : !1), Ja.push((n = t.prefix) != null ? n : !1), Jt.push(new hf(e, t)), si;
}
function Ne(e, t = {}) {
var r, i, s, n;
return ++si, Va.set(e, si), qa.push(e), $a.push((r = t.binop) != null ? r : -1), Ka.push((i = t.beforeExpr) != null ? i : !1), Wa.push((s = t.startsExpr) != null ? s : !1), Ja.push((n = t.prefix) != null ? n : !1), Jt.push(new hf("name", t)), si;
}
const e5 = {
bracketL: me("[", {
  beforeExpr: Oe,
  startsExpr: se
}),
bracketHashL: me("#[", {
  beforeExpr: Oe,
  startsExpr: se
}),
bracketBarL: me("[|", {
  beforeExpr: Oe,
  startsExpr: se
}),
bracketR: me("]"),
bracketBarR: me("|]"),
braceL: me("{", {
  beforeExpr: Oe,
  startsExpr: se
}),
braceBarL: me("{|", {
  beforeExpr: Oe,
  startsExpr: se
}),
braceHashL: me("#{", {
  beforeExpr: Oe,
  startsExpr: se
}),
braceR: me("}"),
braceBarR: me("|}"),
parenL: me("(", {
  beforeExpr: Oe,
  startsExpr: se
}),
parenR: me(")"),
comma: me(",", {
  beforeExpr: Oe
}),
semi: me(";", {
  beforeExpr: Oe
}),
colon: me(":", {
  beforeExpr: Oe
}),
doubleColon: me("::", {
  beforeExpr: Oe
}),
dot: me("."),
question: me("?", {
  beforeExpr: Oe
}),
questionDot: me("?."),
arrow: me("=>", {
  beforeExpr: Oe
}),
template: me("template"),
ellipsis: me("...", {
  beforeExpr: Oe
}),
backQuote: me("`", {
  startsExpr: se
}),
dollarBraceL: me("${", {
  beforeExpr: Oe,
  startsExpr: se
}),
templateTail: me("...`", {
  startsExpr: se
}),
templateNonTail: me("...${", {
  beforeExpr: Oe,
  startsExpr: se
}),
at: me("@"),
hash: me("#", {
  startsExpr: se
}),
interpreterDirective: me("#!..."),
eq: me("=", {
  beforeExpr: Oe,
  isAssign: Xr
}),
assign: me("_=", {
  beforeExpr: Oe,
  isAssign: Xr
}),
slashAssign: me("_=", {
  beforeExpr: Oe,
  isAssign: Xr
}),
xorAssign: me("_=", {
  beforeExpr: Oe,
  isAssign: Xr
}),
moduloAssign: me("_=", {
  beforeExpr: Oe,
  isAssign: Xr
}),
incDec: me("++/--", {
  prefix: tr,
  postfix: Z8,
  startsExpr: se
}),
bang: me("!", {
  beforeExpr: Oe,
  prefix: tr,
  startsExpr: se
}),
tilde: me("~", {
  beforeExpr: Oe,
  prefix: tr,
  startsExpr: se
}),
doubleCaret: me("^^", {
  startsExpr: se
}),
doubleAt: me("@@", {
  startsExpr: se
}),
pipeline: yt("|>", 0),
nullishCoalescing: yt("??", 1),
logicalOR: yt("||", 1),
logicalAND: yt("&&", 2),
bitwiseOR: yt("|", 3),
bitwiseXOR: yt("^", 4),
bitwiseAND: yt("&", 5),
equality: yt("==/!=/===/!==", 6),
lt: yt("</>/<=/>=", 7),
gt: yt("</>/<=/>=", 7),
relational: yt("</>/<=/>=", 7),
bitShift: yt("<</>>/>>>", 8),
bitShiftL: yt("<</>>/>>>", 8),
bitShiftR: yt("<</>>/>>>", 8),
plusMin: me("+/-", {
  beforeExpr: Oe,
  binop: 9,
  prefix: tr,
  startsExpr: se
}),
modulo: me("%", {
  binop: 10,
  startsExpr: se
}),
star: me("*", {
  binop: 10
}),
slash: yt("/", 10),
exponent: me("**", {
  beforeExpr: Oe,
  binop: 11,
  rightAssociative: !0
}),
_in: Me("in", {
  beforeExpr: Oe,
  binop: 7
}),
_instanceof: Me("instanceof", {
  beforeExpr: Oe,
  binop: 7
}),
_break: Me("break"),
_case: Me("case", {
  beforeExpr: Oe
}),
_catch: Me("catch"),
_continue: Me("continue"),
_debugger: Me("debugger"),
_default: Me("default", {
  beforeExpr: Oe
}),
_else: Me("else", {
  beforeExpr: Oe
}),
_finally: Me("finally"),
_function: Me("function", {
  startsExpr: se
}),
_if: Me("if"),
_return: Me("return", {
  beforeExpr: Oe
}),
_switch: Me("switch"),
_throw: Me("throw", {
  beforeExpr: Oe,
  prefix: tr,
  startsExpr: se
}),
_try: Me("try"),
_var: Me("var"),
_const: Me("const"),
_with: Me("with"),
_new: Me("new", {
  beforeExpr: Oe,
  startsExpr: se
}),
_this: Me("this", {
  startsExpr: se
}),
_super: Me("super", {
  startsExpr: se
}),
_class: Me("class", {
  startsExpr: se
}),
_extends: Me("extends", {
  beforeExpr: Oe
}),
_export: Me("export"),
_import: Me("import", {
  startsExpr: se
}),
_null: Me("null", {
  startsExpr: se
}),
_true: Me("true", {
  startsExpr: se
}),
_false: Me("false", {
  startsExpr: se
}),
_typeof: Me("typeof", {
  beforeExpr: Oe,
  prefix: tr,
  startsExpr: se
}),
_void: Me("void", {
  beforeExpr: Oe,
  prefix: tr,
  startsExpr: se
}),
_delete: Me("delete", {
  beforeExpr: Oe,
  prefix: tr,
  startsExpr: se
}),
_do: Me("do", {
  isLoop: vn,
  beforeExpr: Oe
}),
_for: Me("for", {
  isLoop: vn
}),
_while: Me("while", {
  isLoop: vn
}),
_as: Ne("as", {
  startsExpr: se
}),
_assert: Ne("assert", {
  startsExpr: se
}),
_async: Ne("async", {
  startsExpr: se
}),
_await: Ne("await", {
  startsExpr: se
}),
_defer: Ne("defer", {
  startsExpr: se
}),
_from: Ne("from", {
  startsExpr: se
}),
_get: Ne("get", {
  startsExpr: se
}),
_let: Ne("let", {
  startsExpr: se
}),
_meta: Ne("meta", {
  startsExpr: se
}),
_of: Ne("of", {
  startsExpr: se
}),
_sent: Ne("sent", {
  startsExpr: se
}),
_set: Ne("set", {
  startsExpr: se
}),
_source: Ne("source", {
  startsExpr: se
}),
_static: Ne("static", {
  startsExpr: se
}),
_using: Ne("using", {
  startsExpr: se
}),
_yield: Ne("yield", {
  startsExpr: se
}),
_asserts: Ne("asserts", {
  startsExpr: se
}),
_checks: Ne("checks", {
  startsExpr: se
}),
_exports: Ne("exports", {
  startsExpr: se
}),
_global: Ne("global", {
  startsExpr: se
}),
_implements: Ne("implements", {
  startsExpr: se
}),
_intrinsic: Ne("intrinsic", {
  startsExpr: se
}),
_infer: Ne("infer", {
  startsExpr: se
}),
_is: Ne("is", {
  startsExpr: se
}),
_mixins: Ne("mixins", {
  startsExpr: se
}),
_proto: Ne("proto", {
  startsExpr: se
}),
_require: Ne("require", {
  startsExpr: se
}),
_satisfies: Ne("satisfies", {
  startsExpr: se
}),
_keyof: Ne("keyof", {
  startsExpr: se
}),
_readonly: Ne("readonly", {
  startsExpr: se
}),
_unique: Ne("unique", {
  startsExpr: se
}),
_abstract: Ne("abstract", {
  startsExpr: se
}),
_declare: Ne("declare", {
  startsExpr: se
}),
_enum: Ne("enum", {
  startsExpr: se
}),
_module: Ne("module", {
  startsExpr: se
}),
_namespace: Ne("namespace", {
  startsExpr: se
}),
_interface: Ne("interface", {
  startsExpr: se
}),
_type: Ne("type", {
  startsExpr: se
}),
_opaque: Ne("opaque", {
  startsExpr: se
}),
name: me("name", {
  startsExpr: se
}),
string: me("string", {
  startsExpr: se
}),
num: me("num", {
  startsExpr: se
}),
bigint: me("bigint", {
  startsExpr: se
}),
decimal: me("decimal", {
  startsExpr: se
}),
regexp: me("regexp", {
  startsExpr: se
}),
privateName: me("#name", {
  startsExpr: se
}),
eof: me("eof"),
jsxName: me("jsxName"),
jsxText: me("jsxText", {
  beforeExpr: !0
}),
jsxTagStart: me("jsxTagStart", {
  startsExpr: !0
}),
jsxTagEnd: me("jsxTagEnd"),
placeholder: me("%%", {
  startsExpr: !0
})
};
function Be(e) {
return e >= 93 && e <= 132;
}
function t5(e) {
return e <= 92;
}
function _t(e) {
return e >= 58 && e <= 132;
}
function df(e) {
return e >= 58 && e <= 136;
}
function r5(e) {
return Ka[e];
}
function Yn(e) {
return Wa[e];
}
function i5(e) {
return e >= 29 && e <= 33;
}
function ol(e) {
return e >= 129 && e <= 131;
}
function s5(e) {
return e >= 90 && e <= 92;
}
function Ya(e) {
return e >= 58 && e <= 92;
}
function n5(e) {
return e >= 39 && e <= 59;
}
function a5(e) {
return e === 34;
}
function o5(e) {
return Ja[e];
}
function u5(e) {
return e >= 121 && e <= 123;
}
function l5(e) {
return e >= 124 && e <= 130;
}
function or(e) {
return qa[e];
}
function ns(e) {
return $a[e];
}
function c5(e) {
return e === 57;
}
function hs(e) {
return e >= 24 && e <= 25;
}
function Kt(e) {
return Jt[e];
}
Jt[8].updateContext = (e) => {
e.pop();
}, Jt[5].updateContext = Jt[7].updateContext = Jt[23].updateContext = (e) => {
e.push($e.brace);
}, Jt[22].updateContext = (e) => {
e[e.length - 1] === $e.template ? e.pop() : e.push($e.template);
}, Jt[142].updateContext = (e) => {
e.push($e.j_expr, $e.j_oTag);
};
let Xa = "", mf = "";
const f5 = new RegExp("[" + Xa + "]"), p5 = new RegExp("[" + Xa + mf + "]");
Xa = mf = null;
const yf = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], h5 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function Xn(e, t) {
let r = 65536;
for (let i = 0, s = t.length; i < s; i += 2) {
  if (r += t[i], r > e) return !1;
  if (r += t[i + 1], r >= e) return !0;
}
return !1;
}
function Xt(e) {
return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && f5.test(String.fromCharCode(e)) : Xn(e, yf);
}
function Or(e) {
return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && p5.test(String.fromCharCode(e)) : Xn(e, yf) || Xn(e, h5);
}
const Ha = {
keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
strictBind: ["eval", "arguments"]
}, d5 = new Set(Ha.keyword), m5 = new Set(Ha.strict), y5 = new Set(Ha.strictBind);
function bf(e, t) {
return t && e === "await" || e === "enum";
}
function Tf(e, t) {
return bf(e, t) || m5.has(e);
}
function gf(e) {
return y5.has(e);
}
function Sf(e, t) {
return Tf(e, t) || gf(e);
}
function b5(e) {
return d5.has(e);
}
function T5(e, t, r) {
return e === 64 && t === 64 && Xt(r);
}
const g5 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
function S5(e) {
return g5.has(e);
}
class Ga {
constructor(t) {
  this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
}
}
class za {
constructor(t, r) {
  this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = r;
}
get inTopLevel() {
  return (this.currentScope().flags & 1) > 0;
}
get inFunction() {
  return (this.currentVarScopeFlags() & 2) > 0;
}
get allowSuper() {
  return (this.currentThisScopeFlags() & 16) > 0;
}
get allowDirectSuper() {
  return (this.currentThisScopeFlags() & 32) > 0;
}
get inClass() {
  return (this.currentThisScopeFlags() & 64) > 0;
}
get inClassAndNotInNonArrowFunction() {
  const t = this.currentThisScopeFlags();
  return (t & 64) > 0 && (t & 2) === 0;
}
get inStaticBlock() {
  for (let t = this.scopeStack.length - 1; ; t--) {
    const {
      flags: r
    } = this.scopeStack[t];
    if (r & 128)
      return !0;
    if (r & 451)
      return !1;
  }
}
get inNonArrowFunction() {
  return (this.currentThisScopeFlags() & 2) > 0;
}
get treatFunctionsAsVar() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
}
createScope(t) {
  return new Ga(t);
}
enter(t) {
  this.scopeStack.push(this.createScope(t));
}
exit() {
  return this.scopeStack.pop().flags;
}
treatFunctionsAsVarInScope(t) {
  return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
}
declareName(t, r, i) {
  let s = this.currentScope();
  if (r & 8 || r & 16) {
    this.checkRedeclarationInScope(s, t, r, i);
    let n = s.names.get(t) || 0;
    r & 16 ? n = n | 4 : (s.firstLexicalName || (s.firstLexicalName = t), n = n | 2), s.names.set(t, n), r & 8 && this.maybeExportDefined(s, t);
  } else if (r & 4)
    for (let n = this.scopeStack.length - 1; n >= 0 && (s = this.scopeStack[n], this.checkRedeclarationInScope(s, t, r, i), s.names.set(t, (s.names.get(t) || 0) | 1), this.maybeExportDefined(s, t), !(s.flags & 387)); --n)
      ;
  this.parser.inModule && s.flags & 1 && this.undefinedExports.delete(t);
}
maybeExportDefined(t, r) {
  this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(r);
}
checkRedeclarationInScope(t, r, i, s) {
  this.isRedeclaredInScope(t, r, i) && this.parser.raise(w.VarRedeclaration, s, {
    identifierName: r
  });
}
isRedeclaredInScope(t, r, i) {
  if (!(i & 1)) return !1;
  if (i & 8)
    return t.names.has(r);
  const s = t.names.get(r);
  return i & 16 ? (s & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (s & 1) > 0 : (s & 2) > 0 && !(t.flags & 8 && t.firstLexicalName === r) || !this.treatFunctionsAsVarInScope(t) && (s & 4) > 0;
}
checkLocalExport(t) {
  const {
    name: r
  } = t;
  this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, t.loc.start);
}
currentScope() {
  return this.scopeStack[this.scopeStack.length - 1];
}
currentVarScopeFlags() {
  for (let t = this.scopeStack.length - 1; ; t--) {
    const {
      flags: r
    } = this.scopeStack[t];
    if (r & 387)
      return r;
  }
}
currentThisScopeFlags() {
  for (let t = this.scopeStack.length - 1; ; t--) {
    const {
      flags: r
    } = this.scopeStack[t];
    if (r & 451 && !(r & 4))
      return r;
  }
}
}
class x5 extends Ga {
constructor(...t) {
  super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
}
}
class E5 extends za {
createScope(t) {
  return new x5(t);
}
declareName(t, r, i) {
  const s = this.currentScope();
  if (r & 2048) {
    this.checkRedeclarationInScope(s, t, r, i), this.maybeExportDefined(s, t), s.declareFunctions.add(t);
    return;
  }
  super.declareName(t, r, i);
}
isRedeclaredInScope(t, r, i) {
  if (super.isRedeclaredInScope(t, r, i)) return !0;
  if (i & 2048 && !t.declareFunctions.has(r)) {
    const s = t.names.get(r);
    return (s & 4) > 0 || (s & 2) > 0;
  }
  return !1;
}
checkLocalExport(t) {
  this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
}
}
class P5 {
constructor() {
  this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
}
hasPlugin(t) {
  if (typeof t == "string")
    return this.plugins.has(t);
  {
    const [r, i] = t;
    if (!this.hasPlugin(r))
      return !1;
    const s = this.plugins.get(r);
    for (const n of Object.keys(i))
      if ((s == null ? void 0 : s[n]) !== i[n])
        return !1;
    return !0;
  }
}
getPluginOption(t, r) {
  var i;
  return (i = this.plugins.get(t)) == null ? void 0 : i[r];
}
}
function xf(e, t) {
e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
}
function v5(e, t) {
e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
}
function ai(e, t) {
e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
}
function Hr(e, t, r) {
let i = null, s = t.length;
for (; i === null && s > 0; )
  i = t[--s];
i === null || i.start > r.start ? ai(e, r.comments) : xf(i, r.comments);
}
class A5 extends P5 {
addComment(t) {
  this.filename && (t.loc.filename = this.filename);
  const {
    commentsLen: r
  } = this.state;
  this.comments.length !== r && (this.comments.length = r), this.comments.push(t), this.state.commentsLen++;
}
processComment(t) {
  const {
    commentStack: r
  } = this.state, i = r.length;
  if (i === 0) return;
  let s = i - 1;
  const n = r[s];
  n.start === t.end && (n.leadingNode = t, s--);
  const {
    start: a
  } = t;
  for (; s >= 0; s--) {
    const o = r[s], u = o.end;
    if (u > a)
      o.containingNode = t, this.finalizeComment(o), r.splice(s, 1);
    else {
      u === a && (o.trailingNode = t);
      break;
    }
  }
}
finalizeComment(t) {
  const {
    comments: r
  } = t;
  if (t.leadingNode !== null || t.trailingNode !== null)
    t.leadingNode !== null && xf(t.leadingNode, r), t.trailingNode !== null && v5(t.trailingNode, r);
  else {
    const {
      containingNode: i,
      start: s
    } = t;
    if (this.input.charCodeAt(s - 1) === 44)
      switch (i.type) {
        case "ObjectExpression":
        case "ObjectPattern":
        case "RecordExpression":
          Hr(i, i.properties, t);
          break;
        case "CallExpression":
        case "OptionalCallExpression":
          Hr(i, i.arguments, t);
          break;
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
          Hr(i, i.params, t);
          break;
        case "ArrayExpression":
        case "ArrayPattern":
        case "TupleExpression":
          Hr(i, i.elements, t);
          break;
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
          Hr(i, i.specifiers, t);
          break;
        default:
          ai(i, r);
      }
    else
      ai(i, r);
  }
}
finalizeRemainingComments() {
  const {
    commentStack: t
  } = this.state;
  for (let r = t.length - 1; r >= 0; r--)
    this.finalizeComment(t[r]);
  this.state.commentStack = [];
}
resetPreviousNodeTrailingComments(t) {
  const {
    commentStack: r
  } = this.state, {
    length: i
  } = r;
  if (i === 0) return;
  const s = r[i - 1];
  s.leadingNode === t && (s.leadingNode = null);
}
resetPreviousIdentifierLeadingComments(t) {
  const {
    commentStack: r
  } = this.state, {
    length: i
  } = r;
  i !== 0 && (r[i - 1].trailingNode === t ? r[i - 1].trailingNode = null : i >= 2 && r[i - 2].trailingNode === t && (r[i - 2].trailingNode = null));
}
takeSurroundingComments(t, r, i) {
  const {
    commentStack: s
  } = this.state, n = s.length;
  if (n === 0) return;
  let a = n - 1;
  for (; a >= 0; a--) {
    const o = s[a], u = o.end;
    if (o.start === i)
      o.leadingNode = t;
    else if (u === r)
      o.trailingNode = t;
    else if (u < r)
      break;
  }
}
}
const Ef = /\r\n?|[\n\u2028\u2029]/, Zi = new RegExp(Ef.source, "g");
function ni(e) {
switch (e) {
  case 10:
  case 13:
  case 8232:
  case 8233:
    return !0;
  default:
    return !1;
}
}
const An = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, as = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, ul = new RegExp("(?=(" + as.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function I5(e) {
switch (e) {
  case 9:
  case 11:
  case 12:
  case 32:
  case 160:
  case 5760:
  case 8192:
  case 8193:
  case 8194:
  case 8195:
  case 8196:
  case 8197:
  case 8198:
  case 8199:
  case 8200:
  case 8201:
  case 8202:
  case 8239:
  case 8287:
  case 12288:
  case 65279:
    return !0;
  default:
    return !1;
}
}
class Qa {
constructor() {
  this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
    maxNumOfResolvableTopics: 0,
    maxTopicIndex: null
  }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [$e.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
}
get strict() {
  return (this.flags & 1) > 0;
}
set strict(t) {
  t ? this.flags |= 1 : this.flags &= -2;
}
init({
  strictMode: t,
  sourceType: r,
  startLine: i,
  startColumn: s
}) {
  this.strict = t === !1 ? !1 : t === !0 ? !0 : r === "module", this.curLine = i, this.lineStart = -s, this.startLoc = this.endLoc = new ar(i, s, 0);
}
get maybeInArrowParameters() {
  return (this.flags & 2) > 0;
}
set maybeInArrowParameters(t) {
  t ? this.flags |= 2 : this.flags &= -3;
}
get inType() {
  return (this.flags & 4) > 0;
}
set inType(t) {
  t ? this.flags |= 4 : this.flags &= -5;
}
get noAnonFunctionType() {
  return (this.flags & 8) > 0;
}
set noAnonFunctionType(t) {
  t ? this.flags |= 8 : this.flags &= -9;
}
get hasFlowComment() {
  return (this.flags & 16) > 0;
}
set hasFlowComment(t) {
  t ? this.flags |= 16 : this.flags &= -17;
}
get isAmbientContext() {
  return (this.flags & 32) > 0;
}
set isAmbientContext(t) {
  t ? this.flags |= 32 : this.flags &= -33;
}
get inAbstractClass() {
  return (this.flags & 64) > 0;
}
set inAbstractClass(t) {
  t ? this.flags |= 64 : this.flags &= -65;
}
get inDisallowConditionalTypesContext() {
  return (this.flags & 128) > 0;
}
set inDisallowConditionalTypesContext(t) {
  t ? this.flags |= 128 : this.flags &= -129;
}
get soloAwait() {
  return (this.flags & 256) > 0;
}
set soloAwait(t) {
  t ? this.flags |= 256 : this.flags &= -257;
}
get inFSharpPipelineDirectBody() {
  return (this.flags & 512) > 0;
}
set inFSharpPipelineDirectBody(t) {
  t ? this.flags |= 512 : this.flags &= -513;
}
get canStartJSXElement() {
  return (this.flags & 1024) > 0;
}
set canStartJSXElement(t) {
  t ? this.flags |= 1024 : this.flags &= -1025;
}
get containsEsc() {
  return (this.flags & 2048) > 0;
}
set containsEsc(t) {
  t ? this.flags |= 2048 : this.flags &= -2049;
}
curPosition() {
  return new ar(this.curLine, this.pos - this.lineStart, this.pos);
}
clone() {
  const t = new Qa();
  return t.flags = this.flags, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc, t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen, t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
}
}
var C5 = function(t) {
return t >= 48 && t <= 57;
};
const ll = {
decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
}, es = {
bin: (e) => e === 48 || e === 49,
oct: (e) => e >= 48 && e <= 55,
dec: (e) => e >= 48 && e <= 57,
hex: (e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102
};
function cl(e, t, r, i, s, n) {
const a = r, o = i, u = s;
let l = "", c = null, f = r;
const {
  length: p
} = t;
for (; ; ) {
  if (r >= p) {
    n.unterminated(a, o, u), l += t.slice(f, r);
    break;
  }
  const h = t.charCodeAt(r);
  if (w5(e, h, t, r)) {
    l += t.slice(f, r);
    break;
  }
  if (h === 92) {
    l += t.slice(f, r);
    const y = N5(t, r, i, s, e === "template", n);
    y.ch === null && !c ? c = {
      pos: r,
      lineStart: i,
      curLine: s
    } : l += y.ch, {
      pos: r,
      lineStart: i,
      curLine: s
    } = y, f = r;
  } else h === 8232 || h === 8233 ? (++r, ++s, i = r) : h === 10 || h === 13 ? e === "template" ? (l += t.slice(f, r) + `
`, ++r, h === 13 && t.charCodeAt(r) === 10 && ++r, ++s, f = i = r) : n.unterminated(a, o, u) : ++r;
}
return {
  pos: r,
  str: l,
  firstInvalidLoc: c,
  lineStart: i,
  curLine: s,
  containsInvalid: !!c
};
}
function w5(e, t, r, i) {
return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
}
function N5(e, t, r, i, s, n) {
const a = !s;
t++;
const o = (l) => ({
  pos: t,
  ch: l,
  lineStart: r,
  curLine: i
}), u = e.charCodeAt(t++);
switch (u) {
  case 110:
    return o(`
`);
  case 114:
    return o("\r");
  case 120: {
    let l;
    return {
      code: l,
      pos: t
    } = Hn(e, t, r, i, 2, !1, a, n), o(l === null ? null : String.fromCharCode(l));
  }
  case 117: {
    let l;
    return {
      code: l,
      pos: t
    } = vf(e, t, r, i, a, n), o(l === null ? null : String.fromCodePoint(l));
  }
  case 116:
    return o("	");
  case 98:
    return o("\b");
  case 118:
    return o("\v");
  case 102:
    return o("\f");
  case 13:
    e.charCodeAt(t) === 10 && ++t;
  case 10:
    r = t, ++i;
  case 8232:
  case 8233:
    return o("");
  case 56:
  case 57:
    if (s)
      return o(null);
    n.strictNumericEscape(t - 1, r, i);
  default:
    if (u >= 48 && u <= 55) {
      const l = t - 1;
      let f = /^[0-7]+/.exec(e.slice(l, t + 2))[0], p = parseInt(f, 8);
      p > 255 && (f = f.slice(0, -1), p = parseInt(f, 8)), t += f.length - 1;
      const h = e.charCodeAt(t);
      if (f !== "0" || h === 56 || h === 57) {
        if (s)
          return o(null);
        n.strictNumericEscape(l, r, i);
      }
      return o(String.fromCharCode(p));
    }
    return o(String.fromCharCode(u));
}
}
function Hn(e, t, r, i, s, n, a, o) {
const u = t;
let l;
return {
  n: l,
  pos: t
} = Pf(e, t, r, i, 16, s, n, !1, o, !a), l === null && (a ? o.invalidEscapeSequence(u, r, i) : t = u - 1), {
  code: l,
  pos: t
};
}
function Pf(e, t, r, i, s, n, a, o, u, l) {
const c = t, f = s === 16 ? ll.hex : ll.decBinOct, p = s === 16 ? es.hex : s === 10 ? es.dec : s === 8 ? es.oct : es.bin;
let h = !1, y = 0;
for (let g = 0, A = n ?? 1 / 0; g < A; ++g) {
  const C = e.charCodeAt(t);
  let _;
  if (C === 95 && o !== "bail") {
    const j = e.charCodeAt(t - 1), G = e.charCodeAt(t + 1);
    if (o) {
      if (Number.isNaN(G) || !p(G) || f.has(j) || f.has(G)) {
        if (l) return {
          n: null,
          pos: t
        };
        u.unexpectedNumericSeparator(t, r, i);
      }
    } else {
      if (l) return {
        n: null,
        pos: t
      };
      u.numericSeparatorInEscapeSequence(t, r, i);
    }
    ++t;
    continue;
  }
  if (C >= 97 ? _ = C - 97 + 10 : C >= 65 ? _ = C - 65 + 10 : C5(C) ? _ = C - 48 : _ = 1 / 0, _ >= s) {
    if (_ <= 9 && l)
      return {
        n: null,
        pos: t
      };
    if (_ <= 9 && u.invalidDigit(t, r, i, s))
      _ = 0;
    else if (a)
      _ = 0, h = !0;
    else
      break;
  }
  ++t, y = y * s + _;
}
return t === c || n != null && t - c !== n || h ? {
  n: null,
  pos: t
} : {
  n: y,
  pos: t
};
}
function vf(e, t, r, i, s, n) {
const a = e.charCodeAt(t);
let o;
if (a === 123) {
  if (++t, {
    code: o,
    pos: t
  } = Hn(e, t, r, i, e.indexOf("}", t) - t, !0, s, n), ++t, o !== null && o > 1114111)
    if (s)
      n.invalidCodePoint(t, r, i);
    else
      return {
        code: null,
        pos: t
      };
} else
  ({
    code: o,
    pos: t
  } = Hn(e, t, r, i, 4, !1, s, n));
return {
  code: o,
  pos: t
};
}
function Gr(e, t, r) {
return new ar(r, e - t, e);
}
const O5 = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
class ir {
constructor(t) {
  this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new ps(t.startLoc, t.endLoc);
}
}
class _5 extends A5 {
constructor(t, r) {
  super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
    invalidDigit: (i, s, n, a) => this.options.errorRecovery ? (this.raise(w.InvalidDigit, Gr(i, s, n), {
      radix: a
    }), !0) : !1,
    numericSeparatorInEscapeSequence: this.errorBuilder(w.NumericSeparatorInEscapeSequence),
    unexpectedNumericSeparator: this.errorBuilder(w.UnexpectedNumericSeparator)
  }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
    invalidEscapeSequence: this.errorBuilder(w.InvalidEscapeSequence),
    invalidCodePoint: this.errorBuilder(w.InvalidCodePoint)
  }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
    strictNumericEscape: (i, s, n) => {
      this.recordStrictModeErrors(w.StrictNumericEscape, Gr(i, s, n));
    },
    unterminated: (i, s, n) => {
      throw this.raise(w.UnterminatedString, Gr(i - 1, s, n));
    }
  }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
    strictNumericEscape: this.errorBuilder(w.StrictNumericEscape),
    unterminated: (i, s, n) => {
      throw this.raise(w.UnterminatedTemplate, Gr(i, s, n));
    }
  }), this.state = new Qa(), this.state.init(t), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
}
pushToken(t) {
  this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
}
next() {
  this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new ir(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
}
eat(t) {
  return this.match(t) ? (this.next(), !0) : !1;
}
match(t) {
  return this.state.type === t;
}
createLookaheadState(t) {
  return {
    pos: t.pos,
    value: null,
    type: t.type,
    start: t.start,
    end: t.end,
    context: [this.curContext()],
    inType: t.inType,
    startLoc: t.startLoc,
    lastTokEndLoc: t.lastTokEndLoc,
    curLine: t.curLine,
    lineStart: t.lineStart,
    curPosition: t.curPosition
  };
}
lookahead() {
  const t = this.state;
  this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
  const r = this.state;
  return this.state = t, r;
}
nextTokenStart() {
  return this.nextTokenStartSince(this.state.pos);
}
nextTokenStartSince(t) {
  return An.lastIndex = t, An.test(this.input) ? An.lastIndex : t;
}
lookaheadCharCode() {
  return this.input.charCodeAt(this.nextTokenStart());
}
nextTokenInLineStart() {
  return this.nextTokenInLineStartSince(this.state.pos);
}
nextTokenInLineStartSince(t) {
  return as.lastIndex = t, as.test(this.input) ? as.lastIndex : t;
}
lookaheadInLineCharCode() {
  return this.input.charCodeAt(this.nextTokenInLineStart());
}
codePointAtPos(t) {
  let r = this.input.charCodeAt(t);
  if ((r & 64512) === 55296 && ++t < this.input.length) {
    const i = this.input.charCodeAt(t);
    (i & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (i & 1023));
  }
  return r;
}
setStrict(t) {
  this.state.strict = t, t && (this.state.strictErrors.forEach(([r, i]) => this.raise(r, i)), this.state.strictErrors.clear());
}
curContext() {
  return this.state.context[this.state.context.length - 1];
}
nextToken() {
  if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
    this.finishToken(139);
    return;
  }
  this.getTokenFromCode(this.codePointAtPos(this.state.pos));
}
skipBlockComment(t) {
  let r;
  this.isLookahead || (r = this.state.curPosition());
  const i = this.state.pos, s = this.input.indexOf(t, i + 2);
  if (s === -1)
    throw this.raise(w.UnterminatedComment, this.state.curPosition());
  for (this.state.pos = s + t.length, Zi.lastIndex = i + 2; Zi.test(this.input) && Zi.lastIndex <= s; )
    ++this.state.curLine, this.state.lineStart = Zi.lastIndex;
  if (this.isLookahead) return;
  const n = {
    type: "CommentBlock",
    value: this.input.slice(i + 2, s),
    start: i,
    end: s + t.length,
    loc: new ps(r, this.state.curPosition())
  };
  return this.options.tokens && this.pushToken(n), n;
}
skipLineComment(t) {
  const r = this.state.pos;
  let i;
  this.isLookahead || (i = this.state.curPosition());
  let s = this.input.charCodeAt(this.state.pos += t);
  if (this.state.pos < this.length)
    for (; !ni(s) && ++this.state.pos < this.length; )
      s = this.input.charCodeAt(this.state.pos);
  if (this.isLookahead) return;
  const n = this.state.pos, o = {
    type: "CommentLine",
    value: this.input.slice(r + t, n),
    start: r,
    end: n,
    loc: new ps(i, this.state.curPosition())
  };
  return this.options.tokens && this.pushToken(o), o;
}
skipSpace() {
  const t = this.state.pos, r = [];
  e: for (; this.state.pos < this.length; ) {
    const i = this.input.charCodeAt(this.state.pos);
    switch (i) {
      case 32:
      case 160:
      case 9:
        ++this.state.pos;
        break;
      case 13:
        this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
      case 10:
      case 8232:
      case 8233:
        ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
        break;
      case 47:
        switch (this.input.charCodeAt(this.state.pos + 1)) {
          case 42: {
            const s = this.skipBlockComment("*/");
            s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
            break;
          }
          case 47: {
            const s = this.skipLineComment(2);
            s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
            break;
          }
          default:
            break e;
        }
        break;
      default:
        if (I5(i))
          ++this.state.pos;
        else if (i === 45 && !this.inModule && this.options.annexB) {
          const s = this.state.pos;
          if (this.input.charCodeAt(s + 1) === 45 && this.input.charCodeAt(s + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
            const n = this.skipLineComment(3);
            n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
          } else
            break e;
        } else if (i === 60 && !this.inModule && this.options.annexB) {
          const s = this.state.pos;
          if (this.input.charCodeAt(s + 1) === 33 && this.input.charCodeAt(s + 2) === 45 && this.input.charCodeAt(s + 3) === 45) {
            const n = this.skipLineComment(4);
            n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
          } else
            break e;
        } else
          break e;
    }
  }
  if (r.length > 0) {
    const i = this.state.pos, s = {
      start: t,
      end: i,
      comments: r,
      leadingNode: null,
      trailingNode: null,
      containingNode: null
    };
    this.state.commentStack.push(s);
  }
}
finishToken(t, r) {
  this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
  const i = this.state.type;
  this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(i);
}
replaceToken(t) {
  this.state.type = t, this.updateContext();
}
readToken_numberSign() {
  if (this.state.pos === 0 && this.readToken_interpreter())
    return;
  const t = this.state.pos + 1, r = this.codePointAtPos(t);
  if (r >= 48 && r <= 57)
    throw this.raise(w.UnexpectedDigitAfterHash, this.state.curPosition());
  if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
    if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
      throw this.raise(r === 123 ? w.RecordExpressionHashIncorrectStartSyntaxType : w.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
    this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
  } else Xt(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
}
readToken_dot() {
  const t = this.input.charCodeAt(this.state.pos + 1);
  if (t >= 48 && t <= 57) {
    this.readNumber(!0);
    return;
  }
  t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
}
readToken_slash() {
  this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
}
readToken_interpreter() {
  if (this.state.pos !== 0 || this.length < 2) return !1;
  let t = this.input.charCodeAt(this.state.pos + 1);
  if (t !== 33) return !1;
  const r = this.state.pos;
  for (this.state.pos += 1; !ni(t) && ++this.state.pos < this.length; )
    t = this.input.charCodeAt(this.state.pos);
  const i = this.input.slice(r + 2, this.state.pos);
  return this.finishToken(28, i), !0;
}
readToken_mult_modulo(t) {
  let r = t === 42 ? 55 : 54, i = 1, s = this.input.charCodeAt(this.state.pos + 1);
  t === 42 && s === 42 && (i++, s = this.input.charCodeAt(this.state.pos + 2), r = 57), s === 61 && !this.state.inType && (i++, r = t === 37 ? 33 : 30), this.finishOp(r, i);
}
readToken_pipe_amp(t) {
  const r = this.input.charCodeAt(this.state.pos + 1);
  if (r === t) {
    this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
    return;
  }
  if (t === 124) {
    if (r === 62) {
      this.finishOp(39, 2);
      return;
    }
    if (this.hasPlugin("recordAndTuple") && r === 125) {
      if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
        throw this.raise(w.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
      this.state.pos += 2, this.finishToken(9);
      return;
    }
    if (this.hasPlugin("recordAndTuple") && r === 93) {
      if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
        throw this.raise(w.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
      this.state.pos += 2, this.finishToken(4);
      return;
    }
  }
  if (r === 61) {
    this.finishOp(30, 2);
    return;
  }
  this.finishOp(t === 124 ? 43 : 45, 1);
}
readToken_caret() {
  const t = this.input.charCodeAt(this.state.pos + 1);
  t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
    proposal: "hack",
    topicToken: "^^"
  }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
}
readToken_atSign() {
  this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
    proposal: "hack",
    topicToken: "@@"
  }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
}
readToken_plus_min(t) {
  const r = this.input.charCodeAt(this.state.pos + 1);
  if (r === t) {
    this.finishOp(34, 2);
    return;
  }
  r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
}
readToken_lt() {
  const {
    pos: t
  } = this.state, r = this.input.charCodeAt(t + 1);
  if (r === 60) {
    if (this.input.charCodeAt(t + 2) === 61) {
      this.finishOp(30, 3);
      return;
    }
    this.finishOp(51, 2);
    return;
  }
  if (r === 61) {
    this.finishOp(49, 2);
    return;
  }
  this.finishOp(47, 1);
}
readToken_gt() {
  const {
    pos: t
  } = this.state, r = this.input.charCodeAt(t + 1);
  if (r === 62) {
    const i = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(t + i) === 61) {
      this.finishOp(30, i + 1);
      return;
    }
    this.finishOp(52, i);
    return;
  }
  if (r === 61) {
    this.finishOp(49, 2);
    return;
  }
  this.finishOp(48, 1);
}
readToken_eq_excl(t) {
  const r = this.input.charCodeAt(this.state.pos + 1);
  if (r === 61) {
    this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
    return;
  }
  if (t === 61 && r === 62) {
    this.state.pos += 2, this.finishToken(19);
    return;
  }
  this.finishOp(t === 61 ? 29 : 35, 1);
}
readToken_question() {
  const t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
  t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
}
getTokenFromCode(t) {
  switch (t) {
    case 46:
      this.readToken_dot();
      return;
    case 40:
      ++this.state.pos, this.finishToken(10);
      return;
    case 41:
      ++this.state.pos, this.finishToken(11);
      return;
    case 59:
      ++this.state.pos, this.finishToken(13);
      return;
    case 44:
      ++this.state.pos, this.finishToken(12);
      return;
    case 91:
      if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(w.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, this.finishToken(2);
      } else
        ++this.state.pos, this.finishToken(0);
      return;
    case 93:
      ++this.state.pos, this.finishToken(3);
      return;
    case 123:
      if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(w.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, this.finishToken(6);
      } else
        ++this.state.pos, this.finishToken(5);
      return;
    case 125:
      ++this.state.pos, this.finishToken(8);
      return;
    case 58:
      this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
      return;
    case 63:
      this.readToken_question();
      return;
    case 96:
      this.readTemplateToken();
      return;
    case 48: {
      const r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 120 || r === 88) {
        this.readRadixNumber(16);
        return;
      }
      if (r === 111 || r === 79) {
        this.readRadixNumber(8);
        return;
      }
      if (r === 98 || r === 66) {
        this.readRadixNumber(2);
        return;
      }
    }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      this.readNumber(!1);
      return;
    case 34:
    case 39:
      this.readString(t);
      return;
    case 47:
      this.readToken_slash();
      return;
    case 37:
    case 42:
      this.readToken_mult_modulo(t);
      return;
    case 124:
    case 38:
      this.readToken_pipe_amp(t);
      return;
    case 94:
      this.readToken_caret();
      return;
    case 43:
    case 45:
      this.readToken_plus_min(t);
      return;
    case 60:
      this.readToken_lt();
      return;
    case 62:
      this.readToken_gt();
      return;
    case 61:
    case 33:
      this.readToken_eq_excl(t);
      return;
    case 126:
      this.finishOp(36, 1);
      return;
    case 64:
      this.readToken_atSign();
      return;
    case 35:
      this.readToken_numberSign();
      return;
    case 92:
      this.readWord();
      return;
    default:
      if (Xt(t)) {
        this.readWord(t);
        return;
      }
  }
  throw this.raise(w.InvalidOrUnexpectedToken, this.state.curPosition(), {
    unexpected: String.fromCodePoint(t)
  });
}
finishOp(t, r) {
  const i = this.input.slice(this.state.pos, this.state.pos + r);
  this.state.pos += r, this.finishToken(t, i);
}
readRegexp() {
  const t = this.state.startLoc, r = this.state.start + 1;
  let i, s, {
    pos: n
  } = this.state;
  for (; ; ++n) {
    if (n >= this.length)
      throw this.raise(w.UnterminatedRegExp, gt(t, 1));
    const l = this.input.charCodeAt(n);
    if (ni(l))
      throw this.raise(w.UnterminatedRegExp, gt(t, 1));
    if (i)
      i = !1;
    else {
      if (l === 91)
        s = !0;
      else if (l === 93 && s)
        s = !1;
      else if (l === 47 && !s)
        break;
      i = l === 92;
    }
  }
  const a = this.input.slice(r, n);
  ++n;
  let o = "";
  const u = () => gt(t, n + 2 - r);
  for (; n < this.length; ) {
    const l = this.codePointAtPos(n), c = String.fromCharCode(l);
    if (O5.has(l))
      l === 118 ? o.includes("u") && this.raise(w.IncompatibleRegExpUVFlags, u()) : l === 117 && o.includes("v") && this.raise(w.IncompatibleRegExpUVFlags, u()), o.includes(c) && this.raise(w.DuplicateRegExpFlags, u());
    else if (Or(l) || l === 92)
      this.raise(w.MalformedRegExpFlags, u());
    else
      break;
    ++n, o += c;
  }
  this.state.pos = n, this.finishToken(137, {
    pattern: a,
    flags: o
  });
}
readInt(t, r, i = !1, s = !0) {
  const {
    n,
    pos: a
  } = Pf(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, i, s, this.errorHandlers_readInt, !1);
  return this.state.pos = a, n;
}
readRadixNumber(t) {
  const r = this.state.curPosition();
  let i = !1;
  this.state.pos += 2;
  const s = this.readInt(t);
  s == null && this.raise(w.InvalidDigit, gt(r, 2), {
    radix: t
  });
  const n = this.input.charCodeAt(this.state.pos);
  if (n === 110)
    ++this.state.pos, i = !0;
  else if (n === 109)
    throw this.raise(w.InvalidDecimal, r);
  if (Xt(this.codePointAtPos(this.state.pos)))
    throw this.raise(w.NumberIdentifier, this.state.curPosition());
  if (i) {
    const a = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
    this.finishToken(135, a);
    return;
  }
  this.finishToken(134, s);
}
readNumber(t) {
  const r = this.state.pos, i = this.state.curPosition();
  let s = !1, n = !1, a = !1, o = !1, u = !1;
  !t && this.readInt(10) === null && this.raise(w.InvalidNumber, this.state.curPosition());
  const l = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
  if (l) {
    const h = this.input.slice(r, this.state.pos);
    if (this.recordStrictModeErrors(w.StrictOctalLiteral, i), !this.state.strict) {
      const y = h.indexOf("_");
      y > 0 && this.raise(w.ZeroDigitNumericSeparator, gt(i, y));
    }
    u = l && !/[89]/.test(h);
  }
  let c = this.input.charCodeAt(this.state.pos);
  if (c === 46 && !u && (++this.state.pos, this.readInt(10), s = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) && !u && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(w.InvalidOrMissingExponent, i), s = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((s || l) && this.raise(w.InvalidBigIntLiteral, i), ++this.state.pos, n = !0), c === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (o || l) && this.raise(w.InvalidDecimal, i), ++this.state.pos, a = !0), Xt(this.codePointAtPos(this.state.pos)))
    throw this.raise(w.NumberIdentifier, this.state.curPosition());
  const f = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
  if (n) {
    this.finishToken(135, f);
    return;
  }
  if (a) {
    this.finishToken(136, f);
    return;
  }
  const p = u ? parseInt(f, 8) : parseFloat(f);
  this.finishToken(134, p);
}
readCodePoint(t) {
  const {
    code: r,
    pos: i
  } = vf(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
  return this.state.pos = i, r;
}
readString(t) {
  const {
    str: r,
    pos: i,
    curLine: s,
    lineStart: n
  } = cl(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
  this.state.pos = i + 1, this.state.lineStart = n, this.state.curLine = s, this.finishToken(133, r);
}
readTemplateContinuation() {
  this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
}
readTemplateToken() {
  const t = this.input[this.state.pos], {
    str: r,
    firstInvalidLoc: i,
    pos: s,
    curLine: n,
    lineStart: a
  } = cl("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
  this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = n, i && (this.state.firstInvalidTemplateEscapePos = new ar(i.curLine, i.pos - i.lineStart, i.pos)), this.input.codePointAt(s) === 96 ? this.finishToken(24, i ? null : t + r + "`") : (this.state.pos++, this.finishToken(25, i ? null : t + r + "${"));
}
recordStrictModeErrors(t, r) {
  const i = r.index;
  this.state.strict && !this.state.strictErrors.has(i) ? this.raise(t, r) : this.state.strictErrors.set(i, [t, r]);
}
readWord1(t) {
  this.state.containsEsc = !1;
  let r = "";
  const i = this.state.pos;
  let s = this.state.pos;
  for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
    const n = this.codePointAtPos(this.state.pos);
    if (Or(n))
      this.state.pos += n <= 65535 ? 1 : 2;
    else if (n === 92) {
      this.state.containsEsc = !0, r += this.input.slice(s, this.state.pos);
      const a = this.state.curPosition(), o = this.state.pos === i ? Xt : Or;
      if (this.input.charCodeAt(++this.state.pos) !== 117) {
        this.raise(w.MissingUnicodeEscape, this.state.curPosition()), s = this.state.pos - 1;
        continue;
      }
      ++this.state.pos;
      const u = this.readCodePoint(!0);
      u !== null && (o(u) || this.raise(w.EscapedCharNotAnIdentifier, a), r += String.fromCodePoint(u)), s = this.state.pos;
    } else
      break;
  }
  return r + this.input.slice(s, this.state.pos);
}
readWord(t) {
  const r = this.readWord1(t), i = Va.get(r);
  i !== void 0 ? this.finishToken(i, or(i)) : this.finishToken(132, r);
}
checkKeywordEscapes() {
  const {
    type: t
  } = this.state;
  Ya(t) && this.state.containsEsc && this.raise(w.InvalidEscapedReservedWord, this.state.startLoc, {
    reservedWord: or(t)
  });
}
raise(t, r, i = {}) {
  const s = r instanceof ar ? r : r.loc.start, n = t(s, i);
  if (!this.options.errorRecovery) throw n;
  return this.isLookahead || this.state.errors.push(n), n;
}
raiseOverwrite(t, r, i = {}) {
  const s = r instanceof ar ? r : r.loc.start, n = s.index, a = this.state.errors;
  for (let o = a.length - 1; o >= 0; o--) {
    const u = a[o];
    if (u.loc.index === n)
      return a[o] = t(s, i);
    if (u.loc.index < n) break;
  }
  return this.raise(t, r, i);
}
updateContext(t) {
}
unexpected(t, r) {
  throw this.raise(w.UnexpectedToken, t ?? this.state.startLoc, {
    expected: r ? or(r) : null
  });
}
expectPlugin(t, r) {
  if (this.hasPlugin(t))
    return !0;
  throw this.raise(w.MissingPlugin, r ?? this.state.startLoc, {
    missingPlugin: [t]
  });
}
expectOnePlugin(t) {
  if (!t.some((r) => this.hasPlugin(r)))
    throw this.raise(w.MissingOneOfPlugins, this.state.startLoc, {
      missingPlugin: t
    });
}
errorBuilder(t) {
  return (r, i, s) => {
    this.raise(t, Gr(r, i, s));
  };
}
}
class k5 {
constructor() {
  this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
}
}
class D5 {
constructor(t) {
  this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
}
current() {
  return this.stack[this.stack.length - 1];
}
enter() {
  this.stack.push(new k5());
}
exit() {
  const t = this.stack.pop(), r = this.current();
  for (const [i, s] of Array.from(t.undefinedPrivateNames))
    r ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, s) : this.parser.raise(w.InvalidPrivateFieldResolution, s, {
      identifierName: i
    });
}
declarePrivateName(t, r, i) {
  const {
    privateNames: s,
    loneAccessors: n,
    undefinedPrivateNames: a
  } = this.current();
  let o = s.has(t);
  if (r & 3) {
    const u = o && n.get(t);
    if (u) {
      const l = u & 4, c = r & 4, f = u & 3, p = r & 3;
      o = f === p || l !== c, o || n.delete(t);
    } else o || n.set(t, r);
  }
  o && this.parser.raise(w.PrivateNameRedeclaration, i, {
    identifierName: t
  }), s.add(t), a.delete(t);
}
usePrivateName(t, r) {
  let i;
  for (i of this.stack)
    if (i.privateNames.has(t)) return;
  i ? i.undefinedPrivateNames.set(t, r) : this.parser.raise(w.InvalidPrivateFieldResolution, r, {
    identifierName: t
  });
}
}
class Js {
constructor(t = 0) {
  this.type = t;
}
canBeArrowParameterDeclaration() {
  return this.type === 2 || this.type === 1;
}
isCertainlyParameterDeclaration() {
  return this.type === 3;
}
}
class Af extends Js {
constructor(t) {
  super(t), this.declarationErrors = /* @__PURE__ */ new Map();
}
recordDeclarationError(t, r) {
  const i = r.index;
  this.declarationErrors.set(i, [t, r]);
}
clearDeclarationError(t) {
  this.declarationErrors.delete(t);
}
iterateErrors(t) {
  this.declarationErrors.forEach(t);
}
}
class L5 {
constructor(t) {
  this.parser = void 0, this.stack = [new Js()], this.parser = t;
}
enter(t) {
  this.stack.push(t);
}
exit() {
  this.stack.pop();
}
recordParameterInitializerError(t, r) {
  const i = r.loc.start, {
    stack: s
  } = this;
  let n = s.length - 1, a = s[n];
  for (; !a.isCertainlyParameterDeclaration(); ) {
    if (a.canBeArrowParameterDeclaration())
      a.recordDeclarationError(t, i);
    else
      return;
    a = s[--n];
  }
  this.parser.raise(t, i);
}
recordArrowParameterBindingError(t, r) {
  const {
    stack: i
  } = this, s = i[i.length - 1], n = r.loc.start;
  if (s.isCertainlyParameterDeclaration())
    this.parser.raise(t, n);
  else if (s.canBeArrowParameterDeclaration())
    s.recordDeclarationError(t, n);
  else
    return;
}
recordAsyncArrowParametersError(t) {
  const {
    stack: r
  } = this;
  let i = r.length - 1, s = r[i];
  for (; s.canBeArrowParameterDeclaration(); )
    s.type === 2 && s.recordDeclarationError(w.AwaitBindingIdentifier, t), s = r[--i];
}
validateAsPattern() {
  const {
    stack: t
  } = this, r = t[t.length - 1];
  r.canBeArrowParameterDeclaration() && r.iterateErrors(([i, s]) => {
    this.parser.raise(i, s);
    let n = t.length - 2, a = t[n];
    for (; a.canBeArrowParameterDeclaration(); )
      a.clearDeclarationError(s.index), a = t[--n];
  });
}
}
function M5() {
return new Js(3);
}
function B5() {
return new Af(1);
}
function F5() {
return new Af(2);
}
function If() {
return new Js();
}
class j5 {
constructor() {
  this.stacks = [];
}
enter(t) {
  this.stacks.push(t);
}
exit() {
  this.stacks.pop();
}
currentFlags() {
  return this.stacks[this.stacks.length - 1];
}
get hasAwait() {
  return (this.currentFlags() & 2) > 0;
}
get hasYield() {
  return (this.currentFlags() & 1) > 0;
}
get hasReturn() {
  return (this.currentFlags() & 4) > 0;
}
get hasIn() {
  return (this.currentFlags() & 8) > 0;
}
}
function os(e, t) {
return (e ? 2 : 0) | (t ? 1 : 0);
}
class R5 extends _5 {
addExtra(t, r, i, s = !0) {
  if (!t) return;
  const n = t.extra = t.extra || {};
  s ? n[r] = i : Object.defineProperty(n, r, {
    enumerable: s,
    value: i
  });
}
isContextual(t) {
  return this.state.type === t && !this.state.containsEsc;
}
isUnparsedContextual(t, r) {
  const i = t + r.length;
  if (this.input.slice(t, i) === r) {
    const s = this.input.charCodeAt(i);
    return !(Or(s) || (s & 64512) === 55296);
  }
  return !1;
}
isLookaheadContextual(t) {
  const r = this.nextTokenStart();
  return this.isUnparsedContextual(r, t);
}
eatContextual(t) {
  return this.isContextual(t) ? (this.next(), !0) : !1;
}
expectContextual(t, r) {
  if (!this.eatContextual(t)) {
    if (r != null)
      throw this.raise(r, this.state.startLoc);
    this.unexpected(null, t);
  }
}
canInsertSemicolon() {
  return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
}
hasPrecedingLineBreak() {
  return Ef.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
}
hasFollowingLineBreak() {
  return ul.lastIndex = this.state.end, ul.test(this.input);
}
isLineTerminator() {
  return this.eat(13) || this.canInsertSemicolon();
}
semicolon(t = !0) {
  (t ? this.isLineTerminator() : this.eat(13)) || this.raise(w.MissingSemicolon, this.state.lastTokEndLoc);
}
expect(t, r) {
  this.eat(t) || this.unexpected(r, t);
}
tryParse(t, r = this.state.clone()) {
  const i = {
    node: null
  };
  try {
    const s = t((n = null) => {
      throw i.node = n, i;
    });
    if (this.state.errors.length > r.errors.length) {
      const n = this.state;
      return this.state = r, this.state.tokensLength = n.tokensLength, {
        node: s,
        error: n.errors[r.errors.length],
        thrown: !1,
        aborted: !1,
        failState: n
      };
    }
    return {
      node: s,
      error: null,
      thrown: !1,
      aborted: !1,
      failState: null
    };
  } catch (s) {
    const n = this.state;
    if (this.state = r, s instanceof SyntaxError)
      return {
        node: null,
        error: s,
        thrown: !0,
        aborted: !1,
        failState: n
      };
    if (s === i)
      return {
        node: i.node,
        error: null,
        thrown: !1,
        aborted: !0,
        failState: n
      };
    throw s;
  }
}
checkExpressionErrors(t, r) {
  if (!t) return !1;
  const {
    shorthandAssignLoc: i,
    doubleProtoLoc: s,
    privateKeyLoc: n,
    optionalParametersLoc: a
  } = t, o = !!i || !!s || !!a || !!n;
  if (!r)
    return o;
  i != null && this.raise(w.InvalidCoverInitializedName, i), s != null && this.raise(w.DuplicateProto, s), n != null && this.raise(w.UnexpectedPrivateField, n), a != null && this.unexpected(a);
}
isLiteralPropertyName() {
  return df(this.state.type);
}
isPrivateName(t) {
  return t.type === "PrivateName";
}
getPrivateNameSV(t) {
  return t.id.name;
}
hasPropertyAsPrivateName(t) {
  return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
}
isObjectProperty(t) {
  return t.type === "ObjectProperty";
}
isObjectMethod(t) {
  return t.type === "ObjectMethod";
}
initializeScopes(t = this.options.sourceType === "module") {
  const r = this.state.labels;
  this.state.labels = [];
  const i = this.exportedIdentifiers;
  this.exportedIdentifiers = /* @__PURE__ */ new Set();
  const s = this.inModule;
  this.inModule = t;
  const n = this.scope, a = this.getScopeHandler();
  this.scope = new a(this, t);
  const o = this.prodParam;
  this.prodParam = new j5();
  const u = this.classScope;
  this.classScope = new D5(this);
  const l = this.expressionScope;
  return this.expressionScope = new L5(this), () => {
    this.state.labels = r, this.exportedIdentifiers = i, this.inModule = s, this.scope = n, this.prodParam = o, this.classScope = u, this.expressionScope = l;
  };
}
enterInitialScopes() {
  let t = 0;
  this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);
}
checkDestructuringPrivate(t) {
  const {
    privateKeyLoc: r
  } = t;
  r !== null && this.expectPlugin("destructuringPrivate", r);
}
}
class us {
constructor() {
  this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
}
}
class ds {
constructor(t, r, i) {
  this.type = "", this.start = r, this.end = 0, this.loc = new ps(i), t != null && t.options.ranges && (this.range = [r, 0]), t != null && t.filename && (this.loc.filename = t.filename);
}
}
const Za = ds.prototype;
Za.__clone = function() {
const e = new ds(void 0, this.start, this.loc.start), t = Object.keys(this);
for (let r = 0, i = t.length; r < i; r++) {
  const s = t[r];
  s !== "leadingComments" && s !== "trailingComments" && s !== "innerComments" && (e[s] = this[s]);
}
return e;
};
function U5(e) {
return Gt(e);
}
function Gt(e) {
const {
  type: t,
  start: r,
  end: i,
  loc: s,
  range: n,
  extra: a,
  name: o
} = e, u = Object.create(Za);
return u.type = t, u.start = r, u.end = i, u.loc = s, u.range = n, u.extra = a, u.name = o, t === "Placeholder" && (u.expectedNode = e.expectedNode), u;
}
function V5(e) {
const {
  type: t,
  start: r,
  end: i,
  loc: s,
  range: n,
  extra: a
} = e;
if (t === "Placeholder")
  return U5(e);
const o = Object.create(Za);
return o.type = t, o.start = r, o.end = i, o.loc = s, o.range = n, e.raw !== void 0 ? o.raw = e.raw : o.extra = a, o.value = e.value, o;
}
class q5 extends R5 {
startNode() {
  const t = this.state.startLoc;
  return new ds(this, t.index, t);
}
startNodeAt(t) {
  return new ds(this, t.index, t);
}
startNodeAtNode(t) {
  return this.startNodeAt(t.loc.start);
}
finishNode(t, r) {
  return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
}
finishNodeAt(t, r, i) {
  return t.type = r, t.end = i.index, t.loc.end = i, this.options.ranges && (t.range[1] = i.index), this.options.attachComment && this.processComment(t), t;
}
resetStartLocation(t, r) {
  t.start = r.index, t.loc.start = r, this.options.ranges && (t.range[0] = r.index);
}
resetEndLocation(t, r = this.state.lastTokEndLoc) {
  t.end = r.index, t.loc.end = r, this.options.ranges && (t.range[1] = r.index);
}
resetStartLocationFromNode(t, r) {
  this.resetStartLocation(t, r.loc.start);
}
}
const $5 = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), ye = Ht`flow`({
AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
AssignReservedType: ({
  reservedType: e
}) => `Cannot overwrite reserved type ${e}.`,
DeclareClassElement: "The `declare` modifier can only appear on class fields.",
DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
EnumBooleanMemberNotInitialized: ({
  memberName: e,
  enumName: t
}) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`,
EnumDuplicateMemberName: ({
  memberName: e,
  enumName: t
}) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`,
EnumInconsistentMemberValues: ({
  enumName: e
}) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
EnumInvalidExplicitType: ({
  invalidEnumType: e,
  enumName: t
}) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`,
EnumInvalidExplicitTypeUnknownSupplied: ({
  enumName: e
}) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`,
EnumInvalidMemberInitializerPrimaryType: ({
  enumName: e,
  memberName: t,
  explicitType: r
}) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`,
EnumInvalidMemberInitializerSymbolType: ({
  enumName: e,
  memberName: t
}) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`,
EnumInvalidMemberInitializerUnknownType: ({
  enumName: e,
  memberName: t
}) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`,
EnumInvalidMemberName: ({
  enumName: e,
  memberName: t,
  suggestion: r
}) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`,
EnumNumberMemberNotInitialized: ({
  enumName: e,
  memberName: t
}) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`,
EnumStringMemberInconsistentlyInitialized: ({
  enumName: e
}) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`,
GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
InexactVariance: "Explicit inexact syntax cannot have variance.",
InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
PatternIsOptional: Object.assign({
  message: "A binding pattern parameter cannot be optional in an implementation signature."
}, {
  reasonCode: "OptionalBindingPattern"
}),
SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
SpreadVariance: "Spread properties cannot have variance.",
ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
ThisParamNoDefault: "The `this` parameter may not have a default value.",
TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
UnexpectedReservedType: ({
  reservedType: e
}) => `Unexpected reserved type ${e}.`,
UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
UnsupportedDeclareExportKind: ({
  unsupportedExportKind: e,
  suggestion: t
}) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`,
UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
UnterminatedFlowComment: "Unterminated flow-comment."
});
function K5(e) {
return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "TypeAlias" && e.declaration.type !== "InterfaceDeclaration");
}
function fl(e) {
return e.importKind === "type" || e.importKind === "typeof";
}
const W5 = {
const: "declare export var",
let: "declare export var",
type: "export type",
interface: "export interface"
};
function J5(e, t) {
const r = [], i = [];
for (let s = 0; s < e.length; s++)
  (t(e[s], s, e) ? r : i).push(e[s]);
return [r, i];
}
const Y5 = /\*?\s*@((?:no)?flow)\b/;
var X5 = (e) => class extends e {
constructor(...r) {
  super(...r), this.flowPragma = void 0;
}
getScopeHandler() {
  return E5;
}
shouldParseTypes() {
  return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
}
shouldParseEnums() {
  return !!this.getPluginOption("flow", "enums");
}
finishToken(r, i) {
  r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, i);
}
addComment(r) {
  if (this.flowPragma === void 0) {
    const i = Y5.exec(r.value);
    if (i) if (i[1] === "flow")
      this.flowPragma = "flow";
    else if (i[1] === "noflow")
      this.flowPragma = "noflow";
    else
      throw new Error("Unexpected flow pragma");
  }
  super.addComment(r);
}
flowParseTypeInitialiser(r) {
  const i = this.state.inType;
  this.state.inType = !0, this.expect(r || 14);
  const s = this.flowParseType();
  return this.state.inType = i, s;
}
flowParsePredicate() {
  const r = this.startNode(), i = this.state.startLoc;
  return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > i.index + 1 && this.raise(ye.UnexpectedSpaceBetweenModuloChecks, i), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "InferredPredicate");
}
flowParseTypeAndPredicateInitialiser() {
  const r = this.state.inType;
  this.state.inType = !0, this.expect(14);
  let i = null, s = null;
  return this.match(54) ? (this.state.inType = r, s = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = r, this.match(54) && (s = this.flowParsePredicate())), [i, s];
}
flowParseDeclareClass(r) {
  return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
}
flowParseDeclareFunction(r) {
  this.next();
  const i = r.id = this.parseIdentifier(), s = this.startNode(), n = this.startNode();
  this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, this.expect(10);
  const a = this.flowParseFunctionTypeParams();
  return s.params = a.params, s.rest = a.rest, s.this = a._this, this.expect(11), [s.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), n.typeAnnotation = this.finishNode(s, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(n, "TypeAnnotation"), this.resetEndLocation(i), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
}
flowParseDeclare(r, i) {
  if (this.match(80))
    return this.flowParseDeclareClass(r);
  if (this.match(68))
    return this.flowParseDeclareFunction(r);
  if (this.match(74))
    return this.flowParseDeclareVariable(r);
  if (this.eatContextual(127))
    return this.match(16) ? this.flowParseDeclareModuleExports(r) : (i && this.raise(ye.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(r));
  if (this.isContextual(130))
    return this.flowParseDeclareTypeAlias(r);
  if (this.isContextual(131))
    return this.flowParseDeclareOpaqueType(r);
  if (this.isContextual(129))
    return this.flowParseDeclareInterface(r);
  if (this.match(82))
    return this.flowParseDeclareExportDeclaration(r, i);
  this.unexpected();
}
flowParseDeclareVariable(r) {
  return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(), this.finishNode(r, "DeclareVariable");
}
flowParseDeclareModule(r) {
  this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
  const i = r.body = this.startNode(), s = i.body = [];
  for (this.expect(5); !this.match(8); ) {
    let o = this.startNode();
    this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(ye.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(o)) : (this.expectContextual(125, ye.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, !0)), s.push(o);
  }
  this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
  let n = null, a = !1;
  return s.forEach((o) => {
    K5(o) ? (n === "CommonJS" && this.raise(ye.AmbiguousDeclareModuleKind, o), n = "ES") : o.type === "DeclareModuleExports" && (a && this.raise(ye.DuplicateDeclareModuleExports, o), n === "ES" && this.raise(ye.AmbiguousDeclareModuleKind, o), n = "CommonJS", a = !0);
  }), r.kind = n || "CommonJS", this.finishNode(r, "DeclareModule");
}
flowParseDeclareExportDeclaration(r, i) {
  if (this.expect(82), this.eat(65))
    return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(), this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
  if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
    const s = this.state.value;
    throw this.raise(ye.UnsupportedDeclareExportKind, this.state.startLoc, {
      unsupportedExportKind: s,
      suggestion: W5[s]
    });
  }
  if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
    return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
  if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
    return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.exportKind), r.type = "Declare" + r.type, r;
  this.unexpected();
}
flowParseDeclareModuleExports(r) {
  return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r, "DeclareModuleExports");
}
flowParseDeclareTypeAlias(r) {
  this.next();
  const i = this.flowParseTypeAlias(r);
  return i.type = "DeclareTypeAlias", i;
}
flowParseDeclareOpaqueType(r) {
  this.next();
  const i = this.flowParseOpaqueType(r, !0);
  return i.type = "DeclareOpaqueType", i;
}
flowParseDeclareInterface(r) {
  return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
}
flowParseInterfaceish(r, i) {
  if (r.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(r.id.name, i ? 17 : 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
    do
      r.extends.push(this.flowParseInterfaceExtends());
    while (!i && this.eat(12));
  if (i) {
    if (r.implements = [], r.mixins = [], this.eatContextual(117))
      do
        r.mixins.push(this.flowParseInterfaceExtends());
      while (this.eat(12));
    if (this.eatContextual(113))
      do
        r.implements.push(this.flowParseInterfaceExtends());
      while (this.eat(12));
  }
  r.body = this.flowParseObjectType({
    allowStatic: i,
    allowExact: !1,
    allowSpread: !1,
    allowProto: i,
    allowInexact: !1
  });
}
flowParseInterfaceExtends() {
  const r = this.startNode();
  return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
}
flowParseInterface(r) {
  return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
}
checkNotUnderscore(r) {
  r === "_" && this.raise(ye.UnexpectedReservedUnderscore, this.state.startLoc);
}
checkReservedType(r, i, s) {
  $5.has(r) && this.raise(s ? ye.AssignReservedType : ye.UnexpectedReservedType, i, {
    reservedType: r
  });
}
flowParseRestrictedIdentifier(r, i) {
  return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(r);
}
flowParseTypeAlias(r) {
  return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(r, "TypeAlias");
}
flowParseOpaqueType(r, i) {
  return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, i || (r.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(r, "OpaqueType");
}
flowParseTypeParameter(r = !1) {
  const i = this.state.startLoc, s = this.startNode(), n = this.flowParseVariance(), a = this.flowParseTypeAnnotatableIdentifier();
  return s.name = a.name, s.variance = n, s.bound = a.typeAnnotation, this.match(29) ? (this.eat(29), s.default = this.flowParseType()) : r && this.raise(ye.MissingTypeParamDefault, i), this.finishNode(s, "TypeParameter");
}
flowParseTypeParameterDeclaration() {
  const r = this.state.inType, i = this.startNode();
  i.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
  let s = !1;
  do {
    const n = this.flowParseTypeParameter(s);
    i.params.push(n), n.default && (s = !0), this.match(48) || this.expect(12);
  } while (!this.match(48));
  return this.expect(48), this.state.inType = r, this.finishNode(i, "TypeParameterDeclaration");
}
flowParseTypeParameterInstantiation() {
  const r = this.startNode(), i = this.state.inType;
  r.params = [], this.state.inType = !0, this.expect(47);
  const s = this.state.noAnonFunctionType;
  for (this.state.noAnonFunctionType = !1; !this.match(48); )
    r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
  return this.state.noAnonFunctionType = s, this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
}
flowParseTypeParameterInstantiationCallOrNew() {
  const r = this.startNode(), i = this.state.inType;
  for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
    r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
  return this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
}
flowParseInterfaceType() {
  const r = this.startNode();
  if (this.expectContextual(129), r.extends = [], this.eat(81))
    do
      r.extends.push(this.flowParseInterfaceExtends());
    while (this.eat(12));
  return r.body = this.flowParseObjectType({
    allowStatic: !1,
    allowExact: !1,
    allowSpread: !1,
    allowProto: !1,
    allowInexact: !1
  }), this.finishNode(r, "InterfaceTypeAnnotation");
}
flowParseObjectPropertyKey() {
  return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
}
flowParseObjectTypeIndexer(r, i, s) {
  return r.static = i, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) : (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = s, this.finishNode(r, "ObjectTypeIndexer");
}
flowParseObjectTypeInternalSlot(r, i) {
  return r.static = i, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method = !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
}
flowParseObjectTypeMethodish(r) {
  for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
    r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
  return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(), this.finishNode(r, "FunctionTypeAnnotation");
}
flowParseObjectTypeCallProperty(r, i) {
  const s = this.startNode();
  return r.static = i, r.value = this.flowParseObjectTypeMethodish(s), this.finishNode(r, "ObjectTypeCallProperty");
}
flowParseObjectType({
  allowStatic: r,
  allowExact: i,
  allowSpread: s,
  allowProto: n,
  allowInexact: a
}) {
  const o = this.state.inType;
  this.state.inType = !0;
  const u = this.startNode();
  u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
  let l, c, f = !1;
  for (i && this.match(6) ? (this.expect(6), l = 9, c = !0) : (this.expect(5), l = 8, c = !1), u.exact = c; !this.match(l); ) {
    let h = !1, y = null, g = null;
    const A = this.startNode();
    if (n && this.isContextual(118)) {
      const _ = this.lookahead();
      _.type !== 14 && _.type !== 17 && (this.next(), y = this.state.startLoc, r = !1);
    }
    if (r && this.isContextual(106)) {
      const _ = this.lookahead();
      _.type !== 14 && _.type !== 17 && (this.next(), h = !0);
    }
    const C = this.flowParseVariance();
    if (this.eat(0))
      y != null && this.unexpected(y), this.eat(0) ? (C && this.unexpected(C.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(A, h))) : u.indexers.push(this.flowParseObjectTypeIndexer(A, h, C));
    else if (this.match(10) || this.match(47))
      y != null && this.unexpected(y), C && this.unexpected(C.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(A, h));
    else {
      let _ = "init";
      if (this.isContextual(99) || this.isContextual(104)) {
        const G = this.lookahead();
        df(G.type) && (_ = this.state.value, this.next());
      }
      const j = this.flowParseObjectTypeProperty(A, h, y, C, _, s, a ?? !c);
      j === null ? (f = !0, g = this.state.lastTokStartLoc) : u.properties.push(j);
    }
    this.flowObjectTypeSemicolon(), g && !this.match(8) && !this.match(9) && this.raise(ye.UnexpectedExplicitInexactInObject, g);
  }
  this.expect(l), s && (u.inexact = f);
  const p = this.finishNode(u, "ObjectTypeAnnotation");
  return this.state.inType = o, p;
}
flowParseObjectTypeProperty(r, i, s, n, a, o, u) {
  if (this.eat(21))
    return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? u || this.raise(ye.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(ye.InexactInsideNonObject, this.state.lastTokStartLoc), n && this.raise(ye.InexactVariance, n), null) : (o || this.raise(ye.UnexpectedSpreadType, this.state.lastTokStartLoc), s != null && this.unexpected(s), n && this.raise(ye.SpreadVariance, n), r.argument = this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
  {
    r.key = this.flowParseObjectPropertyKey(), r.static = i, r.proto = s != null, r.kind = a;
    let l = !1;
    return this.match(47) || this.match(10) ? (r.method = !0, s != null && this.unexpected(s), n && this.unexpected(n.loc.start), r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (a === "get" || a === "set") && this.flowCheckGetterSetterParams(r), !o && r.key.name === "constructor" && r.value.this && this.raise(ye.ThisParamBannedInConstructor, r.value.this)) : (a !== "init" && this.unexpected(), r.method = !1, this.eat(17) && (l = !0), r.value = this.flowParseTypeInitialiser(), r.variance = n), r.optional = l, this.finishNode(r, "ObjectTypeProperty");
  }
}
flowCheckGetterSetterParams(r) {
  const i = r.kind === "get" ? 0 : 1, s = r.value.params.length + (r.value.rest ? 1 : 0);
  r.value.this && this.raise(r.kind === "get" ? ye.GetterMayNotHaveThisParam : ye.SetterMayNotHaveThisParam, r.value.this), s !== i && this.raise(r.kind === "get" ? w.BadGetterArity : w.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(w.BadSetterRestParameter, r);
}
flowObjectTypeSemicolon() {
  !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
}
flowParseQualifiedTypeIdentifier(r, i) {
  var s;
  (s = r) != null || (r = this.state.startLoc);
  let n = i || this.flowParseRestrictedIdentifier(!0);
  for (; this.eat(16); ) {
    const a = this.startNodeAt(r);
    a.qualification = n, a.id = this.flowParseRestrictedIdentifier(!0), n = this.finishNode(a, "QualifiedTypeIdentifier");
  }
  return n;
}
flowParseGenericType(r, i) {
  const s = this.startNodeAt(r);
  return s.typeParameters = null, s.id = this.flowParseQualifiedTypeIdentifier(r, i), this.match(47) && (s.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(s, "GenericTypeAnnotation");
}
flowParseTypeofType() {
  const r = this.startNode();
  return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
}
flowParseTupleType() {
  const r = this.startNode();
  for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(3)); )
    this.expect(12);
  return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
}
flowParseFunctionTypeParam(r) {
  let i = null, s = !1, n = null;
  const a = this.startNode(), o = this.lookahead(), u = this.state.type === 78;
  return o.type === 14 || o.type === 17 ? (u && !r && this.raise(ye.ThisParamMustBeFirst, a), i = this.parseIdentifier(u), this.eat(17) && (s = !0, u && this.raise(ye.ThisParamMayNotBeOptional, a)), n = this.flowParseTypeInitialiser()) : n = this.flowParseType(), a.name = i, a.optional = s, a.typeAnnotation = n, this.finishNode(a, "FunctionTypeParam");
}
reinterpretTypeAsFunctionTypeParam(r) {
  const i = this.startNodeAt(r.loc.start);
  return i.name = null, i.optional = !1, i.typeAnnotation = r, this.finishNode(i, "FunctionTypeParam");
}
flowParseFunctionTypeParams(r = []) {
  let i = null, s = null;
  for (this.match(78) && (s = this.flowParseFunctionTypeParam(!0), s.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
    r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
  return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
    params: r,
    rest: i,
    _this: s
  };
}
flowIdentToTypeAnnotation(r, i, s) {
  switch (s.name) {
    case "any":
      return this.finishNode(i, "AnyTypeAnnotation");
    case "bool":
    case "boolean":
      return this.finishNode(i, "BooleanTypeAnnotation");
    case "mixed":
      return this.finishNode(i, "MixedTypeAnnotation");
    case "empty":
      return this.finishNode(i, "EmptyTypeAnnotation");
    case "number":
      return this.finishNode(i, "NumberTypeAnnotation");
    case "string":
      return this.finishNode(i, "StringTypeAnnotation");
    case "symbol":
      return this.finishNode(i, "SymbolTypeAnnotation");
    default:
      return this.checkNotUnderscore(s.name), this.flowParseGenericType(r, s);
  }
}
flowParsePrimaryType() {
  const r = this.state.startLoc, i = this.startNode();
  let s, n, a = !1;
  const o = this.state.noAnonFunctionType;
  switch (this.state.type) {
    case 5:
      return this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !0,
        allowProto: !1,
        allowInexact: !0
      });
    case 6:
      return this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !0,
        allowSpread: !0,
        allowProto: !1,
        allowInexact: !1
      });
    case 0:
      return this.state.noAnonFunctionType = !1, n = this.flowParseTupleType(), this.state.noAnonFunctionType = o, n;
    case 47: {
      const u = this.startNode();
      return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), s = this.flowParseFunctionTypeParams(), u.params = s.params, u.rest = s.rest, u.this = s._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(u, "FunctionTypeAnnotation");
    }
    case 10: {
      const u = this.startNode();
      if (this.next(), !this.match(11) && !this.match(21))
        if (Be(this.state.type) || this.match(78)) {
          const l = this.lookahead().type;
          a = l !== 17 && l !== 14;
        } else
          a = !0;
      if (a) {
        if (this.state.noAnonFunctionType = !1, n = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
          return this.expect(11), n;
        this.eat(12);
      }
      return n ? s = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(n)]) : s = this.flowParseFunctionTypeParams(), u.params = s.params, u.rest = s.rest, u.this = s._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters = null, this.finishNode(u, "FunctionTypeAnnotation");
    }
    case 133:
      return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
    case 85:
    case 86:
      return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
    case 53:
      if (this.state.value === "-") {
        if (this.next(), this.match(134))
          return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
        if (this.match(135))
          return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
        throw this.raise(ye.UnexpectedSubtractionOperand, this.state.startLoc);
      }
      this.unexpected();
      return;
    case 134:
      return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
    case 135:
      return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
    case 88:
      return this.next(), this.finishNode(i, "VoidTypeAnnotation");
    case 84:
      return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
    case 78:
      return this.next(), this.finishNode(i, "ThisTypeAnnotation");
    case 55:
      return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
    case 87:
      return this.flowParseTypeofType();
    default:
      if (Ya(this.state.type)) {
        const u = or(this.state.type);
        return this.next(), super.createIdentifier(i, u);
      } else if (Be(this.state.type))
        return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, i, this.parseIdentifier());
  }
  this.unexpected();
}
flowParsePostfixType() {
  const r = this.state.startLoc;
  let i = this.flowParsePrimaryType(), s = !1;
  for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
    const n = this.startNodeAt(r), a = this.eat(18);
    s = s || a, this.expect(0), !a && this.match(3) ? (n.elementType = i, this.next(), i = this.finishNode(n, "ArrayTypeAnnotation")) : (n.objectType = i, n.indexType = this.flowParseType(), this.expect(3), s ? (n.optional = a, i = this.finishNode(n, "OptionalIndexedAccessType")) : i = this.finishNode(n, "IndexedAccessType"));
  }
  return i;
}
flowParsePrefixType() {
  const r = this.startNode();
  return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
}
flowParseAnonFunctionWithoutParens() {
  const r = this.flowParsePrefixType();
  if (!this.state.noAnonFunctionType && this.eat(19)) {
    const i = this.startNodeAt(r.loc.start);
    return i.params = [this.reinterpretTypeAsFunctionTypeParam(r)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
  }
  return r;
}
flowParseIntersectionType() {
  const r = this.startNode();
  this.eat(45);
  const i = this.flowParseAnonFunctionWithoutParens();
  for (r.types = [i]; this.eat(45); )
    r.types.push(this.flowParseAnonFunctionWithoutParens());
  return r.types.length === 1 ? i : this.finishNode(r, "IntersectionTypeAnnotation");
}
flowParseUnionType() {
  const r = this.startNode();
  this.eat(43);
  const i = this.flowParseIntersectionType();
  for (r.types = [i]; this.eat(43); )
    r.types.push(this.flowParseIntersectionType());
  return r.types.length === 1 ? i : this.finishNode(r, "UnionTypeAnnotation");
}
flowParseType() {
  const r = this.state.inType;
  this.state.inType = !0;
  const i = this.flowParseUnionType();
  return this.state.inType = r, i;
}
flowParseTypeOrImplicitInstantiation() {
  if (this.state.type === 132 && this.state.value === "_") {
    const r = this.state.startLoc, i = this.parseIdentifier();
    return this.flowParseGenericType(r, i);
  } else
    return this.flowParseType();
}
flowParseTypeAnnotation() {
  const r = this.startNode();
  return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
}
flowParseTypeAnnotatableIdentifier(r) {
  const i = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
  return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
}
typeCastToParameter(r) {
  return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
}
flowParseVariance() {
  let r = null;
  return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(r, "Variance")) : r;
}
parseFunctionBody(r, i, s = !1) {
  if (i) {
    this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, s));
    return;
  }
  super.parseFunctionBody(r, !1, s);
}
parseFunctionBodyAndFinish(r, i, s = !1) {
  if (this.match(14)) {
    const n = this.startNode();
    [n.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = n.typeAnnotation ? this.finishNode(n, "TypeAnnotation") : null;
  }
  return super.parseFunctionBodyAndFinish(r, i, s);
}
parseStatementLike(r) {
  if (this.state.strict && this.isContextual(129)) {
    const s = this.lookahead();
    if (_t(s.type)) {
      const n = this.startNode();
      return this.next(), this.flowParseInterface(n);
    }
  } else if (this.shouldParseEnums() && this.isContextual(126)) {
    const s = this.startNode();
    return this.next(), this.flowParseEnumDeclaration(s);
  }
  const i = super.parseStatementLike(r);
  return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
}
parseExpressionStatement(r, i, s) {
  if (i.type === "Identifier") {
    if (i.name === "declare") {
      if (this.match(80) || Be(this.state.type) || this.match(68) || this.match(74) || this.match(82))
        return this.flowParseDeclare(r);
    } else if (Be(this.state.type)) {
      if (i.name === "interface")
        return this.flowParseInterface(r);
      if (i.name === "type")
        return this.flowParseTypeAlias(r);
      if (i.name === "opaque")
        return this.flowParseOpaqueType(r, !1);
    }
  }
  return super.parseExpressionStatement(r, i, s);
}
shouldParseExportDeclaration() {
  const {
    type: r
  } = this.state;
  return ol(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
}
isExportDefaultSpecifier() {
  const {
    type: r
  } = this.state;
  return ol(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
}
parseExportDefaultExpression() {
  if (this.shouldParseEnums() && this.isContextual(126)) {
    const r = this.startNode();
    return this.next(), this.flowParseEnumDeclaration(r);
  }
  return super.parseExportDefaultExpression();
}
parseConditional(r, i, s) {
  if (!this.match(17)) return r;
  if (this.state.maybeInArrowParameters) {
    const p = this.lookaheadCharCode();
    if (p === 44 || p === 61 || p === 58 || p === 41)
      return this.setOptionalParametersError(s), r;
  }
  this.expect(17);
  const n = this.state.clone(), a = this.state.noArrowAt, o = this.startNodeAt(i);
  let {
    consequent: u,
    failed: l
  } = this.tryParseConditionalConsequent(), [c, f] = this.getArrowLikeExpressions(u);
  if (l || f.length > 0) {
    const p = [...a];
    if (f.length > 0) {
      this.state = n, this.state.noArrowAt = p;
      for (let h = 0; h < f.length; h++)
        p.push(f[h].start);
      ({
        consequent: u,
        failed: l
      } = this.tryParseConditionalConsequent()), [c, f] = this.getArrowLikeExpressions(u);
    }
    l && c.length > 1 && this.raise(ye.AmbiguousConditionalArrow, n.startLoc), l && c.length === 1 && (this.state = n, p.push(c[0].start), this.state.noArrowAt = p, {
      consequent: u,
      failed: l
    } = this.tryParseConditionalConsequent());
  }
  return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = a, this.expect(14), o.test = r, o.consequent = u, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
}
tryParseConditionalConsequent() {
  this.state.noArrowParamsConversionAt.push(this.state.start);
  const r = this.parseMaybeAssignAllowIn(), i = !this.match(14);
  return this.state.noArrowParamsConversionAt.pop(), {
    consequent: r,
    failed: i
  };
}
getArrowLikeExpressions(r, i) {
  const s = [r], n = [];
  for (; s.length !== 0; ) {
    const a = s.pop();
    a.type === "ArrowFunctionExpression" && a.body.type !== "BlockStatement" ? (a.typeParameters || !a.returnType ? this.finishArrowValidation(a) : n.push(a), s.push(a.body)) : a.type === "ConditionalExpression" && (s.push(a.consequent), s.push(a.alternate));
  }
  return i ? (n.forEach((a) => this.finishArrowValidation(a)), [n, []]) : J5(n, (a) => a.params.every((o) => this.isAssignable(o, !0)));
}
finishArrowValidation(r) {
  var i;
  this.toAssignableList(r.params, (i = r.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1, !0), this.scope.exit();
}
forwardNoArrowParamsConversionAt(r, i) {
  let s;
  return this.state.noArrowParamsConversionAt.includes(r.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), s = i(), this.state.noArrowParamsConversionAt.pop()) : s = i(), s;
}
parseParenItem(r, i) {
  const s = super.parseParenItem(r, i);
  if (this.eat(17) && (s.optional = !0, this.resetEndLocation(r)), this.match(14)) {
    const n = this.startNodeAt(i);
    return n.expression = s, n.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(n, "TypeCastExpression");
  }
  return s;
}
assertModuleNodeAllowed(r) {
  r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind === "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
}
parseExportDeclaration(r) {
  if (this.isContextual(130)) {
    r.exportKind = "type";
    const i = this.startNode();
    return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(i);
  } else if (this.isContextual(131)) {
    r.exportKind = "type";
    const i = this.startNode();
    return this.next(), this.flowParseOpaqueType(i, !1);
  } else if (this.isContextual(129)) {
    r.exportKind = "type";
    const i = this.startNode();
    return this.next(), this.flowParseInterface(i);
  } else if (this.shouldParseEnums() && this.isContextual(126)) {
    r.exportKind = "value";
    const i = this.startNode();
    return this.next(), this.flowParseEnumDeclaration(i);
  } else
    return super.parseExportDeclaration(r);
}
eatExportStar(r) {
  return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.next(), !0) : !1;
}
maybeParseExportNamespaceSpecifier(r) {
  const {
    startLoc: i
  } = this.state, s = super.maybeParseExportNamespaceSpecifier(r);
  return s && r.exportKind === "type" && this.unexpected(i), s;
}
parseClassId(r, i, s) {
  super.parseClassId(r, i, s), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
}
parseClassMember(r, i, s) {
  const {
    startLoc: n
  } = this.state;
  if (this.isContextual(125)) {
    if (super.parseClassMemberFromModifier(r, i))
      return;
    i.declare = !0;
  }
  super.parseClassMember(r, i, s), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "PropertyDefinition" ? this.raise(ye.DeclareClassElement, n) : i.value && this.raise(ye.DeclareClassFieldInitializer, i.value));
}
isIterator(r) {
  return r === "iterator" || r === "asyncIterator";
}
readIterator() {
  const r = super.readWord1(), i = "@@" + r;
  (!this.isIterator(r) || !this.state.inType) && this.raise(w.InvalidIdentifier, this.state.curPosition(), {
    identifierName: i
  }), this.finishToken(132, i);
}
getTokenFromCode(r) {
  const i = this.input.charCodeAt(this.state.pos + 1);
  r === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.state.inType && r === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : T5(r, i, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
}
isAssignable(r, i) {
  return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, i) : super.isAssignable(r, i);
}
toAssignable(r, i = !1) {
  !i && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.toAssignable(r, i);
}
toAssignableList(r, i, s) {
  for (let n = 0; n < r.length; n++) {
    const a = r[n];
    (a == null ? void 0 : a.type) === "TypeCastExpression" && (r[n] = this.typeCastToParameter(a));
  }
  super.toAssignableList(r, i, s);
}
toReferencedList(r, i) {
  for (let n = 0; n < r.length; n++) {
    var s;
    const a = r[n];
    a && a.type === "TypeCastExpression" && !((s = a.extra) != null && s.parenthesized) && (r.length > 1 || !i) && this.raise(ye.TypeCastInPattern, a.typeAnnotation);
  }
  return r;
}
parseArrayLike(r, i, s, n) {
  const a = super.parseArrayLike(r, i, s, n);
  return i && !this.state.maybeInArrowParameters && this.toReferencedList(a.elements), a;
}
isValidLVal(r, i, s) {
  return r === "TypeCastExpression" || super.isValidLVal(r, i, s);
}
parseClassProperty(r) {
  return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
}
parseClassPrivateProperty(r) {
  return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
}
isClassMethod() {
  return this.match(47) || super.isClassMethod();
}
isClassProperty() {
  return this.match(14) || super.isClassProperty();
}
isNonstaticConstructor(r) {
  return !this.match(14) && super.isNonstaticConstructor(r);
}
pushClassMethod(r, i, s, n, a, o) {
  if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(r, i, s, n, a, o), i.params && a) {
    const u = i.params;
    u.length > 0 && this.isThisParam(u[0]) && this.raise(ye.ThisParamBannedInConstructor, i);
  } else if (i.type === "MethodDefinition" && a && i.value.params) {
    const u = i.value.params;
    u.length > 0 && this.isThisParam(u[0]) && this.raise(ye.ThisParamBannedInConstructor, i);
  }
}
pushClassPrivateMethod(r, i, s, n) {
  i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(r, i, s, n);
}
parseClassSuper(r) {
  if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
    this.next();
    const i = r.implements = [];
    do {
      const s = this.startNode();
      s.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? s.typeParameters = this.flowParseTypeParameterInstantiation() : s.typeParameters = null, i.push(this.finishNode(s, "ClassImplements"));
    } while (this.eat(12));
  }
}
checkGetterSetterParams(r) {
  super.checkGetterSetterParams(r);
  const i = this.getObjectOrClassMethodParams(r);
  if (i.length > 0) {
    const s = i[0];
    this.isThisParam(s) && r.kind === "get" ? this.raise(ye.GetterMayNotHaveThisParam, s) : this.isThisParam(s) && this.raise(ye.SetterMayNotHaveThisParam, s);
  }
}
parsePropertyNamePrefixOperator(r) {
  r.variance = this.flowParseVariance();
}
parseObjPropValue(r, i, s, n, a, o, u) {
  r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
  let l;
  this.match(47) && !o && (l = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
  const c = super.parseObjPropValue(r, i, s, n, a, o, u);
  return l && ((c.value || c).typeParameters = l), c;
}
parseAssignableListItemTypes(r) {
  return this.eat(17) && (r.type !== "Identifier" && this.raise(ye.PatternIsOptional, r), this.isThisParam(r) && this.raise(ye.ThisParamMayNotBeOptional, r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(ye.ThisParamAnnotationRequired, r), this.match(29) && this.isThisParam(r) && this.raise(ye.ThisParamNoDefault, r), this.resetEndLocation(r), r;
}
parseMaybeDefault(r, i) {
  const s = super.parseMaybeDefault(r, i);
  return s.type === "AssignmentPattern" && s.typeAnnotation && s.right.start < s.typeAnnotation.start && this.raise(ye.TypeBeforeInitializer, s.typeAnnotation), s;
}
checkImportReflection(r) {
  super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(ye.ImportReflectionHasImportType, r.specifiers[0].loc.start);
}
parseImportSpecifierLocal(r, i, s) {
  i.local = fl(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(i, s));
}
isPotentialImportPhase(r) {
  if (super.isPotentialImportPhase(r)) return !0;
  if (this.isContextual(130)) {
    if (!r) return !0;
    const i = this.lookaheadCharCode();
    return i === 123 || i === 42;
  }
  return !r && this.isContextual(87);
}
applyImportPhase(r, i, s, n) {
  if (super.applyImportPhase(r, i, s, n), i) {
    if (!s && this.match(65))
      return;
    r.exportKind = s === "type" ? s : "value";
  } else
    s === "type" && this.match(55) && this.unexpected(), r.importKind = s === "type" || s === "typeof" ? s : "value";
}
parseImportSpecifier(r, i, s, n, a) {
  const o = r.imported;
  let u = null;
  o.type === "Identifier" && (o.name === "type" ? u = "type" : o.name === "typeof" && (u = "typeof"));
  let l = !1;
  if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
    const f = this.parseIdentifier(!0);
    u !== null && !_t(this.state.type) ? (r.imported = f, r.importKind = u, r.local = Gt(f)) : (r.imported = o, r.importKind = null, r.local = this.parseIdentifier());
  } else {
    if (u !== null && _t(this.state.type))
      r.imported = this.parseIdentifier(!0), r.importKind = u;
    else {
      if (i)
        throw this.raise(w.ImportBindingIsString, r, {
          importName: o.value
        });
      r.imported = o, r.importKind = null;
    }
    this.eatContextual(93) ? r.local = this.parseIdentifier() : (l = !0, r.local = Gt(r.imported));
  }
  const c = fl(r);
  return s && c && this.raise(ye.ImportTypeShorthandOnlyInPureImport, r), (s || c) && this.checkReservedType(r.local.name, r.local.loc.start, !0), l && !s && !c && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
}
parseBindingAtom() {
  switch (this.state.type) {
    case 78:
      return this.parseIdentifier(!0);
    default:
      return super.parseBindingAtom();
  }
}
parseFunctionParams(r, i) {
  const s = r.kind;
  s !== "get" && s !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(r, i);
}
parseVarId(r, i) {
  super.parseVarId(r, i), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
}
parseAsyncArrowFromCallExpression(r, i) {
  if (this.match(14)) {
    const s = this.state.noAnonFunctionType;
    this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = s;
  }
  return super.parseAsyncArrowFromCallExpression(r, i);
}
shouldParseAsyncArrow() {
  return this.match(14) || super.shouldParseAsyncArrow();
}
parseMaybeAssign(r, i) {
  var s;
  let n = null, a;
  if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
    if (n = this.state.clone(), a = this.tryParse(() => super.parseMaybeAssign(r, i), n), !a.error) return a.node;
    const {
      context: l
    } = this.state, c = l[l.length - 1];
    (c === $e.j_oTag || c === $e.j_expr) && l.pop();
  }
  if ((s = a) != null && s.error || this.match(47)) {
    var o, u;
    n = n || this.state.clone();
    let l;
    const c = this.tryParse((p) => {
      var h;
      l = this.flowParseTypeParameterDeclaration();
      const y = this.forwardNoArrowParamsConversionAt(l, () => {
        const A = super.parseMaybeAssign(r, i);
        return this.resetStartLocationFromNode(A, l), A;
      });
      (h = y.extra) != null && h.parenthesized && p();
      const g = this.maybeUnwrapTypeCastExpression(y);
      return g.type !== "ArrowFunctionExpression" && p(), g.typeParameters = l, this.resetStartLocationFromNode(g, l), y;
    }, n);
    let f = null;
    if (c.node && this.maybeUnwrapTypeCastExpression(c.node).type === "ArrowFunctionExpression") {
      if (!c.error && !c.aborted)
        return c.node.async && this.raise(ye.UnexpectedTypeParameterBeforeAsyncArrowFunction, l), c.node;
      f = c.node;
    }
    if ((o = a) != null && o.node)
      return this.state = a.failState, a.node;
    if (f)
      return this.state = c.failState, f;
    throw (u = a) != null && u.thrown ? a.error : c.thrown ? c.error : this.raise(ye.UnexpectedTokenAfterTypeParameter, l);
  }
  return super.parseMaybeAssign(r, i);
}
parseArrow(r) {
  if (this.match(14)) {
    const i = this.tryParse(() => {
      const s = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = !0;
      const n = this.startNode();
      return [n.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = s, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), n;
    });
    if (i.thrown) return null;
    i.error && (this.state = i.failState), r.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
  }
  return super.parseArrow(r);
}
shouldParseArrow(r) {
  return this.match(14) || super.shouldParseArrow(r);
}
setArrowFunctionParameters(r, i) {
  this.state.noArrowParamsConversionAt.includes(r.start) ? r.params = i : super.setArrowFunctionParameters(r, i);
}
checkParams(r, i, s, n = !0) {
  if (!(s && this.state.noArrowParamsConversionAt.includes(r.start))) {
    for (let a = 0; a < r.params.length; a++)
      this.isThisParam(r.params[a]) && a > 0 && this.raise(ye.ThisParamMustBeFirst, r.params[a]);
    super.checkParams(r, i, s, n);
  }
}
parseParenAndDistinguishExpression(r) {
  return super.parseParenAndDistinguishExpression(r && !this.state.noArrowAt.includes(this.state.start));
}
parseSubscripts(r, i, s) {
  if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.includes(i.index)) {
    this.next();
    const n = this.startNodeAt(i);
    n.callee = r, n.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(n, "CallExpression");
  } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
    const n = this.state.clone(), a = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(i) || u(), n);
    if (!a.error && !a.aborted) return a.node;
    const o = this.tryParse(() => super.parseSubscripts(r, i, s), n);
    if (o.node && !o.error) return o.node;
    if (a.node)
      return this.state = a.failState, a.node;
    if (o.node)
      return this.state = o.failState, o.node;
    throw a.error || o.error;
  }
  return super.parseSubscripts(r, i, s);
}
parseSubscript(r, i, s, n) {
  if (this.match(18) && this.isLookaheadToken_lt()) {
    if (n.optionalChainMember = !0, s)
      return n.stop = !0, r;
    this.next();
    const a = this.startNodeAt(i);
    return a.callee = r, a.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), a.arguments = this.parseCallExpressionArguments(11, !1), a.optional = !0, this.finishCallExpression(a, !0);
  } else if (!s && this.shouldParseTypes() && this.match(47)) {
    const a = this.startNodeAt(i);
    a.callee = r;
    const o = this.tryParse(() => (a.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), a.arguments = super.parseCallExpressionArguments(11, !1), n.optionalChainMember && (a.optional = !1), this.finishCallExpression(a, n.optionalChainMember)));
    if (o.node)
      return o.error && (this.state = o.failState), o.node;
  }
  return super.parseSubscript(r, i, s, n);
}
parseNewCallee(r) {
  super.parseNewCallee(r);
  let i = null;
  this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments = i;
}
parseAsyncArrowWithTypeParameters(r) {
  const i = this.startNodeAt(r);
  if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
    return super.parseArrowExpression(i, void 0, !0);
}
readToken_mult_modulo(r) {
  const i = this.input.charCodeAt(this.state.pos + 1);
  if (r === 42 && i === 47 && this.state.hasFlowComment) {
    this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
    return;
  }
  super.readToken_mult_modulo(r);
}
readToken_pipe_amp(r) {
  const i = this.input.charCodeAt(this.state.pos + 1);
  if (r === 124 && i === 125) {
    this.finishOp(9, 2);
    return;
  }
  super.readToken_pipe_amp(r);
}
parseTopLevel(r, i) {
  const s = super.parseTopLevel(r, i);
  return this.state.hasFlowComment && this.raise(ye.UnterminatedFlowComment, this.state.curPosition()), s;
}
skipBlockComment() {
  if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
    if (this.state.hasFlowComment)
      throw this.raise(ye.NestedFlowComment, this.state.startLoc);
    this.hasFlowCommentCompletion();
    const r = this.skipFlowComment();
    r && (this.state.pos += r, this.state.hasFlowComment = !0);
    return;
  }
  return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
}
skipFlowComment() {
  const {
    pos: r
  } = this.state;
  let i = 2;
  for (; [32, 9].includes(this.input.charCodeAt(r + i)); )
    i++;
  const s = this.input.charCodeAt(i + r), n = this.input.charCodeAt(i + r + 1);
  return s === 58 && n === 58 ? i + 2 : this.input.slice(i + r, i + r + 12) === "flow-include" ? i + 12 : s === 58 && n !== 58 ? i : !1;
}
hasFlowCommentCompletion() {
  if (this.input.indexOf("*/", this.state.pos) === -1)
    throw this.raise(w.UnterminatedComment, this.state.curPosition());
}
flowEnumErrorBooleanMemberNotInitialized(r, {
  enumName: i,
  memberName: s
}) {
  this.raise(ye.EnumBooleanMemberNotInitialized, r, {
    memberName: s,
    enumName: i
  });
}
flowEnumErrorInvalidMemberInitializer(r, i) {
  return this.raise(i.explicitType ? i.explicitType === "symbol" ? ye.EnumInvalidMemberInitializerSymbolType : ye.EnumInvalidMemberInitializerPrimaryType : ye.EnumInvalidMemberInitializerUnknownType, r, i);
}
flowEnumErrorNumberMemberNotInitialized(r, i) {
  this.raise(ye.EnumNumberMemberNotInitialized, r, i);
}
flowEnumErrorStringMemberInconsistentlyInitialized(r, i) {
  this.raise(ye.EnumStringMemberInconsistentlyInitialized, r, i);
}
flowEnumMemberInit() {
  const r = this.state.startLoc, i = () => this.match(12) || this.match(8);
  switch (this.state.type) {
    case 134: {
      const s = this.parseNumericLiteral(this.state.value);
      return i() ? {
        type: "number",
        loc: s.loc.start,
        value: s
      } : {
        type: "invalid",
        loc: r
      };
    }
    case 133: {
      const s = this.parseStringLiteral(this.state.value);
      return i() ? {
        type: "string",
        loc: s.loc.start,
        value: s
      } : {
        type: "invalid",
        loc: r
      };
    }
    case 85:
    case 86: {
      const s = this.parseBooleanLiteral(this.match(85));
      return i() ? {
        type: "boolean",
        loc: s.loc.start,
        value: s
      } : {
        type: "invalid",
        loc: r
      };
    }
    default:
      return {
        type: "invalid",
        loc: r
      };
  }
}
flowEnumMemberRaw() {
  const r = this.state.startLoc, i = this.parseIdentifier(!0), s = this.eat(29) ? this.flowEnumMemberInit() : {
    type: "none",
    loc: r
  };
  return {
    id: i,
    init: s
  };
}
flowEnumCheckExplicitTypeMismatch(r, i, s) {
  const {
    explicitType: n
  } = i;
  n !== null && n !== s && this.flowEnumErrorInvalidMemberInitializer(r, i);
}
flowEnumMembers({
  enumName: r,
  explicitType: i
}) {
  const s = /* @__PURE__ */ new Set(), n = {
    booleanMembers: [],
    numberMembers: [],
    stringMembers: [],
    defaultedMembers: []
  };
  let a = !1;
  for (; !this.match(8); ) {
    if (this.eat(21)) {
      a = !0;
      break;
    }
    const o = this.startNode(), {
      id: u,
      init: l
    } = this.flowEnumMemberRaw(), c = u.name;
    if (c === "")
      continue;
    /^[a-z]/.test(c) && this.raise(ye.EnumInvalidMemberName, u, {
      memberName: c,
      suggestion: c[0].toUpperCase() + c.slice(1),
      enumName: r
    }), s.has(c) && this.raise(ye.EnumDuplicateMemberName, u, {
      memberName: c,
      enumName: r
    }), s.add(c);
    const f = {
      enumName: r,
      explicitType: i,
      memberName: c
    };
    switch (o.id = u, l.type) {
      case "boolean": {
        this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "boolean"), o.init = l.value, n.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
        break;
      }
      case "number": {
        this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "number"), o.init = l.value, n.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
        break;
      }
      case "string": {
        this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "string"), o.init = l.value, n.stringMembers.push(this.finishNode(o, "EnumStringMember"));
        break;
      }
      case "invalid":
        throw this.flowEnumErrorInvalidMemberInitializer(l.loc, f);
      case "none":
        switch (i) {
          case "boolean":
            this.flowEnumErrorBooleanMemberNotInitialized(l.loc, f);
            break;
          case "number":
            this.flowEnumErrorNumberMemberNotInitialized(l.loc, f);
            break;
          default:
            n.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
        }
    }
    this.match(8) || this.expect(12);
  }
  return {
    members: n,
    hasUnknownMembers: a
  };
}
flowEnumStringMembers(r, i, {
  enumName: s
}) {
  if (r.length === 0)
    return i;
  if (i.length === 0)
    return r;
  if (i.length > r.length) {
    for (const n of r)
      this.flowEnumErrorStringMemberInconsistentlyInitialized(n, {
        enumName: s
      });
    return i;
  } else {
    for (const n of i)
      this.flowEnumErrorStringMemberInconsistentlyInitialized(n, {
        enumName: s
      });
    return r;
  }
}
flowEnumParseExplicitType({
  enumName: r
}) {
  if (!this.eatContextual(102)) return null;
  if (!Be(this.state.type))
    throw this.raise(ye.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
      enumName: r
    });
  const {
    value: i
  } = this.state;
  return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(ye.EnumInvalidExplicitType, this.state.startLoc, {
    enumName: r,
    invalidEnumType: i
  }), i;
}
flowEnumBody(r, i) {
  const s = i.name, n = i.loc.start, a = this.flowEnumParseExplicitType({
    enumName: s
  });
  this.expect(5);
  const {
    members: o,
    hasUnknownMembers: u
  } = this.flowEnumMembers({
    enumName: s,
    explicitType: a
  });
  switch (r.hasUnknownMembers = u, a) {
    case "boolean":
      return r.explicitType = !0, r.members = o.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
    case "number":
      return r.explicitType = !0, r.members = o.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
    case "string":
      return r.explicitType = !0, r.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {
        enumName: s
      }), this.expect(8), this.finishNode(r, "EnumStringBody");
    case "symbol":
      return r.members = o.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
    default: {
      const l = () => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody"));
      r.explicitType = !1;
      const c = o.booleanMembers.length, f = o.numberMembers.length, p = o.stringMembers.length, h = o.defaultedMembers.length;
      if (!c && !f && !p && !h)
        return l();
      if (!c && !f)
        return r.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {
          enumName: s
        }), this.expect(8), this.finishNode(r, "EnumStringBody");
      if (!f && !p && c >= h) {
        for (const y of o.defaultedMembers)
          this.flowEnumErrorBooleanMemberNotInitialized(y.loc.start, {
            enumName: s,
            memberName: y.id.name
          });
        return r.members = o.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
      } else if (!c && !p && f >= h) {
        for (const y of o.defaultedMembers)
          this.flowEnumErrorNumberMemberNotInitialized(y.loc.start, {
            enumName: s,
            memberName: y.id.name
          });
        return r.members = o.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
      } else
        return this.raise(ye.EnumInconsistentMemberValues, n, {
          enumName: s
        }), l();
    }
  }
}
flowParseEnumDeclaration(r) {
  const i = this.parseIdentifier();
  return r.id = i, r.body = this.flowEnumBody(this.startNode(), i), this.finishNode(r, "EnumDeclaration");
}
isLookaheadToken_lt() {
  const r = this.nextTokenStart();
  if (this.input.charCodeAt(r) === 60) {
    const i = this.input.charCodeAt(r + 1);
    return i !== 60 && i !== 61;
  }
  return !1;
}
maybeUnwrapTypeCastExpression(r) {
  return r.type === "TypeCastExpression" ? r.expression : r;
}
};
const H5 = {
__proto__: null,
quot: '"',
amp: "&",
apos: "'",
lt: "<",
gt: ">",
nbsp: " ",
iexcl: "¡",
cent: "¢",
pound: "£",
curren: "¤",
yen: "¥",
brvbar: "¦",
sect: "§",
uml: "¨",
copy: "©",
ordf: "ª",
laquo: "«",
not: "¬",
shy: "­",
reg: "®",
macr: "¯",
deg: "°",
plusmn: "±",
sup2: "²",
sup3: "³",
acute: "´",
micro: "µ",
para: "¶",
middot: "·",
cedil: "¸",
sup1: "¹",
ordm: "º",
raquo: "»",
frac14: "¼",
frac12: "½",
frac34: "¾",
iquest: "¿",
Agrave: "À",
Aacute: "Á",
Acirc: "Â",
Atilde: "Ã",
Auml: "Ä",
Aring: "Å",
AElig: "Æ",
Ccedil: "Ç",
Egrave: "È",
Eacute: "É",
Ecirc: "Ê",
Euml: "Ë",
Igrave: "Ì",
Iacute: "Í",
Icirc: "Î",
Iuml: "Ï",
ETH: "Ð",
Ntilde: "Ñ",
Ograve: "Ò",
Oacute: "Ó",
Ocirc: "Ô",
Otilde: "Õ",
Ouml: "Ö",
times: "×",
Oslash: "Ø",
Ugrave: "Ù",
Uacute: "Ú",
Ucirc: "Û",
Uuml: "Ü",
Yacute: "Ý",
THORN: "Þ",
szlig: "ß",
agrave: "à",
aacute: "á",
acirc: "â",
atilde: "ã",
auml: "ä",
aring: "å",
aelig: "æ",
ccedil: "ç",
egrave: "è",
eacute: "é",
ecirc: "ê",
euml: "ë",
igrave: "ì",
iacute: "í",
icirc: "î",
iuml: "ï",
eth: "ð",
ntilde: "ñ",
ograve: "ò",
oacute: "ó",
ocirc: "ô",
otilde: "õ",
ouml: "ö",
divide: "÷",
oslash: "ø",
ugrave: "ù",
uacute: "ú",
ucirc: "û",
uuml: "ü",
yacute: "ý",
thorn: "þ",
yuml: "ÿ",
OElig: "Œ",
oelig: "œ",
Scaron: "Š",
scaron: "š",
Yuml: "Ÿ",
fnof: "ƒ",
circ: "ˆ",
tilde: "˜",
Alpha: "Α",
Beta: "Β",
Gamma: "Γ",
Delta: "Δ",
Epsilon: "Ε",
Zeta: "Ζ",
Eta: "Η",
Theta: "Θ",
Iota: "Ι",
Kappa: "Κ",
Lambda: "Λ",
Mu: "Μ",
Nu: "Ν",
Xi: "Ξ",
Omicron: "Ο",
Pi: "Π",
Rho: "Ρ",
Sigma: "Σ",
Tau: "Τ",
Upsilon: "Υ",
Phi: "Φ",
Chi: "Χ",
Psi: "Ψ",
Omega: "Ω",
alpha: "α",
beta: "β",
gamma: "γ",
delta: "δ",
epsilon: "ε",
zeta: "ζ",
eta: "η",
theta: "θ",
iota: "ι",
kappa: "κ",
lambda: "λ",
mu: "μ",
nu: "ν",
xi: "ξ",
omicron: "ο",
pi: "π",
rho: "ρ",
sigmaf: "ς",
sigma: "σ",
tau: "τ",
upsilon: "υ",
phi: "φ",
chi: "χ",
psi: "ψ",
omega: "ω",
thetasym: "ϑ",
upsih: "ϒ",
piv: "ϖ",
ensp: " ",
emsp: " ",
thinsp: " ",
zwnj: "‌",
zwj: "‍",
lrm: "‎",
rlm: "‏",
ndash: "–",
mdash: "—",
lsquo: "‘",
rsquo: "’",
sbquo: "‚",
ldquo: "“",
rdquo: "”",
bdquo: "„",
dagger: "†",
Dagger: "‡",
bull: "•",
hellip: "…",
permil: "‰",
prime: "′",
Prime: "″",
lsaquo: "‹",
rsaquo: "›",
oline: "‾",
frasl: "⁄",
euro: "€",
image: "ℑ",
weierp: "℘",
real: "ℜ",
trade: "™",
alefsym: "ℵ",
larr: "←",
uarr: "↑",
rarr: "→",
darr: "↓",
harr: "↔",
crarr: "↵",
lArr: "⇐",
uArr: "⇑",
rArr: "⇒",
dArr: "⇓",
hArr: "⇔",
forall: "∀",
part: "∂",
exist: "∃",
empty: "∅",
nabla: "∇",
isin: "∈",
notin: "∉",
ni: "∋",
prod: "∏",
sum: "∑",
minus: "−",
lowast: "∗",
radic: "√",
prop: "∝",
infin: "∞",
ang: "∠",
and: "∧",
or: "∨",
cap: "∩",
cup: "∪",
int: "∫",
there4: "∴",
sim: "∼",
cong: "≅",
asymp: "≈",
ne: "≠",
equiv: "≡",
le: "≤",
ge: "≥",
sub: "⊂",
sup: "⊃",
nsub: "⊄",
sube: "⊆",
supe: "⊇",
oplus: "⊕",
otimes: "⊗",
perp: "⊥",
sdot: "⋅",
lceil: "⌈",
rceil: "⌉",
lfloor: "⌊",
rfloor: "⌋",
lang: "〈",
rang: "〉",
loz: "◊",
spades: "♠",
clubs: "♣",
hearts: "♥",
diams: "♦"
}, pr = Ht`jsx`({
AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
MissingClosingTagElement: ({
  openingTagName: e
}) => `Expected corresponding JSX closing tag for <${e}>.`,
MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
UnexpectedToken: ({
  unexpected: e,
  HTMLEntity: t
}) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`,
UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
UnterminatedJsxContent: "Unterminated JSX contents.",
UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
});
function rr(e) {
return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
}
function Nr(e) {
if (e.type === "JSXIdentifier")
  return e.name;
if (e.type === "JSXNamespacedName")
  return e.namespace.name + ":" + e.name.name;
if (e.type === "JSXMemberExpression")
  return Nr(e.object) + "." + Nr(e.property);
throw new Error("Node had unexpected type: " + e.type);
}
var G5 = (e) => class extends e {
jsxReadToken() {
  let r = "", i = this.state.pos;
  for (; ; ) {
    if (this.state.pos >= this.length)
      throw this.raise(pr.UnterminatedJsxContent, this.state.startLoc);
    const s = this.input.charCodeAt(this.state.pos);
    switch (s) {
      case 60:
      case 123:
        if (this.state.pos === this.state.start) {
          s === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(s);
          return;
        }
        r += this.input.slice(i, this.state.pos), this.finishToken(141, r);
        return;
      case 38:
        r += this.input.slice(i, this.state.pos), r += this.jsxReadEntity(), i = this.state.pos;
        break;
      case 62:
      case 125:
      default:
        ni(s) ? (r += this.input.slice(i, this.state.pos), r += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
    }
  }
}
jsxReadNewLine(r) {
  const i = this.input.charCodeAt(this.state.pos);
  let s;
  return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s = r ? `
` : `\r
`) : s = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, s;
}
jsxReadString(r) {
  let i = "", s = ++this.state.pos;
  for (; ; ) {
    if (this.state.pos >= this.length)
      throw this.raise(w.UnterminatedString, this.state.startLoc);
    const n = this.input.charCodeAt(this.state.pos);
    if (n === r) break;
    n === 38 ? (i += this.input.slice(s, this.state.pos), i += this.jsxReadEntity(), s = this.state.pos) : ni(n) ? (i += this.input.slice(s, this.state.pos), i += this.jsxReadNewLine(!1), s = this.state.pos) : ++this.state.pos;
  }
  i += this.input.slice(s, this.state.pos++), this.finishToken(133, i);
}
jsxReadEntity() {
  const r = ++this.state.pos;
  if (this.codePointAtPos(this.state.pos) === 35) {
    ++this.state.pos;
    let i = 10;
    this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
    const s = this.readInt(i, void 0, !1, "bail");
    if (s !== null && this.codePointAtPos(this.state.pos) === 59)
      return ++this.state.pos, String.fromCodePoint(s);
  } else {
    let i = 0, s = !1;
    for (; i++ < 10 && this.state.pos < this.length && !(s = this.codePointAtPos(this.state.pos) === 59); )
      ++this.state.pos;
    if (s) {
      const n = this.input.slice(r, this.state.pos), a = H5[n];
      if (++this.state.pos, a)
        return a;
    }
  }
  return this.state.pos = r, "&";
}
jsxReadWord() {
  let r;
  const i = this.state.pos;
  do
    r = this.input.charCodeAt(++this.state.pos);
  while (Or(r) || r === 45);
  this.finishToken(140, this.input.slice(i, this.state.pos));
}
jsxParseIdentifier() {
  const r = this.startNode();
  return this.match(140) ? r.name = this.state.value : Ya(this.state.type) ? r.name = or(this.state.type) : this.unexpected(), this.next(), this.finishNode(r, "JSXIdentifier");
}
jsxParseNamespacedName() {
  const r = this.state.startLoc, i = this.jsxParseIdentifier();
  if (!this.eat(14)) return i;
  const s = this.startNodeAt(r);
  return s.namespace = i, s.name = this.jsxParseIdentifier(), this.finishNode(s, "JSXNamespacedName");
}
jsxParseElementName() {
  const r = this.state.startLoc;
  let i = this.jsxParseNamespacedName();
  if (i.type === "JSXNamespacedName")
    return i;
  for (; this.eat(16); ) {
    const s = this.startNodeAt(r);
    s.object = i, s.property = this.jsxParseIdentifier(), i = this.finishNode(s, "JSXMemberExpression");
  }
  return i;
}
jsxParseAttributeValue() {
  let r;
  switch (this.state.type) {
    case 5:
      return r = this.startNode(), this.setContext($e.brace), this.next(), r = this.jsxParseExpressionContainer(r, $e.j_oTag), r.expression.type === "JSXEmptyExpression" && this.raise(pr.AttributeIsEmpty, r), r;
    case 142:
    case 133:
      return this.parseExprAtom();
    default:
      throw this.raise(pr.UnsupportedJsxValue, this.state.startLoc);
  }
}
jsxParseEmptyExpression() {
  const r = this.startNodeAt(this.state.lastTokEndLoc);
  return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
}
jsxParseSpreadChild(r) {
  return this.next(), r.expression = this.parseExpression(), this.setContext($e.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadChild");
}
jsxParseExpressionContainer(r, i) {
  if (this.match(8))
    r.expression = this.jsxParseEmptyExpression();
  else {
    const s = this.parseExpression();
    r.expression = s;
  }
  return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
}
jsxParseAttribute() {
  const r = this.startNode();
  return this.match(5) ? (this.setContext($e.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext($e.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(), r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
}
jsxParseOpeningElementAt(r) {
  const i = this.startNodeAt(r);
  return this.eat(143) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(i));
}
jsxParseOpeningElementAfterName(r) {
  const i = [];
  for (; !this.match(56) && !this.match(143); )
    i.push(this.jsxParseAttribute());
  return r.attributes = i, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
}
jsxParseClosingElementAt(r) {
  const i = this.startNodeAt(r);
  return this.eat(143) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(143), this.finishNode(i, "JSXClosingElement"));
}
jsxParseElementAt(r) {
  const i = this.startNodeAt(r), s = [], n = this.jsxParseOpeningElementAt(r);
  let a = null;
  if (!n.selfClosing) {
    e: for (; ; )
      switch (this.state.type) {
        case 142:
          if (r = this.state.startLoc, this.next(), this.eat(56)) {
            a = this.jsxParseClosingElementAt(r);
            break e;
          }
          s.push(this.jsxParseElementAt(r));
          break;
        case 141:
          s.push(this.parseLiteral(this.state.value, "JSXText"));
          break;
        case 5: {
          const o = this.startNode();
          this.setContext($e.brace), this.next(), this.match(21) ? s.push(this.jsxParseSpreadChild(o)) : s.push(this.jsxParseExpressionContainer(o, $e.j_expr));
          break;
        }
        default:
          this.unexpected();
      }
    rr(n) && !rr(a) && a !== null ? this.raise(pr.MissingClosingTagFragment, a) : !rr(n) && rr(a) ? this.raise(pr.MissingClosingTagElement, a, {
      openingTagName: Nr(n.name)
    }) : !rr(n) && !rr(a) && Nr(a.name) !== Nr(n.name) && this.raise(pr.MissingClosingTagElement, a, {
      openingTagName: Nr(n.name)
    });
  }
  if (rr(n) ? (i.openingFragment = n, i.closingFragment = a) : (i.openingElement = n, i.closingElement = a), i.children = s, this.match(47))
    throw this.raise(pr.UnwrappedAdjacentJSXElements, this.state.startLoc);
  return rr(n) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
}
jsxParseElement() {
  const r = this.state.startLoc;
  return this.next(), this.jsxParseElementAt(r);
}
setContext(r) {
  const {
    context: i
  } = this.state;
  i[i.length - 1] = r;
}
parseExprAtom(r) {
  return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(r);
}
skipSpace() {
  this.curContext().preserveSpace || super.skipSpace();
}
getTokenFromCode(r) {
  const i = this.curContext();
  if (i === $e.j_expr) {
    this.jsxReadToken();
    return;
  }
  if (i === $e.j_oTag || i === $e.j_cTag) {
    if (Xt(r)) {
      this.jsxReadWord();
      return;
    }
    if (r === 62) {
      ++this.state.pos, this.finishToken(143);
      return;
    }
    if ((r === 34 || r === 39) && i === $e.j_oTag) {
      this.jsxReadString(r);
      return;
    }
  }
  if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
    ++this.state.pos, this.finishToken(142);
    return;
  }
  super.getTokenFromCode(r);
}
updateContext(r) {
  const {
    context: i,
    type: s
  } = this.state;
  if (s === 56 && r === 142)
    i.splice(-2, 2, $e.j_cTag), this.state.canStartJSXElement = !1;
  else if (s === 142)
    i.push($e.j_oTag);
  else if (s === 143) {
    const n = i[i.length - 1];
    n === $e.j_oTag && r === 56 || n === $e.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === $e.j_expr) : (this.setContext($e.j_expr), this.state.canStartJSXElement = !0);
  } else
    this.state.canStartJSXElement = r5(s);
}
};
class z5 extends Ga {
constructor(...t) {
  super(...t), this.tsNames = /* @__PURE__ */ new Map();
}
}
class Q5 extends za {
constructor(...t) {
  super(...t), this.importsStack = [];
}
createScope(t) {
  return this.importsStack.push(/* @__PURE__ */ new Set()), new z5(t);
}
enter(t) {
  t === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
}
exit() {
  const t = super.exit();
  return t === 256 && this.importsStack.pop(), t;
}
hasImport(t, r) {
  const i = this.importsStack.length;
  if (this.importsStack[i - 1].has(t))
    return !0;
  if (!r && i > 1) {
    for (let s = 0; s < i - 1; s++)
      if (this.importsStack[s].has(t)) return !0;
  }
  return !1;
}
declareName(t, r, i) {
  if (r & 4096) {
    this.hasImport(t, !0) && this.parser.raise(w.VarRedeclaration, i, {
      identifierName: t
    }), this.importsStack[this.importsStack.length - 1].add(t);
    return;
  }
  const s = this.currentScope();
  let n = s.tsNames.get(t) || 0;
  if (r & 1024) {
    this.maybeExportDefined(s, t), s.tsNames.set(t, n | 16);
    return;
  }
  super.declareName(t, r, i), r & 2 && (r & 1 || (this.checkRedeclarationInScope(s, t, r, i), this.maybeExportDefined(s, t)), n = n | 1), r & 256 && (n = n | 2), r & 512 && (n = n | 4), r & 128 && (n = n | 8), n && s.tsNames.set(t, n);
}
isRedeclaredInScope(t, r, i) {
  const s = t.tsNames.get(r);
  if ((s & 2) > 0) {
    if (i & 256) {
      const n = !!(i & 512), a = (s & 4) > 0;
      return n !== a;
    }
    return !0;
  }
  return i & 128 && (s & 8) > 0 ? t.names.get(r) & 2 ? !!(i & 1) : !1 : i & 2 && (s & 1) > 0 ? !0 : super.isRedeclaredInScope(t, r, i);
}
checkLocalExport(t) {
  const {
    name: r
  } = t;
  if (this.hasImport(r)) return;
  const i = this.scopeStack.length;
  for (let s = i - 1; s >= 0; s--) {
    const a = this.scopeStack[s].tsNames.get(r);
    if ((a & 1) > 0 || (a & 16) > 0)
      return;
  }
  super.checkLocalExport(t);
}
}
const Z5 = (e, t) => hasOwnProperty.call(e, t) && e[t], Cf = (e) => e.type === "ParenthesizedExpression" ? Cf(e.expression) : e;
class e_ extends q5 {
toAssignable(t, r = !1) {
  var i, s;
  let n;
  switch ((t.type === "ParenthesizedExpression" || (i = t.extra) != null && i.parenthesized) && (n = Cf(t), r ? n.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(w.InvalidParenthesizedAssignment, t) : n.type !== "MemberExpression" && !this.isOptionalMemberExpression(n) && this.raise(w.InvalidParenthesizedAssignment, t) : this.raise(w.InvalidParenthesizedAssignment, t)), t.type) {
    case "Identifier":
    case "ObjectPattern":
    case "ArrayPattern":
    case "AssignmentPattern":
    case "RestElement":
      break;
    case "ObjectExpression":
      t.type = "ObjectPattern";
      for (let o = 0, u = t.properties.length, l = u - 1; o < u; o++) {
        var a;
        const c = t.properties[o], f = o === l;
        this.toAssignableObjectExpressionProp(c, f, r), f && c.type === "RestElement" && (a = t.extra) != null && a.trailingCommaLoc && this.raise(w.RestTrailingComma, t.extra.trailingCommaLoc);
      }
      break;
    case "ObjectProperty": {
      const {
        key: o,
        value: u
      } = t;
      this.isPrivateName(o) && this.classScope.usePrivateName(this.getPrivateNameSV(o), o.loc.start), this.toAssignable(u, r);
      break;
    }
    case "SpreadElement":
      throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
    case "ArrayExpression":
      t.type = "ArrayPattern", this.toAssignableList(t.elements, (s = t.extra) == null ? void 0 : s.trailingCommaLoc, r);
      break;
    case "AssignmentExpression":
      t.operator !== "=" && this.raise(w.MissingEqInAssignment, t.left.loc.end), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, r);
      break;
    case "ParenthesizedExpression":
      this.toAssignable(n, r);
      break;
  }
}
toAssignableObjectExpressionProp(t, r, i) {
  if (t.type === "ObjectMethod")
    this.raise(t.kind === "get" || t.kind === "set" ? w.PatternHasAccessor : w.PatternHasMethod, t.key);
  else if (t.type === "SpreadElement") {
    t.type = "RestElement";
    const s = t.argument;
    this.checkToRestConversion(s, !1), this.toAssignable(s, i), r || this.raise(w.RestTrailingComma, t);
  } else
    this.toAssignable(t, i);
}
toAssignableList(t, r, i) {
  const s = t.length - 1;
  for (let n = 0; n <= s; n++) {
    const a = t[n];
    if (a) {
      if (a.type === "SpreadElement") {
        a.type = "RestElement";
        const o = a.argument;
        this.checkToRestConversion(o, !0), this.toAssignable(o, i);
      } else
        this.toAssignable(a, i);
      a.type === "RestElement" && (n < s ? this.raise(w.RestTrailingComma, a) : r && this.raise(w.RestTrailingComma, r));
    }
  }
}
isAssignable(t, r) {
  switch (t.type) {
    case "Identifier":
    case "ObjectPattern":
    case "ArrayPattern":
    case "AssignmentPattern":
    case "RestElement":
      return !0;
    case "ObjectExpression": {
      const i = t.properties.length - 1;
      return t.properties.every((s, n) => s.type !== "ObjectMethod" && (n === i || s.type !== "SpreadElement") && this.isAssignable(s));
    }
    case "ObjectProperty":
      return this.isAssignable(t.value);
    case "SpreadElement":
      return this.isAssignable(t.argument);
    case "ArrayExpression":
      return t.elements.every((i) => i === null || this.isAssignable(i));
    case "AssignmentExpression":
      return t.operator === "=";
    case "ParenthesizedExpression":
      return this.isAssignable(t.expression);
    case "MemberExpression":
    case "OptionalMemberExpression":
      return !r;
    default:
      return !1;
  }
}
toReferencedList(t, r) {
  return t;
}
toReferencedListDeep(t, r) {
  this.toReferencedList(t, r);
  for (const i of t)
    (i == null ? void 0 : i.type) === "ArrayExpression" && this.toReferencedListDeep(i.elements);
}
parseSpread(t) {
  const r = this.startNode();
  return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
}
parseRestBinding() {
  const t = this.startNode();
  return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
}
parseBindingAtom() {
  switch (this.state.type) {
    case 0: {
      const t = this.startNode();
      return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
    }
    case 5:
      return this.parseObjectLike(8, !0);
  }
  return this.parseIdentifier();
}
parseBindingList(t, r, i) {
  const s = i & 1, n = [];
  let a = !0;
  for (; !this.eat(t); )
    if (a ? a = !1 : this.expect(12), s && this.match(12))
      n.push(null);
    else {
      if (this.eat(t))
        break;
      if (this.match(21)) {
        if (n.push(this.parseAssignableListItemTypes(this.parseRestBinding(), i)), !this.checkCommaAfterRest(r)) {
          this.expect(t);
          break;
        }
      } else {
        const o = [];
        for (this.match(26) && this.hasPlugin("decorators") && this.raise(w.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
          o.push(this.parseDecorator());
        n.push(this.parseAssignableListItem(i, o));
      }
    }
  return n;
}
parseBindingRestProperty(t) {
  return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
}
parseBindingProperty() {
  const {
    type: t,
    startLoc: r
  } = this.state;
  if (t === 21)
    return this.parseBindingRestProperty(this.startNode());
  const i = this.startNode();
  return t === 138 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), i.key = this.parsePrivateName()) : this.parsePropertyName(i), i.method = !1, this.parseObjPropValue(i, r, !1, !1, !0, !1);
}
parseAssignableListItem(t, r) {
  const i = this.parseMaybeDefault();
  this.parseAssignableListItemTypes(i, t);
  const s = this.parseMaybeDefault(i.loc.start, i);
  return r.length && (i.decorators = r), s;
}
parseAssignableListItemTypes(t, r) {
  return t;
}
parseMaybeDefault(t, r) {
  var i, s;
  if ((i = t) != null || (t = this.state.startLoc), r = (s = r) != null ? s : this.parseBindingAtom(), !this.eat(29)) return r;
  const n = this.startNodeAt(t);
  return n.left = r, n.right = this.parseMaybeAssignAllowIn(), this.finishNode(n, "AssignmentPattern");
}
isValidLVal(t, r, i) {
  return Z5({
    AssignmentPattern: "left",
    RestElement: "argument",
    ObjectProperty: "value",
    ParenthesizedExpression: "expression",
    ArrayPattern: "elements",
    ObjectPattern: "properties"
  }, t);
}
isOptionalMemberExpression(t) {
  return t.type === "OptionalMemberExpression";
}
checkLVal(t, {
  in: r,
  binding: i = 64,
  checkClashes: s = !1,
  strictModeChanged: n = !1,
  hasParenthesizedAncestor: a = !1
}) {
  var o;
  const u = t.type;
  if (this.isObjectMethod(t)) return;
  const l = this.isOptionalMemberExpression(t);
  if (l || u === "MemberExpression") {
    l && (this.expectPlugin("optionalChainingAssign", t.loc.start), r.type !== "AssignmentExpression" && this.raise(w.InvalidLhsOptionalChaining, t, {
      ancestor: r
    })), i !== 64 && this.raise(w.InvalidPropertyBindingPattern, t);
    return;
  }
  if (u === "Identifier") {
    this.checkIdentifier(t, i, n);
    const {
      name: y
    } = t;
    s && (s.has(y) ? this.raise(w.ParamDupe, t) : s.add(y));
    return;
  }
  const c = this.isValidLVal(u, !(a || (o = t.extra) != null && o.parenthesized) && r.type === "AssignmentExpression", i);
  if (c === !0) return;
  if (c === !1) {
    const y = i === 64 ? w.InvalidLhs : w.InvalidLhsBinding;
    this.raise(y, t, {
      ancestor: r
    });
    return;
  }
  const [f, p] = Array.isArray(c) ? c : [c, u === "ParenthesizedExpression"], h = u === "ArrayPattern" || u === "ObjectPattern" ? {
    type: u
  } : r;
  for (const y of [].concat(t[f]))
    y && this.checkLVal(y, {
      in: h,
      binding: i,
      checkClashes: s,
      strictModeChanged: n,
      hasParenthesizedAncestor: p
    });
}
checkIdentifier(t, r, i = !1) {
  this.state.strict && (i ? Sf(t.name, this.inModule) : gf(t.name)) && (r === 64 ? this.raise(w.StrictEvalArguments, t, {
    referenceName: t.name
  }) : this.raise(w.StrictEvalArgumentsBinding, t, {
    bindingName: t.name
  })), r & 8192 && t.name === "let" && this.raise(w.LetInLexicalBinding, t), r & 64 || this.declareNameFromIdentifier(t, r);
}
declareNameFromIdentifier(t, r) {
  this.scope.declareName(t.name, r, t.loc.start);
}
checkToRestConversion(t, r) {
  switch (t.type) {
    case "ParenthesizedExpression":
      this.checkToRestConversion(t.expression, r);
      break;
    case "Identifier":
    case "MemberExpression":
      break;
    case "ArrayExpression":
    case "ObjectExpression":
      if (r) break;
    default:
      this.raise(w.InvalidRestAssignmentPattern, t);
  }
}
checkCommaAfterRest(t) {
  return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? w.RestTrailingComma : w.ElementAfterRest, this.state.startLoc), !0) : !1;
}
}
const t_ = (e, t) => hasOwnProperty.call(e, t) && e[t];
function r_(e) {
if (e == null)
  throw new Error(`Unexpected ${e} value.`);
return e;
}
function pl(e) {
if (!e)
  throw new Error("Assert fail");
}
const le = Ht`typescript`({
AbstractMethodHasImplementation: ({
  methodName: e
}) => `Method '${e}' cannot have an implementation because it is marked abstract.`,
AbstractPropertyHasInitializer: ({
  propertyName: e
}) => `Property '${e}' cannot have an initializer because it is marked abstract.`,
AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
DeclareAccessor: ({
  kind: e
}) => `'declare' is not allowed in ${e}ters.`,
DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
DuplicateAccessibilityModifier: ({
  modifier: e
}) => "Accessibility modifier already seen.",
DuplicateModifier: ({
  modifier: e
}) => `Duplicate modifier: '${e}'.`,
EmptyHeritageClauseType: ({
  token: e
}) => `'${e}' list cannot be empty.`,
EmptyTypeArguments: "Type argument list cannot be empty.",
EmptyTypeParameters: "Type parameter list cannot be empty.",
ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
ImportAliasHasImportType: "An import alias can not use 'import type'.",
ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
IncompatibleModifiers: ({
  modifiers: e
}) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`,
IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
IndexSignatureHasAccessibility: ({
  modifier: e
}) => `Index signatures cannot have an accessibility modifier ('${e}').`,
IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
InvalidModifierOnTypeMember: ({
  modifier: e
}) => `'${e}' modifier cannot appear on a type member.`,
InvalidModifierOnTypeParameter: ({
  modifier: e
}) => `'${e}' modifier cannot appear on a type parameter.`,
InvalidModifierOnTypeParameterPositions: ({
  modifier: e
}) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`,
InvalidModifiersOrder: ({
  orderedModifiers: e
}) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`,
InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
PrivateElementHasAccessibility: ({
  modifier: e
}) => `Private elements cannot have an accessibility modifier ('${e}').`,
ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
SingleTypeParameterWithoutTrailingComma: ({
  typeParameterName: e
}) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`,
StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
UnsupportedSignatureParameterKind: ({
  type: e
}) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`
});
function i_(e) {
switch (e) {
  case "any":
    return "TSAnyKeyword";
  case "boolean":
    return "TSBooleanKeyword";
  case "bigint":
    return "TSBigIntKeyword";
  case "never":
    return "TSNeverKeyword";
  case "number":
    return "TSNumberKeyword";
  case "object":
    return "TSObjectKeyword";
  case "string":
    return "TSStringKeyword";
  case "symbol":
    return "TSSymbolKeyword";
  case "undefined":
    return "TSUndefinedKeyword";
  case "unknown":
    return "TSUnknownKeyword";
  default:
    return;
}
}
function hl(e) {
return e === "private" || e === "public" || e === "protected";
}
function s_(e) {
return e === "in" || e === "out";
}
var n_ = (e) => class extends e {
constructor(...r) {
  super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
    allowedModifiers: ["in", "out"],
    disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
    errorTemplate: le.InvalidModifierOnTypeParameter
  }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
    allowedModifiers: ["const"],
    disallowedModifiers: ["in", "out"],
    errorTemplate: le.InvalidModifierOnTypeParameterPositions
  }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
    allowedModifiers: ["in", "out", "const"],
    disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
    errorTemplate: le.InvalidModifierOnTypeParameter
  });
}
getScopeHandler() {
  return Q5;
}
tsIsIdentifier() {
  return Be(this.state.type);
}
tsTokenCanFollowModifier() {
  return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
}
tsNextTokenCanFollowModifier() {
  return this.next(), this.tsTokenCanFollowModifier();
}
tsParseModifier(r, i) {
  if (!Be(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
    return;
  const s = this.state.value;
  if (r.includes(s)) {
    if (i && this.tsIsStartOfStaticBlocks())
      return;
    if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
      return s;
  }
}
tsParseModifiers({
  allowedModifiers: r,
  disallowedModifiers: i,
  stopOnStartOfClassStaticBlock: s,
  errorTemplate: n = le.InvalidModifierOnTypeMember
}, a) {
  const o = (l, c, f, p) => {
    c === f && a[p] && this.raise(le.InvalidModifiersOrder, l, {
      orderedModifiers: [f, p]
    });
  }, u = (l, c, f, p) => {
    (a[f] && c === p || a[p] && c === f) && this.raise(le.IncompatibleModifiers, l, {
      modifiers: [f, p]
    });
  };
  for (; ; ) {
    const {
      startLoc: l
    } = this.state, c = this.tsParseModifier(r.concat(i ?? []), s);
    if (!c) break;
    hl(c) ? a.accessibility ? this.raise(le.DuplicateAccessibilityModifier, l, {
      modifier: c
    }) : (o(l, c, c, "override"), o(l, c, c, "static"), o(l, c, c, "readonly"), a.accessibility = c) : s_(c) ? (a[c] && this.raise(le.DuplicateModifier, l, {
      modifier: c
    }), a[c] = !0, o(l, c, "in", "out")) : (hasOwnProperty.call(a, c) ? this.raise(le.DuplicateModifier, l, {
      modifier: c
    }) : (o(l, c, "static", "readonly"), o(l, c, "static", "override"), o(l, c, "override", "readonly"), o(l, c, "abstract", "override"), u(l, c, "declare", "override"), u(l, c, "static", "abstract")), a[c] = !0), i != null && i.includes(c) && this.raise(n, l, {
      modifier: c
    });
  }
}
tsIsListTerminator(r) {
  switch (r) {
    case "EnumMembers":
    case "TypeMembers":
      return this.match(8);
    case "HeritageClauseElement":
      return this.match(5);
    case "TupleElementTypes":
      return this.match(3);
    case "TypeParametersOrArguments":
      return this.match(48);
  }
}
tsParseList(r, i) {
  const s = [];
  for (; !this.tsIsListTerminator(r); )
    s.push(i());
  return s;
}
tsParseDelimitedList(r, i, s) {
  return r_(this.tsParseDelimitedListWorker(r, i, !0, s));
}
tsParseDelimitedListWorker(r, i, s, n) {
  const a = [];
  let o = -1;
  for (; !this.tsIsListTerminator(r); ) {
    o = -1;
    const u = i();
    if (u == null)
      return;
    if (a.push(u), this.eat(12)) {
      o = this.state.lastTokStartLoc.index;
      continue;
    }
    if (this.tsIsListTerminator(r))
      break;
    s && this.expect(12);
    return;
  }
  return n && (n.value = o), a;
}
tsParseBracketedList(r, i, s, n, a) {
  n || (s ? this.expect(0) : this.expect(47));
  const o = this.tsParseDelimitedList(r, i, a);
  return s ? this.expect(3) : this.expect(48), o;
}
tsParseImportType() {
  const r = this.startNode();
  return this.expect(83), this.expect(10), this.match(133) || this.raise(le.UnsupportedImportTypeArgument, this.state.startLoc), r.argument = super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSImportType");
}
tsParseEntityName(r = !0) {
  let i = this.parseIdentifier(r);
  for (; this.eat(16); ) {
    const s = this.startNodeAtNode(i);
    s.left = i, s.right = this.parseIdentifier(r), i = this.finishNode(s, "TSQualifiedName");
  }
  return i;
}
tsParseTypeReference() {
  const r = this.startNode();
  return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeReference");
}
tsParseThisTypePredicate(r) {
  this.next();
  const i = this.startNodeAtNode(r);
  return i.parameterName = r, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
}
tsParseThisTypeNode() {
  const r = this.startNode();
  return this.next(), this.finishNode(r, "TSThisType");
}
tsParseTypeQuery() {
  const r = this.startNode();
  return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
}
tsParseTypeParameter(r) {
  const i = this.startNode();
  return r(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(29), this.finishNode(i, "TSTypeParameter");
}
tsTryParseTypeParameters(r) {
  if (this.match(47))
    return this.tsParseTypeParameters(r);
}
tsParseTypeParameters(r) {
  const i = this.startNode();
  this.match(47) || this.match(142) ? this.next() : this.unexpected();
  const s = {
    value: -1
  };
  return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, s), i.params.length === 0 && this.raise(le.EmptyTypeParameters, i), s.value !== -1 && this.addExtra(i, "trailingComma", s.value), this.finishNode(i, "TSTypeParameterDeclaration");
}
tsFillSignature(r, i) {
  const s = r === 19, n = "parameters", a = "typeAnnotation";
  i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[n] = this.tsParseBindingListForSignature(), s ? i[a] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (i[a] = this.tsParseTypeOrTypePredicateAnnotation(r));
}
tsParseBindingListForSignature() {
  const r = super.parseBindingList(11, 41, 2);
  for (const i of r) {
    const {
      type: s
    } = i;
    (s === "AssignmentPattern" || s === "TSParameterProperty") && this.raise(le.UnsupportedSignatureParameterKind, i, {
      type: s
    });
  }
  return r;
}
tsParseTypeMemberSemicolon() {
  !this.eat(12) && !this.isLineTerminator() && this.expect(13);
}
tsParseSignatureMember(r, i) {
  return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, r);
}
tsIsUnambiguouslyIndexSignature() {
  return this.next(), Be(this.state.type) ? (this.next(), this.match(14)) : !1;
}
tsTryParseIndexSignature(r) {
  if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
    return;
  this.expect(0);
  const i = this.parseIdentifier();
  i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), r.parameters = [i];
  const s = this.tsTryParseTypeAnnotation();
  return s && (r.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
}
tsParsePropertyOrMethodSignature(r, i) {
  this.eat(17) && (r.optional = !0);
  const s = r;
  if (this.match(10) || this.match(47)) {
    i && this.raise(le.ReadonlyForMethodSignature, r);
    const n = s;
    n.kind && this.match(47) && this.raise(le.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, n), this.tsParseTypeMemberSemicolon();
    const a = "parameters", o = "typeAnnotation";
    if (n.kind === "get")
      n[a].length > 0 && (this.raise(w.BadGetterArity, this.state.curPosition()), this.isThisParam(n[a][0]) && this.raise(le.AccesorCannotDeclareThisParameter, this.state.curPosition()));
    else if (n.kind === "set") {
      if (n[a].length !== 1)
        this.raise(w.BadSetterArity, this.state.curPosition());
      else {
        const u = n[a][0];
        this.isThisParam(u) && this.raise(le.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.optional && this.raise(le.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(le.SetAccesorCannotHaveRestParameter, this.state.curPosition());
      }
      n[o] && this.raise(le.SetAccesorCannotHaveReturnType, n[o]);
    } else
      n.kind = "method";
    return this.finishNode(n, "TSMethodSignature");
  } else {
    const n = s;
    i && (n.readonly = !0);
    const a = this.tsTryParseTypeAnnotation();
    return a && (n.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(n, "TSPropertySignature");
  }
}
tsParseTypeMember() {
  const r = this.startNode();
  if (this.match(10) || this.match(47))
    return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
  if (this.match(77)) {
    const s = this.startNode();
    return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.createIdentifier(s, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
  }
  this.tsParseModifiers({
    allowedModifiers: ["readonly"],
    disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
  }, r);
  const i = this.tsTryParseIndexSignature(r);
  return i || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") && this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
}
tsParseTypeLiteral() {
  const r = this.startNode();
  return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
}
tsParseObjectTypeMembers() {
  this.expect(5);
  const r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
  return this.expect(8), r;
}
tsIsStartOfMappedType() {
  return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
}
tsParseMappedTypeParameter() {
  const r = this.startNode();
  return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
}
tsParseMappedType() {
  const r = this.startNode();
  return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
}
tsParseTupleType() {
  const r = this.startNode();
  r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
  let i = !1;
  return r.elementTypes.forEach((s) => {
    const {
      type: n
    } = s;
    i && n !== "TSRestType" && n !== "TSOptionalType" && !(n === "TSNamedTupleMember" && s.optional) && this.raise(le.OptionalTypeBeforeRequired, s), i || (i = n === "TSNamedTupleMember" && s.optional || n === "TSOptionalType");
  }), this.finishNode(r, "TSTupleType");
}
tsParseTupleElementType() {
  const {
    startLoc: r
  } = this.state, i = this.eat(21);
  let s, n, a, o;
  const l = _t(this.state.type) ? this.lookaheadCharCode() : null;
  if (l === 58)
    s = !0, a = !1, n = this.parseIdentifier(!0), this.expect(14), o = this.tsParseType();
  else if (l === 63) {
    a = !0;
    const c = this.state.startLoc, f = this.state.value, p = this.tsParseNonArrayType();
    this.lookaheadCharCode() === 58 ? (s = !0, n = this.createIdentifier(this.startNodeAt(c), f), this.expect(17), this.expect(14), o = this.tsParseType()) : (s = !1, o = p, this.expect(17));
  } else
    o = this.tsParseType(), a = this.eat(17), s = this.eat(14);
  if (s) {
    let c;
    n ? (c = this.startNodeAtNode(n), c.optional = a, c.label = n, c.elementType = o, this.eat(17) && (c.optional = !0, this.raise(le.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (c = this.startNodeAtNode(o), c.optional = a, this.raise(le.InvalidTupleMemberLabel, o), c.label = o, c.elementType = this.tsParseType()), o = this.finishNode(c, "TSNamedTupleMember");
  } else if (a) {
    const c = this.startNodeAtNode(o);
    c.typeAnnotation = o, o = this.finishNode(c, "TSOptionalType");
  }
  if (i) {
    const c = this.startNodeAt(r);
    c.typeAnnotation = o, o = this.finishNode(c, "TSRestType");
  }
  return o;
}
tsParseParenthesizedType() {
  const r = this.startNode();
  return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
}
tsParseFunctionOrConstructorType(r, i) {
  const s = this.startNode();
  return r === "TSConstructorType" && (s.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, s)), this.finishNode(s, r);
}
tsParseLiteralTypeNode() {
  const r = this.startNode();
  switch (this.state.type) {
    case 134:
    case 135:
    case 133:
    case 85:
    case 86:
      r.literal = super.parseExprAtom();
      break;
    default:
      this.unexpected();
  }
  return this.finishNode(r, "TSLiteralType");
}
tsParseTemplateLiteralType() {
  const r = this.startNode();
  return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
}
parseTemplateSubstitution() {
  return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
}
tsParseThisTypeOrThisTypePredicate() {
  const r = this.tsParseThisTypeNode();
  return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
}
tsParseNonArrayType() {
  switch (this.state.type) {
    case 133:
    case 134:
    case 135:
    case 85:
    case 86:
      return this.tsParseLiteralTypeNode();
    case 53:
      if (this.state.value === "-") {
        const r = this.startNode(), i = this.lookahead();
        return i.type !== 134 && i.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralType");
      }
      break;
    case 78:
      return this.tsParseThisTypeOrThisTypePredicate();
    case 87:
      return this.tsParseTypeQuery();
    case 83:
      return this.tsParseImportType();
    case 5:
      return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
    case 0:
      return this.tsParseTupleType();
    case 10:
      return this.tsParseParenthesizedType();
    case 25:
    case 24:
      return this.tsParseTemplateLiteralType();
    default: {
      const {
        type: r
      } = this.state;
      if (Be(r) || r === 88 || r === 84) {
        const i = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : i_(this.state.value);
        if (i !== void 0 && this.lookaheadCharCode() !== 46) {
          const s = this.startNode();
          return this.next(), this.finishNode(s, i);
        }
        return this.tsParseTypeReference();
      }
    }
  }
  this.unexpected();
}
tsParseArrayTypeOrHigher() {
  let r = this.tsParseNonArrayType();
  for (; !this.hasPrecedingLineBreak() && this.eat(0); )
    if (this.match(3)) {
      const i = this.startNodeAtNode(r);
      i.elementType = r, this.expect(3), r = this.finishNode(i, "TSArrayType");
    } else {
      const i = this.startNodeAtNode(r);
      i.objectType = r, i.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(i, "TSIndexedAccessType");
    }
  return r;
}
tsParseTypeOperator() {
  const r = this.startNode(), i = this.state.value;
  return this.next(), r.operator = i, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(r), this.finishNode(r, "TSTypeOperator");
}
tsCheckTypeAnnotationForReadOnly(r) {
  switch (r.typeAnnotation.type) {
    case "TSTupleType":
    case "TSArrayType":
      return;
    default:
      this.raise(le.UnexpectedReadonly, r);
  }
}
tsParseInferType() {
  const r = this.startNode();
  this.expectContextual(115);
  const i = this.startNode();
  return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter = this.finishNode(i, "TSTypeParameter"), this.finishNode(r, "TSInferType");
}
tsParseConstraintForInferType() {
  if (this.eat(81)) {
    const r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
    if (this.state.inDisallowConditionalTypesContext || !this.match(17))
      return r;
  }
}
tsParseTypeOperatorOrHigher() {
  return u5(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
}
tsParseUnionOrIntersectionType(r, i, s) {
  const n = this.startNode(), a = this.eat(s), o = [];
  do
    o.push(i());
  while (this.eat(s));
  return o.length === 1 && !a ? o[0] : (n.types = o, this.finishNode(n, r));
}
tsParseIntersectionTypeOrHigher() {
  return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
}
tsParseUnionTypeOrHigher() {
  return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
}
tsIsStartOfFunctionType() {
  return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
}
tsSkipParameterStart() {
  if (Be(this.state.type) || this.match(78))
    return this.next(), !0;
  if (this.match(5)) {
    const {
      errors: r
    } = this.state, i = r.length;
    try {
      return this.parseObjectLike(8, !0), r.length === i;
    } catch {
      return !1;
    }
  }
  if (this.match(0)) {
    this.next();
    const {
      errors: r
    } = this.state, i = r.length;
    try {
      return super.parseBindingList(3, 93, 1), r.length === i;
    } catch {
      return !1;
    }
  }
  return !1;
}
tsIsUnambiguouslyStartOfFunctionType() {
  return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
}
tsParseTypeOrTypePredicateAnnotation(r) {
  return this.tsInType(() => {
    const i = this.startNode();
    this.expect(r);
    const s = this.startNode(), n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
    if (n && this.match(78)) {
      let u = this.tsParseThisTypeOrThisTypePredicate();
      return u.type === "TSThisType" ? (s.parameterName = u, s.asserts = !0, s.typeAnnotation = null, u = this.finishNode(s, "TSTypePredicate")) : (this.resetStartLocationFromNode(u, s), u.asserts = !0), i.typeAnnotation = u, this.finishNode(i, "TSTypeAnnotation");
    }
    const a = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
    if (!a)
      return n ? (s.parameterName = this.parseIdentifier(), s.asserts = n, s.typeAnnotation = null, i.typeAnnotation = this.finishNode(s, "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
    const o = this.tsParseTypeAnnotation(!1);
    return s.parameterName = a, s.typeAnnotation = o, s.asserts = n, i.typeAnnotation = this.finishNode(s, "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation");
  });
}
tsTryParseTypeOrTypePredicateAnnotation() {
  if (this.match(14))
    return this.tsParseTypeOrTypePredicateAnnotation(14);
}
tsTryParseTypeAnnotation() {
  if (this.match(14))
    return this.tsParseTypeAnnotation();
}
tsTryParseType() {
  return this.tsEatThenParseType(14);
}
tsParseTypePredicatePrefix() {
  const r = this.parseIdentifier();
  if (this.isContextual(116) && !this.hasPrecedingLineBreak())
    return this.next(), r;
}
tsParseTypePredicateAsserts() {
  if (this.state.type !== 109)
    return !1;
  const r = this.state.containsEsc;
  return this.next(), !Be(this.state.type) && !this.match(78) ? !1 : (r && this.raise(w.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
    reservedWord: "asserts"
  }), !0);
}
tsParseTypeAnnotation(r = !0, i = this.startNode()) {
  return this.tsInType(() => {
    r && this.expect(14), i.typeAnnotation = this.tsParseType();
  }), this.finishNode(i, "TSTypeAnnotation");
}
tsParseType() {
  pl(this.state.inType);
  const r = this.tsParseNonConditionalType();
  if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
    return r;
  const i = this.startNodeAtNode(r);
  return i.checkType = r, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(i, "TSConditionalType");
}
isAbstractConstructorSignature() {
  return this.isContextual(124) && this.lookahead().type === 77;
}
tsParseNonConditionalType() {
  return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
}
tsParseTypeAssertion() {
  this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(le.ReservedTypeAssertion, this.state.startLoc);
  const r = this.startNode();
  return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
}
tsParseHeritageClause(r) {
  const i = this.state.startLoc, s = this.tsParseDelimitedList("HeritageClauseElement", () => {
    const n = this.startNode();
    return n.expression = this.tsParseEntityName(), this.match(47) && (n.typeParameters = this.tsParseTypeArguments()), this.finishNode(n, "TSExpressionWithTypeArguments");
  });
  return s.length || this.raise(le.EmptyHeritageClauseType, i, {
    token: r
  }), s;
}
tsParseInterfaceDeclaration(r, i = {}) {
  if (this.hasFollowingLineBreak()) return null;
  this.expectContextual(129), i.declare && (r.declare = !0), Be(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 130)) : (r.id = null, this.raise(le.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
  const s = this.startNode();
  return s.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(s, "TSInterfaceBody"), this.finishNode(r, "TSInterfaceDeclaration");
}
tsParseTypeAliasDeclaration(r) {
  return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
    if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
      const i = this.startNode();
      return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
    }
    return this.tsParseType();
  }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
}
tsInNoContext(r) {
  const i = this.state.context;
  this.state.context = [i[0]];
  try {
    return r();
  } finally {
    this.state.context = i;
  }
}
tsInType(r) {
  const i = this.state.inType;
  this.state.inType = !0;
  try {
    return r();
  } finally {
    this.state.inType = i;
  }
}
tsInDisallowConditionalTypesContext(r) {
  const i = this.state.inDisallowConditionalTypesContext;
  this.state.inDisallowConditionalTypesContext = !0;
  try {
    return r();
  } finally {
    this.state.inDisallowConditionalTypesContext = i;
  }
}
tsInAllowConditionalTypesContext(r) {
  const i = this.state.inDisallowConditionalTypesContext;
  this.state.inDisallowConditionalTypesContext = !1;
  try {
    return r();
  } finally {
    this.state.inDisallowConditionalTypesContext = i;
  }
}
tsEatThenParseType(r) {
  if (this.match(r))
    return this.tsNextThenParseType();
}
tsExpectThenParseType(r) {
  return this.tsInType(() => (this.expect(r), this.tsParseType()));
}
tsNextThenParseType() {
  return this.tsInType(() => (this.next(), this.tsParseType()));
}
tsParseEnumMember() {
  const r = this.startNode();
  return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
}
tsParseEnumDeclaration(r, i = {}) {
  return i.const && (r.const = !0), i.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(r, "TSEnumDeclaration");
}
tsParseModuleBlock() {
  const r = this.startNode();
  return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(r, "TSModuleBlock");
}
tsParseModuleOrNamespaceDeclaration(r, i = !1) {
  if (r.id = this.parseIdentifier(), i || this.checkIdentifier(r.id, 1024), this.eat(16)) {
    const s = this.startNode();
    this.tsParseModuleOrNamespaceDeclaration(s, !0), r.body = s;
  } else
    this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
  return this.finishNode(r, "TSModuleDeclaration");
}
tsParseAmbientExternalModuleDeclaration(r) {
  return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
}
tsParseImportEqualsDeclaration(r, i, s) {
  r.isExport = s || !1, r.id = i || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
  const n = this.tsParseModuleReference();
  return r.importKind === "type" && n.type !== "TSExternalModuleReference" && this.raise(le.ImportAliasHasImportType, n), r.moduleReference = n, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
}
tsIsExternalModuleReference() {
  return this.isContextual(119) && this.lookaheadCharCode() === 40;
}
tsParseModuleReference() {
  return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
}
tsParseExternalModuleReference() {
  const r = this.startNode();
  return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
}
tsLookAhead(r) {
  const i = this.state.clone(), s = r();
  return this.state = i, s;
}
tsTryParseAndCatch(r) {
  const i = this.tryParse((s) => r() || s());
  if (!(i.aborted || !i.node))
    return i.error && (this.state = i.failState), i.node;
}
tsTryParse(r) {
  const i = this.state.clone(), s = r();
  if (s !== void 0 && s !== !1)
    return s;
  this.state = i;
}
tsTryParseDeclare(r) {
  if (this.isLineTerminator())
    return;
  let i = this.state.type, s;
  return this.isContextual(100) && (i = 74, s = "let"), this.tsInAmbientContext(() => {
    switch (i) {
      case 68:
        return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
      case 80:
        return r.declare = !0, this.parseClass(r, !0, !1);
      case 126:
        return this.tsParseEnumDeclaration(r, {
          declare: !0
        });
      case 112:
        return this.tsParseAmbientExternalModuleDeclaration(r);
      case 75:
      case 74:
        return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, s || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
          const: !0,
          declare: !0
        }));
      case 129: {
        const n = this.tsParseInterfaceDeclaration(r, {
          declare: !0
        });
        if (n) return n;
      }
      default:
        if (Be(i))
          return this.tsParseDeclaration(r, this.state.value, !0, null);
    }
  });
}
tsTryParseExportDeclaration() {
  return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
}
tsParseExpressionStatement(r, i, s) {
  switch (i.name) {
    case "declare": {
      const n = this.tsTryParseDeclare(r);
      return n && (n.declare = !0), n;
    }
    case "global":
      if (this.match(5)) {
        this.scope.enter(256), this.prodParam.enter(0);
        const n = r;
        return n.global = !0, n.id = i, n.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(n, "TSModuleDeclaration");
      }
      break;
    default:
      return this.tsParseDeclaration(r, i.name, !1, s);
  }
}
tsParseDeclaration(r, i, s, n) {
  switch (i) {
    case "abstract":
      if (this.tsCheckLineTerminator(s) && (this.match(80) || Be(this.state.type)))
        return this.tsParseAbstractDeclaration(r, n);
      break;
    case "module":
      if (this.tsCheckLineTerminator(s)) {
        if (this.match(133))
          return this.tsParseAmbientExternalModuleDeclaration(r);
        if (Be(this.state.type))
          return this.tsParseModuleOrNamespaceDeclaration(r);
      }
      break;
    case "namespace":
      if (this.tsCheckLineTerminator(s) && Be(this.state.type))
        return this.tsParseModuleOrNamespaceDeclaration(r);
      break;
    case "type":
      if (this.tsCheckLineTerminator(s) && Be(this.state.type))
        return this.tsParseTypeAliasDeclaration(r);
      break;
  }
}
tsCheckLineTerminator(r) {
  return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
}
tsTryParseGenericAsyncArrowFunction(r) {
  if (!this.match(47)) return;
  const i = this.state.maybeInArrowParameters;
  this.state.maybeInArrowParameters = !0;
  const s = this.tsTryParseAndCatch(() => {
    const n = this.startNodeAt(r);
    return n.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(n), n.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), n;
  });
  if (this.state.maybeInArrowParameters = i, !!s)
    return super.parseArrowExpression(s, null, !0);
}
tsParseTypeArgumentsInExpression() {
  if (this.reScan_lt() === 47)
    return this.tsParseTypeArguments();
}
tsParseTypeArguments() {
  const r = this.startNode();
  return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(le.EmptyTypeArguments, r) : !this.state.inType && this.curContext() === $e.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
}
tsIsDeclarationStart() {
  return l5(this.state.type);
}
isExportDefaultSpecifier() {
  return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
}
parseAssignableListItem(r, i) {
  const s = this.state.startLoc, n = {};
  this.tsParseModifiers({
    allowedModifiers: ["public", "private", "protected", "override", "readonly"]
  }, n);
  const a = n.accessibility, o = n.override, u = n.readonly;
  !(r & 4) && (a || u || o) && this.raise(le.UnexpectedParameterModifier, s);
  const l = this.parseMaybeDefault();
  this.parseAssignableListItemTypes(l, r);
  const c = this.parseMaybeDefault(l.loc.start, l);
  if (a || u || o) {
    const f = this.startNodeAt(s);
    return i.length && (f.decorators = i), a && (f.accessibility = a), u && (f.readonly = u), o && (f.override = o), c.type !== "Identifier" && c.type !== "AssignmentPattern" && this.raise(le.UnsupportedParameterPropertyKind, f), f.parameter = c, this.finishNode(f, "TSParameterProperty");
  }
  return i.length && (l.decorators = i), c;
}
isSimpleParameter(r) {
  return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
}
tsDisallowOptionalPattern(r) {
  for (const i of r.params)
    i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(le.PatternIsOptional, i);
}
setArrowFunctionParameters(r, i, s) {
  super.setArrowFunctionParameters(r, i, s), this.tsDisallowOptionalPattern(r);
}
parseFunctionBodyAndFinish(r, i, s = !1) {
  this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
  const n = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
  return n && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, n) : n === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(le.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, n, s) : (this.tsDisallowOptionalPattern(r), super.parseFunctionBodyAndFinish(r, i, s));
}
registerFunctionStatementId(r) {
  !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
}
tsCheckForInvalidTypeCasts(r) {
  r.forEach((i) => {
    (i == null ? void 0 : i.type) === "TSTypeCastExpression" && this.raise(le.UnexpectedTypeAnnotation, i.typeAnnotation);
  });
}
toReferencedList(r, i) {
  return this.tsCheckForInvalidTypeCasts(r), r;
}
parseArrayLike(r, i, s, n) {
  const a = super.parseArrayLike(r, i, s, n);
  return a.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(a.elements), a;
}
parseSubscript(r, i, s, n) {
  if (!this.hasPrecedingLineBreak() && this.match(35)) {
    this.state.canStartJSXElement = !1, this.next();
    const o = this.startNodeAt(i);
    return o.expression = r, this.finishNode(o, "TSNonNullExpression");
  }
  let a = !1;
  if (this.match(18) && this.lookaheadCharCode() === 60) {
    if (s)
      return n.stop = !0, r;
    n.optionalChainMember = a = !0, this.next();
  }
  if (this.match(47) || this.match(51)) {
    let o;
    const u = this.tsTryParseAndCatch(() => {
      if (!s && this.atPossibleAsyncArrow(r)) {
        const p = this.tsTryParseGenericAsyncArrowFunction(i);
        if (p)
          return p;
      }
      const l = this.tsParseTypeArgumentsInExpression();
      if (!l) return;
      if (a && !this.match(10)) {
        o = this.state.curPosition();
        return;
      }
      if (hs(this.state.type)) {
        const p = super.parseTaggedTemplateExpression(r, i, n);
        return p.typeParameters = l, p;
      }
      if (!s && this.eat(10)) {
        const p = this.startNodeAt(i);
        return p.callee = r, p.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(p.arguments), p.typeParameters = l, n.optionalChainMember && (p.optional = a), this.finishCallExpression(p, n.optionalChainMember);
      }
      const c = this.state.type;
      if (c === 48 || c === 52 || c !== 10 && Yn(c) && !this.hasPrecedingLineBreak())
        return;
      const f = this.startNodeAt(i);
      return f.expression = r, f.typeParameters = l, this.finishNode(f, "TSInstantiationExpression");
    });
    if (o && this.unexpected(o, 10), u)
      return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(le.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
  }
  return super.parseSubscript(r, i, s, n);
}
parseNewCallee(r) {
  var i;
  super.parseNewCallee(r);
  const {
    callee: s
  } = r;
  s.type === "TSInstantiationExpression" && !((i = s.extra) != null && i.parenthesized) && (r.typeParameters = s.typeParameters, r.callee = s.expression);
}
parseExprOp(r, i, s) {
  let n;
  if (ns(58) > s && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n = this.isContextual(120)))) {
    const a = this.startNodeAt(i);
    return a.expression = r, a.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n && this.raise(w.UnexpectedKeyword, this.state.startLoc, {
      keyword: "const"
    }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(a, n ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(a, i, s);
  }
  return super.parseExprOp(r, i, s);
}
checkReservedWord(r, i, s, n) {
  this.state.isAmbientContext || super.checkReservedWord(r, i, s, n);
}
checkImportReflection(r) {
  super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(le.ImportReflectionHasImportType, r.specifiers[0].loc.start);
}
checkDuplicateExports() {
}
isPotentialImportPhase(r) {
  if (super.isPotentialImportPhase(r)) return !0;
  if (this.isContextual(130)) {
    const i = this.lookaheadCharCode();
    return r ? i === 123 || i === 42 : i !== 61;
  }
  return !r && this.isContextual(87);
}
applyImportPhase(r, i, s, n) {
  super.applyImportPhase(r, i, s, n), i ? r.exportKind = s === "type" ? "type" : "value" : r.importKind = s === "type" || s === "typeof" ? s : "value";
}
parseImport(r) {
  if (this.match(133))
    return r.importKind = "value", super.parseImport(r);
  let i;
  if (Be(this.state.type) && this.lookaheadCharCode() === 61)
    return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
  if (this.isContextual(130)) {
    const s = this.parseMaybeImportPhase(r, !1);
    if (this.lookaheadCharCode() === 61)
      return this.tsParseImportEqualsDeclaration(r, s);
    i = super.parseImportSpecifiersAndAfter(r, s);
  } else
    i = super.parseImport(r);
  return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(le.TypeImportCannotSpecifyDefaultAndNamed, i), i;
}
parseExport(r, i) {
  if (this.match(83)) {
    this.next();
    const s = r;
    let n = null;
    return this.isContextual(130) && this.isPotentialImportPhase(!1) ? n = this.parseMaybeImportPhase(s, !1) : s.importKind = "value", this.tsParseImportEqualsDeclaration(s, n, !0);
  } else if (this.eat(29)) {
    const s = r;
    return s.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(s, "TSExportAssignment");
  } else if (this.eatContextual(93)) {
    const s = r;
    return this.expectContextual(128), s.id = this.parseIdentifier(), this.semicolon(), this.finishNode(s, "TSNamespaceExportDeclaration");
  } else
    return super.parseExport(r, i);
}
isAbstractClass() {
  return this.isContextual(124) && this.lookahead().type === 80;
}
parseExportDefaultExpression() {
  if (this.isAbstractClass()) {
    const r = this.startNode();
    return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
  }
  if (this.match(129)) {
    const r = this.tsParseInterfaceDeclaration(this.startNode());
    if (r) return r;
  }
  return super.parseExportDefaultExpression();
}
parseVarStatement(r, i, s = !1) {
  const {
    isAmbientContext: n
  } = this.state, a = super.parseVarStatement(r, i, s || n);
  if (!n) return a;
  for (const {
    id: o,
    init: u
  } of a.declarations)
    u && (i !== "const" || o.typeAnnotation ? this.raise(le.InitializerNotAllowedInAmbientContext, u) : o_(u, this.hasPlugin("estree")) || this.raise(le.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
  return a;
}
parseStatementContent(r, i) {
  if (this.match(75) && this.isLookaheadContextual("enum")) {
    const s = this.startNode();
    return this.expect(75), this.tsParseEnumDeclaration(s, {
      const: !0
    });
  }
  if (this.isContextual(126))
    return this.tsParseEnumDeclaration(this.startNode());
  if (this.isContextual(129)) {
    const s = this.tsParseInterfaceDeclaration(this.startNode());
    if (s) return s;
  }
  return super.parseStatementContent(r, i);
}
parseAccessModifier() {
  return this.tsParseModifier(["public", "protected", "private"]);
}
tsHasSomeModifiers(r, i) {
  return i.some((s) => hl(s) ? r.accessibility === s : !!r[s]);
}
tsIsStartOfStaticBlocks() {
  return this.isContextual(106) && this.lookaheadCharCode() === 123;
}
parseClassMember(r, i, s) {
  const n = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
  this.tsParseModifiers({
    allowedModifiers: n,
    disallowedModifiers: ["in", "out"],
    stopOnStartOfClassStaticBlock: !0,
    errorTemplate: le.InvalidModifierOnTypeParameterPositions
  }, i);
  const a = () => {
    this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, n) && this.raise(le.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(r, i)) : this.parseClassMemberWithIsStatic(r, i, s, !!i.static);
  };
  i.declare ? this.tsInAmbientContext(a) : a();
}
parseClassMemberWithIsStatic(r, i, s, n) {
  const a = this.tsTryParseIndexSignature(i);
  if (a) {
    r.body.push(a), i.abstract && this.raise(le.IndexSignatureHasAbstract, i), i.accessibility && this.raise(le.IndexSignatureHasAccessibility, i, {
      modifier: i.accessibility
    }), i.declare && this.raise(le.IndexSignatureHasDeclare, i), i.override && this.raise(le.IndexSignatureHasOverride, i);
    return;
  }
  !this.state.inAbstractClass && i.abstract && this.raise(le.NonAbstractClassHasAbstractMethod, i), i.override && (s.hadSuperClass || this.raise(le.OverrideNotInSubClass, i)), super.parseClassMemberWithIsStatic(r, i, s, n);
}
parsePostMemberNameModifiers(r) {
  this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(le.ClassMethodHasReadonly, r), r.declare && this.match(10) && this.raise(le.ClassMethodHasDeclare, r);
}
parseExpressionStatement(r, i, s) {
  return (i.type === "Identifier" ? this.tsParseExpressionStatement(r, i, s) : void 0) || super.parseExpressionStatement(r, i, s);
}
shouldParseExportDeclaration() {
  return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
}
parseConditional(r, i, s) {
  if (!this.state.maybeInArrowParameters || !this.match(17))
    return super.parseConditional(r, i, s);
  const n = this.tryParse(() => super.parseConditional(r, i));
  return n.node ? (n.error && (this.state = n.failState), n.node) : (n.error && super.setOptionalParametersError(s, n.error), r);
}
parseParenItem(r, i) {
  const s = super.parseParenItem(r, i);
  if (this.eat(17) && (s.optional = !0, this.resetEndLocation(r)), this.match(14)) {
    const n = this.startNodeAt(i);
    return n.expression = r, n.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(n, "TSTypeCastExpression");
  }
  return r;
}
parseExportDeclaration(r) {
  if (!this.state.isAmbientContext && this.isContextual(125))
    return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
  const i = this.state.startLoc, s = this.eatContextual(125);
  if (s && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
    throw this.raise(le.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
  const a = Be(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
  return a ? ((a.type === "TSInterfaceDeclaration" || a.type === "TSTypeAliasDeclaration" || s) && (r.exportKind = "type"), s && (this.resetStartLocation(a, i), a.declare = !0), a) : null;
}
parseClassId(r, i, s, n) {
  if ((!i || s) && this.isContextual(113))
    return;
  super.parseClassId(r, i, s, r.declare ? 1024 : 8331);
  const a = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
  a && (r.typeParameters = a);
}
parseClassPropertyAnnotation(r) {
  r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
  const i = this.tsTryParseTypeAnnotation();
  i && (r.typeAnnotation = i);
}
parseClassProperty(r) {
  if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.raise(le.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
    const {
      key: i
    } = r;
    this.raise(le.AbstractPropertyHasInitializer, this.state.startLoc, {
      propertyName: i.type === "Identifier" && !r.computed ? i.name : `[${this.input.slice(i.start, i.end)}]`
    });
  }
  return super.parseClassProperty(r);
}
parseClassPrivateProperty(r) {
  return r.abstract && this.raise(le.PrivateElementHasAbstract, r), r.accessibility && this.raise(le.PrivateElementHasAccessibility, r, {
    modifier: r.accessibility
  }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
}
parseClassAccessorProperty(r) {
  return this.parseClassPropertyAnnotation(r), r.optional && this.raise(le.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(r);
}
pushClassMethod(r, i, s, n, a, o) {
  const u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
  u && a && this.raise(le.ConstructorHasTypeParameters, u);
  const {
    declare: l = !1,
    kind: c
  } = i;
  l && (c === "get" || c === "set") && this.raise(le.DeclareAccessor, i, {
    kind: c
  }), u && (i.typeParameters = u), super.pushClassMethod(r, i, s, n, a, o);
}
pushClassPrivateMethod(r, i, s, n) {
  const a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
  a && (i.typeParameters = a), super.pushClassPrivateMethod(r, i, s, n);
}
declareClassPrivateMethodInScope(r, i) {
  r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !hasOwnProperty.call(r.value, "body") || super.declareClassPrivateMethodInScope(r, i));
}
parseClassSuper(r) {
  super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
}
parseObjPropValue(r, i, s, n, a, o, u) {
  const l = this.tsTryParseTypeParameters(this.tsParseConstModifier);
  return l && (r.typeParameters = l), super.parseObjPropValue(r, i, s, n, a, o, u);
}
parseFunctionParams(r, i) {
  const s = this.tsTryParseTypeParameters(this.tsParseConstModifier);
  s && (r.typeParameters = s), super.parseFunctionParams(r, i);
}
parseVarId(r, i) {
  super.parseVarId(r, i), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
  const s = this.tsTryParseTypeAnnotation();
  s && (r.id.typeAnnotation = s, this.resetEndLocation(r.id));
}
parseAsyncArrowFromCallExpression(r, i) {
  return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, i);
}
parseMaybeAssign(r, i) {
  var s, n, a, o, u;
  let l, c, f;
  if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
    if (l = this.state.clone(), c = this.tryParse(() => super.parseMaybeAssign(r, i), l), !c.error) return c.node;
    const {
      context: y
    } = this.state, g = y[y.length - 1];
    (g === $e.j_oTag || g === $e.j_expr) && y.pop();
  }
  if (!((s = c) != null && s.error) && !this.match(47))
    return super.parseMaybeAssign(r, i);
  (!l || l === this.state) && (l = this.state.clone());
  let p;
  const h = this.tryParse((y) => {
    var g, A;
    p = this.tsParseTypeParameters(this.tsParseConstModifier);
    const C = super.parseMaybeAssign(r, i);
    return (C.type !== "ArrowFunctionExpression" || (g = C.extra) != null && g.parenthesized) && y(), ((A = p) == null ? void 0 : A.params.length) !== 0 && this.resetStartLocationFromNode(C, p), C.typeParameters = p, C;
  }, l);
  if (!h.error && !h.aborted)
    return p && this.reportReservedArrowTypeParam(p), h.node;
  if (!c && (pl(!this.hasPlugin("jsx")), f = this.tryParse(() => super.parseMaybeAssign(r, i), l), !f.error))
    return f.node;
  if ((n = c) != null && n.node)
    return this.state = c.failState, c.node;
  if (h.node)
    return this.state = h.failState, p && this.reportReservedArrowTypeParam(p), h.node;
  if ((a = f) != null && a.node)
    return this.state = f.failState, f.node;
  throw ((o = c) == null ? void 0 : o.error) || h.error || ((u = f) == null ? void 0 : u.error);
}
reportReservedArrowTypeParam(r) {
  var i;
  r.params.length === 1 && !r.params[0].constraint && !((i = r.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(le.ReservedArrowTypeParam, r);
}
parseMaybeUnary(r, i) {
  return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, i);
}
parseArrow(r) {
  if (this.match(14)) {
    const i = this.tryParse((s) => {
      const n = this.tsParseTypeOrTypePredicateAnnotation(14);
      return (this.canInsertSemicolon() || !this.match(19)) && s(), n;
    });
    if (i.aborted) return;
    i.thrown || (i.error && (this.state = i.failState), r.returnType = i.node);
  }
  return super.parseArrow(r);
}
parseAssignableListItemTypes(r, i) {
  if (!(i & 2)) return r;
  this.eat(17) && (r.optional = !0);
  const s = this.tsTryParseTypeAnnotation();
  return s && (r.typeAnnotation = s), this.resetEndLocation(r), r;
}
isAssignable(r, i) {
  switch (r.type) {
    case "TSTypeCastExpression":
      return this.isAssignable(r.expression, i);
    case "TSParameterProperty":
      return !0;
    default:
      return super.isAssignable(r, i);
  }
}
toAssignable(r, i = !1) {
  switch (r.type) {
    case "ParenthesizedExpression":
      this.toAssignableParenthesizedExpression(r, i);
      break;
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSNonNullExpression":
    case "TSTypeAssertion":
      i ? this.expressionScope.recordArrowParameterBindingError(le.UnexpectedTypeCastInParameter, r) : this.raise(le.UnexpectedTypeCastInParameter, r), this.toAssignable(r.expression, i);
      break;
    case "AssignmentExpression":
      !i && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
    default:
      super.toAssignable(r, i);
  }
}
toAssignableParenthesizedExpression(r, i) {
  switch (r.expression.type) {
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSNonNullExpression":
    case "TSTypeAssertion":
    case "ParenthesizedExpression":
      this.toAssignable(r.expression, i);
      break;
    default:
      super.toAssignable(r, i);
  }
}
checkToRestConversion(r, i) {
  switch (r.type) {
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSNonNullExpression":
      this.checkToRestConversion(r.expression, !1);
      break;
    default:
      super.checkToRestConversion(r, i);
  }
}
isValidLVal(r, i, s) {
  return t_({
    TSTypeCastExpression: !0,
    TSParameterProperty: "parameter",
    TSNonNullExpression: "expression",
    TSInstantiationExpression: "expression",
    TSAsExpression: (s !== 64 || !i) && ["expression", !0],
    TSSatisfiesExpression: (s !== 64 || !i) && ["expression", !0],
    TSTypeAssertion: (s !== 64 || !i) && ["expression", !0]
  }, r) || super.isValidLVal(r, i, s);
}
parseBindingAtom() {
  return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
}
parseMaybeDecoratorArguments(r) {
  if (this.match(47) || this.match(51)) {
    const i = this.tsParseTypeArgumentsInExpression();
    if (this.match(10)) {
      const s = super.parseMaybeDecoratorArguments(r);
      return s.typeParameters = i, s;
    }
    this.unexpected(null, 10);
  }
  return super.parseMaybeDecoratorArguments(r);
}
checkCommaAfterRest(r) {
  return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(r);
}
isClassMethod() {
  return this.match(47) || super.isClassMethod();
}
isClassProperty() {
  return this.match(35) || this.match(14) || super.isClassProperty();
}
parseMaybeDefault(r, i) {
  const s = super.parseMaybeDefault(r, i);
  return s.type === "AssignmentPattern" && s.typeAnnotation && s.right.start < s.typeAnnotation.start && this.raise(le.TypeAnnotationAfterAssign, s.typeAnnotation), s;
}
getTokenFromCode(r) {
  if (this.state.inType) {
    if (r === 62) {
      this.finishOp(48, 1);
      return;
    }
    if (r === 60) {
      this.finishOp(47, 1);
      return;
    }
  }
  super.getTokenFromCode(r);
}
reScan_lt_gt() {
  const {
    type: r
  } = this.state;
  r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
}
reScan_lt() {
  const {
    type: r
  } = this.state;
  return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
}
toAssignableList(r, i, s) {
  for (let n = 0; n < r.length; n++) {
    const a = r[n];
    (a == null ? void 0 : a.type) === "TSTypeCastExpression" && (r[n] = this.typeCastToParameter(a));
  }
  super.toAssignableList(r, i, s);
}
typeCastToParameter(r) {
  return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
}
shouldParseArrow(r) {
  return this.match(14) ? r.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(r);
}
shouldParseAsyncArrow() {
  return this.match(14) || super.shouldParseAsyncArrow();
}
canHaveLeadingDecorator() {
  return super.canHaveLeadingDecorator() || this.isAbstractClass();
}
jsxParseOpeningElementAfterName(r) {
  if (this.match(47) || this.match(51)) {
    const i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
    i && (r.typeParameters = i);
  }
  return super.jsxParseOpeningElementAfterName(r);
}
getGetterSetterExpectedParamCount(r) {
  const i = super.getGetterSetterExpectedParamCount(r), n = this.getObjectOrClassMethodParams(r)[0];
  return n && this.isThisParam(n) ? i + 1 : i;
}
parseCatchClauseParam() {
  const r = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
  return i && (r.typeAnnotation = i, this.resetEndLocation(r)), r;
}
tsInAmbientContext(r) {
  const {
    isAmbientContext: i,
    strict: s
  } = this.state;
  this.state.isAmbientContext = !0, this.state.strict = !1;
  try {
    return r();
  } finally {
    this.state.isAmbientContext = i, this.state.strict = s;
  }
}
parseClass(r, i, s) {
  const n = this.state.inAbstractClass;
  this.state.inAbstractClass = !!r.abstract;
  try {
    return super.parseClass(r, i, s);
  } finally {
    this.state.inAbstractClass = n;
  }
}
tsParseAbstractDeclaration(r, i) {
  if (this.match(80))
    return r.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(r, !0, !1));
  if (this.isContextual(129)) {
    if (!this.hasFollowingLineBreak())
      return r.abstract = !0, this.raise(le.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
  } else
    this.unexpected(null, 80);
}
parseMethod(r, i, s, n, a, o, u) {
  const l = super.parseMethod(r, i, s, n, a, o, u);
  if (l.abstract && (this.hasPlugin("estree") ? !!l.value.body : !!l.body)) {
    const {
      key: f
    } = l;
    this.raise(le.AbstractMethodHasImplementation, l, {
      methodName: f.type === "Identifier" && !l.computed ? f.name : `[${this.input.slice(f.start, f.end)}]`
    });
  }
  return l;
}
tsParseTypeParameterName() {
  return this.parseIdentifier().name;
}
shouldParseAsAmbientContext() {
  return !!this.getPluginOption("typescript", "dts");
}
parse() {
  return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
}
getExpression() {
  return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
}
parseExportSpecifier(r, i, s, n) {
  return !i && n ? (this.parseTypeOnlyImportExportSpecifier(r, !1, s), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value", super.parseExportSpecifier(r, i, s, n));
}
parseImportSpecifier(r, i, s, n, a) {
  return !i && n ? (this.parseTypeOnlyImportExportSpecifier(r, !0, s), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value", super.parseImportSpecifier(r, i, s, n, s ? 4098 : 4096));
}
parseTypeOnlyImportExportSpecifier(r, i, s) {
  const n = i ? "imported" : "local", a = i ? "local" : "exported";
  let o = r[n], u, l = !1, c = !0;
  const f = o.loc.start;
  if (this.isContextual(93)) {
    const h = this.parseIdentifier();
    if (this.isContextual(93)) {
      const y = this.parseIdentifier();
      _t(this.state.type) ? (l = !0, o = h, u = i ? this.parseIdentifier() : this.parseModuleExportName(), c = !1) : (u = y, c = !1);
    } else _t(this.state.type) ? (c = !1, u = i ? this.parseIdentifier() : this.parseModuleExportName()) : (l = !0, o = h);
  } else _t(this.state.type) && (l = !0, i ? (o = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, !0, !0)) : o = this.parseModuleExportName());
  l && s && this.raise(i ? le.TypeModifierIsUsedInTypeImports : le.TypeModifierIsUsedInTypeExports, f), r[n] = o, r[a] = u;
  const p = i ? "importKind" : "exportKind";
  r[p] = l ? "type" : "value", c && this.eatContextual(93) && (r[a] = i ? this.parseIdentifier() : this.parseModuleExportName()), r[a] || (r[a] = Gt(r[n])), i && this.checkIdentifier(r[a], l ? 4098 : 4096);
}
};
function a_(e) {
if (e.type !== "MemberExpression") return !1;
const {
  computed: t,
  property: r
} = e;
return t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : Nf(e.object);
}
function o_(e, t) {
var r;
const {
  type: i
} = e;
if ((r = e.extra) != null && r.parenthesized)
  return !1;
if (t) {
  if (i === "Literal") {
    const {
      value: s
    } = e;
    if (typeof s == "string" || typeof s == "boolean")
      return !0;
  }
} else if (i === "StringLiteral" || i === "BooleanLiteral")
  return !0;
return !!(wf(e, t) || u_(e, t) || i === "TemplateLiteral" && e.expressions.length === 0 || a_(e));
}
function wf(e, t) {
return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLiteral";
}
function u_(e, t) {
if (e.type === "UnaryExpression") {
  const {
    operator: r,
    argument: i
  } = e;
  if (r === "-" && wf(i, t))
    return !0;
}
return !1;
}
function Nf(e) {
return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : Nf(e.object);
}
const dl = Ht`placeholders`({
ClassNameIsRequired: "A class name is required.",
UnexpectedSpace: "Unexpected space in placeholder."
});
var l_ = (e) => class extends e {
parsePlaceholder(r) {
  if (this.match(144)) {
    const i = this.startNode();
    return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(i, r);
  }
}
finishPlaceholder(r, i) {
  let s = r;
  return (!s.expectedNode || !s.type) && (s = this.finishNode(s, "Placeholder")), s.expectedNode = i, s;
}
getTokenFromCode(r) {
  r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
}
parseExprAtom(r) {
  return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
}
parseIdentifier(r) {
  return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
}
checkReservedWord(r, i, s, n) {
  r !== void 0 && super.checkReservedWord(r, i, s, n);
}
parseBindingAtom() {
  return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
}
isValidLVal(r, i, s) {
  return r === "Placeholder" || super.isValidLVal(r, i, s);
}
toAssignable(r, i) {
  r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, i);
}
chStartsBindingIdentifier(r, i) {
  return !!(super.chStartsBindingIdentifier(r, i) || this.lookahead().type === 144);
}
verifyBreakContinue(r, i) {
  r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, i);
}
parseExpressionStatement(r, i) {
  var s;
  if (i.type !== "Placeholder" || (s = i.extra) != null && s.parenthesized)
    return super.parseExpressionStatement(r, i);
  if (this.match(14)) {
    const a = r;
    return a.label = this.finishPlaceholder(i, "Identifier"), this.next(), a.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(a, "LabeledStatement");
  }
  this.semicolon();
  const n = r;
  return n.name = i.name, this.finishPlaceholder(n, "Statement");
}
parseBlock(r, i, s) {
  return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, i, s);
}
parseFunctionId(r) {
  return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
}
parseClass(r, i, s) {
  const n = i ? "ClassDeclaration" : "ClassExpression";
  this.next();
  const a = this.state.strict, o = this.parsePlaceholder("Identifier");
  if (o)
    if (this.match(81) || this.match(144) || this.match(5))
      r.id = o;
    else {
      if (s || !i)
        return r.id = null, r.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(r, n);
      throw this.raise(dl.ClassNameIsRequired, this.state.startLoc);
    }
  else
    this.parseClassId(r, i, s);
  return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, a), this.finishNode(r, n);
}
parseExport(r, i) {
  const s = this.parsePlaceholder("Identifier");
  if (!s) return super.parseExport(r, i);
  const n = r;
  if (!this.isContextual(98) && !this.match(12))
    return n.specifiers = [], n.source = null, n.declaration = this.finishPlaceholder(s, "Declaration"), this.finishNode(n, "ExportNamedDeclaration");
  this.expectPlugin("exportDefaultFrom");
  const a = this.startNode();
  return a.exported = s, n.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(n, i);
}
isExportDefaultSpecifier() {
  if (this.match(65)) {
    const r = this.nextTokenStart();
    if (this.isUnparsedContextual(r, "from") && this.input.startsWith(or(144), this.nextTokenStartSince(r + 4)))
      return !0;
  }
  return super.isExportDefaultSpecifier();
}
maybeParseExportDefaultSpecifier(r, i) {
  var s;
  return (s = r.specifiers) != null && s.length ? !0 : super.maybeParseExportDefaultSpecifier(r, i);
}
checkExport(r) {
  const {
    specifiers: i
  } = r;
  i != null && i.length && (r.specifiers = i.filter((s) => s.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = i;
}
parseImport(r) {
  const i = this.parsePlaceholder("Identifier");
  if (!i) return super.parseImport(r);
  if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
    return r.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
  const s = this.startNodeAtNode(i);
  return s.local = i, r.specifiers.push(this.finishNode(s, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(r, "ImportDeclaration");
}
parseImportSource() {
  return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
}
assertNoSpace() {
  this.state.start > this.state.lastTokEndLoc.index && this.raise(dl.UnexpectedSpace, this.state.lastTokEndLoc);
}
}, c_ = (e) => class extends e {
parseV8Intrinsic() {
  if (this.match(54)) {
    const r = this.state.startLoc, i = this.startNode();
    if (this.next(), Be(this.state.type)) {
      const s = this.parseIdentifierName(), n = this.createIdentifier(i, s);
      if (n.type = "V8IntrinsicIdentifier", this.match(10))
        return n;
    }
    this.unexpected(r);
  }
}
parseExprAtom(r) {
  return this.parseV8Intrinsic() || super.parseExprAtom(r);
}
};
function at(e, t) {
const [r, i] = typeof t == "string" ? [t, {}] : t, s = Object.keys(i), n = s.length === 0;
return e.some((a) => {
  if (typeof a == "string")
    return n && a === r;
  {
    const [o, u] = a;
    if (o !== r)
      return !1;
    for (const l of s)
      if (u[l] !== i[l])
        return !1;
    return !0;
  }
});
}
function hr(e, t, r) {
const i = e.find((s) => Array.isArray(s) ? s[0] === t : s === t);
return i && Array.isArray(i) && i.length > 1 ? i[1][r] : null;
}
const ml = ["minimal", "fsharp", "hack", "smart"], yl = ["^^", "@@", "^", "%", "#"];
function f_(e) {
if (at(e, "decorators")) {
  if (at(e, "decorators-legacy"))
    throw new Error("Cannot use the decorators and decorators-legacy plugin together");
  const t = hr(e, "decorators", "decoratorsBeforeExport");
  if (t != null && typeof t != "boolean")
    throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
  const r = hr(e, "decorators", "allowCallParenthesized");
  if (r != null && typeof r != "boolean")
    throw new Error("'allowCallParenthesized' must be a boolean.");
}
if (at(e, "flow") && at(e, "typescript"))
  throw new Error("Cannot combine flow and typescript plugins.");
if (at(e, "placeholders") && at(e, "v8intrinsic"))
  throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
if (at(e, "pipelineOperator")) {
  const t = hr(e, "pipelineOperator", "proposal");
  if (!ml.includes(t)) {
    const s = ml.map((n) => `"${n}"`).join(", ");
    throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s}.`);
  }
  const r = ["recordAndTuple", {
    syntaxType: "hash"
  }], i = at(e, r);
  if (t === "hack") {
    if (at(e, "placeholders"))
      throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
    if (at(e, "v8intrinsic"))
      throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
    const s = hr(e, "pipelineOperator", "topicToken");
    if (!yl.includes(s)) {
      const n = yl.map((a) => `"${a}"`).join(", ");
      throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${n}.`);
    }
    if (s === "#" && i)
      throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(r)}\`.`);
  } else if (t === "smart" && i)
    throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(r)}\`.`);
}
if (at(e, "moduleAttributes")) {
  if (at(e, "importAssertions") || at(e, "importAttributes"))
    throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
  if (hr(e, "moduleAttributes", "version") !== "may-2020")
    throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
}
if (at(e, "importAssertions") && at(e, "importAttributes"))
  throw new Error("Cannot combine importAssertions and importAttributes plugins.");
if (at(e, "recordAndTuple")) {
  const t = hr(e, "recordAndTuple", "syntaxType");
  if (t != null) {
    const r = ["hash", "bar"];
    if (!r.includes(t))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + r.map((i) => `'${i}'`).join(", "));
  }
}
if (at(e, "asyncDoExpressions") && !at(e, "doExpressions")) {
  const t = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
  throw t.missingPlugins = "doExpressions", t;
}
if (at(e, "optionalChainingAssign") && hr(e, "optionalChainingAssign", "version") !== "2023-07")
  throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
}
const Of = {
estree: Q8,
jsx: G5,
flow: X5,
typescript: n_,
v8intrinsic: c_,
placeholders: l_
}, p_ = Object.keys(Of), In = {
sourceType: "script",
sourceFilename: void 0,
startColumn: 0,
startLine: 1,
allowAwaitOutsideFunction: !1,
allowReturnOutsideFunction: !1,
allowNewTargetOutsideFunction: !1,
allowImportExportEverywhere: !1,
allowSuperOutsideMethod: !1,
allowUndeclaredExports: !1,
plugins: [],
strictMode: null,
ranges: !1,
tokens: !1,
createImportExpressions: !1,
createParenthesizedExpressions: !1,
errorRecovery: !1,
attachComment: !0,
annexB: !0
};
function h_(e) {
if (e == null)
  return Object.assign({}, In);
if (e.annexB != null && e.annexB !== !1)
  throw new Error("The `annexB` option can only be set to `false`.");
const t = {};
for (const i of Object.keys(In)) {
  var r;
  t[i] = (r = e[i]) != null ? r : In[i];
}
return t;
}
class d_ extends e_ {
checkProto(t, r, i, s) {
  if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
    return;
  const n = t.key;
  if ((n.type === "Identifier" ? n.name : n.value) === "__proto__") {
    if (r) {
      this.raise(w.RecordNoProto, n);
      return;
    }
    i.used && (s ? s.doubleProtoLoc === null && (s.doubleProtoLoc = n.loc.start) : this.raise(w.DuplicateProto, n)), i.used = !0;
  }
}
shouldExitDescending(t, r) {
  return t.type === "ArrowFunctionExpression" && t.start === r;
}
getExpression() {
  this.enterInitialScopes(), this.nextToken();
  const t = this.parseExpression();
  return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
}
parseExpression(t, r) {
  return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
}
parseExpressionBase(t) {
  const r = this.state.startLoc, i = this.parseMaybeAssign(t);
  if (this.match(12)) {
    const s = this.startNodeAt(r);
    for (s.expressions = [i]; this.eat(12); )
      s.expressions.push(this.parseMaybeAssign(t));
    return this.toReferencedList(s.expressions), this.finishNode(s, "SequenceExpression");
  }
  return i;
}
parseMaybeAssignDisallowIn(t, r) {
  return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
}
parseMaybeAssignAllowIn(t, r) {
  return this.allowInAnd(() => this.parseMaybeAssign(t, r));
}
setOptionalParametersError(t, r) {
  var i;
  t.optionalParametersLoc = (i = r == null ? void 0 : r.loc) != null ? i : this.state.startLoc;
}
parseMaybeAssign(t, r) {
  const i = this.state.startLoc;
  if (this.isContextual(108) && this.prodParam.hasYield) {
    let o = this.parseYield();
    return r && (o = r.call(this, o, i)), o;
  }
  let s;
  t ? s = !1 : (t = new us(), s = !0);
  const {
    type: n
  } = this.state;
  (n === 10 || Be(n)) && (this.state.potentialArrowAt = this.state.start);
  let a = this.parseMaybeConditional(t);
  if (r && (a = r.call(this, a, i)), i5(this.state.type)) {
    const o = this.startNodeAt(i), u = this.state.value;
    if (o.operator = u, this.match(29)) {
      this.toAssignable(a, !0), o.left = a;
      const l = i.index;
      t.doubleProtoLoc != null && t.doubleProtoLoc.index >= l && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= l && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= l && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null);
    } else
      o.left = a;
    return this.next(), o.right = this.parseMaybeAssign(), this.checkLVal(a, {
      in: this.finishNode(o, "AssignmentExpression")
    }), o;
  } else s && this.checkExpressionErrors(t, !0);
  return a;
}
parseMaybeConditional(t) {
  const r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseExprOps(t);
  return this.shouldExitDescending(s, i) ? s : this.parseConditional(s, r, t);
}
parseConditional(t, r, i) {
  if (this.eat(17)) {
    const s = this.startNodeAt(r);
    return s.test = t, s.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), s.alternate = this.parseMaybeAssign(), this.finishNode(s, "ConditionalExpression");
  }
  return t;
}
parseMaybeUnaryOrPrivate(t) {
  return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t);
}
parseExprOps(t) {
  const r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseMaybeUnaryOrPrivate(t);
  return this.shouldExitDescending(s, i) ? s : this.parseExprOp(s, r, -1);
}
parseExprOp(t, r, i) {
  if (this.isPrivateName(t)) {
    const n = this.getPrivateNameSV(t);
    (i >= ns(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(w.PrivateInExpectedIn, t, {
      identifierName: n
    }), this.classScope.usePrivateName(n, t.loc.start);
  }
  const s = this.state.type;
  if (n5(s) && (this.prodParam.hasIn || !this.match(58))) {
    let n = ns(s);
    if (n > i) {
      if (s === 39) {
        if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
          return t;
        this.checkPipelineAtInfixOperator(t, r);
      }
      const a = this.startNodeAt(r);
      a.left = t, a.operator = this.state.value;
      const o = s === 41 || s === 42, u = s === 40;
      if (u && (n = ns(42)), this.next(), s === 39 && this.hasPlugin(["pipelineOperator", {
        proposal: "minimal"
      }]) && this.state.type === 96 && this.prodParam.hasAwait)
        throw this.raise(w.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
      a.right = this.parseExprOpRightExpr(s, n);
      const l = this.finishNode(a, o || u ? "LogicalExpression" : "BinaryExpression"), c = this.state.type;
      if (u && (c === 41 || c === 42) || o && c === 40)
        throw this.raise(w.MixingCoalesceWithLogical, this.state.startLoc);
      return this.parseExprOp(l, r, i);
    }
  }
  return t;
}
parseExprOpRightExpr(t, r) {
  const i = this.state.startLoc;
  switch (t) {
    case 39:
      switch (this.getPluginOption("pipelineOperator", "proposal")) {
        case "hack":
          return this.withTopicBindingContext(() => this.parseHackPipeBody());
        case "smart":
          return this.withTopicBindingContext(() => {
            if (this.prodParam.hasYield && this.isContextual(108))
              throw this.raise(w.PipeBodyIsTighter, this.state.startLoc);
            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), i);
          });
        case "fsharp":
          return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
      }
    default:
      return this.parseExprOpBaseRightExpr(t, r);
  }
}
parseExprOpBaseRightExpr(t, r) {
  const i = this.state.startLoc;
  return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, c5(t) ? r - 1 : r);
}
parseHackPipeBody() {
  var t;
  const {
    startLoc: r
  } = this.state, i = this.parseMaybeAssign();
  return J8.has(i.type) && !((t = i.extra) != null && t.parenthesized) && this.raise(w.PipeUnparenthesizedBody, r, {
    type: i.type
  }), this.topicReferenceWasUsedInCurrentContext() || this.raise(w.PipeTopicUnused, r), i;
}
checkExponentialAfterUnary(t) {
  this.match(57) && this.raise(w.UnexpectedTokenUnaryExponentiation, t.argument);
}
parseMaybeUnary(t, r) {
  const i = this.state.startLoc, s = this.isContextual(96);
  if (s && this.isAwaitAllowed()) {
    this.next();
    const u = this.parseAwait(i);
    return r || this.checkExponentialAfterUnary(u), u;
  }
  const n = this.match(34), a = this.startNode();
  if (o5(this.state.type)) {
    a.operator = this.state.value, a.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
    const u = this.match(89);
    if (this.next(), a.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && u) {
      const l = a.argument;
      l.type === "Identifier" ? this.raise(w.StrictDelete, a) : this.hasPropertyAsPrivateName(l) && this.raise(w.DeletePrivateField, a);
    }
    if (!n)
      return r || this.checkExponentialAfterUnary(a), this.finishNode(a, "UnaryExpression");
  }
  const o = this.parseUpdate(a, n, t);
  if (s) {
    const {
      type: u
    } = this.state;
    if ((this.hasPlugin("v8intrinsic") ? Yn(u) : Yn(u) && !this.match(54)) && !this.isAmbiguousAwait())
      return this.raiseOverwrite(w.AwaitNotInAsyncContext, i), this.parseAwait(i);
  }
  return o;
}
parseUpdate(t, r, i) {
  if (r) {
    const a = t;
    return this.checkLVal(a.argument, {
      in: this.finishNode(a, "UpdateExpression")
    }), t;
  }
  const s = this.state.startLoc;
  let n = this.parseExprSubscripts(i);
  if (this.checkExpressionErrors(i, !1)) return n;
  for (; a5(this.state.type) && !this.canInsertSemicolon(); ) {
    const a = this.startNodeAt(s);
    a.operator = this.state.value, a.prefix = !1, a.argument = n, this.next(), this.checkLVal(n, {
      in: n = this.finishNode(a, "UpdateExpression")
    });
  }
  return n;
}
parseExprSubscripts(t) {
  const r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseExprAtom(t);
  return this.shouldExitDescending(s, i) ? s : this.parseSubscripts(s, r);
}
parseSubscripts(t, r, i) {
  const s = {
    optionalChainMember: !1,
    maybeAsyncArrow: this.atPossibleAsyncArrow(t),
    stop: !1
  };
  do
    t = this.parseSubscript(t, r, i, s), s.maybeAsyncArrow = !1;
  while (!s.stop);
  return t;
}
parseSubscript(t, r, i, s) {
  const {
    type: n
  } = this.state;
  if (!i && n === 15)
    return this.parseBind(t, r, i, s);
  if (hs(n))
    return this.parseTaggedTemplateExpression(t, r, s);
  let a = !1;
  if (n === 18) {
    if (i && (this.raise(w.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
      return s.stop = !0, t;
    s.optionalChainMember = a = !0, this.next();
  }
  if (!i && this.match(10))
    return this.parseCoverCallAndAsyncArrowHead(t, r, s, a);
  {
    const o = this.eat(0);
    return o || a || this.eat(16) ? this.parseMember(t, r, s, o, a) : (s.stop = !0, t);
  }
}
parseMember(t, r, i, s, n) {
  const a = this.startNodeAt(r);
  return a.object = t, a.computed = s, s ? (a.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (t.type === "Super" && this.raise(w.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), a.property = this.parsePrivateName()) : a.property = this.parseIdentifier(!0), i.optionalChainMember ? (a.optional = n, this.finishNode(a, "OptionalMemberExpression")) : this.finishNode(a, "MemberExpression");
}
parseBind(t, r, i, s) {
  const n = this.startNodeAt(r);
  return n.object = t, this.next(), n.callee = this.parseNoCallExpr(), s.stop = !0, this.parseSubscripts(this.finishNode(n, "BindExpression"), r, i);
}
parseCoverCallAndAsyncArrowHead(t, r, i, s) {
  const n = this.state.maybeInArrowParameters;
  let a = null;
  this.state.maybeInArrowParameters = !0, this.next();
  const o = this.startNodeAt(r);
  o.callee = t;
  const {
    maybeAsyncArrow: u,
    optionalChainMember: l
  } = i;
  u && (this.expressionScope.enter(F5()), a = new us()), l && (o.optional = s), s ? o.arguments = this.parseCallExpressionArguments(11) : o.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", o, a);
  let c = this.finishCallExpression(o, l);
  return u && this.shouldParseAsyncArrow() && !s ? (i.stop = !0, this.checkDestructuringPrivate(a), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), c)) : (u && (this.checkExpressionErrors(a, !0), this.expressionScope.exit()), this.toReferencedArguments(c)), this.state.maybeInArrowParameters = n, c;
}
toReferencedArguments(t, r) {
  this.toReferencedListDeep(t.arguments, r);
}
parseTaggedTemplateExpression(t, r, i) {
  const s = this.startNodeAt(r);
  return s.tag = t, s.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(w.OptionalChainingNoTemplate, r), this.finishNode(s, "TaggedTemplateExpression");
}
atPossibleAsyncArrow(t) {
  return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && t.start === this.state.potentialArrowAt;
}
expectImportAttributesPlugin() {
  this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
}
finishCallExpression(t, r) {
  if (t.callee.type === "Import")
    if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t.arguments.length === 0 || t.arguments.length > 2)
      this.raise(w.ImportCallArity, t, {
        maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
      });
    else
      for (const i of t.arguments)
        i.type === "SpreadElement" && this.raise(w.ImportCallSpreadArgument, i);
  return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
}
parseCallExpressionArguments(t, r, i, s, n) {
  const a = [];
  let o = !0;
  const u = this.state.inFSharpPipelineDirectBody;
  for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t); ) {
    if (o)
      o = !1;
    else if (this.expect(12), this.match(t)) {
      r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(w.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), s && this.addTrailingCommaExtraToNode(s), this.next();
      break;
    }
    a.push(this.parseExprListItem(!1, n, i));
  }
  return this.state.inFSharpPipelineDirectBody = u, a;
}
shouldParseAsyncArrow() {
  return this.match(19) && !this.canInsertSemicolon();
}
parseAsyncArrowFromCallExpression(t, r) {
  var i;
  return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, !0, (i = r.extra) == null ? void 0 : i.trailingCommaLoc), r.innerComments && ai(t, r.innerComments), r.callee.trailingComments && ai(t, r.callee.trailingComments), t;
}
parseNoCallExpr() {
  const t = this.state.startLoc;
  return this.parseSubscripts(this.parseExprAtom(), t, !0);
}
parseExprAtom(t) {
  let r, i = null;
  const {
    type: s
  } = this.state;
  switch (s) {
    case 79:
      return this.parseSuper();
    case 83:
      return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(w.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(r, "Import"));
    case 78:
      return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
    case 90:
      return this.parseDo(this.startNode(), !1);
    case 56:
    case 31:
      return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
    case 134:
      return this.parseNumericLiteral(this.state.value);
    case 135:
      return this.parseBigIntLiteral(this.state.value);
    case 136:
      return this.parseDecimalLiteral(this.state.value);
    case 133:
      return this.parseStringLiteral(this.state.value);
    case 84:
      return this.parseNullLiteral();
    case 85:
      return this.parseBooleanLiteral(!0);
    case 86:
      return this.parseBooleanLiteral(!1);
    case 10: {
      const n = this.state.potentialArrowAt === this.state.start;
      return this.parseParenAndDistinguishExpression(n);
    }
    case 2:
    case 1:
      return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
    case 0:
      return this.parseArrayLike(3, !0, !1, t);
    case 6:
    case 7:
      return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
    case 5:
      return this.parseObjectLike(8, !1, !1, t);
    case 68:
      return this.parseFunctionOrFunctionSent();
    case 26:
      i = this.parseDecorators();
    case 80:
      return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
    case 77:
      return this.parseNewOrNewTarget();
    case 25:
    case 24:
      return this.parseTemplate(!1);
    case 15: {
      r = this.startNode(), this.next(), r.object = null;
      const n = r.callee = this.parseNoCallExpr();
      if (n.type === "MemberExpression")
        return this.finishNode(r, "BindExpression");
      throw this.raise(w.UnsupportedBind, n);
    }
    case 138:
      return this.raise(w.PrivateInExpectedIn, this.state.startLoc, {
        identifierName: this.state.value
      }), this.parsePrivateName();
    case 33:
      return this.parseTopicReferenceThenEqualsSign(54, "%");
    case 32:
      return this.parseTopicReferenceThenEqualsSign(44, "^");
    case 37:
    case 38:
      return this.parseTopicReference("hack");
    case 44:
    case 54:
    case 27: {
      const n = this.getPluginOption("pipelineOperator", "proposal");
      if (n)
        return this.parseTopicReference(n);
      this.unexpected();
      break;
    }
    case 47: {
      const n = this.input.codePointAt(this.nextTokenStart());
      Xt(n) || n === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
      break;
    }
    default:
      if (Be(s)) {
        if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
          return this.parseModuleExpression();
        const n = this.state.potentialArrowAt === this.state.start, a = this.state.containsEsc, o = this.parseIdentifier();
        if (!a && o.name === "async" && !this.canInsertSemicolon()) {
          const {
            type: u
          } = this.state;
          if (u === 68)
            return this.resetPreviousNodeTrailingComments(o), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o));
          if (Be(u))
            return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o)) : o;
          if (u === 90)
            return this.resetPreviousNodeTrailingComments(o), this.parseDo(this.startNodeAtNode(o), !0);
        }
        return n && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o), [o], !1)) : o;
      } else
        this.unexpected();
  }
}
parseTopicReferenceThenEqualsSign(t, r) {
  const i = this.getPluginOption("pipelineOperator", "proposal");
  if (i)
    return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = gt(this.state.endLoc, -1), this.parseTopicReference(i);
  this.unexpected();
}
parseTopicReference(t) {
  const r = this.startNode(), i = this.state.startLoc, s = this.state.type;
  return this.next(), this.finishTopicReference(r, i, t, s);
}
finishTopicReference(t, r, i, s) {
  if (this.testTopicReferenceConfiguration(i, r, s)) {
    const n = i === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
    return this.topicReferenceIsAllowedInCurrentContext() || this.raise(i === "smart" ? w.PrimaryTopicNotAllowed : w.PipeTopicUnbound, r), this.registerTopicReference(), this.finishNode(t, n);
  } else
    throw this.raise(w.PipeTopicUnconfiguredToken, r, {
      token: or(s)
    });
}
testTopicReferenceConfiguration(t, r, i) {
  switch (t) {
    case "hack":
      return this.hasPlugin(["pipelineOperator", {
        topicToken: or(i)
      }]);
    case "smart":
      return i === 27;
    default:
      throw this.raise(w.PipeTopicRequiresHackPipes, r);
  }
}
parseAsyncArrowUnaryFunction(t) {
  this.prodParam.enter(os(!0, this.prodParam.hasYield));
  const r = [this.parseIdentifier()];
  return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(w.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(t, r, !0);
}
parseDo(t, r) {
  this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
  const i = this.state.labels;
  return this.state.labels = [], r ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = i, this.finishNode(t, "DoExpression");
}
parseSuper() {
  const t = this.startNode();
  return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(w.SuperNotAllowed, t) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(w.UnexpectedSuper, t), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(w.UnsupportedSuper, t), this.finishNode(t, "Super");
}
parsePrivateName() {
  const t = this.startNode(), r = this.startNodeAt(gt(this.state.startLoc, 1)), i = this.state.value;
  return this.next(), t.id = this.createIdentifier(r, i), this.finishNode(t, "PrivateName");
}
parseFunctionOrFunctionSent() {
  const t = this.startNode();
  if (this.next(), this.prodParam.hasYield && this.match(16)) {
    const r = this.createIdentifier(this.startNodeAtNode(t), "function");
    return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, r, "sent");
  }
  return this.parseFunction(t);
}
parseMetaProperty(t, r, i) {
  t.meta = r;
  const s = this.state.containsEsc;
  return t.property = this.parseIdentifier(!0), (t.property.name !== i || s) && this.raise(w.UnsupportedMetaProperty, t.property, {
    target: r.name,
    onlyValidPropertyName: i
  }), this.finishNode(t, "MetaProperty");
}
parseImportMetaProperty(t) {
  const r = this.createIdentifier(this.startNodeAtNode(t), "import");
  if (this.next(), this.isContextual(101))
    this.inModule || this.raise(w.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
  else if (this.isContextual(105) || this.isContextual(97)) {
    const i = this.isContextual(105);
    if (i || this.unexpected(), this.expectPlugin(i ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
      throw this.raise(w.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
        phase: this.state.value
      });
    return this.next(), t.phase = i ? "source" : "defer", this.parseImportCall(t);
  }
  return this.parseMetaProperty(t, r, "meta");
}
parseLiteralAtNode(t, r, i) {
  return this.addExtra(i, "rawValue", t), this.addExtra(i, "raw", this.input.slice(i.start, this.state.end)), i.value = t, this.next(), this.finishNode(i, r);
}
parseLiteral(t, r) {
  const i = this.startNode();
  return this.parseLiteralAtNode(t, r, i);
}
parseStringLiteral(t) {
  return this.parseLiteral(t, "StringLiteral");
}
parseNumericLiteral(t) {
  return this.parseLiteral(t, "NumericLiteral");
}
parseBigIntLiteral(t) {
  return this.parseLiteral(t, "BigIntLiteral");
}
parseDecimalLiteral(t) {
  return this.parseLiteral(t, "DecimalLiteral");
}
parseRegExpLiteral(t) {
  const r = this.startNode();
  return this.addExtra(r, "raw", this.input.slice(r.start, this.state.end)), r.pattern = t.pattern, r.flags = t.flags, this.next(), this.finishNode(r, "RegExpLiteral");
}
parseBooleanLiteral(t) {
  const r = this.startNode();
  return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
}
parseNullLiteral() {
  const t = this.startNode();
  return this.next(), this.finishNode(t, "NullLiteral");
}
parseParenAndDistinguishExpression(t) {
  const r = this.state.startLoc;
  let i;
  this.next(), this.expressionScope.enter(B5());
  const s = this.state.maybeInArrowParameters, n = this.state.inFSharpPipelineDirectBody;
  this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
  const a = this.state.startLoc, o = [], u = new us();
  let l = !0, c, f;
  for (; !this.match(11); ) {
    if (l)
      l = !1;
    else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
      f = this.state.startLoc;
      break;
    }
    if (this.match(21)) {
      const y = this.state.startLoc;
      if (c = this.state.startLoc, o.push(this.parseParenItem(this.parseRestBinding(), y)), !this.checkCommaAfterRest(41))
        break;
    } else
      o.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
  }
  const p = this.state.lastTokEndLoc;
  this.expect(11), this.state.maybeInArrowParameters = s, this.state.inFSharpPipelineDirectBody = n;
  let h = this.startNodeAt(r);
  return t && this.shouldParseArrow(o) && (h = this.parseArrow(h)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(h, o, !1), h) : (this.expressionScope.exit(), o.length || this.unexpected(this.state.lastTokStartLoc), f && this.unexpected(f), c && this.unexpected(c), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(o, !0), o.length > 1 ? (i = this.startNodeAt(a), i.expressions = o, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i, p)) : i = o[0], this.wrapParenthesis(r, i));
}
wrapParenthesis(t, r) {
  if (!this.options.createParenthesizedExpressions)
    return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.state.lastTokEndLoc.index), r;
  const i = this.startNodeAt(t);
  return i.expression = r, this.finishNode(i, "ParenthesizedExpression");
}
shouldParseArrow(t) {
  return !this.canInsertSemicolon();
}
parseArrow(t) {
  if (this.eat(19))
    return t;
}
parseParenItem(t, r) {
  return t;
}
parseNewOrNewTarget() {
  const t = this.startNode();
  if (this.next(), this.match(16)) {
    const r = this.createIdentifier(this.startNodeAtNode(t), "new");
    this.next();
    const i = this.parseMetaProperty(t, r, "target");
    return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(w.UnexpectedNewTarget, i), i;
  }
  return this.parseNew(t);
}
parseNew(t) {
  if (this.parseNewCallee(t), this.eat(10)) {
    const r = this.parseExprList(11);
    this.toReferencedList(r), t.arguments = r;
  } else
    t.arguments = [];
  return this.finishNode(t, "NewExpression");
}
parseNewCallee(t) {
  const r = this.match(83), i = this.parseNoCallExpr();
  t.callee = i, r && (i.type === "Import" || i.type === "ImportExpression") && this.raise(w.ImportCallNotNewExpression, i);
}
parseTemplateElement(t) {
  const {
    start: r,
    startLoc: i,
    end: s,
    value: n
  } = this.state, a = r + 1, o = this.startNodeAt(gt(i, 1));
  n === null && (t || this.raise(w.InvalidEscapeSequenceTemplate, gt(this.state.firstInvalidTemplateEscapePos, 1)));
  const u = this.match(24), l = u ? -1 : -2, c = s + l;
  o.value = {
    raw: this.input.slice(a, c).replace(/\r\n?/g, `
`),
    cooked: n === null ? null : n.slice(1, l)
  }, o.tail = u, this.next();
  const f = this.finishNode(o, "TemplateElement");
  return this.resetEndLocation(f, gt(this.state.lastTokEndLoc, l)), f;
}
parseTemplate(t) {
  const r = this.startNode();
  let i = this.parseTemplateElement(t);
  const s = [i], n = [];
  for (; !i.tail; )
    n.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), s.push(i = this.parseTemplateElement(t));
  return r.expressions = n, r.quasis = s, this.finishNode(r, "TemplateLiteral");
}
parseTemplateSubstitution() {
  return this.parseExpression();
}
parseObjectLike(t, r, i, s) {
  i && this.expectPlugin("recordAndTuple");
  const n = this.state.inFSharpPipelineDirectBody;
  this.state.inFSharpPipelineDirectBody = !1;
  const a = /* @__PURE__ */ Object.create(null);
  let o = !0;
  const u = this.startNode();
  for (u.properties = [], this.next(); !this.match(t); ) {
    if (o)
      o = !1;
    else if (this.expect(12), this.match(t)) {
      this.addTrailingCommaExtraToNode(u);
      break;
    }
    let c;
    r ? c = this.parseBindingProperty() : (c = this.parsePropertyDefinition(s), this.checkProto(c, i, a, s)), i && !this.isObjectProperty(c) && c.type !== "SpreadElement" && this.raise(w.InvalidRecordProperty, c), c.shorthand && this.addExtra(c, "shorthand", !0), u.properties.push(c);
  }
  this.next(), this.state.inFSharpPipelineDirectBody = n;
  let l = "ObjectExpression";
  return r ? l = "ObjectPattern" : i && (l = "RecordExpression"), this.finishNode(u, l);
}
addTrailingCommaExtraToNode(t) {
  this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
}
maybeAsyncOrAccessorProp(t) {
  return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
}
parsePropertyDefinition(t) {
  let r = [];
  if (this.match(26))
    for (this.hasPlugin("decorators") && this.raise(w.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
      r.push(this.parseDecorator());
  const i = this.startNode();
  let s = !1, n = !1, a;
  if (this.match(21))
    return r.length && this.unexpected(), this.parseSpread();
  r.length && (i.decorators = r, r = []), i.method = !1, t && (a = this.state.startLoc);
  let o = this.eat(55);
  this.parsePropertyNamePrefixOperator(i);
  const u = this.state.containsEsc;
  if (this.parsePropertyName(i, t), !o && !u && this.maybeAsyncOrAccessorProp(i)) {
    const {
      key: l
    } = i, c = l.name;
    c === "async" && !this.hasPrecedingLineBreak() && (s = !0, this.resetPreviousNodeTrailingComments(l), o = this.eat(55), this.parsePropertyName(i)), (c === "get" || c === "set") && (n = !0, this.resetPreviousNodeTrailingComments(l), i.kind = c, this.match(55) && (o = !0, this.raise(w.AccessorIsGenerator, this.state.curPosition(), {
      kind: c
    }), this.next()), this.parsePropertyName(i));
  }
  return this.parseObjPropValue(i, a, o, s, !1, n, t);
}
getGetterSetterExpectedParamCount(t) {
  return t.kind === "get" ? 0 : 1;
}
getObjectOrClassMethodParams(t) {
  return t.params;
}
checkGetterSetterParams(t) {
  var r;
  const i = this.getGetterSetterExpectedParamCount(t), s = this.getObjectOrClassMethodParams(t);
  s.length !== i && this.raise(t.kind === "get" ? w.BadGetterArity : w.BadSetterArity, t), t.kind === "set" && ((r = s[s.length - 1]) == null ? void 0 : r.type) === "RestElement" && this.raise(w.BadSetterRestParameter, t);
}
parseObjectMethod(t, r, i, s, n) {
  if (n) {
    const a = this.parseMethod(t, r, !1, !1, !1, "ObjectMethod");
    return this.checkGetterSetterParams(a), a;
  }
  if (i || r || this.match(10))
    return s && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, r, i, !1, !1, "ObjectMethod");
}
parseObjectProperty(t, r, i, s) {
  if (t.shorthand = !1, this.eat(14))
    return t.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(s), this.finishNode(t, "ObjectProperty");
  if (!t.computed && t.key.type === "Identifier") {
    if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), i)
      t.value = this.parseMaybeDefault(r, Gt(t.key));
    else if (this.match(29)) {
      const n = this.state.startLoc;
      s != null ? s.shorthandAssignLoc === null && (s.shorthandAssignLoc = n) : this.raise(w.InvalidCoverInitializedName, n), t.value = this.parseMaybeDefault(r, Gt(t.key));
    } else
      t.value = Gt(t.key);
    return t.shorthand = !0, this.finishNode(t, "ObjectProperty");
  }
}
parseObjPropValue(t, r, i, s, n, a, o) {
  const u = this.parseObjectMethod(t, i, s, n, a) || this.parseObjectProperty(t, r, n, o);
  return u || this.unexpected(), u;
}
parsePropertyName(t, r) {
  if (this.eat(0))
    t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
  else {
    const {
      type: i,
      value: s
    } = this.state;
    let n;
    if (_t(i))
      n = this.parseIdentifier(!0);
    else
      switch (i) {
        case 134:
          n = this.parseNumericLiteral(s);
          break;
        case 133:
          n = this.parseStringLiteral(s);
          break;
        case 135:
          n = this.parseBigIntLiteral(s);
          break;
        case 136:
          n = this.parseDecimalLiteral(s);
          break;
        case 138: {
          const a = this.state.startLoc;
          r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = a) : this.raise(w.UnexpectedPrivateField, a), n = this.parsePrivateName();
          break;
        }
        default:
          this.unexpected();
      }
    t.key = n, i !== 138 && (t.computed = !1);
  }
}
initFunction(t, r) {
  t.id = null, t.generator = !1, t.async = r;
}
parseMethod(t, r, i, s, n, a, o = !1) {
  this.initFunction(t, i), t.generator = r, this.scope.enter(18 | (o ? 64 : 0) | (n ? 32 : 0)), this.prodParam.enter(os(i, t.generator)), this.parseFunctionParams(t, s);
  const u = this.parseFunctionBodyAndFinish(t, a, !0);
  return this.prodParam.exit(), this.scope.exit(), u;
}
parseArrayLike(t, r, i, s) {
  i && this.expectPlugin("recordAndTuple");
  const n = this.state.inFSharpPipelineDirectBody;
  this.state.inFSharpPipelineDirectBody = !1;
  const a = this.startNode();
  return this.next(), a.elements = this.parseExprList(t, !i, s, a), this.state.inFSharpPipelineDirectBody = n, this.finishNode(a, i ? "TupleExpression" : "ArrayExpression");
}
parseArrowExpression(t, r, i, s) {
  this.scope.enter(6);
  let n = os(i, !1);
  !this.match(5) && this.prodParam.hasIn && (n |= 8), this.prodParam.enter(n), this.initFunction(t, i);
  const a = this.state.maybeInArrowParameters;
  return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, r, s)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a, this.finishNode(t, "ArrowFunctionExpression");
}
setArrowFunctionParameters(t, r, i) {
  this.toAssignableList(r, i, !1), t.params = r;
}
parseFunctionBodyAndFinish(t, r, i = !1) {
  return this.parseFunctionBody(t, !1, i), this.finishNode(t, r);
}
parseFunctionBody(t, r, i = !1) {
  const s = r && !this.match(5);
  if (this.expressionScope.enter(If()), s)
    t.body = this.parseMaybeAssign(), this.checkParams(t, !1, r, !1);
  else {
    const n = this.state.strict, a = this.state.labels;
    this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (o) => {
      const u = !this.isSimpleParamList(t.params);
      o && u && this.raise(w.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
      const l = !n && this.state.strict;
      this.checkParams(t, !this.state.strict && !r && !i && !u, r, l), this.state.strict && t.id && this.checkIdentifier(t.id, 65, l);
    }), this.prodParam.exit(), this.state.labels = a;
  }
  this.expressionScope.exit();
}
isSimpleParameter(t) {
  return t.type === "Identifier";
}
isSimpleParamList(t) {
  for (let r = 0, i = t.length; r < i; r++)
    if (!this.isSimpleParameter(t[r])) return !1;
  return !0;
}
checkParams(t, r, i, s = !0) {
  const n = !r && /* @__PURE__ */ new Set(), a = {
    type: "FormalParameters"
  };
  for (const o of t.params)
    this.checkLVal(o, {
      in: a,
      binding: 5,
      checkClashes: n,
      strictModeChanged: s
    });
}
parseExprList(t, r, i, s) {
  const n = [];
  let a = !0;
  for (; !this.eat(t); ) {
    if (a)
      a = !1;
    else if (this.expect(12), this.match(t)) {
      s && this.addTrailingCommaExtraToNode(s), this.next();
      break;
    }
    n.push(this.parseExprListItem(r, i));
  }
  return n;
}
parseExprListItem(t, r, i) {
  let s;
  if (this.match(12))
    t || this.raise(w.UnexpectedToken, this.state.curPosition(), {
      unexpected: ","
    }), s = null;
  else if (this.match(21)) {
    const n = this.state.startLoc;
    s = this.parseParenItem(this.parseSpread(r), n);
  } else if (this.match(17)) {
    this.expectPlugin("partialApplication"), i || this.raise(w.UnexpectedArgumentPlaceholder, this.state.startLoc);
    const n = this.startNode();
    this.next(), s = this.finishNode(n, "ArgumentPlaceholder");
  } else
    s = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
  return s;
}
parseIdentifier(t) {
  const r = this.startNode(), i = this.parseIdentifierName(t);
  return this.createIdentifier(r, i);
}
createIdentifier(t, r) {
  return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
}
parseIdentifierName(t) {
  let r;
  const {
    startLoc: i,
    type: s
  } = this.state;
  _t(s) ? r = this.state.value : this.unexpected();
  const n = t5(s);
  return t ? n && this.replaceToken(132) : this.checkReservedWord(r, i, n, !1), this.next(), r;
}
checkReservedWord(t, r, i, s) {
  if (t.length > 10 || !S5(t))
    return;
  if (i && b5(t)) {
    this.raise(w.UnexpectedKeyword, r, {
      keyword: t
    });
    return;
  }
  if ((this.state.strict ? s ? Sf : Tf : bf)(t, this.inModule)) {
    this.raise(w.UnexpectedReservedWord, r, {
      reservedWord: t
    });
    return;
  } else if (t === "yield") {
    if (this.prodParam.hasYield) {
      this.raise(w.YieldBindingIdentifier, r);
      return;
    }
  } else if (t === "await") {
    if (this.prodParam.hasAwait) {
      this.raise(w.AwaitBindingIdentifier, r);
      return;
    }
    if (this.scope.inStaticBlock) {
      this.raise(w.AwaitBindingIdentifierInStaticBlock, r);
      return;
    }
    this.expressionScope.recordAsyncArrowParametersError(r);
  } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
    this.raise(w.ArgumentsInClass, r);
    return;
  }
}
isAwaitAllowed() {
  return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
}
parseAwait(t) {
  const r = this.startNodeAt(t);
  return this.expressionScope.recordParameterInitializerError(w.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(w.ObsoleteAwaitStar, r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExpression");
}
isAmbiguousAwait() {
  if (this.hasPrecedingLineBreak()) return !0;
  const {
    type: t
  } = this.state;
  return t === 53 || t === 10 || t === 0 || hs(t) || t === 102 && !this.state.containsEsc || t === 137 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
}
parseYield() {
  const t = this.startNode();
  this.expressionScope.recordParameterInitializerError(w.YieldInParameter, t), this.next();
  let r = !1, i = null;
  if (!this.hasPrecedingLineBreak())
    switch (r = this.eat(55), this.state.type) {
      case 13:
      case 139:
      case 8:
      case 11:
      case 3:
      case 9:
      case 14:
      case 12:
        if (!r) break;
      default:
        i = this.parseMaybeAssign();
    }
  return t.delegate = r, t.argument = i, this.finishNode(t, "YieldExpression");
}
parseImportCall(t) {
  return this.next(), t.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (t.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(t, "ImportExpression");
}
checkPipelineAtInfixOperator(t, r) {
  this.hasPlugin(["pipelineOperator", {
    proposal: "smart"
  }]) && t.type === "SequenceExpression" && this.raise(w.PipelineHeadSequenceExpression, r);
}
parseSmartPipelineBodyInStyle(t, r) {
  if (this.isSimpleReference(t)) {
    const i = this.startNodeAt(r);
    return i.callee = t, this.finishNode(i, "PipelineBareFunction");
  } else {
    const i = this.startNodeAt(r);
    return this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = t, this.finishNode(i, "PipelineTopicExpression");
  }
}
isSimpleReference(t) {
  switch (t.type) {
    case "MemberExpression":
      return !t.computed && this.isSimpleReference(t.object);
    case "Identifier":
      return !0;
    default:
      return !1;
  }
}
checkSmartPipeTopicBodyEarlyErrors(t) {
  if (this.match(19))
    throw this.raise(w.PipelineBodyNoArrow, this.state.startLoc);
  this.topicReferenceWasUsedInCurrentContext() || this.raise(w.PipelineTopicUnused, t);
}
withTopicBindingContext(t) {
  const r = this.state.topicContext;
  this.state.topicContext = {
    maxNumOfResolvableTopics: 1,
    maxTopicIndex: null
  };
  try {
    return t();
  } finally {
    this.state.topicContext = r;
  }
}
withSmartMixTopicForbiddingContext(t) {
  if (this.hasPlugin(["pipelineOperator", {
    proposal: "smart"
  }])) {
    const r = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    };
    try {
      return t();
    } finally {
      this.state.topicContext = r;
    }
  } else
    return t();
}
withSoloAwaitPermittingContext(t) {
  const r = this.state.soloAwait;
  this.state.soloAwait = !0;
  try {
    return t();
  } finally {
    this.state.soloAwait = r;
  }
}
allowInAnd(t) {
  const r = this.prodParam.currentFlags();
  if (8 & ~r) {
    this.prodParam.enter(r | 8);
    try {
      return t();
    } finally {
      this.prodParam.exit();
    }
  }
  return t();
}
disallowInAnd(t) {
  const r = this.prodParam.currentFlags();
  if (8 & r) {
    this.prodParam.enter(r & -9);
    try {
      return t();
    } finally {
      this.prodParam.exit();
    }
  }
  return t();
}
registerTopicReference() {
  this.state.topicContext.maxTopicIndex = 0;
}
topicReferenceIsAllowedInCurrentContext() {
  return this.state.topicContext.maxNumOfResolvableTopics >= 1;
}
topicReferenceWasUsedInCurrentContext() {
  return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
}
parseFSharpPipelineBody(t) {
  const r = this.state.startLoc;
  this.state.potentialArrowAt = this.state.start;
  const i = this.state.inFSharpPipelineDirectBody;
  this.state.inFSharpPipelineDirectBody = !0;
  const s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
  return this.state.inFSharpPipelineDirectBody = i, s;
}
parseModuleExpression() {
  this.expectPlugin("moduleBlocks");
  const t = this.startNode();
  this.next(), this.match(5) || this.unexpected(null, 5);
  const r = this.startNodeAt(this.state.endLoc);
  this.next();
  const i = this.initializeScopes(!0);
  this.enterInitialScopes();
  try {
    t.body = this.parseProgram(r, 8, "module");
  } finally {
    i();
  }
  return this.finishNode(t, "ModuleExpression");
}
parsePropertyNamePrefixOperator(t) {
}
}
const Cn = {
kind: 1
}, m_ = {
kind: 2
}, y_ = /[\uD800-\uDFFF]/u, wn = /in(?:stanceof)?/y;
function b_(e, t) {
for (let r = 0; r < e.length; r++) {
  const i = e[r], {
    type: s
  } = i;
  if (typeof s == "number") {
    {
      if (s === 138) {
        const {
          loc: n,
          start: a,
          value: o,
          end: u
        } = i, l = a + 1, c = gt(n.start, 1);
        e.splice(r, 1, new ir({
          type: Kt(27),
          value: "#",
          start: a,
          end: l,
          startLoc: n.start,
          endLoc: c
        }), new ir({
          type: Kt(132),
          value: o,
          start: l,
          end: u,
          startLoc: c,
          endLoc: n.end
        })), r++;
        continue;
      }
      if (hs(s)) {
        const {
          loc: n,
          start: a,
          value: o,
          end: u
        } = i, l = a + 1, c = gt(n.start, 1);
        let f;
        t.charCodeAt(a) === 96 ? f = new ir({
          type: Kt(22),
          value: "`",
          start: a,
          end: l,
          startLoc: n.start,
          endLoc: c
        }) : f = new ir({
          type: Kt(8),
          value: "}",
          start: a,
          end: l,
          startLoc: n.start,
          endLoc: c
        });
        let p, h, y, g;
        s === 24 ? (h = u - 1, y = gt(n.end, -1), p = o === null ? null : o.slice(1, -1), g = new ir({
          type: Kt(22),
          value: "`",
          start: h,
          end: u,
          startLoc: y,
          endLoc: n.end
        })) : (h = u - 2, y = gt(n.end, -2), p = o === null ? null : o.slice(1, -2), g = new ir({
          type: Kt(23),
          value: "${",
          start: h,
          end: u,
          startLoc: y,
          endLoc: n.end
        })), e.splice(r, 1, f, new ir({
          type: Kt(20),
          value: p,
          start: l,
          end: h,
          startLoc: c,
          endLoc: y
        }), g), r += 2;
        continue;
      }
    }
    i.type = Kt(s);
  }
}
return e;
}
class T_ extends d_ {
parseTopLevel(t, r) {
  return t.program = this.parseProgram(r), t.comments = this.comments, this.options.tokens && (t.tokens = b_(this.tokens, this.input)), this.finishNode(t, "File");
}
parseProgram(t, r = 139, i = this.options.sourceType) {
  if (t.sourceType = i, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, r), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
    for (const [n, a] of Array.from(this.scope.undefinedExports))
      this.raise(w.ModuleExportUndefined, a, {
        localName: n
      });
  let s;
  return r === 139 ? s = this.finishNode(t, "Program") : s = this.finishNodeAt(t, "Program", gt(this.state.startLoc, -1)), s;
}
stmtToDirective(t) {
  const r = t;
  r.type = "Directive", r.value = r.expression, delete r.expression;
  const i = r.value, s = i.value, n = this.input.slice(i.start, i.end), a = i.value = n.slice(1, -1);
  return this.addExtra(i, "raw", n), this.addExtra(i, "rawValue", a), this.addExtra(i, "expressionValue", s), i.type = "DirectiveLiteral", r;
}
parseInterpreterDirective() {
  if (!this.match(28))
    return null;
  const t = this.startNode();
  return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
}
isLet() {
  return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
}
chStartsBindingIdentifier(t, r) {
  if (Xt(t)) {
    if (wn.lastIndex = r, wn.test(this.input)) {
      const i = this.codePointAtPos(wn.lastIndex);
      if (!Or(i) && i !== 92)
        return !1;
    }
    return !0;
  } else return t === 92;
}
chStartsBindingPattern(t) {
  return t === 91 || t === 123;
}
hasFollowingBindingAtom() {
  const t = this.nextTokenStart(), r = this.codePointAtPos(t);
  return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
}
hasInLineFollowingBindingIdentifierOrBrace() {
  const t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
  return r === 123 || this.chStartsBindingIdentifier(r, t);
}
startsUsingForOf() {
  const {
    type: t,
    containsEsc: r
  } = this.lookahead();
  if (t === 102 && !r)
    return !1;
  if (Be(t) && !this.hasFollowingLineBreak())
    return this.expectPlugin("explicitResourceManagement"), !0;
}
startsAwaitUsing() {
  let t = this.nextTokenInLineStart();
  if (this.isUnparsedContextual(t, "using")) {
    t = this.nextTokenInLineStartSince(t + 5);
    const r = this.codePointAtPos(t);
    if (this.chStartsBindingIdentifier(r, t))
      return this.expectPlugin("explicitResourceManagement"), !0;
  }
  return !1;
}
parseModuleItem() {
  return this.parseStatementLike(15);
}
parseStatementListItem() {
  return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
}
parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
  let r = 0;
  return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
}
parseStatement() {
  return this.parseStatementLike(0);
}
parseStatementLike(t) {
  let r = null;
  return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(t, r);
}
parseStatementContent(t, r) {
  const i = this.state.type, s = this.startNode(), n = !!(t & 2), a = !!(t & 4), o = t & 1;
  switch (i) {
    case 60:
      return this.parseBreakContinueStatement(s, !0);
    case 63:
      return this.parseBreakContinueStatement(s, !1);
    case 64:
      return this.parseDebuggerStatement(s);
    case 90:
      return this.parseDoWhileStatement(s);
    case 91:
      return this.parseForStatement(s);
    case 68:
      if (this.lookaheadCharCode() === 46) break;
      return a || this.raise(this.state.strict ? w.StrictFunction : this.options.annexB ? w.SloppyFunctionAnnexB : w.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(s, !1, !n && a);
    case 80:
      return n || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, s), !0);
    case 69:
      return this.parseIfStatement(s);
    case 70:
      return this.parseReturnStatement(s);
    case 71:
      return this.parseSwitchStatement(s);
    case 72:
      return this.parseThrowStatement(s);
    case 73:
      return this.parseTryStatement(s);
    case 96:
      if (!this.state.containsEsc && this.startsAwaitUsing())
        return this.isAwaitAllowed() ? n || this.raise(w.UnexpectedLexicalDeclaration, s) : this.raise(w.AwaitUsingNotInAsyncContext, s), this.next(), this.parseVarStatement(s, "await using");
      break;
    case 107:
      if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
        break;
      return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(w.UnexpectedUsingDeclaration, this.state.startLoc) : n || this.raise(w.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(s, "using");
    case 100: {
      if (this.state.containsEsc)
        break;
      const c = this.nextTokenStart(), f = this.codePointAtPos(c);
      if (f !== 91 && (!n && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, c) && f !== 123))
        break;
    }
    case 75:
      n || this.raise(w.UnexpectedLexicalDeclaration, this.state.startLoc);
    case 74: {
      const c = this.state.value;
      return this.parseVarStatement(s, c);
    }
    case 92:
      return this.parseWhileStatement(s);
    case 76:
      return this.parseWithStatement(s);
    case 5:
      return this.parseBlock();
    case 13:
      return this.parseEmptyStatement(s);
    case 83: {
      const c = this.lookaheadCharCode();
      if (c === 40 || c === 46)
        break;
    }
    case 82: {
      !this.options.allowImportExportEverywhere && !o && this.raise(w.UnexpectedImportExport, this.state.startLoc), this.next();
      let c;
      return i === 83 ? (c = this.parseImport(s), c.type === "ImportDeclaration" && (!c.importKind || c.importKind === "value") && (this.sawUnambiguousESM = !0)) : (c = this.parseExport(s, r), (c.type === "ExportNamedDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportAllDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(c), c;
    }
    default:
      if (this.isAsyncFunction())
        return n || this.raise(w.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(s, !0, !n && a);
  }
  const u = this.state.value, l = this.parseExpression();
  return Be(i) && l.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(s, u, l, t) : this.parseExpressionStatement(s, l, r);
}
assertModuleNodeAllowed(t) {
  !this.options.allowImportExportEverywhere && !this.inModule && this.raise(w.ImportOutsideModule, t);
}
decoratorsEnabledBeforeExport() {
  return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
}
maybeTakeDecorators(t, r, i) {
  return t && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(w.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(r, t[0]), i && this.resetStartLocationFromNode(i, r)), r;
}
canHaveLeadingDecorator() {
  return this.match(80);
}
parseDecorators(t) {
  const r = [];
  do
    r.push(this.parseDecorator());
  while (this.match(26));
  if (this.match(82))
    t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(w.DecoratorExportClass, this.state.startLoc);
  else if (!this.canHaveLeadingDecorator())
    throw this.raise(w.UnexpectedLeadingDecorator, this.state.startLoc);
  return r;
}
parseDecorator() {
  this.expectOnePlugin(["decorators", "decorators-legacy"]);
  const t = this.startNode();
  if (this.next(), this.hasPlugin("decorators")) {
    const r = this.state.startLoc;
    let i;
    if (this.match(10)) {
      const s = this.state.startLoc;
      this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(s, i);
      const n = this.state.startLoc;
      t.expression = this.parseMaybeDecoratorArguments(i), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !== i && this.raise(w.DecoratorArgumentsOutsideParentheses, n);
    } else {
      for (i = this.parseIdentifier(!1); this.eat(16); ) {
        const s = this.startNodeAt(r);
        s.object = i, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), s.property = this.parsePrivateName()) : s.property = this.parseIdentifier(!0), s.computed = !1, i = this.finishNode(s, "MemberExpression");
      }
      t.expression = this.parseMaybeDecoratorArguments(i);
    }
  } else
    t.expression = this.parseExprSubscripts();
  return this.finishNode(t, "Decorator");
}
parseMaybeDecoratorArguments(t) {
  if (this.eat(10)) {
    const r = this.startNodeAtNode(t);
    return r.callee = t, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r, "CallExpression");
  }
  return t;
}
parseBreakContinueStatement(t, r) {
  return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
}
verifyBreakContinue(t, r) {
  let i;
  for (i = 0; i < this.state.labels.length; ++i) {
    const s = this.state.labels[i];
    if ((t.label == null || s.name === t.label.name) && (s.kind != null && (r || s.kind === 1) || t.label && r))
      break;
  }
  if (i === this.state.labels.length) {
    const s = r ? "BreakStatement" : "ContinueStatement";
    this.raise(w.IllegalBreakContinue, t, {
      type: s
    });
  }
}
parseDebuggerStatement(t) {
  return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
}
parseHeaderExpression() {
  this.expect(10);
  const t = this.parseExpression();
  return this.expect(11), t;
}
parseDoWhileStatement(t) {
  return this.next(), this.state.labels.push(Cn), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
}
parseForStatement(t) {
  this.next(), this.state.labels.push(Cn);
  let r = null;
  if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
    return r !== null && this.unexpected(r), this.parseFor(t, null);
  const i = this.isContextual(100);
  {
    const u = this.isContextual(96) && this.startsAwaitUsing(), l = u || this.isContextual(107) && this.startsUsingForOf(), c = i && this.hasFollowingBindingAtom() || l;
    if (this.match(74) || this.match(75) || c) {
      const f = this.startNode();
      let p;
      u ? (p = "await using", this.isAwaitAllowed() || this.raise(w.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : p = this.state.value, this.next(), this.parseVar(f, !0, p);
      const h = this.finishNode(f, "VariableDeclaration"), y = this.match(58);
      return y && l && this.raise(w.ForInUsing, h), (y || this.isContextual(102)) && h.declarations.length === 1 ? this.parseForIn(t, h, r) : (r !== null && this.unexpected(r), this.parseFor(t, h));
    }
  }
  const s = this.isContextual(95), n = new us(), a = this.parseExpression(!0, n), o = this.isContextual(102);
  if (o && (i && this.raise(w.ForOfLet, a), r === null && s && a.type === "Identifier" && this.raise(w.ForOfAsync, a)), o || this.match(58)) {
    this.checkDestructuringPrivate(n), this.toAssignable(a, !0);
    const u = o ? "ForOfStatement" : "ForInStatement";
    return this.checkLVal(a, {
      in: {
        type: u
      }
    }), this.parseForIn(t, a, r);
  } else
    this.checkExpressionErrors(n, !0);
  return r !== null && this.unexpected(r), this.parseFor(t, a);
}
parseFunctionStatement(t, r, i) {
  return this.next(), this.parseFunction(t, 1 | (i ? 2 : 0) | (r ? 8 : 0));
}
parseIfStatement(t) {
  return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
}
parseReturnStatement(t) {
  return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(w.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
}
parseSwitchStatement(t) {
  this.next(), t.discriminant = this.parseHeaderExpression();
  const r = t.cases = [];
  this.expect(5), this.state.labels.push(m_), this.scope.enter(0);
  let i;
  for (let s; !this.match(8); )
    if (this.match(61) || this.match(65)) {
      const n = this.match(61);
      i && this.finishNode(i, "SwitchCase"), r.push(i = this.startNode()), i.consequent = [], this.next(), n ? i.test = this.parseExpression() : (s && this.raise(w.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), s = !0, i.test = null), this.expect(14);
    } else
      i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
  return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
}
parseThrowStatement(t) {
  return this.next(), this.hasPrecedingLineBreak() && this.raise(w.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
}
parseCatchClauseParam() {
  const t = this.parseBindingAtom();
  return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {
    in: {
      type: "CatchClause"
    },
    binding: 9
  }), t;
}
parseTryStatement(t) {
  if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
    const r = this.startNode();
    this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(r, "CatchClause");
  }
  return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(w.NoCatchOrFinally, t), this.finishNode(t, "TryStatement");
}
parseVarStatement(t, r, i = !1) {
  return this.next(), this.parseVar(t, !1, r, i), this.semicolon(), this.finishNode(t, "VariableDeclaration");
}
parseWhileStatement(t) {
  return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(Cn), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
}
parseWithStatement(t) {
  return this.state.strict && this.raise(w.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
}
parseEmptyStatement(t) {
  return this.next(), this.finishNode(t, "EmptyStatement");
}
parseLabeledStatement(t, r, i, s) {
  for (const a of this.state.labels)
    a.name === r && this.raise(w.LabelRedeclaration, i, {
      labelName: r
    });
  const n = s5(this.state.type) ? 1 : this.match(71) ? 2 : null;
  for (let a = this.state.labels.length - 1; a >= 0; a--) {
    const o = this.state.labels[a];
    if (o.statementStart === t.start)
      o.statementStart = this.state.start, o.kind = n;
    else
      break;
  }
  return this.state.labels.push({
    name: r,
    kind: n,
    statementStart: this.state.start
  }), t.body = s & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label = i, this.finishNode(t, "LabeledStatement");
}
parseExpressionStatement(t, r, i) {
  return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
}
parseBlock(t = !1, r = !0, i) {
  const s = this.startNode();
  return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(s, t, !1, 8, i), r && this.scope.exit(), this.finishNode(s, "BlockStatement");
}
isValidDirective(t) {
  return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
}
parseBlockBody(t, r, i, s, n) {
  const a = t.body = [], o = t.directives = [];
  this.parseBlockOrModuleBlockBody(a, r ? o : void 0, i, s, n);
}
parseBlockOrModuleBlockBody(t, r, i, s, n) {
  const a = this.state.strict;
  let o = !1, u = !1;
  for (; !this.match(s); ) {
    const l = i ? this.parseModuleItem() : this.parseStatementListItem();
    if (r && !u) {
      if (this.isValidDirective(l)) {
        const c = this.stmtToDirective(l);
        r.push(c), !o && c.value.value === "use strict" && (o = !0, this.setStrict(!0));
        continue;
      }
      u = !0, this.state.strictErrors.clear();
    }
    t.push(l);
  }
  n == null || n.call(this, o), a || this.setStrict(!1), this.next();
}
parseFor(t, r) {
  return t.init = r, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
}
parseForIn(t, r, i) {
  const s = this.match(58);
  return this.next(), s ? i !== null && this.unexpected(i) : t.await = i !== null, r.type === "VariableDeclaration" && r.declarations[0].init != null && (!s || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") && this.raise(w.ForInOfLoopInitializer, r, {
    type: s ? "ForInStatement" : "ForOfStatement"
  }), r.type === "AssignmentPattern" && this.raise(w.InvalidLhs, r, {
    ancestor: {
      type: "ForStatement"
    }
  }), t.left = r, t.right = s ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, s ? "ForInStatement" : "ForOfStatement");
}
parseVar(t, r, i, s = !1) {
  const n = t.declarations = [];
  for (t.kind = i; ; ) {
    const a = this.startNode();
    if (this.parseVarId(a, i), a.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a.init === null && !s && (a.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(w.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
      kind: "destructuring"
    }) : (i === "const" || i === "using" || i === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(w.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
      kind: i
    })), n.push(this.finishNode(a, "VariableDeclarator")), !this.eat(12)) break;
  }
  return t;
}
parseVarId(t, r) {
  const i = this.parseBindingAtom();
  (r === "using" || r === "await using") && (i.type === "ArrayPattern" || i.type === "ObjectPattern") && this.raise(w.UsingDeclarationHasBindingPattern, i.loc.start), this.checkLVal(i, {
    in: {
      type: "VariableDeclarator"
    },
    binding: r === "var" ? 5 : 8201
  }), t.id = i;
}
parseAsyncFunctionExpression(t) {
  return this.parseFunction(t, 8);
}
parseFunction(t, r = 0) {
  const i = r & 2, s = !!(r & 1), n = s && !(r & 4), a = !!(r & 8);
  this.initFunction(t, a), this.match(55) && (i && this.raise(w.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.generator = !0), s && (t.id = this.parseFunctionId(n));
  const o = this.state.maybeInArrowParameters;
  return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(os(a, t.generator)), s || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
    this.parseFunctionBodyAndFinish(t, s ? "FunctionDeclaration" : "FunctionExpression");
  }), this.prodParam.exit(), this.scope.exit(), s && !i && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = o, t;
}
parseFunctionId(t) {
  return t || Be(this.state.type) ? this.parseIdentifier() : null;
}
parseFunctionParams(t, r) {
  this.expect(10), this.expressionScope.enter(M5()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
}
registerFunctionStatementId(t) {
  t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t.id.loc.start);
}
parseClass(t, r, i) {
  this.next();
  const s = this.state.strict;
  return this.state.strict = !0, this.parseClassId(t, r, i), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, s), this.finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
}
isClassProperty() {
  return this.match(29) || this.match(13) || this.match(8);
}
isClassMethod() {
  return this.match(10);
}
nameIsConstructor(t) {
  return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
}
isNonstaticConstructor(t) {
  return !t.computed && !t.static && this.nameIsConstructor(t.key);
}
parseClassBody(t, r) {
  this.classScope.enter();
  const i = {
    hadConstructor: !1,
    hadSuperClass: t
  };
  let s = [];
  const n = this.startNode();
  if (n.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
    for (; !this.match(8); ) {
      if (this.eat(13)) {
        if (s.length > 0)
          throw this.raise(w.DecoratorSemicolon, this.state.lastTokEndLoc);
        continue;
      }
      if (this.match(26)) {
        s.push(this.parseDecorator());
        continue;
      }
      const a = this.startNode();
      s.length && (a.decorators = s, this.resetStartLocationFromNode(a, s[0]), s = []), this.parseClassMember(n, a, i), a.kind === "constructor" && a.decorators && a.decorators.length > 0 && this.raise(w.DecoratorConstructor, a);
    }
  }), this.state.strict = r, this.next(), s.length)
    throw this.raise(w.TrailingDecorator, this.state.startLoc);
  return this.classScope.exit(), this.finishNode(n, "ClassBody");
}
parseClassMemberFromModifier(t, r) {
  const i = this.parseIdentifier(!0);
  if (this.isClassMethod()) {
    const s = r;
    return s.kind = "method", s.computed = !1, s.key = i, s.static = !1, this.pushClassMethod(t, s, !1, !1, !1, !1), !0;
  } else if (this.isClassProperty()) {
    const s = r;
    return s.computed = !1, s.key = i, s.static = !1, t.body.push(this.parseClassProperty(s)), !0;
  }
  return this.resetPreviousNodeTrailingComments(i), !1;
}
parseClassMember(t, r, i) {
  const s = this.isContextual(106);
  if (s) {
    if (this.parseClassMemberFromModifier(t, r))
      return;
    if (this.eat(5)) {
      this.parseClassStaticBlock(t, r);
      return;
    }
  }
  this.parseClassMemberWithIsStatic(t, r, i, s);
}
parseClassMemberWithIsStatic(t, r, i, s) {
  const n = r, a = r, o = r, u = r, l = r, c = n, f = n;
  if (r.static = s, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
    c.kind = "method";
    const C = this.match(138);
    if (this.parseClassElementName(c), C) {
      this.pushClassPrivateMethod(t, a, !0, !1);
      return;
    }
    this.isNonstaticConstructor(n) && this.raise(w.ConstructorIsGenerator, n.key), this.pushClassMethod(t, n, !0, !1, !1, !1);
    return;
  }
  const p = !this.state.containsEsc && Be(this.state.type), h = this.parseClassElementName(r), y = p ? h.name : null, g = this.isPrivateName(h), A = this.state.startLoc;
  if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
    if (c.kind = "method", g) {
      this.pushClassPrivateMethod(t, a, !1, !1);
      return;
    }
    const C = this.isNonstaticConstructor(n);
    let _ = !1;
    C && (n.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(w.DuplicateConstructor, h), C && this.hasPlugin("typescript") && r.override && this.raise(w.OverrideOnConstructor, h), i.hadConstructor = !0, _ = i.hadSuperClass), this.pushClassMethod(t, n, !1, !1, C, _);
  } else if (this.isClassProperty())
    g ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, o);
  else if (y === "async" && !this.isLineTerminator()) {
    this.resetPreviousNodeTrailingComments(h);
    const C = this.eat(55);
    f.optional && this.unexpected(A), c.kind = "method";
    const _ = this.match(138);
    this.parseClassElementName(c), this.parsePostMemberNameModifiers(f), _ ? this.pushClassPrivateMethod(t, a, C, !0) : (this.isNonstaticConstructor(n) && this.raise(w.ConstructorIsAsync, n.key), this.pushClassMethod(t, n, C, !0, !1, !1));
  } else if ((y === "get" || y === "set") && !(this.match(55) && this.isLineTerminator())) {
    this.resetPreviousNodeTrailingComments(h), c.kind = y;
    const C = this.match(138);
    this.parseClassElementName(n), C ? this.pushClassPrivateMethod(t, a, !1, !1) : (this.isNonstaticConstructor(n) && this.raise(w.ConstructorIsAccessor, n.key), this.pushClassMethod(t, n, !1, !1, !1, !1)), this.checkGetterSetterParams(n);
  } else if (y === "accessor" && !this.isLineTerminator()) {
    this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(h);
    const C = this.match(138);
    this.parseClassElementName(o), this.pushClassAccessorProperty(t, l, C);
  } else this.isLineTerminator() ? g ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, o) : this.unexpected();
}
parseClassElementName(t) {
  const {
    type: r,
    value: i
  } = this.state;
  if ((r === 132 || r === 133) && t.static && i === "prototype" && this.raise(w.StaticPrototype, this.state.startLoc), r === 138) {
    i === "constructor" && this.raise(w.ConstructorClassPrivateField, this.state.startLoc);
    const s = this.parsePrivateName();
    return t.key = s, s;
  }
  return this.parsePropertyName(t), t.key;
}
parseClassStaticBlock(t, r) {
  var i;
  this.scope.enter(208);
  const s = this.state.labels;
  this.state.labels = [], this.prodParam.enter(0);
  const n = r.body = [];
  this.parseBlockOrModuleBlockBody(n, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s, t.body.push(this.finishNode(r, "StaticBlock")), (i = r.decorators) != null && i.length && this.raise(w.DecoratorStaticBlock, r);
}
pushClassProperty(t, r) {
  !r.computed && this.nameIsConstructor(r.key) && this.raise(w.ConstructorClassField, r.key), t.body.push(this.parseClassProperty(r));
}
pushClassPrivateProperty(t, r) {
  const i = this.parseClassPrivateProperty(r);
  t.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
}
pushClassAccessorProperty(t, r, i) {
  !i && !r.computed && this.nameIsConstructor(r.key) && this.raise(w.ConstructorClassField, r.key);
  const s = this.parseClassAccessorProperty(r);
  t.body.push(s), i && this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
}
pushClassMethod(t, r, i, s, n, a) {
  t.body.push(this.parseMethod(r, i, s, n, a, "ClassMethod", !0));
}
pushClassPrivateMethod(t, r, i, s) {
  const n = this.parseMethod(r, i, s, !1, !1, "ClassPrivateMethod", !0);
  t.body.push(n);
  const a = n.kind === "get" ? n.static ? 6 : 2 : n.kind === "set" ? n.static ? 5 : 1 : 0;
  this.declareClassPrivateMethodInScope(n, a);
}
declareClassPrivateMethodInScope(t, r) {
  this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
}
parsePostMemberNameModifiers(t) {
}
parseClassPrivateProperty(t) {
  return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
}
parseClassProperty(t) {
  return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
}
parseClassAccessorProperty(t) {
  return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
}
parseInitializer(t) {
  this.scope.enter(80), this.expressionScope.enter(If()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
}
parseClassId(t, r, i, s = 8331) {
  if (Be(this.state.type))
    t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, s);
  else if (i || !r)
    t.id = null;
  else
    throw this.raise(w.MissingClassName, this.state.startLoc);
}
parseClassSuper(t) {
  t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
}
parseExport(t, r) {
  const i = this.parseMaybeImportPhase(t, !0), s = this.maybeParseExportDefaultSpecifier(t, i), n = !s || this.eat(12), a = n && this.eatExportStar(t), o = a && this.maybeParseExportNamespaceSpecifier(t), u = n && (!o || this.eat(12)), l = s || a;
  if (a && !o) {
    if (s && this.unexpected(), r)
      throw this.raise(w.UnsupportedDecoratorExport, t);
    return this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
  }
  const c = this.maybeParseExportNamedSpecifiers(t);
  s && n && !a && !c && this.unexpected(null, 5), o && u && this.unexpected(null, 98);
  let f;
  if (l || c) {
    if (f = !1, r)
      throw this.raise(w.UnsupportedDecoratorExport, t);
    this.parseExportFrom(t, l);
  } else
    f = this.maybeParseExportDeclaration(t);
  if (l || c || f) {
    var p;
    const h = t;
    if (this.checkExport(h, !0, !1, !!h.source), ((p = h.declaration) == null ? void 0 : p.type) === "ClassDeclaration")
      this.maybeTakeDecorators(r, h.declaration, h);
    else if (r)
      throw this.raise(w.UnsupportedDecoratorExport, t);
    return this.finishNode(h, "ExportNamedDeclaration");
  }
  if (this.eat(65)) {
    const h = t, y = this.parseExportDefaultExpression();
    if (h.declaration = y, y.type === "ClassDeclaration")
      this.maybeTakeDecorators(r, y, h);
    else if (r)
      throw this.raise(w.UnsupportedDecoratorExport, t);
    return this.checkExport(h, !0, !0), this.finishNode(h, "ExportDefaultDeclaration");
  }
  this.unexpected(null, 5);
}
eatExportStar(t) {
  return this.eat(55);
}
maybeParseExportDefaultSpecifier(t, r) {
  if (r || this.isExportDefaultSpecifier()) {
    this.expectPlugin("exportDefaultFrom", r == null ? void 0 : r.loc.start);
    const i = r || this.parseIdentifier(!0), s = this.startNodeAtNode(i);
    return s.exported = i, t.specifiers = [this.finishNode(s, "ExportDefaultSpecifier")], !0;
  }
  return !1;
}
maybeParseExportNamespaceSpecifier(t) {
  if (this.isContextual(93)) {
    var r, i;
    (i = (r = t).specifiers) != null || (r.specifiers = []);
    const s = this.startNodeAt(this.state.lastTokStartLoc);
    return this.next(), s.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(s, "ExportNamespaceSpecifier")), !0;
  }
  return !1;
}
maybeParseExportNamedSpecifiers(t) {
  if (this.match(5)) {
    const r = t;
    r.specifiers || (r.specifiers = []);
    const i = r.exportKind === "type";
    return r.specifiers.push(...this.parseExportSpecifiers(i)), r.source = null, r.declaration = null, this.hasPlugin("importAssertions") && (r.assertions = []), !0;
  }
  return !1;
}
maybeParseExportDeclaration(t) {
  return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), !0) : !1;
}
isAsyncFunction() {
  if (!this.isContextual(95)) return !1;
  const t = this.nextTokenInLineStart();
  return this.isUnparsedContextual(t, "function");
}
parseExportDefaultExpression() {
  const t = this.startNode();
  if (this.match(68))
    return this.next(), this.parseFunction(t, 5);
  if (this.isAsyncFunction())
    return this.next(), this.next(), this.parseFunction(t, 13);
  if (this.match(80))
    return this.parseClass(t, !0, !0);
  if (this.match(26))
    return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(w.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
  if (this.match(75) || this.match(74) || this.isLet())
    throw this.raise(w.UnsupportedDefaultExport, this.state.startLoc);
  const r = this.parseMaybeAssignAllowIn();
  return this.semicolon(), r;
}
parseExportDeclaration(t) {
  return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
}
isExportDefaultSpecifier() {
  const {
    type: t
  } = this.state;
  if (Be(t)) {
    if (t === 95 && !this.state.containsEsc || t === 100)
      return !1;
    if ((t === 130 || t === 129) && !this.state.containsEsc) {
      const {
        type: s
      } = this.lookahead();
      if (Be(s) && s !== 98 || s === 5)
        return this.expectOnePlugin(["flow", "typescript"]), !1;
    }
  } else if (!this.match(65))
    return !1;
  const r = this.nextTokenStart(), i = this.isUnparsedContextual(r, "from");
  if (this.input.charCodeAt(r) === 44 || Be(this.state.type) && i)
    return !0;
  if (this.match(65) && i) {
    const s = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
    return s === 34 || s === 39;
  }
  return !1;
}
parseExportFrom(t, r) {
  this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(t)) : r && this.unexpected(), this.semicolon();
}
shouldParseExportDeclaration() {
  const {
    type: t
  } = this.state;
  return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(w.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.raise(w.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(w.UsingDeclarationExport, this.state.startLoc), !0) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
}
checkExport(t, r, i, s) {
  if (r) {
    var n;
    if (i) {
      if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
        var a;
        const o = t.declaration;
        o.type === "Identifier" && o.name === "from" && o.end - o.start === 4 && !((a = o.extra) != null && a.parenthesized) && this.raise(w.ExportDefaultFromAsIdentifier, o);
      }
    } else if ((n = t.specifiers) != null && n.length)
      for (const o of t.specifiers) {
        const {
          exported: u
        } = o, l = u.type === "Identifier" ? u.name : u.value;
        if (this.checkDuplicateExports(o, l), !s && o.local) {
          const {
            local: c
          } = o;
          c.type !== "Identifier" ? this.raise(w.ExportBindingIsString, o, {
            localName: c.value,
            exportName: l
          }) : (this.checkReservedWord(c.name, c.loc.start, !0, !1), this.scope.checkLocalExport(c));
        }
      }
    else if (t.declaration) {
      const o = t.declaration;
      if (o.type === "FunctionDeclaration" || o.type === "ClassDeclaration") {
        const {
          id: u
        } = o;
        if (!u) throw new Error("Assertion failure");
        this.checkDuplicateExports(t, u.name);
      } else if (o.type === "VariableDeclaration")
        for (const u of o.declarations)
          this.checkDeclaration(u.id);
    }
  }
}
checkDeclaration(t) {
  if (t.type === "Identifier")
    this.checkDuplicateExports(t, t.name);
  else if (t.type === "ObjectPattern")
    for (const r of t.properties)
      this.checkDeclaration(r);
  else if (t.type === "ArrayPattern")
    for (const r of t.elements)
      r && this.checkDeclaration(r);
  else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
}
checkDuplicateExports(t, r) {
  this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(w.DuplicateDefaultExport, t) : this.raise(w.DuplicateExport, t, {
    exportName: r
  })), this.exportedIdentifiers.add(r);
}
parseExportSpecifiers(t) {
  const r = [];
  let i = !0;
  for (this.expect(5); !this.eat(8); ) {
    if (i)
      i = !1;
    else if (this.expect(12), this.eat(8)) break;
    const s = this.isContextual(130), n = this.match(133), a = this.startNode();
    a.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(a, n, t, s));
  }
  return r;
}
parseExportSpecifier(t, r, i, s) {
  return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = V5(t.local) : t.exported || (t.exported = Gt(t.local)), this.finishNode(t, "ExportSpecifier");
}
parseModuleExportName() {
  if (this.match(133)) {
    const t = this.parseStringLiteral(this.state.value), r = y_.exec(t.value);
    return r && this.raise(w.ModuleExportNameHasLoneSurrogate, t, {
      surrogateCharCode: r[0].charCodeAt(0)
    }), t;
  }
  return this.parseIdentifier(!0);
}
isJSONModuleImport(t) {
  return t.assertions != null ? t.assertions.some(({
    key: r,
    value: i
  }) => i.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
}
checkImportReflection(t) {
  const {
    specifiers: r
  } = t, i = r.length === 1 ? r[0].type : null;
  if (t.phase === "source")
    i !== "ImportDefaultSpecifier" && this.raise(w.SourcePhaseImportRequiresDefault, r[0].loc.start);
  else if (t.phase === "defer")
    i !== "ImportNamespaceSpecifier" && this.raise(w.DeferImportRequiresNamespace, r[0].loc.start);
  else if (t.module) {
    var s;
    i !== "ImportDefaultSpecifier" && this.raise(w.ImportReflectionNotBinding, r[0].loc.start), ((s = t.assertions) == null ? void 0 : s.length) > 0 && this.raise(w.ImportReflectionHasAssertion, r[0].loc.start);
  }
}
checkJSONModuleImport(t) {
  if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
    const {
      specifiers: r
    } = t;
    if (r != null) {
      const i = r.find((s) => {
        let n;
        if (s.type === "ExportSpecifier" ? n = s.local : s.type === "ImportSpecifier" && (n = s.imported), n !== void 0)
          return n.type === "Identifier" ? n.name !== "default" : n.value !== "default";
      });
      i !== void 0 && this.raise(w.ImportJSONBindingNotDefault, i.loc.start);
    }
  }
}
isPotentialImportPhase(t) {
  return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
}
applyImportPhase(t, r, i, s) {
  r || (i === "module" ? (this.expectPlugin("importReflection", s), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1), i === "source" ? (this.expectPlugin("sourcePhaseImports", s), t.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImportEvaluation", s), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
}
parseMaybeImportPhase(t, r) {
  if (!this.isPotentialImportPhase(r))
    return this.applyImportPhase(t, r, null), null;
  const i = this.parseIdentifier(!0), {
    type: s
  } = this.state;
  return (_t(s) ? s !== 98 || this.lookaheadCharCode() === 102 : s !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(t, r, i.name, i.loc.start), null) : (this.applyImportPhase(t, r, null), i);
}
isPrecedingIdImportPhase(t) {
  const {
    type: r
  } = this.state;
  return Be(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
}
parseImport(t) {
  return this.match(133) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
}
parseImportSpecifiersAndAfter(t, r) {
  t.specifiers = [];
  const s = !this.maybeParseDefaultImportSpecifier(t, r) || this.eat(12), n = s && this.maybeParseStarImportSpecifier(t);
  return s && !n && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
}
parseImportSourceAndAttributes(t) {
  var r;
  return (r = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
}
parseImportSource() {
  return this.match(133) || this.unexpected(), this.parseExprAtom();
}
parseImportSpecifierLocal(t, r, i) {
  r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, i));
}
finishImportSpecifier(t, r, i = 8201) {
  return this.checkLVal(t.local, {
    in: {
      type: r
    },
    binding: i
  }), this.finishNode(t, r);
}
parseImportAttributes() {
  this.expect(5);
  const t = [], r = /* @__PURE__ */ new Set();
  do {
    if (this.match(8))
      break;
    const i = this.startNode(), s = this.state.value;
    if (r.has(s) && this.raise(w.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
      key: s
    }), r.add(s), this.match(133) ? i.key = this.parseStringLiteral(s) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(133))
      throw this.raise(w.ModuleAttributeInvalidValue, this.state.startLoc);
    i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
  } while (this.eat(12));
  return this.expect(8), t;
}
parseModuleAttributes() {
  const t = [], r = /* @__PURE__ */ new Set();
  do {
    const i = this.startNode();
    if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(w.ModuleAttributeDifferentFromType, i.key), r.has(i.key.name) && this.raise(w.ModuleAttributesWithDuplicateKeys, i.key, {
      key: i.key.name
    }), r.add(i.key.name), this.expect(14), !this.match(133))
      throw this.raise(w.ModuleAttributeInvalidValue, this.state.startLoc);
    i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
  } while (this.eat(12));
  return t;
}
maybeParseImportAttributes(t) {
  let r, i = !1;
  if (this.match(76)) {
    if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
      return;
    this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.parseImportAttributes()), i = !0;
  } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
    this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(w.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(t, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), r = this.parseImportAttributes();
  else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
    r = [];
  else if (this.hasPlugin("moduleAttributes"))
    r = [];
  else return;
  !i && this.hasPlugin("importAssertions") ? t.assertions = r : t.attributes = r;
}
maybeParseDefaultImportSpecifier(t, r) {
  if (r) {
    const i = this.startNodeAtNode(r);
    return i.local = r, t.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
  } else if (_t(this.state.type))
    return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
  return !1;
}
maybeParseStarImportSpecifier(t) {
  if (this.match(55)) {
    const r = this.startNode();
    return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), !0;
  }
  return !1;
}
parseNamedImportSpecifiers(t) {
  let r = !0;
  for (this.expect(5); !this.eat(8); ) {
    if (r)
      r = !1;
    else {
      if (this.eat(14))
        throw this.raise(w.DestructureNamedImport, this.state.startLoc);
      if (this.expect(12), this.eat(8)) break;
    }
    const i = this.startNode(), s = this.match(133), n = this.isContextual(130);
    i.imported = this.parseModuleExportName();
    const a = this.parseImportSpecifier(i, s, t.importKind === "type" || t.importKind === "typeof", n, void 0);
    t.specifiers.push(a);
  }
}
parseImportSpecifier(t, r, i, s, n) {
  if (this.eatContextual(93))
    t.local = this.parseIdentifier();
  else {
    const {
      imported: a
    } = t;
    if (r)
      throw this.raise(w.ImportBindingIsString, t, {
        importName: a.value
      });
    this.checkReservedWord(a.name, t.loc.start, !0, !0), t.local || (t.local = Gt(a));
  }
  return this.finishImportSpecifier(t, "ImportSpecifier", n);
}
isThisParam(t) {
  return t.type === "Identifier" && t.name === "this";
}
}
class _f extends T_ {
constructor(t, r) {
  t = h_(t), super(t, r), this.options = t, this.initializeScopes(), this.plugins = g_(this.options.plugins), this.filename = t.sourceFilename;
}
getScopeHandler() {
  return za;
}
parse() {
  this.enterInitialScopes();
  const t = this.startNode(), r = this.startNode();
  return this.nextToken(), t.errors = null, this.parseTopLevel(t, r), t.errors = this.state.errors, t.comments.length = this.state.commentsLen, t;
}
}
function g_(e) {
const t = /* @__PURE__ */ new Map();
for (const r of e) {
  const [i, s] = Array.isArray(r) ? r : [r, {}];
  t.has(i) || t.set(i, s || {});
}
return t;
}
function S_(e, t) {
var r;
if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
  t = Object.assign({}, t);
  try {
    t.sourceType = "module";
    const i = ti(t, e), s = i.parse();
    if (i.sawUnambiguousESM)
      return s;
    if (i.ambiguousScriptDifferentAst)
      try {
        return t.sourceType = "script", ti(t, e).parse();
      } catch {
      }
    else
      s.program.sourceType = "script";
    return s;
  } catch (i) {
    try {
      return t.sourceType = "script", ti(t, e).parse();
    } catch {
    }
    throw i;
  }
} else
  return ti(t, e).parse();
}
function x_(e, t) {
const r = ti(t, e);
return r.options.strictMode && (r.state.strict = !0), r.getExpression();
}
function E_(e) {
const t = {};
for (const r of Object.keys(e))
  t[r] = Kt(e[r]);
return t;
}
const P_ = E_(e5);
function ti(e, t) {
let r = _f;
return e != null && e.plugins && (f_(e.plugins), r = v_(e.plugins)), new r(e, t);
}
const bl = {};
function v_(e) {
const t = p_.filter((s) => at(e, s)), r = t.join("/");
let i = bl[r];
if (!i) {
  i = _f;
  for (const s of t)
    i = Of[s](i);
  bl[r] = i;
}
return i;
}
var A_ = Mr.parse = S_;
Mr.parseExpression = x_;
Mr.tokTypes = P_;
var eo = {};
Object.defineProperty(eo, "__esModule", {
value: !0
});
eo.default = __;
var I_ = Ce();
const {
assignmentExpression: C_,
expressionStatement: w_,
identifier: N_
} = I_, O_ = {
Scope(e, t) {
  t.kind === "let" && e.skip();
},
FunctionParent(e) {
  e.skip();
},
VariableDeclaration(e, t) {
  if (t.kind && e.node.kind !== t.kind) return;
  const r = [], i = e.get("declarations");
  let s;
  for (const n of i) {
    s = n.node.id, n.node.init && r.push(w_(C_("=", n.node.id, n.node.init)));
    for (const a of Object.keys(n.getBindingIdentifiers()))
      t.emit(N_(a), a, n.node.init !== null);
  }
  e.parentPath.isFor({
    left: e.node
  }) ? e.replaceWith(s) : e.replaceWithMultiple(r);
}
};
function __(e, t, r = "var") {
e.traverse(O_, {
  kind: r,
  emit: t
});
}
var Tl;
function kf() {
if (Tl) return Vt;
Tl = 1, Object.defineProperty(Vt, "__esModule", {
  value: !0
}), Vt._replaceWith = H, Vt.replaceExpressionWithStatements = ne, Vt.replaceInline = qe, Vt.replaceWith = V, Vt.replaceWithMultiple = R, Vt.replaceWithSourceString = q;
var e = xi, t = zs(), r = vr(), i = lt, s = ff(), n = Mr, a = Ce(), o = eo;
const {
  FUNCTION_TYPES: u,
  arrowFunctionExpression: l,
  assignmentExpression: c,
  awaitExpression: f,
  blockStatement: p,
  buildUndefinedNode: h,
  callExpression: y,
  cloneNode: g,
  conditionalExpression: A,
  expressionStatement: C,
  getBindingIdentifiers: _,
  identifier: j,
  inheritLeadingComments: G,
  inheritTrailingComments: fe,
  inheritsComments: re,
  isBlockStatement: oe,
  isEmptyStatement: K,
  isExpression: X,
  isExpressionStatement: ie,
  isIfStatement: W,
  isProgram: Q,
  isStatement: U,
  isVariableDeclaration: L,
  removeComments: k,
  returnStatement: F,
  sequenceExpression: B,
  validate: O,
  yieldExpression: D
} = a;
function R(pe) {
  var he;
  this.resync(), pe = s._verifyNodeList.call(this, pe), G(pe[0], this.node), fe(pe[pe.length - 1], this.node), (he = (0, i.getCachedPaths)(this.hub, this.parent)) == null || he.delete(this.node), this.node = this.container[this.key] = null;
  const Ee = this.insertAfter(pe);
  return this.node ? this.requeue() : this.remove(), Ee;
}
function q(pe) {
  this.resync();
  let he;
  try {
    pe = `(${pe})`, he = (0, n.parse)(pe);
  } catch (we) {
    const Pe = we.loc;
    throw Pe && (we.message += ` - make sure this is an expression.
` + (0, e.codeFrameColumns)(pe, {
      start: {
        line: Pe.line,
        column: Pe.column + 1
      }
    }), we.code = "BABEL_REPLACE_SOURCE_ERROR"), we;
  }
  const Ee = he.program.body[0].expression;
  return t.default.removeProperties(Ee), this.replaceWith(Ee);
}
function V(pe) {
  if (this.resync(), this.removed)
    throw new Error("You can't replace this node, we've already removed it");
  let he = pe instanceof r.default ? pe.node : pe;
  if (!he)
    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
  if (this.node === he)
    return [this];
  if (this.isProgram() && !Q(he))
    throw new Error("You can only replace a Program root node with another Program node");
  if (Array.isArray(he))
    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
  if (typeof he == "string")
    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
  let Ee = "";
  if (this.isNodeType("Statement") && X(he) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(he) && !this.parentPath.isExportDefaultDeclaration() && (he = C(he), Ee = "expression"), this.isNodeType("Expression") && U(he) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(he))
    return this.replaceExpressionWithStatements([he]);
  const we = this.node;
  return we && (re(he, we), k(we)), H.call(this, he), this.type = he.type, this.setScope(), this.requeue(), [Ee ? this.get(Ee) : this];
}
function H(pe) {
  var he;
  if (!this.container)
    throw new ReferenceError("Container is falsy");
  this.inList ? O(this.parent, this.key, [pe]) : O(this.parent, this.key, pe), this.debug(`Replace with ${pe == null ? void 0 : pe.type}`), (he = (0, i.getCachedPaths)(this.hub, this.parent)) == null || he.set(pe, this).delete(this.node), this.node = this.container[this.key] = pe;
}
function ne(pe) {
  this.resync();
  const he = [], Ee = ue(pe, he);
  if (Ee) {
    for (const Ve of he) this.scope.push({
      id: Ve
    });
    return this.replaceWith(Ee)[0].get("expressions");
  }
  const we = this.getFunctionParent(), Pe = we == null ? void 0 : we.is("async"), ke = we == null ? void 0 : we.is("generator"), De = l([], p(pe));
  this.replaceWith(y(De, []));
  const Je = this.get("callee");
  (0, o.default)(Je.get("body"), (Ve) => {
    this.scope.push({
      id: Ve
    });
  }, "var");
  const it = this.get("callee").getCompletionRecords();
  for (const Ve of it) {
    if (!Ve.isExpressionStatement()) continue;
    const ht = Ve.findParent((ze) => ze.isLoop());
    if (ht) {
      let ze = ht.getData("expressionReplacementReturnUid");
      ze ? ze = j(ze.name) : (ze = Je.scope.generateDeclaredUidIdentifier("ret"), Je.get("body").pushContainer("body", F(g(ze))), ht.setData("expressionReplacementReturnUid", ze)), Ve.get("expression").replaceWith(c("=", g(ze), Ve.node.expression));
    } else
      Ve.replaceWith(F(Ve.node.expression));
  }
  Je.arrowFunctionToExpression();
  const ve = Je, je = Pe && t.default.hasType(this.get("callee.body").node, "AwaitExpression", u), Ie = ke && t.default.hasType(this.get("callee.body").node, "YieldExpression", u);
  return je && (ve.set("async", !0), Ie || this.replaceWith(f(this.node))), Ie && (ve.set("generator", !0), this.replaceWith(D(this.node, !0))), ve.get("body.body");
}
function ue(pe, he) {
  const Ee = [];
  let we = !0;
  for (const Pe of pe)
    if (K(Pe) || (we = !1), X(Pe))
      Ee.push(Pe);
    else if (ie(Pe))
      Ee.push(Pe.expression);
    else if (L(Pe)) {
      if (Pe.kind !== "var") return;
      for (const ke of Pe.declarations) {
        const De = _(ke);
        for (const Je of Object.keys(De))
          he.push(g(De[Je]));
        ke.init && Ee.push(c("=", ke.id, ke.init));
      }
      we = !0;
    } else if (W(Pe)) {
      const ke = Pe.consequent ? ue([Pe.consequent], he) : h(), De = Pe.alternate ? ue([Pe.alternate], he) : h();
      if (!ke || !De) return;
      Ee.push(A(Pe.test, ke, De));
    } else if (oe(Pe)) {
      const ke = ue(Pe.body, he);
      if (!ke) return;
      Ee.push(ke);
    } else if (K(Pe))
      pe.indexOf(Pe) === 0 && (we = !0);
    else
      return;
  return we && Ee.push(h()), Ee.length === 1 ? Ee[0] : B(Ee);
}
function qe(pe) {
  if (this.resync(), Array.isArray(pe))
    if (Array.isArray(this.container)) {
      pe = s._verifyNodeList.call(this, pe);
      const he = s._containerInsertAfter.call(this, pe);
      return this.remove(), he;
    } else
      return this.replaceWithMultiple(pe);
  else
    return this.replaceWith(pe);
}
return Vt;
}
var Ys = {};
Object.defineProperty(Ys, "__esModule", {
value: !0
});
Ys.evaluate = R_;
Ys.evaluateTruthy = F_;
const k_ = ["Number", "String", "Math"], D_ = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null], L_ = ["random"];
function gl(e) {
return k_.includes(e);
}
function M_(e) {
return D_.includes(e);
}
function B_(e) {
return L_.includes(e);
}
function F_() {
const e = this.evaluate();
if (e.confident) return !!e.value;
}
function Wt(e, t) {
t.confident && (t.deoptPath = e, t.confident = !1);
}
const Sl = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
function Tt(e, t) {
const {
  node: r
} = e, {
  seen: i
} = t;
if (i.has(r)) {
  const s = i.get(r);
  if (s.resolved)
    return s.value;
  Wt(e, t);
  return;
} else {
  const s = {
    resolved: !1
  };
  i.set(r, s);
  const n = j_(e, t);
  return t.confident && (s.resolved = !0, s.value = n), n;
}
}
function j_(e, t) {
if (t.confident) {
  if (e.isSequenceExpression()) {
    const r = e.get("expressions");
    return Tt(r[r.length - 1], t);
  }
  if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral())
    return e.node.value;
  if (e.isNullLiteral())
    return null;
  if (e.isTemplateLiteral())
    return xl(e, e.node.quasis, t);
  if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
    const r = e.get("tag.object"), {
      node: {
        name: i
      }
    } = r, s = e.get("tag.property");
    if (r.isIdentifier() && i === "String" && !e.scope.getBinding(i) && s.isIdentifier() && s.node.name === "raw")
      return xl(e, e.node.quasi.quasis, t, !0);
  }
  if (e.isConditionalExpression()) {
    const r = Tt(e.get("test"), t);
    return t.confident ? Tt(r ? e.get("consequent") : e.get("alternate"), t) : void 0;
  }
  if (e.isExpressionWrapper())
    return Tt(e.get("expression"), t);
  if (e.isMemberExpression() && !e.parentPath.isCallExpression({
    callee: e.node
  })) {
    const r = e.get("property"), i = e.get("object");
    if (i.isLiteral()) {
      const s = i.node.value, n = typeof s;
      let a = null;
      if (e.node.computed) {
        if (a = Tt(r, t), !t.confident) return;
      } else r.isIdentifier() && (a = r.node.name);
      if ((n === "number" || n === "string") && a != null && (typeof a == "number" || typeof a == "string"))
        return s[a];
    }
  }
  if (e.isReferencedIdentifier()) {
    const r = e.scope.getBinding(e.node.name);
    if (r) {
      if (r.constantViolations.length > 0 || e.node.start < r.path.node.end) {
        Wt(r.path, t);
        return;
      }
      if (r.hasValue)
        return r.value;
    }
    const i = e.node.name;
    if (Sl.has(i)) {
      if (!r)
        return Sl.get(i);
      Wt(r.path, t);
      return;
    }
    const s = e.resolve();
    if (s === e) {
      Wt(e, t);
      return;
    } else
      return Tt(s, t);
  }
  if (e.isUnaryExpression({
    prefix: !0
  })) {
    if (e.node.operator === "void")
      return;
    const r = e.get("argument");
    if (e.node.operator === "typeof" && (r.isFunction() || r.isClass()))
      return "function";
    const i = Tt(r, t);
    if (!t.confident) return;
    switch (e.node.operator) {
      case "!":
        return !i;
      case "+":
        return +i;
      case "-":
        return -i;
      case "~":
        return ~i;
      case "typeof":
        return typeof i;
    }
  }
  if (e.isArrayExpression()) {
    const r = [], i = e.get("elements");
    for (const s of i) {
      const n = s.evaluate();
      if (n.confident)
        r.push(n.value);
      else {
        Wt(n.deopt, t);
        return;
      }
    }
    return r;
  }
  if (e.isObjectExpression()) {
    const r = {}, i = e.get("properties");
    for (const s of i) {
      if (s.isObjectMethod() || s.isSpreadElement()) {
        Wt(s, t);
        return;
      }
      const n = s.get("key");
      let a;
      if (s.node.computed) {
        if (a = n.evaluate(), !a.confident) {
          Wt(a.deopt, t);
          return;
        }
        a = a.value;
      } else n.isIdentifier() ? a = n.node.name : a = n.node.value;
      let u = s.get("value").evaluate();
      if (!u.confident) {
        Wt(u.deopt, t);
        return;
      }
      u = u.value, r[a] = u;
    }
    return r;
  }
  if (e.isLogicalExpression()) {
    const r = t.confident, i = Tt(e.get("left"), t), s = t.confident;
    t.confident = r;
    const n = Tt(e.get("right"), t), a = t.confident;
    switch (e.node.operator) {
      case "||":
        return t.confident = s && (!!i || a), t.confident ? i || n : void 0;
      case "&&":
        return t.confident = s && (!i || a), t.confident ? i && n : void 0;
      case "??":
        return t.confident = s && (i != null || a), t.confident ? i ?? n : void 0;
    }
  }
  if (e.isBinaryExpression()) {
    const r = Tt(e.get("left"), t);
    if (!t.confident) return;
    const i = Tt(e.get("right"), t);
    if (!t.confident) return;
    switch (e.node.operator) {
      case "-":
        return r - i;
      case "+":
        return r + i;
      case "/":
        return r / i;
      case "*":
        return r * i;
      case "%":
        return r % i;
      case "**":
        return Math.pow(r, i);
      case "<":
        return r < i;
      case ">":
        return r > i;
      case "<=":
        return r <= i;
      case ">=":
        return r >= i;
      case "==":
        return r == i;
      case "!=":
        return r != i;
      case "===":
        return r === i;
      case "!==":
        return r !== i;
      case "|":
        return r | i;
      case "&":
        return r & i;
      case "^":
        return r ^ i;
      case "<<":
        return r << i;
      case ">>":
        return r >> i;
      case ">>>":
        return r >>> i;
    }
  }
  if (e.isCallExpression()) {
    const r = e.get("callee");
    let i, s;
    if (r.isIdentifier() && !e.scope.getBinding(r.node.name) && (gl(r.node.name) || M_(r.node.name)) && (s = Tr[r.node.name]), r.isMemberExpression()) {
      const n = r.get("object"), a = r.get("property");
      if (n.isIdentifier() && a.isIdentifier() && gl(n.node.name) && !B_(a.node.name)) {
        i = Tr[n.node.name];
        const o = a.node.name;
        hasOwnProperty.call(i, o) && (s = i[o]);
      }
      if (n.isLiteral() && a.isIdentifier()) {
        const o = typeof n.node.value;
        (o === "string" || o === "number") && (i = n.node.value, s = i[a.node.name]);
      }
    }
    if (s) {
      const n = e.get("arguments").map((a) => Tt(a, t));
      return t.confident ? s.apply(i, n) : void 0;
    }
  }
  Wt(e, t);
}
}
function xl(e, t, r, i = !1) {
let s = "", n = 0;
const a = e.isTemplateLiteral() ? e.get("expressions") : e.get("quasi.expressions");
for (const o of t) {
  if (!r.confident) break;
  s += i ? o.value.raw : o.value.cooked;
  const u = a[n++];
  u && (s += String(Tt(u, r)));
}
if (r.confident)
  return s;
}
function R_() {
const e = {
  confident: !0,
  deoptPath: null,
  seen: /* @__PURE__ */ new Map()
};
let t = Tt(this, e);
return e.confident || (t = void 0), {
  confident: e.confident,
  deopt: e.deoptPath,
  value: t
};
}
var Er = {}, to = {}, Et = {}, It = {};
Object.defineProperty(It, "__esModule", {
value: !0
});
It.statements = It.statement = It.smart = It.program = It.expression = void 0;
var U_ = Ce();
const {
assertExpressionStatement: V_
} = U_;
function ro(e) {
return {
  code: (t) => `/* @babel/template */;
${t}`,
  validate: () => {
  },
  unwrap: (t) => e(t.program.body.slice(1))
};
}
It.smart = ro((e) => e.length > 1 ? e : e[0]);
It.statements = ro((e) => e);
It.statement = ro((e) => {
if (e.length === 0)
  throw new Error("Found nothing to return.");
if (e.length > 1)
  throw new Error("Found multiple statements but wanted one");
return e[0];
});
const q_ = It.expression = {
code: (e) => `(
${e}
)`,
validate: (e) => {
  if (e.program.body.length > 1)
    throw new Error("Found multiple statements but wanted one");
  if (q_.unwrap(e).start === 0)
    throw new Error("Parse result included parens.");
},
unwrap: ({
  program: e
}) => {
  const [t] = e.body;
  return V_(t), t.expression;
}
};
It.program = {
code: (e) => e,
validate: () => {
},
unwrap: (e) => e.program
};
var io = {}, Pr = {};
Object.defineProperty(Pr, "__esModule", {
value: !0
});
Pr.merge = W_;
Pr.normalizeReplacements = Y_;
Pr.validate = J_;
const $_ = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
function K_(e, t) {
if (e == null) return {};
var r = {}, i = Object.keys(e), s, n;
for (n = 0; n < i.length; n++)
  s = i[n], !(t.indexOf(s) >= 0) && (r[s] = e[s]);
return r;
}
function W_(e, t) {
const {
  placeholderWhitelist: r = e.placeholderWhitelist,
  placeholderPattern: i = e.placeholderPattern,
  preserveComments: s = e.preserveComments,
  syntacticPlaceholders: n = e.syntacticPlaceholders
} = t;
return {
  parser: Object.assign({}, e.parser, t.parser),
  placeholderWhitelist: r,
  placeholderPattern: i,
  preserveComments: s,
  syntacticPlaceholders: n
};
}
function J_(e) {
if (e != null && typeof e != "object")
  throw new Error("Unknown template options.");
const t = e || {}, {
  placeholderWhitelist: r,
  placeholderPattern: i,
  preserveComments: s,
  syntacticPlaceholders: n
} = t, a = K_(t, $_);
if (r != null && !(r instanceof Set))
  throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
if (i != null && !(i instanceof RegExp) && i !== !1)
  throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
if (s != null && typeof s != "boolean")
  throw new Error("'.preserveComments' must be a boolean, null, or undefined");
if (n != null && typeof n != "boolean")
  throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
if (n === !0 && (r != null || i != null))
  throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
return {
  parser: a,
  placeholderWhitelist: r || void 0,
  placeholderPattern: i ?? void 0,
  preserveComments: s ?? void 0,
  syntacticPlaceholders: n ?? void 0
};
}
function Y_(e) {
if (Array.isArray(e))
  return e.reduce((t, r, i) => (t["$" + i] = r, t), {});
if (typeof e == "object" || e == null)
  return e || void 0;
throw new Error("Template replacements must be an array, object, null, or undefined");
}
var so = {}, Xs = {};
Object.defineProperty(Xs, "__esModule", {
value: !0
});
Xs.default = ok;
var X_ = Ce(), H_ = Mr, G_ = xi;
const {
isCallExpression: z_,
isExpressionStatement: Q_,
isFunction: Z_,
isIdentifier: ek,
isJSXIdentifier: tk,
isNewExpression: rk,
isPlaceholder: ts,
isStatement: ik,
isStringLiteral: El,
removePropertiesDeep: sk,
traverse: nk
} = X_, ak = /^[_$A-Z0-9]+$/;
function ok(e, t, r) {
const {
  placeholderWhitelist: i,
  placeholderPattern: s,
  preserveComments: n,
  syntacticPlaceholders: a
} = r, o = ck(t, r.parser, a);
sk(o, {
  preserveComments: n
}), e.validate(o);
const u = {
  syntactic: {
    placeholders: [],
    placeholderNames: /* @__PURE__ */ new Set()
  },
  legacy: {
    placeholders: [],
    placeholderNames: /* @__PURE__ */ new Set()
  },
  placeholderWhitelist: i,
  placeholderPattern: s,
  syntacticPlaceholders: a
};
return nk(o, uk, u), Object.assign({
  ast: o
}, u.syntactic.placeholders.length ? u.syntactic : u.legacy);
}
function uk(e, t, r) {
var i;
let s, n = r.syntactic.placeholders.length > 0;
if (ts(e)) {
  if (r.syntacticPlaceholders === !1)
    throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
  s = e.name.name, n = !0;
} else {
  if (n || r.syntacticPlaceholders)
    return;
  if (ek(e) || tk(e))
    s = e.name;
  else if (El(e))
    s = e.value;
  else
    return;
}
if (n && (r.placeholderPattern != null || r.placeholderWhitelist != null))
  throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
if (!n && (r.placeholderPattern === !1 || !(r.placeholderPattern || ak).test(s)) && !((i = r.placeholderWhitelist) != null && i.has(s)))
  return;
t = t.slice();
const {
  node: a,
  key: o
} = t[t.length - 1];
let u;
El(e) || ts(e, {
  expectedNode: "StringLiteral"
}) ? u = "string" : rk(a) && o === "arguments" || z_(a) && o === "arguments" || Z_(a) && o === "params" ? u = "param" : Q_(a) && !ts(e) ? (u = "statement", t = t.slice(0, -1)) : ik(e) && ts(e) ? u = "statement" : u = "other";
const {
  placeholders: l,
  placeholderNames: c
} = n ? r.syntactic : r.legacy;
l.push({
  name: s,
  type: u,
  resolve: (f) => lk(f, t),
  isDuplicate: c.has(s)
}), c.add(s);
}
function lk(e, t) {
let r = e;
for (let n = 0; n < t.length - 1; n++) {
  const {
    key: a,
    index: o
  } = t[n];
  o === void 0 ? r = r[a] : r = r[a][o];
}
const {
  key: i,
  index: s
} = t[t.length - 1];
return {
  parent: r,
  key: i,
  index: s
};
}
function ck(e, t, r) {
const i = (t.plugins || []).slice();
r !== !1 && i.push("placeholders"), t = Object.assign({
  allowReturnOutsideFunction: !0,
  allowSuperOutsideMethod: !0,
  sourceType: "module"
}, t, {
  plugins: i
});
try {
  return (0, H_.parse)(e, t);
} catch (s) {
  const n = s.loc;
  throw n && (s.message += `
` + (0, G_.codeFrameColumns)(e, {
    start: n
  }), s.code = "BABEL_TEMPLATE_PARSE_ERROR"), s;
}
}
var Hs = {};
Object.defineProperty(Hs, "__esModule", {
value: !0
});
Hs.default = yk;
var fk = Ce();
const {
blockStatement: pk,
cloneNode: Gn,
emptyStatement: hk,
expressionStatement: Nn,
identifier: rs,
isStatement: Pl,
isStringLiteral: dk,
stringLiteral: mk,
validate: vl
} = fk;
function yk(e, t) {
const r = Gn(e.ast);
return t && (e.placeholders.forEach((i) => {
  if (!hasOwnProperty.call(t, i.name)) {
    const s = i.name;
    throw new Error(`Error: No substitution given for "${s}". If this is not meant to be a
          placeholder you may want to consider passing one of the following options to @babel/template:
          - { placeholderPattern: false, placeholderWhitelist: new Set(['${s}'])}
          - { placeholderPattern: /^${s}$/ }`);
  }
}), Object.keys(t).forEach((i) => {
  if (!e.placeholderNames.has(i))
    throw new Error(`Unknown substitution "${i}" given`);
})), e.placeholders.slice().reverse().forEach((i) => {
  try {
    bk(i, r, t && t[i.name] || null);
  } catch (s) {
    throw s.message = `@babel/template placeholder "${i.name}": ${s.message}`, s;
  }
}), r;
}
function bk(e, t, r) {
e.isDuplicate && (Array.isArray(r) ? r = r.map((a) => Gn(a)) : typeof r == "object" && (r = Gn(r)));
const {
  parent: i,
  key: s,
  index: n
} = e.resolve(t);
if (e.type === "string") {
  if (typeof r == "string" && (r = mk(r)), !r || !dk(r))
    throw new Error("Expected string substitution");
} else if (e.type === "statement")
  n === void 0 ? r ? Array.isArray(r) ? r = pk(r) : typeof r == "string" ? r = Nn(rs(r)) : Pl(r) || (r = Nn(r)) : r = hk() : r && !Array.isArray(r) && (typeof r == "string" && (r = rs(r)), Pl(r) || (r = Nn(r)));
else if (e.type === "param") {
  if (typeof r == "string" && (r = rs(r)), n === void 0) throw new Error("Assertion failure.");
} else if (typeof r == "string" && (r = rs(r)), Array.isArray(r))
  throw new Error("Cannot replace single expression with an array.");
if (n === void 0)
  vl(i, s, r), i[s] = r;
else {
  const a = i[s].slice();
  e.type === "statement" || e.type === "param" ? r == null ? a.splice(n, 1) : Array.isArray(r) ? a.splice(n, 1, ...r) : a[n] = r : a[n] = r, vl(i, s, a), i[s] = a;
}
}
Object.defineProperty(so, "__esModule", {
value: !0
});
so.default = xk;
var Tk = Pr, gk = Xs, Sk = Hs;
function xk(e, t, r) {
t = e.code(t);
let i;
return (s) => {
  const n = (0, Tk.normalizeReplacements)(s);
  return i || (i = (0, gk.default)(e, t, r)), e.unwrap((0, Sk.default)(i, n));
};
}
var no = {};
Object.defineProperty(no, "__esModule", {
value: !0
});
no.default = Ak;
var Ek = Pr, Pk = Xs, vk = Hs;
function Ak(e, t, r) {
const {
  metadata: i,
  names: s
} = Ik(e, t, r);
return (n) => {
  const a = {};
  return n.forEach((o, u) => {
    a[s[u]] = o;
  }), (o) => {
    const u = (0, Ek.normalizeReplacements)(o);
    return u && Object.keys(u).forEach((l) => {
      if (hasOwnProperty.call(a, l))
        throw new Error("Unexpected replacement overlap.");
    }), e.unwrap((0, vk.default)(i, u ? Object.assign(u, a) : a));
  };
};
}
function Ik(e, t, r) {
let i = "BABEL_TPL$";
const s = t.join("");
do
  i = "$$" + i;
while (s.includes(i));
const {
  names: n,
  code: a
} = Ck(t, i);
return {
  metadata: (0, Pk.default)(e, e.code(a), {
    parser: r.parser,
    placeholderWhitelist: new Set(n.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
    placeholderPattern: r.placeholderPattern,
    preserveComments: r.preserveComments,
    syntacticPlaceholders: r.syntacticPlaceholders
  }),
  names: n
};
}
function Ck(e, t) {
const r = [];
let i = e[0];
for (let s = 1; s < e.length; s++) {
  const n = `${t}${s - 1}`;
  r.push(n), i += n + e[s];
}
return {
  names: r,
  code: i
};
}
Object.defineProperty(io, "__esModule", {
value: !0
});
io.default = Df;
var Lt = Pr, Al = so, Il = no;
const Cl = (0, Lt.validate)({
placeholderPattern: !1
});
function Df(e, t) {
const r = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), s = t || (0, Lt.validate)(null);
return Object.assign((n, ...a) => {
  if (typeof n == "string") {
    if (a.length > 1) throw new Error("Unexpected extra params.");
    return wl((0, Al.default)(e, n, (0, Lt.merge)(s, (0, Lt.validate)(a[0]))));
  } else if (Array.isArray(n)) {
    let o = r.get(n);
    return o || (o = (0, Il.default)(e, n, s), r.set(n, o)), wl(o(a));
  } else if (typeof n == "object" && n) {
    if (a.length > 0) throw new Error("Unexpected extra params.");
    return Df(e, (0, Lt.merge)(s, (0, Lt.validate)(n)));
  }
  throw new Error(`Unexpected template param ${typeof n}`);
}, {
  ast: (n, ...a) => {
    if (typeof n == "string") {
      if (a.length > 1) throw new Error("Unexpected extra params.");
      return (0, Al.default)(e, n, (0, Lt.merge)((0, Lt.merge)(s, (0, Lt.validate)(a[0])), Cl))();
    } else if (Array.isArray(n)) {
      let o = i.get(n);
      return o || (o = (0, Il.default)(e, n, (0, Lt.merge)(s, Cl)), i.set(n, o)), o(a)();
    }
    throw new Error(`Unexpected template param ${typeof n}`);
  }
});
}
function wl(e) {
let t = "";
try {
  throw new Error();
} catch (r) {
  r.stack && (t = r.stack.split(`
`).slice(3).join(`
`));
}
return (r) => {
  try {
    return e(r);
  } catch (i) {
    throw i.stack += `
  =============
${t}`, i;
  }
};
}
Object.defineProperty(Et, "__esModule", {
value: !0
});
Et.statements = Et.statement = Et.smart = Et.program = Et.expression = Et.default = void 0;
var Pi = It, vi = io;
const On = Et.smart = (0, vi.default)(Pi.smart), wk = Et.statement = (0, vi.default)(Pi.statement), Nk = Et.statements = (0, vi.default)(Pi.statements), Ok = Et.expression = (0, vi.default)(Pi.expression), _k = Et.program = (0, vi.default)(Pi.program);
Et.default = Object.assign(On.bind(void 0), {
smart: On,
statement: wk,
statements: Nk,
expression: Ok,
program: _k,
ast: On.ast
});
Object.defineProperty(to, "__esModule", {
value: !0
});
to.default = Qk;
var Lf = Et, kk = Ce();
const {
NOT_LOCAL_BINDING: Nl,
cloneNode: Dk,
identifier: Lk,
isAssignmentExpression: Mk,
isAssignmentPattern: Bk,
isFunction: Mf,
isIdentifier: Ol,
isLiteral: _l,
isNullLiteral: Fk,
isObjectMethod: jk,
isObjectProperty: Rk,
isRegExpLiteral: Uk,
isRestElement: Vk,
isTemplateLiteral: qk,
isVariableDeclarator: $k,
toBindingIdentifierName: Kk
} = kk;
function Wk(e) {
const t = e.params.findIndex((r) => Bk(r) || Vk(r));
return t === -1 ? e.params.length : t;
}
const Jk = Lf.default.statement(`
(function (FUNCTION_KEY) {
  function FUNCTION_ID() {
    return FUNCTION_KEY.apply(this, arguments);
  }

  FUNCTION_ID.toString = function () {
    return FUNCTION_KEY.toString();
  }

  return FUNCTION_ID;
})(FUNCTION)
`), Yk = Lf.default.statement(`
(function (FUNCTION_KEY) {
  function* FUNCTION_ID() {
    return yield* FUNCTION_KEY.apply(this, arguments);
  }

  FUNCTION_ID.toString = function () {
    return FUNCTION_KEY.toString();
  };

  return FUNCTION_ID;
})(FUNCTION)
`), Xk = {
"ReferencedIdentifier|BindingIdentifier"(e, t) {
  e.node.name !== t.name || e.scope.getBindingIdentifier(t.name) !== t.outerDeclar || (t.selfReference = !0, e.stop());
}
};
function Hk(e) {
return Fk(e) ? "null" : Uk(e) ? `_${e.pattern}_${e.flags}` : qk(e) ? e.quasis.map((t) => t.value.raw).join("") : e.value !== void 0 ? e.value + "" : "";
}
function Gk(e, t, r, i) {
if (e.selfReference)
  if (i.hasBinding(r.name) && !i.hasGlobal(r.name))
    i.rename(r.name);
  else {
    if (!Mf(t)) return;
    let s = Jk;
    t.generator && (s = Yk);
    const n = s({
      FUNCTION: t,
      FUNCTION_ID: r,
      FUNCTION_KEY: i.generateUidIdentifier(r.name)
    }).expression, a = n.callee.body.body[0].params;
    for (let o = 0, u = Wk(t); o < u; o++)
      a.push(i.generateUidIdentifier("x"));
    return n;
  }
t.id = r, i.getProgramParent().references[r.name] = !0;
}
function zk(e, t, r) {
const i = {
  selfAssignment: !1,
  selfReference: !1,
  outerDeclar: r.getBindingIdentifier(t),
  name: t
}, s = r.getOwnBinding(t);
return s ? s.kind === "param" && (i.selfReference = !0) : (i.outerDeclar || r.hasGlobal(t)) && r.traverse(e, Xk, i), i;
}
function Qk({
node: e,
parent: t,
scope: r,
id: i
}, s = !1, n = !1) {
if (e.id) return;
if ((Rk(t) || jk(t, {
  kind: "method"
})) && (!t.computed || _l(t.key)))
  i = t.key;
else if ($k(t)) {
  if (i = t.id, Ol(i) && !s) {
    const l = r.parent.getBinding(i.name);
    if (l && l.constant && r.getBinding(i.name) === l) {
      e.id = Dk(i), e.id[Nl] = !0;
      return;
    }
  }
} else if (Mk(t, {
  operator: "="
}))
  i = t.left;
else if (!i)
  return;
let a;
if (i && _l(i) ? a = Hk(i) : i && Ol(i) && (a = i.name), a === void 0 || !n && Mf(e) && /[\uD800-\uDFFF]/.test(a))
  return;
a = Kk(a);
const o = Lk(a);
o[Nl] = !0;
const u = zk(e, a, r);
return Gk(u, e, o, r) || e;
}
Object.defineProperty(Er, "__esModule", {
value: !0
});
Er.arrowFunctionToExpression = SD;
Er.ensureBlock = bD;
Er.toComputedKey = yD;
Er.unwrapFunctionEnvironment = TD;
var Zk = Ce(), ao = xr, eD = to, oo = zt;
const {
arrowFunctionExpression: uo,
assignmentExpression: dr,
binaryExpression: zn,
blockStatement: tD,
callExpression: _r,
conditionalExpression: rD,
expressionStatement: Bf,
identifier: Ge,
isIdentifier: iD,
jsxIdentifier: sD,
logicalExpression: nD,
LOGICAL_OPERATORS: aD,
memberExpression: Ot,
metaProperty: oD,
numericLiteral: uD,
objectExpression: lD,
restElement: cD,
returnStatement: fD,
sequenceExpression: pD,
spreadElement: hD,
stringLiteral: Ff,
super: Qn,
thisExpression: oi,
toExpression: dD,
unaryExpression: mD
} = Zk;
function yD() {
let e;
if (this.isMemberExpression())
  e = this.node.property;
else if (this.isProperty() || this.isMethod())
  e = this.node.key;
else
  throw new ReferenceError("todo");
return this.node.computed || iD(e) && (e = Ff(e.name)), e;
}
function bD() {
const e = this.get("body"), t = e.node;
if (Array.isArray(e))
  throw new Error("Can't convert array path to a block statement");
if (!t)
  throw new Error("Can't convert node without a body");
if (e.isBlockStatement())
  return t;
const r = [];
let i = "body", s, n;
e.isStatement() ? (n = "body", s = 0, r.push(e.node)) : (i += ".body.0", this.isFunction() ? (s = "argument", r.push(fD(e.node))) : (s = "expression", r.push(Bf(e.node)))), this.node.body = tD(r);
const a = this.get(i);
return e.setup(a, n ? a.node[n] : a.node, n, s), this.node;
}
Er.arrowFunctionToShadowed = function() {
this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
};
function TD() {
if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
  throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
jf(this);
}
function gD(e, t) {
e.node.type = t;
}
function SD({
allowInsertArrow: e = !0,
allowInsertArrowWithRest: t = e,
noNewArrows: r = !((i) => (i = arguments[0]) == null ? void 0 : i.specCompliant)()
} = {}) {
if (!this.isArrowFunctionExpression())
  throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
const {
  thisBinding: i,
  fnPath: s
} = jf(this, r, e, t);
if (s.ensureBlock(), gD(s, "FunctionExpression"), !r) {
  const n = i ? null : s.scope.generateUidIdentifier("arrowCheckId");
  return n && s.parentPath.scope.push({
    id: n,
    init: lD([])
  }), s.get("body").unshiftContainer("body", Bf(_r(this.hub.addHelper("newArrowCheck"), [oi(), Ge(n ? n.name : i)]))), s.replaceWith(_r(Ot((0, eD.default)(this, !0) || s.node, Ge("bind")), [n ? Ge(n.name) : oi()])), s.get("callee.object");
}
return s;
}
const xD = (0, oo.merge)([{
CallExpression(e, {
  allSuperCalls: t
}) {
  e.get("callee").isSuper() && t.push(e);
}
}, ao.default]);
function jf(e, t = !0, r = !0, i = !0) {
let s, n = e.findParent((h) => {
  if (h.isArrowFunctionExpression()) {
    var y;
    return (y = s) != null || (s = h), !1;
  }
  return h.isFunction() || h.isProgram() || h.isClassProperty({
    static: !1
  }) || h.isClassPrivateProperty({
    static: !1
  });
});
const a = n.isClassMethod({
  kind: "constructor"
});
if (n.isClassProperty() || n.isClassPrivateProperty())
  if (s)
    n = s;
  else if (r)
    e.replaceWith(_r(uo([], dD(e.node)), [])), n = e.get("callee"), e = n.get("body");
  else
    throw e.buildCodeFrameError("Unable to transform arrow inside class property");
const {
  thisPaths: o,
  argumentsPaths: u,
  newTargetPaths: l,
  superProps: c,
  superCalls: f
} = ND(e);
if (a && f.length > 0) {
  if (!r)
    throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
  if (!i)
    throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
  const h = [];
  n.traverse(xD, {
    allSuperCalls: h
  });
  const y = ID(n);
  h.forEach((g) => {
    const A = Ge(y);
    A.loc = g.node.callee.loc, g.get("callee").replaceWith(A);
  });
}
if (u.length > 0) {
  const h = ui(n, "arguments", () => {
    const y = () => Ge("arguments");
    return n.scope.path.isProgram() ? rD(zn("===", mD("typeof", y()), Ff("undefined")), n.scope.buildUndefinedNode(), y()) : y();
  });
  u.forEach((y) => {
    const g = Ge(h);
    g.loc = y.node.loc, y.replaceWith(g);
  });
}
if (l.length > 0) {
  const h = ui(n, "newtarget", () => oD(Ge("new"), Ge("target")));
  l.forEach((y) => {
    const g = Ge(h);
    g.loc = y.node.loc, y.replaceWith(g);
  });
}
if (c.length > 0) {
  if (!r)
    throw c[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
  c.reduce((y, g) => y.concat(PD(g)), []).forEach((y) => {
    const g = y.node.computed ? "" : y.get("property").node.name, A = y.parentPath, C = A.isAssignmentExpression({
      left: y.node
    }), _ = A.isCallExpression({
      callee: y.node
    }), j = A.isTaggedTemplateExpression({
      tag: y.node
    }), G = CD(n, C, g), fe = [];
    if (y.node.computed && fe.push(y.get("property").node), C) {
      const oe = A.node.right;
      fe.push(oe);
    }
    const re = _r(Ge(G), fe);
    _ ? (A.unshiftContainer("arguments", oi()), y.replaceWith(Ot(re, Ge("call"))), o.push(A.get("arguments.0"))) : C ? A.replaceWith(re) : j ? (y.replaceWith(_r(Ot(re, Ge("bind"), !1), [oi()])), o.push(y.get("arguments.0"))) : y.replaceWith(re);
  });
}
let p;
return (o.length > 0 || !t) && (p = AD(n, a), (t || a && Rf(n)) && (o.forEach((h) => {
  const y = h.isJSX() ? sD(p) : Ge(p);
  y.loc = h.node.loc, h.replaceWith(y);
}), t || (p = null))), {
  thisBinding: p,
  fnPath: e
};
}
function ED(e) {
return aD.includes(e);
}
function PD(e) {
if (e.parentPath.isAssignmentExpression() && e.parentPath.node.operator !== "=") {
  const r = e.parentPath, i = r.node.operator.slice(0, -1), s = r.node.right, n = ED(i);
  if (e.node.computed) {
    const a = e.scope.generateDeclaredUidIdentifier("tmp"), o = e.node.object, u = e.node.property;
    r.get("left").replaceWith(Ot(o, dr("=", a, u), !0)), r.get("right").replaceWith(t(n ? "=" : i, Ot(o, Ge(a.name), !0), s));
  } else {
    const a = e.node.object, o = e.node.property;
    r.get("left").replaceWith(Ot(a, o)), r.get("right").replaceWith(t(n ? "=" : i, Ot(a, Ge(o.name)), s));
  }
  return n ? r.replaceWith(nD(i, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
} else if (e.parentPath.isUpdateExpression()) {
  const r = e.parentPath, i = e.scope.generateDeclaredUidIdentifier("tmp"), s = e.node.computed ? e.scope.generateDeclaredUidIdentifier("prop") : null, n = [dr("=", i, Ot(e.node.object, s ? dr("=", s, e.node.property) : e.node.property, e.node.computed)), dr("=", Ot(e.node.object, s ? Ge(s.name) : e.node.property, e.node.computed), zn(e.parentPath.node.operator[0], Ge(i.name), uD(1)))];
  e.parentPath.node.prefix || n.push(Ge(i.name)), r.replaceWith(pD(n));
  const a = r.get("expressions.0.right"), o = r.get("expressions.1.left");
  return [a, o];
}
return [e];
function t(r, i, s) {
  return r === "=" ? dr("=", i, s) : zn(r, i, s);
}
}
function Rf(e) {
return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
}
const vD = (0, oo.merge)([{
CallExpression(e, {
  supers: t,
  thisBinding: r
}) {
  e.get("callee").isSuper() && (t.has(e.node) || (t.add(e.node), e.replaceWithMultiple([e.node, dr("=", Ge(r), Ge("this"))])));
}
}, ao.default]);
function AD(e, t) {
return ui(e, "this", (r) => {
  if (!t || !Rf(e)) return oi();
  e.traverse(vD, {
    supers: /* @__PURE__ */ new WeakSet(),
    thisBinding: r
  });
});
}
function ID(e) {
return ui(e, "supercall", () => {
  const t = e.scope.generateUidIdentifier("args");
  return uo([cD(t)], _r(Qn(), [hD(Ge(t.name))]));
});
}
function CD(e, t, r) {
return ui(e, `superprop_${t ? "set" : "get"}:${r || ""}`, () => {
  const s = [];
  let n;
  if (r)
    n = Ot(Qn(), Ge(r));
  else {
    const a = e.scope.generateUidIdentifier("prop");
    s.unshift(a), n = Ot(Qn(), Ge(a.name), !0);
  }
  if (t) {
    const a = e.scope.generateUidIdentifier("value");
    s.push(a), n = dr("=", n, Ge(a.name));
  }
  return uo(s, n);
});
}
function ui(e, t, r) {
const i = "binding:" + t;
let s = e.getData(i);
if (!s) {
  const n = e.scope.generateUidIdentifier(t);
  s = n.name, e.setData(i, s), e.scope.push({
    id: n,
    init: r(s)
  });
}
return s;
}
const wD = (0, oo.merge)([{
ThisExpression(e, {
  thisPaths: t
}) {
  t.push(e);
},
JSXIdentifier(e, {
  thisPaths: t
}) {
  e.node.name === "this" && (!e.parentPath.isJSXMemberExpression({
    object: e.node
  }) && !e.parentPath.isJSXOpeningElement({
    name: e.node
  }) || t.push(e));
},
CallExpression(e, {
  superCalls: t
}) {
  e.get("callee").isSuper() && t.push(e);
},
MemberExpression(e, {
  superProps: t
}) {
  e.get("object").isSuper() && t.push(e);
},
Identifier(e, {
  argumentsPaths: t
}) {
  if (!e.isReferencedIdentifier({
    name: "arguments"
  })) return;
  let r = e.scope;
  do {
    if (r.hasOwnBinding("arguments")) {
      r.rename("arguments");
      return;
    }
    if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
      break;
  } while (r = r.parent);
  t.push(e);
},
MetaProperty(e, {
  newTargetPaths: t
}) {
  e.get("meta").isIdentifier({
    name: "new"
  }) && e.get("property").isIdentifier({
    name: "target"
  }) && t.push(e);
}
}, ao.default]);
function ND(e) {
const t = [], r = [], i = [], s = [], n = [];
return e.traverse(wD, {
  thisPaths: t,
  argumentsPaths: r,
  newTargetPaths: i,
  superProps: s,
  superCalls: n
}), {
  thisPaths: t,
  argumentsPaths: r,
  newTargetPaths: i,
  superProps: s,
  superCalls: n
};
}
var et = {};
Object.defineProperty(et, "__esModule", {
value: !0
});
et._guessExecutionStatusRelativeTo = QD;
et._resolve = qf;
et.canHaveVariableDeclarationOrExpression = KD;
et.canSwapBetweenExpressionAndStatement = WD;
et.equals = qD;
et.getSource = HD;
et.has = Vf;
et.is = void 0;
et.isCompletionRecord = JD;
et.isConstantExpression = rL;
et.isInStrictMode = iL;
et.isNodeType = $D;
et.isStatementOrBlock = YD;
et.isStatic = UD;
et.isnt = VD;
et.matchesPattern = RD;
et.referencesImport = XD;
et.resolve = tL;
et.willIMaybeExecuteBefore = GD;
var OD = Ce();
const {
STATEMENT_OR_BLOCK_KEYS: _D,
VISITOR_KEYS: kD,
isBlockStatement: Uf,
isExpression: DD,
isIdentifier: LD,
isLiteral: MD,
isStringLiteral: BD,
isType: FD,
matchesPattern: jD
} = OD;
function RD(e, t) {
return jD(this.node, e, t);
}
function Vf(e) {
var t;
const r = (t = this.node) == null ? void 0 : t[e];
return r && Array.isArray(r) ? !!r.length : !!r;
}
function UD() {
return this.scope.isStatic(this.node);
}
et.is = Vf;
function VD(e) {
return !this.has(e);
}
function qD(e, t) {
return this.node[e] === t;
}
function $D(e) {
return FD(this.type, e);
}
function KD() {
return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
}
function WD(e) {
return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? Uf(e) : this.isBlockStatement() ? DD(e) : !1;
}
function JD(e) {
let t = this, r = !0;
do {
  const {
    type: i,
    container: s
  } = t;
  if (!r && (t.isFunction() || i === "StaticBlock"))
    return !!e;
  if (r = !1, Array.isArray(s) && t.key !== s.length - 1)
    return !1;
} while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
return !0;
}
function YD() {
return this.parentPath.isLabeledStatement() || Uf(this.container) ? !1 : _D.includes(this.key);
}
function XD(e, t) {
if (!this.isReferencedIdentifier()) {
  if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? BD(this.node.property, {
    value: t
  }) : this.node.property.name === t)) {
    const n = this.get("object");
    return n.isReferencedIdentifier() && n.referencesImport(e, "*");
  }
  return !1;
}
const r = this.scope.getBinding(this.node.name);
if (!r || r.kind !== "module") return !1;
const i = r.path, s = i.parentPath;
if (!s.isImportDeclaration()) return !1;
if (s.node.source.value === e) {
  if (!t) return !0;
} else
  return !1;
return !!(i.isImportDefaultSpecifier() && t === "default" || i.isImportNamespaceSpecifier() && t === "*" || i.isImportSpecifier() && LD(i.node.imported, {
  name: t
}));
}
function HD() {
const e = this.node;
if (e.end) {
  const t = this.hub.getCode();
  if (t) return t.slice(e.start, e.end);
}
return "";
}
function GD(e) {
return this._guessExecutionStatusRelativeTo(e) !== "after";
}
function kl(e) {
return e.isProgram() ? e : (e.parentPath.scope.getFunctionParent() || e.parentPath.scope.getProgramParent()).path;
}
function zD(e, t) {
switch (e) {
  case "LogicalExpression":
    return t === "right";
  case "ConditionalExpression":
  case "IfStatement":
    return t === "consequent" || t === "alternate";
  case "WhileStatement":
  case "DoWhileStatement":
  case "ForInStatement":
  case "ForOfStatement":
    return t === "body";
  case "ForStatement":
    return t === "body" || t === "update";
  case "SwitchStatement":
    return t === "cases";
  case "TryStatement":
    return t === "handler";
  case "AssignmentPattern":
    return t === "right";
  case "OptionalMemberExpression":
    return t === "property";
  case "OptionalCallExpression":
    return t === "arguments";
  default:
    return !1;
}
}
function Dl(e, t) {
for (let r = 0; r < t; r++) {
  const i = e[r];
  if (zD(i.parent.type, i.parentKey))
    return !0;
}
return !1;
}
const Ll = Symbol();
function QD(e) {
return Zn(this, e, /* @__PURE__ */ new Map());
}
function Zn(e, t, r) {
const i = {
  this: kl(e),
  target: kl(t)
};
if (i.target.node !== i.this.node)
  return eL(e, i.target, r);
const s = {
  target: t.getAncestry(),
  this: e.getAncestry()
};
if (s.target.includes(e)) return "after";
if (s.this.includes(t)) return "before";
let n;
const a = {
  target: 0,
  this: 0
};
for (; !n && a.this < s.this.length; ) {
  const c = s.this[a.this];
  a.target = s.target.indexOf(c), a.target >= 0 ? n = c : a.this++;
}
if (!n)
  throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
if (Dl(s.this, a.this - 1) || Dl(s.target, a.target - 1))
  return "unknown";
const o = {
  this: s.this[a.this - 1],
  target: s.target[a.target - 1]
};
if (o.target.listKey && o.this.listKey && o.target.container === o.this.container)
  return o.target.key > o.this.key ? "before" : "after";
const u = kD[n.type], l = {
  this: u.indexOf(o.this.parentKey),
  target: u.indexOf(o.target.parentKey)
};
return l.target > l.this ? "before" : "after";
}
function ZD(e, t, r) {
if (t.isFunctionDeclaration()) {
  if (t.parentPath.isExportDeclaration())
    return "unknown";
} else return Zn(e, t, r) === "before" ? "before" : "unknown";
const i = t.scope.getBinding(t.node.id.name);
if (!i.references) return "before";
const s = i.referencePaths;
let n;
for (const a of s) {
  if (!!a.find((l) => l.node === t.node)) continue;
  if (a.key !== "callee" || !a.parentPath.isCallExpression())
    return "unknown";
  const u = Zn(e, a, r);
  if (n && n !== u)
    return "unknown";
  n = u;
}
return n;
}
function eL(e, t, r) {
let i = r.get(e.node), s;
if (!i)
  r.set(e.node, i = /* @__PURE__ */ new Map());
else if (s = i.get(t.node))
  return s === Ll ? "unknown" : s;
i.set(t.node, Ll);
const n = ZD(e, t, r);
return i.set(t.node, n), n;
}
function tL(e, t) {
return qf.call(this, e, t) || this;
}
function qf(e, t) {
var r;
if (!((r = t) != null && r.includes(this)))
  if (t = t || [], t.push(this), this.isVariableDeclarator()) {
    if (this.get("id").isIdentifier())
      return this.get("init").resolve(e, t);
  } else if (this.isReferencedIdentifier()) {
    const i = this.scope.getBinding(this.node.name);
    if (!i || !i.constant || i.kind === "module") return;
    if (i.path !== this) {
      const s = i.path.resolve(e, t);
      return this.find((n) => n.node === s.node) ? void 0 : s;
    }
  } else {
    if (this.isTypeCastExpression())
      return this.get("expression").resolve(e, t);
    if (e && this.isMemberExpression()) {
      const i = this.toComputedKey();
      if (!MD(i)) return;
      const s = i.value, n = this.get("object").resolve(e, t);
      if (n.isObjectExpression()) {
        const a = n.get("properties");
        for (const o of a) {
          if (!o.isProperty()) continue;
          const u = o.get("key");
          let l = o.isnt("computed") && u.isIdentifier({
            name: s
          });
          if (l = l || u.isLiteral({
            value: s
          }), l) return o.get("value").resolve(e, t);
        }
      } else if (n.isArrayExpression() && !isNaN(+s)) {
        const o = n.get("elements")[s];
        if (o) return o.resolve(e, t);
      }
    }
  }
}
function rL() {
if (this.isIdentifier()) {
  const e = this.scope.getBinding(this.node.name);
  return e ? e.constant : !1;
}
if (this.isLiteral())
  return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((e) => e.isConstantExpression()) : !0;
if (this.isUnaryExpression())
  return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
if (this.isBinaryExpression()) {
  const {
    operator: e
  } = this.node;
  return e !== "in" && e !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
}
return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
  name: "Symbol"
}) && !this.scope.hasBinding("Symbol", {
  noGlobals: !0
}) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
  noGlobals: !0
}) && this.get("arguments")[0].isStringLiteral() : !1;
}
function iL() {
return !!(this.isProgram() ? this : this.parentPath).find((r) => {
  if (r.isProgram({
    sourceType: "module"
  }) || r.isClass()) return !0;
  if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement())
    return !1;
  let i;
  if (r.isFunction())
    i = r.node.body;
  else if (r.isProgram())
    i = r.node;
  else
    return !1;
  for (const s of i.directives)
    if (s.value.value === "use strict")
      return !0;
});
}
var ft = {}, Ml;
function sL() {
if (Ml) return ft;
Ml = 1, Object.defineProperty(ft, "__esModule", {
  value: !0
}), ft._getKey = K, ft._getPattern = X, ft.get = oe, ft.getAllNextSiblings = fe, ft.getAllPrevSiblings = re, ft.getBindingIdentifierPaths = Q, ft.getBindingIdentifiers = ie, ft.getCompletionRecords = C, ft.getNextSibling = G, ft.getOpposite = c, ft.getOuterBindingIdentifierPaths = U, ft.getOuterBindingIdentifiers = W, ft.getPrevSibling = j, ft.getSibling = _;
var e = vr(), t = Ce();
const {
  getBindingIdentifiers: r,
  getOuterBindingIdentifiers: i,
  numericLiteral: s,
  unaryExpression: n
} = t, a = 0, o = 1;
function u(L) {
  return {
    type: a,
    path: L
  };
}
function l(L) {
  return {
    type: o,
    path: L
  };
}
function c() {
  return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
}
function f(L, k, F) {
  return L && k.push(...A(L, F)), k;
}
function p(L, k, F) {
  let B = [];
  for (let O = 0; O < L.length; O++) {
    const D = L[O], R = A(D, F), q = [], V = [];
    for (const H of R)
      H.type === a && q.push(H), H.type === o && V.push(H);
    q.length && (B = q), k.push(...V);
  }
  return k.push(...B), k;
}
function h(L) {
  L.forEach((k) => {
    k.type = o;
  });
}
function y(L, k) {
  L.forEach((F) => {
    F.path.isBreakStatement({
      label: null
    }) && (k ? F.path.replaceWith(n("void", s(0))) : F.path.remove());
  });
}
function g(L, k) {
  const F = [];
  if (k.canHaveBreak) {
    let B = [];
    for (let O = 0; O < L.length; O++) {
      const D = L[O], R = Object.assign({}, k, {
        inCaseClause: !1
      });
      D.isBlockStatement() && (k.inCaseClause || k.shouldPopulateBreak) ? R.shouldPopulateBreak = !0 : R.shouldPopulateBreak = !1;
      const q = A(D, R);
      if (q.length > 0 && q.every((V) => V.type === o)) {
        B.length > 0 && q.every((V) => V.path.isBreakStatement({
          label: null
        })) ? (h(B), F.push(...B), B.some((V) => V.path.isDeclaration()) && (F.push(...q), y(q, !0)), y(q, !1)) : (F.push(...q), k.shouldPopulateBreak || y(q, !0));
        break;
      }
      if (O === L.length - 1)
        F.push(...q);
      else {
        B = [];
        for (let V = 0; V < q.length; V++) {
          const H = q[V];
          H.type === o && F.push(H), H.type === a && B.push(H);
        }
      }
    }
  } else if (L.length)
    for (let B = L.length - 1; B >= 0; B--) {
      const O = A(L[B], k);
      if (O.length > 1 || O.length === 1 && !O[0].path.isVariableDeclaration()) {
        F.push(...O);
        break;
      }
    }
  return F;
}
function A(L, k) {
  let F = [];
  if (L.isIfStatement())
    F = f(L.get("consequent"), F, k), F = f(L.get("alternate"), F, k);
  else {
    if (L.isDoExpression() || L.isFor() || L.isWhile() || L.isLabeledStatement())
      return f(L.get("body"), F, k);
    if (L.isProgram() || L.isBlockStatement())
      return g(L.get("body"), k);
    if (L.isFunction())
      return A(L.get("body"), k);
    if (L.isTryStatement())
      F = f(L.get("block"), F, k), F = f(L.get("handler"), F, k);
    else {
      if (L.isCatchClause())
        return f(L.get("body"), F, k);
      if (L.isSwitchStatement())
        return p(L.get("cases"), F, k);
      if (L.isSwitchCase())
        return g(L.get("consequent"), {
          canHaveBreak: !0,
          shouldPopulateBreak: !1,
          inCaseClause: !0
        });
      L.isBreakStatement() ? F.push(l(L)) : F.push(u(L));
    }
  }
  return F;
}
function C() {
  return A(this, {
    canHaveBreak: !1,
    shouldPopulateBreak: !1,
    inCaseClause: !1
  }).map((k) => k.path);
}
function _(L) {
  return e.default.get({
    parentPath: this.parentPath,
    parent: this.parent,
    container: this.container,
    listKey: this.listKey,
    key: L
  }).setContext(this.context);
}
function j() {
  return this.getSibling(this.key - 1);
}
function G() {
  return this.getSibling(this.key + 1);
}
function fe() {
  let L = this.key, k = this.getSibling(++L);
  const F = [];
  for (; k.node; )
    F.push(k), k = this.getSibling(++L);
  return F;
}
function re() {
  let L = this.key, k = this.getSibling(--L);
  const F = [];
  for (; k.node; )
    F.push(k), k = this.getSibling(--L);
  return F;
}
function oe(L, k = !0) {
  k === !0 && (k = this.context);
  const F = L.split(".");
  return F.length === 1 ? K.call(this, L, k) : X.call(this, F, k);
}
function K(L, k) {
  const F = this.node, B = F[L];
  return Array.isArray(B) ? B.map((O, D) => e.default.get({
    listKey: L,
    parentPath: this,
    parent: F,
    container: B,
    key: D
  }).setContext(k)) : e.default.get({
    parentPath: this,
    parent: F,
    container: F,
    key: L
  }).setContext(k);
}
function X(L, k) {
  let F = this;
  for (const B of L)
    B === "." ? F = F.parentPath : Array.isArray(F) ? F = F[B] : F = F.get(B, k);
  return F;
}
function ie(L) {
  return r(this.node, L);
}
function W(L) {
  return i(this.node, L);
}
function Q(L = !1, k = !1) {
  const B = [this], O = /* @__PURE__ */ Object.create(null);
  for (; B.length; ) {
    const D = B.shift();
    if (!D || !D.node) continue;
    const R = r.keys[D.node.type];
    if (D.isIdentifier()) {
      L ? (O[D.node.name] = O[D.node.name] || []).push(D) : O[D.node.name] = D;
      continue;
    }
    if (D.isExportDeclaration()) {
      const q = D.get("declaration");
      q.isDeclaration() && B.push(q);
      continue;
    }
    if (k) {
      if (D.isFunctionDeclaration()) {
        B.push(D.get("id"));
        continue;
      }
      if (D.isFunctionExpression())
        continue;
    }
    if (R)
      for (let q = 0; q < R.length; q++) {
        const V = R[q], H = D.get(V);
        Array.isArray(H) ? B.push(...H) : H.node && B.push(H);
      }
  }
  return O;
}
function U(L = !1) {
  return this.getBindingIdentifierPaths(L, !0);
}
return ft;
}
var Ai = {};
Object.defineProperty(Ai, "__esModule", {
value: !0
});
Ai.addComment = lL;
Ai.addComments = cL;
Ai.shareCommentsWithSiblings = uL;
var nL = Ce();
const {
addComment: aL,
addComments: oL
} = nL;
function uL() {
if (typeof this.key == "string") return;
const e = this.node;
if (!e) return;
const t = e.trailingComments, r = e.leadingComments;
if (!t && !r) return;
const i = this.getSibling(this.key - 1), s = this.getSibling(this.key + 1), n = !!i.node, a = !!s.node;
n && (r && i.addComments("trailing", Bl(r, i.node.trailingComments)), t && !a && i.addComments("trailing", t)), a && (t && s.addComments("leading", Bl(t, s.node.leadingComments)), r && !n && s.addComments("leading", r));
}
function Bl(e, t) {
if (!(t != null && t.length)) return e;
const r = new Set(t);
return e.filter((i) => !r.has(i));
}
function lL(e, t, r) {
aL(this.node, e, t, r);
}
function cL(e, t) {
oL(this.node, e, t);
}
var Fl;
function vr() {
if (Fl) return Nt;
Fl = 1, Object.defineProperty(Nt, "__esModule", {
  value: !0
}), Nt.default = Nt.SHOULD_STOP = Nt.SHOULD_SKIP = Nt.REMOVED = void 0;
var e = _e, t = X3, r = zs(), i = Ec(), s = Ce(), n = s, a = lt, o = Ms, u = wt, l = lr, c = kf(), f = Ys, p = Er, h = et, y = cf(), g = Ua(), A = ff(), C = sL(), _ = Ai, j = rt;
const {
  validate: G
} = s, fe = t("babel");
Nt.REMOVED = 1, Nt.SHOULD_STOP = 2, Nt.SHOULD_SKIP = 4;
const re = Nt.default = class $f {
  constructor(X, ie) {
    this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = ie, this.hub = X, this.data = null, this.context = null, this.scope = null;
  }
  get removed() {
    return (this._traverseFlags & 1) > 0;
  }
  set removed(X) {
    X ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
  }
  get shouldStop() {
    return (this._traverseFlags & 2) > 0;
  }
  set shouldStop(X) {
    X ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
  }
  get shouldSkip() {
    return (this._traverseFlags & 4) > 0;
  }
  set shouldSkip(X) {
    X ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
  }
  static get({
    hub: X,
    parentPath: ie,
    parent: W,
    container: Q,
    listKey: U,
    key: L
  }) {
    if (!X && ie && (X = ie.hub), !W)
      throw new Error("To get a node path the parent needs to exist");
    const k = Q[L], F = a.getOrCreateCachedPaths(X, W);
    let B = F.get(k);
    return B || (B = new $f(X, W), k && F.set(k, B)), B.setup(ie, Q, U, L), B;
  }
  getScope(X) {
    return this.isScope() ? new i.default(this) : X;
  }
  setData(X, ie) {
    return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[X] = ie;
  }
  getData(X, ie) {
    this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
    let W = this.data[X];
    return W === void 0 && ie !== void 0 && (W = this.data[X] = ie), W;
  }
  hasNode() {
    return this.node != null;
  }
  buildCodeFrameError(X, ie = SyntaxError) {
    return this.hub.buildError(this.node, X, ie);
  }
  traverse(X, ie) {
    (0, r.default)(this.node, X, this.scope, ie, this);
  }
  set(X, ie) {
    G(this.node, X, ie), this.node[X] = ie;
  }
  getPathLocation() {
    const X = [];
    let ie = this;
    do {
      let W = ie.key;
      ie.inList && (W = `${ie.listKey}[${W}]`), X.unshift(W);
    } while (ie = ie.parentPath);
    return X.join(".");
  }
  debug(X) {
    fe.enabled && fe(`${this.getPathLocation()} ${this.type}: ${X}`);
  }
  toString() {
    return (0, o.default)(this.node).code;
  }
  get inList() {
    return !!this.listKey;
  }
  set inList(X) {
    X || (this.listKey = null);
  }
  get parentKey() {
    return this.listKey || this.key;
  }
}, oe = {
  findParent: u.findParent,
  find: u.find,
  getFunctionParent: u.getFunctionParent,
  getStatementParent: u.getStatementParent,
  getEarliestCommonAncestorFrom: u.getEarliestCommonAncestorFrom,
  getDeepestCommonAncestorFrom: u.getDeepestCommonAncestorFrom,
  getAncestry: u.getAncestry,
  isAncestor: u.isAncestor,
  isDescendant: u.isDescendant,
  inType: u.inType,
  getTypeAnnotation: l.getTypeAnnotation,
  isBaseType: l.isBaseType,
  couldBeBaseType: l.couldBeBaseType,
  baseTypeStrictlyMatches: l.baseTypeStrictlyMatches,
  isGenericType: l.isGenericType,
  replaceWithMultiple: c.replaceWithMultiple,
  replaceWithSourceString: c.replaceWithSourceString,
  replaceWith: c.replaceWith,
  replaceExpressionWithStatements: c.replaceExpressionWithStatements,
  replaceInline: c.replaceInline,
  evaluateTruthy: f.evaluateTruthy,
  evaluate: f.evaluate,
  toComputedKey: p.toComputedKey,
  ensureBlock: p.ensureBlock,
  unwrapFunctionEnvironment: p.unwrapFunctionEnvironment,
  arrowFunctionToExpression: p.arrowFunctionToExpression,
  matchesPattern: h.matchesPattern,
  has: h.has,
  isStatic: h.isStatic,
  is: h.is,
  isnt: h.isnt,
  equals: h.equals,
  isNodeType: h.isNodeType,
  canHaveVariableDeclarationOrExpression: h.canHaveVariableDeclarationOrExpression,
  canSwapBetweenExpressionAndStatement: h.canSwapBetweenExpressionAndStatement,
  isCompletionRecord: h.isCompletionRecord,
  isStatementOrBlock: h.isStatementOrBlock,
  referencesImport: h.referencesImport,
  getSource: h.getSource,
  willIMaybeExecuteBefore: h.willIMaybeExecuteBefore,
  _guessExecutionStatusRelativeTo: h._guessExecutionStatusRelativeTo,
  resolve: h.resolve,
  isConstantExpression: h.isConstantExpression,
  isInStrictMode: h.isInStrictMode,
  call: y.call,
  isDenylisted: y.isDenylisted,
  isBlacklisted: y.isBlacklisted,
  visit: y.visit,
  skip: y.skip,
  skipKey: y.skipKey,
  stop: y.stop,
  setScope: y.setScope,
  setContext: y.setContext,
  resync: y.resync,
  popContext: y.popContext,
  pushContext: y.pushContext,
  setup: y.setup,
  setKey: y.setKey,
  requeue: y.requeue,
  remove: g.remove,
  insertBefore: A.insertBefore,
  insertAfter: A.insertAfter,
  updateSiblingKeys: A.updateSiblingKeys,
  unshiftContainer: A.unshiftContainer,
  pushContainer: A.pushContainer,
  hoist: A.hoist,
  getOpposite: C.getOpposite,
  getCompletionRecords: C.getCompletionRecords,
  getSibling: C.getSibling,
  getPrevSibling: C.getPrevSibling,
  getNextSibling: C.getNextSibling,
  getAllNextSiblings: C.getAllNextSiblings,
  getAllPrevSiblings: C.getAllPrevSiblings,
  get: C.get,
  getBindingIdentifiers: C.getBindingIdentifiers,
  getOuterBindingIdentifiers: C.getOuterBindingIdentifiers,
  getBindingIdentifierPaths: C.getBindingIdentifierPaths,
  getOuterBindingIdentifierPaths: C.getOuterBindingIdentifierPaths,
  shareCommentsWithSiblings: _.shareCommentsWithSiblings,
  addComment: _.addComment,
  addComments: _.addComments
};
Object.assign(re.prototype, oe), re.prototype.arrowFunctionToShadowed = p.arrowFunctionToShadowed, re.prototype._guessExecutionStatusRelativeToDifferentFunctions = h._guessExecutionStatusRelativeTo, re.prototype._guessExecutionStatusRelativeToDifferentFunctions = h._guessExecutionStatusRelativeTo, Object.assign(re.prototype, {
  _getTypeAnnotation: l._getTypeAnnotation,
  _replaceWith: c._replaceWith,
  _resolve: h._resolve,
  _call: y._call,
  _resyncParent: y._resyncParent,
  _resyncKey: y._resyncKey,
  _resyncList: y._resyncList,
  _resyncRemoved: y._resyncRemoved,
  _getQueueContexts: y._getQueueContexts,
  _removeFromScope: g._removeFromScope,
  _callRemovalHooks: g._callRemovalHooks,
  _remove: g._remove,
  _markRemoved: g._markRemoved,
  _assertUnremoved: g._assertUnremoved,
  _containerInsert: A._containerInsert,
  _containerInsertBefore: A._containerInsertBefore,
  _containerInsertAfter: A._containerInsertAfter,
  _verifyNodeList: A._verifyNodeList,
  _getKey: C._getKey,
  _getPattern: C._getPattern
});
for (const K of n.TYPES) {
  const X = `is${K}`, ie = n[X];
  re.prototype[X] = function(W) {
    return ie(this.node, W);
  }, re.prototype[`assert${K}`] = function(W) {
    if (!ie(this.node, W))
      throw new TypeError(`Expected node path of type ${K}`);
  };
}
Object.assign(re.prototype, j);
for (const K of Object.keys(e))
  K[0] !== "_" && (n.TYPES.includes(K) || n.TYPES.push(K));
return Nt;
}
var jl;
function fL() {
if (jl) return Kr;
jl = 1, Object.defineProperty(Kr, "__esModule", {
  value: !0
}), Kr.default = void 0;
var e = vr(), t = Ce();
const {
  VISITOR_KEYS: r
} = t;
class i {
  constructor(n, a, o, u) {
    this.queue = null, this.priorityQueue = null, this.parentPath = u, this.scope = n, this.state = o, this.opts = a;
  }
  shouldVisit(n) {
    const a = this.opts;
    if (a.enter || a.exit || a[n.type]) return !0;
    const o = r[n.type];
    if (!(o != null && o.length)) return !1;
    for (const u of o)
      if (n[u])
        return !0;
    return !1;
  }
  create(n, a, o, u) {
    return e.default.get({
      parentPath: this.parentPath,
      parent: n,
      container: a,
      key: o,
      listKey: u
    });
  }
  maybeQueue(n, a) {
    this.queue && (a ? this.queue.push(n) : this.priorityQueue.push(n));
  }
  visitMultiple(n, a, o) {
    if (n.length === 0) return !1;
    const u = [];
    for (let l = 0; l < n.length; l++) {
      const c = n[l];
      c && this.shouldVisit(c) && u.push(this.create(a, n, l, o));
    }
    return this.visitQueue(u);
  }
  visitSingle(n, a) {
    return this.shouldVisit(n[a]) ? this.visitQueue([this.create(n, n, a)]) : !1;
  }
  visitQueue(n) {
    this.queue = n, this.priorityQueue = [];
    const a = /* @__PURE__ */ new WeakSet();
    let o = !1, u = 0;
    for (; u < n.length; ) {
      const l = n[u];
      if (u++, l.resync(), (l.contexts.length === 0 || l.contexts[l.contexts.length - 1] !== this) && l.pushContext(this), l.key === null) continue;
      const {
        node: c
      } = l;
      if (!a.has(c)) {
        if (c && a.add(c), l.visit()) {
          o = !0;
          break;
        }
        if (this.priorityQueue.length && (o = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = n, o))
          break;
      }
    }
    for (let l = 0; l < u; l++)
      n[l].popContext();
    return this.queue = null, o;
  }
  visit(n, a) {
    const o = n[a];
    return o ? Array.isArray(o) ? this.visitMultiple(o, n, a) : this.visitSingle(n, a) : !1;
  }
}
return Kr.default = i, Kr;
}
var Rl;
function lo() {
if (Rl) return Gi;
Rl = 1, Object.defineProperty(Gi, "__esModule", {
  value: !0
}), Gi.traverseNode = i;
var e = fL(), t = Ce();
const {
  VISITOR_KEYS: r
} = t;
function i(s, n, a, o, u, l, c) {
  const f = r[s.type];
  if (!f) return !1;
  const p = new e.default(a, n, o, u);
  if (c)
    return l != null && l[u.parentKey] ? !1 : p.visitQueue([u]);
  for (const h of f)
    if (!(l != null && l[h]) && p.visit(s, h))
      return !0;
  return !1;
}
return Gi;
}
var Gs = {};
Object.defineProperty(Gs, "__esModule", {
value: !0
});
Gs.default = void 0;
class pL {
getCode() {
}
getScope() {
}
addHelper() {
  throw new Error("Helpers are not supported by the default hub.");
}
buildError(t, r, i = TypeError) {
  return new i(r);
}
}
Gs.default = pL;
var Ul;
function zs() {
return Ul || (Ul = 1, function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), Object.defineProperty(e, "Hub", {
    enumerable: !0,
    get: function() {
      return o.default;
    }
  }), Object.defineProperty(e, "NodePath", {
    enumerable: !0,
    get: function() {
      return n.default;
    }
  }), Object.defineProperty(e, "Scope", {
    enumerable: !0,
    get: function() {
      return a.default;
    }
  }), e.visitors = e.default = void 0;
  var t = zt;
  e.visitors = t;
  var r = Ce(), i = lt, s = lo(), n = vr(), a = Ec(), o = Gs;
  const {
    VISITOR_KEYS: u,
    removeProperties: l,
    traverseFast: c
  } = r;
  function f(h, y = {}, g, A, C, _) {
    if (h) {
      if (!y.noScope && !g && h.type !== "Program" && h.type !== "File")
        throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${h.type} node without passing scope and parentPath.`);
      if (!C && _)
        throw new Error("visitSelf can only be used when providing a NodePath.");
      u[h.type] && (t.explode(y), (0, s.traverseNode)(h, y, g, A, C, null, _));
    }
  }
  e.default = f, f.visitors = t, f.verify = t.verify, f.explode = t.explode, f.cheap = function(h, y) {
    c(h, y);
  }, f.node = function(h, y, g, A, C, _) {
    (0, s.traverseNode)(h, y, g, A, C, _);
  }, f.clearNode = function(h, y) {
    l(h, y);
  }, f.removeProperties = function(h, y) {
    return c(h, f.clearNode, y), h;
  };
  function p(h, y) {
    h.node.type === y.type && (y.has = !0, h.stop());
  }
  f.hasType = function(h, y, g) {
    if (g != null && g.includes(h.type)) return !1;
    if (h.type === y) return !0;
    const A = {
      has: !1,
      type: y
    };
    return f(h, {
      noScope: !0,
      denylist: g,
      enter: p
    }, null, A), A.has;
  }, f.cache = i;
}(tn)), tn;
}
var hL = zs();
const dL = /* @__PURE__ */ Wl(hL);
function Kf(e) {
return A_(e, {
  plugins: ["typescript"],
  sourceType: "module"
  // todo
});
}
function Wf(e, t) {
dL(e, t);
}
function mL(e) {
return b4(e, {}).code;
}
var Jf = Ce();
const yL = /* @__PURE__ */ Wl(Jf), bL = /* @__PURE__ */ n0({
__proto__: null,
default: yL
}, [Jf]);
var bt = bL;
function ms(e) {
var t = Gf(e), r = t.type, i = t.key, s = t.operator;
return r === "AssignmentExpression" && i === "left" || r === "UpdateExpression" && i === "argument" || r === "UnaryExpression" && s === "delete" || // delete a.a;
TL(e);
}
function TL(e) {
var t = e.parentPath;
if (t.type === "CallExpression") {
  var r, i, s = t.node.callee;
  if (s.type === "MemberExpression" && ((r = s.object) === null || r === void 0 ? void 0 : r.name) === "Object" && ((i = s.property) === null || i === void 0 ? void 0 : i.name) === "assign" && e.key === 0)
    return !0;
}
return !1;
}
var gL = /* @__PURE__ */ new Set(["push", "pop", "unshift", "shift", "splice", "sort", "reverse"]);
function Yf(e) {
if (e.parent.type === "CallExpression") {
  var t = e.node.property.name;
  if (typeof t != "string") return;
  if (gL.has(t))
    return !0;
}
return !1;
}
function Xf(e) {
return Hf(e.node);
}
function Hf(e) {
for (var t = e.object; t.type === "MemberExpression"; )
  t = t.object;
return t.type === "Identifier" ? t.name : "";
}
function Gf(e) {
var t, r, i = ((t = e.container) === null || t === void 0 ? void 0 : t.type) || "", s = (r = e.container) === null || r === void 0 ? void 0 : r.operator, n = e.key, a = e.listKey;
return {
  type: i,
  key: n,
  listKey: a,
  operator: s
};
}
function SL(e, t, r) {
var i = e.scope.getBinding(t);
if (!i) return !1;
var s = i.path.parentPath;
if ((s == null ? void 0 : s.type) === "ImportDeclaration") {
  var n;
  if (((n = s.node) === null || n === void 0 || (n = n.source) === null || n === void 0 ? void 0 : n.value) === r) return !0;
}
return !1;
}
var xL = /* @__PURE__ */ new Set(["ref", "reactive", "shallowRef", "shallowReactive", "computed", "ShallowUnwrapRef", "toRaw"]), zf = /* @__PURE__ */ function(e) {
return e[e.Import = 0] = "Import", e[e.Define = 1] = "Define", e[e.Function = 2] = "Function", e[e.Temporary = 3] = "Temporary", e;
}(zf || {});
function EL(e) {
var t = Gf(e), r = t.type, i = t.key;
if (r === "ImportSpecifier" && i === "local" || r === "ImportDefaultSpecifier" && i === "local")
  return {
    type: 0,
    declarePath: e.parentPath.parentPath,
    kind: "none",
    modified: !1,
    path: e
  };
if (r === "VariableDeclarator" && i === "id") {
  var s = e.parentPath.node.init;
  if (!s) return null;
  var n = s == null ? void 0 : s.type;
  if (Qf(e) || n === "ArrowFunctionExpression" || n === "FunctionExpression")
    return null;
  var a = e.parentPath.parentPath;
  return {
    type: 1,
    declarePath: a,
    kind: a.node.kind,
    modified: !1,
    path: e
  };
}
return null;
}
function Qf(e) {
var t, r = ((t = e.parentPath) === null || t === void 0 ? void 0 : t.node).init, i = r == null ? void 0 : r.type;
if (i === "CallExpression") {
  var s = r.callee.name;
  if (xL.has(s) && SL(e, s, "vue"))
    return !0;
}
return !1;
}
function PL(e) {
e = e.trim();
var t = [], r = Kf(e);
return Wf(r, {
  Identifier: function(s) {
    var n = s.node.name;
    if (ms(s)) {
      if (s.scope.getOwnBinding(n)) return;
      t.push(n);
    }
  },
  MemberExpression: function(s) {
    if (ms(s) || Yf(s)) {
      var n = Xf(s);
      if (s.scope.getOwnBinding(n)) return;
      t.push(n);
    }
  },
  CallExpression: function(s) {
    var n = s.node.arguments, a = o0(n), o;
    try {
      for (a.s(); !(o = a.n()).done; ) {
        var u = o.value;
        u.type === "Identifier" ? t.push(u.name) : u.type === "MemberExpression" && t.push(Hf(u));
      }
    } catch (l) {
      a.e(l);
    } finally {
      a.f();
    }
  }
}), t;
}
var vL = /* @__PURE__ */ function() {
function e(t) {
  ea(this, e), this.script = t;
}
return ta(e, [{
  key: "checkRelatedComputed",
  value: function(r) {
    var i = r.findParent(function(a) {
      return a.node.type === "VariableDeclarator";
    });
    if (!(!i || !i.node.init)) {
      var s = i.node.init.type;
      if (!(s === "CallExpression" && // @ts-ignore
      i.node.init.callee.name === "computed") && !(s === "ArrowFunctionExpression" || s === "FunctionExpression")) {
        this.script.addImport("computed");
        var n = i.scope.getBinding(
          // @ts-ignore
          i.node.id.name
        );
        this.script.modifyVariable(n, "computed");
      }
    }
  }
}]);
}(), AL = /* @__PURE__ */ function() {
function e(t) {
  var r = this;
  ea(this, e), this.defineVariables = {}, this.computed = new vL(this), this.code = t, this.ast = Kf(t);
  var i = 0;
  Wf(this.ast, {
    BlockStatement: {
      enter: function() {
        i++;
      },
      exit: function() {
        i--;
      }
    },
    Identifier: function(n) {
      var a = n.node.name;
      if (i === 0) {
        var o = EL(n);
        if (o) {
          var u = n.findParent(function(l) {
            return /Declaration$/.test(l.node.type);
          });
          if (!u) throw new Error("Cannot find declaration: ".concat(n.toString()));
          r.defineVariables[a] = o;
        }
      }
      ms(n) && r.checkUpdatedVariable(n, a);
    },
    MemberExpression: function(n) {
      if (ms(n) || Yf(n)) {
        var a = Xf(n);
        r.checkUpdatedVariable(n, a);
      }
    }
  });
}
return ta(e, [{
  key: "checkUpdatedVariable",
  value: function(r, i) {
    var s = r.scope.getBinding(i);
    this.onBinding(i, s);
  }
}, {
  key: "onEventModify",
  value: function(r) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, s = this.defineVariables[r];
    if (s) {
      if (i && !s.forceRef && s.modifiedFn === "computed")
        s.forceRef = !0, s.modified = !1;
      else if (Qf(s.path))
        return;
      if (!s.modified) {
        var n = s.path.scope.getBinding(r);
        this.onBinding(r, n);
      }
    }
  }
}, {
  key: "onBinding",
  value: function(r, i) {
    if (!i) throw new Error("".concat(r, " is Undefined"));
    var s = this.defineVariables[r];
    !s || s.modified || s.path.parentPath === i.path && (this.addImport("ref"), this.modifyVariable(i));
  }
}, {
  key: "modifyVariable",
  value: function(r) {
    var i = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ref", n = r.identifier.name, a = this.defineVariables[n];
    if (a && !a.modified) {
      a.modified = !0;
      var o = a.declarePath.node.declarations.find(function(l) {
        return l.id.name === n;
      });
      if (!o)
        throw new Error("未找到节点");
      var u = s === "ref" ? o.init : bt.arrowFunctionExpression([], o.init);
      a.forceRef && a.modifiedFn === "computed" ? o.init = bt.callExpression(bt.identifier(s), [
        // @ts-ignore
        o.init.arguments[0].body
      ]) : o.init = bt.callExpression(bt.identifier(s), [u]), r.referencePaths.forEach(function(l) {
        l.parent.type === "CallExpression" && // @ts-ignore
        l.parent.callee.name === "watch" || (i.computed.checkRelatedComputed(l), l.replaceInline(bt.memberExpression(bt.identifier(n), bt.identifier("value"))), l.skip());
      }), r.constantViolations.forEach(function(l) {
        l.type === "AssignmentExpression" && (l.node.left = bt.memberExpression(l.node.left, bt.identifier("value")));
      }), a.modifiedFn = s;
    }
  }
}, {
  key: "addImport",
  value: function(r) {
    var i = "_added_".concat(r, "_import");
    if (!this[i]) {
      this[i] = !0;
      var s = this.defineVariables[r];
      if (s) {
        var n;
        if (s.type === zf.Import && ((n = s.declarePath.node) === null || n === void 0 ? void 0 : n.source.value) == "vue") {
          this._vueImport = s.declarePath.node;
          return;
        } else
          throw new Error('"'.concat(r, '" ').concat(r, " has the same name: ").concat(s.declarePath.toString()));
      }
      var a = bt.importSpecifier(bt.identifier(r), bt.identifier(r));
      this._vueImport ? this._vueImport.specifiers.push(a) : (this._vueImport = bt.importDeclaration([a], bt.stringLiteral("vue")), this.ast.program.body.unshift(this._vueImport));
    }
  }
}, {
  key: "transformJs",
  value: function(r) {
    var i = mL(this.ast);
    return r.replace(this.code, i);
  }
}]);
}(), IL = /* @__PURE__ */ function() {
function e(t) {
  ea(this, e), this.originCode = t;
  var r = new P0({
    onopentag: this.onOpenTag.bind(this),
    ontext: this.onText.bind(this)
  });
  r.write(this.originCode), r.end();
}
return ta(e, [{
  key: "onOpenTag",
  value: function(r, i) {
    var s = this;
    if (r === "script")
      "setup" in i && "lim" in i && (this.isInLimScript = !0);
    else {
      if (!this.script) return;
      for (var n in i) {
        var a = i[n];
        if (n.startsWith("@")) {
          var o = PL(a);
          o.length && o.forEach(function(u) {
            s.script.onEventModify(u);
          });
        } else n === "v-model" ? this.script.onEventModify(a, !0) : n === "v-for" && this.script.onEventModify(a.substring(a.lastIndexOf(" in ") + 4));
      }
    }
  }
}, {
  key: "onText",
  value: function(r) {
    this.isInLimScript && !this.script && (this.script = new AL(r));
  }
}, {
  key: "toString",
  value: function() {
    return this.script ? this.script.transformJs(this.originCode) : this.originCode;
  }
}]);
}();
typeof window < "u" && (window.process || (window.process = {
env: {}
}), window.Buffer || (window.Buffer = {
// @ts-ignore
from: function(t) {
  return new Uint8Array(t);
},
// @ts-ignore
isBuffer: function(t) {
  return t instanceof Uint8Array;
}
}));
function CL(e) {
var t = new IL(e);
return t.toString();
}
function wL(e) {
var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
return t.endsWith(".lim.vue") || /<script.*?lim.*?>/.test(e);
}
const RL = {
transformVue: CL,
isLimSFC: wL
};
export {
RL as default,
wL as isLimSFC,
CL as transformVue
};
