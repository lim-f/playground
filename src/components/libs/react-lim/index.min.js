function Ld(e, t) {
  for (var r = 0; r < t.length; r++) {
    const i = t[r];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const s in i)
        if (s !== "default" && !(s in e)) {
          const n = Object.getOwnPropertyDescriptor(i, s);
          n && Object.defineProperty(e, s, n.get ? n : {
            enumerable: !0,
            get: () => i[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
function Ga(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function xu(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function Md(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, jd(i.key), i);
  }
}
function vu(e, t, r) {
  return t && Md(e.prototype, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Bd(e, t) {
  var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (!r) {
    if (Array.isArray(e) || (r = Rd(e)) || t) {
      r && (e = r);
      var i = 0, s = function() {
      };
      return {
        s,
        n: function() {
          return i >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[i++]
          };
        },
        e: function(l) {
          throw l;
        },
        f: s
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var n, a = !0, o = !1;
  return {
    s: function() {
      r = r.call(e);
    },
    n: function() {
      var l = r.next();
      return a = l.done, l;
    },
    e: function(l) {
      o = !0, n = l;
    },
    f: function() {
      try {
        a || r.return == null || r.return();
      } finally {
        if (o) throw n;
      }
    }
  };
}
function Fd(e, t) {
  if (typeof e != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function jd(e) {
  var t = Fd(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Rd(e, t) {
  if (e) {
    if (typeof e == "string") return Ga(e, t);
    var r = {}.toString.call(e).slice(8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Ga(e, t) : void 0;
  }
}
var ur = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Au(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ks = {}, Vt = {}, Oe = {};
Object.defineProperty(Oe, "__esModule", {
  value: !0
});
Oe.Var = Oe.User = Oe.Statement = Oe.SpreadProperty = Oe.Scope = Oe.RestProperty = Oe.ReferencedMemberExpression = Oe.ReferencedIdentifier = Oe.Referenced = Oe.Pure = Oe.NumericLiteralTypeAnnotation = Oe.Generated = Oe.ForAwaitStatement = Oe.Flow = Oe.Expression = Oe.ExistentialTypeParam = Oe.BlockScoped = Oe.BindingIdentifier = void 0;
Oe.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
Oe.ReferencedMemberExpression = ["MemberExpression"];
Oe.BindingIdentifier = ["Identifier"];
Oe.Statement = ["Statement"];
Oe.Expression = ["Expression"];
Oe.Scope = ["Scopable", "Pattern"];
Oe.Referenced = null;
Oe.BlockScoped = null;
Oe.Var = ["VariableDeclaration"];
Oe.User = null;
Oe.Generated = null;
Oe.Pure = null;
Oe.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
Oe.RestProperty = ["RestElement"];
Oe.SpreadProperty = ["RestElement"];
Oe.ExistentialTypeParam = ["ExistsTypeAnnotation"];
Oe.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
Oe.ForAwaitStatement = ["ForOfStatement"];
var et = {}, qs = {}, ns = {}, as = {}, os = {}, g = {}, ei = {};
Object.defineProperty(ei, "__esModule", {
  value: !0
});
ei.default = Ud;
function Ud(e, t) {
  const r = Object.keys(t);
  for (const i of r)
    if (e[i] !== t[i])
      return !1;
  return !0;
}
var Pr = {};
Object.defineProperty(Pr, "__esModule", {
  value: !0
});
Pr.default = $d;
const za = /* @__PURE__ */ new Set();
function $d(e, t, r = "") {
  if (za.has(e)) return;
  za.add(e);
  const {
    internal: i,
    trace: s
  } = Vd(1, 2);
  i || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${s}`);
}
function Vd(e, t) {
  const {
    stackTraceLimit: r,
    prepareStackTrace: i
  } = Error;
  let s;
  if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(a, o) {
    s = o;
  }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = i, !s) return {
    internal: !1,
    trace: ""
  };
  const n = s.slice(1 + e, 1 + e + t);
  return {
    internal: /[\\/]@babel[\\/]/.test(n[1].getFileName()),
    trace: n.map((a) => `    at ${a}`).join(`
`)
  };
}
Object.defineProperty(g, "__esModule", {
  value: !0
});
g.isAccessor = rb;
g.isAnyTypeAnnotation = xy;
g.isArgumentPlaceholder = QT;
g.isArrayExpression = Kd;
g.isArrayPattern = $m;
g.isArrayTypeAnnotation = vy;
g.isArrowFunctionExpression = Vm;
g.isAssignmentExpression = qd;
g.isAssignmentPattern = Um;
g.isAwaitExpression = fy;
g.isBigIntLiteral = hy;
g.isBinary = Ag;
g.isBinaryExpression = Wd;
g.isBindExpression = ZT;
g.isBlock = wg;
g.isBlockParent = Ig;
g.isBlockStatement = Hd;
g.isBooleanLiteral = ym;
g.isBooleanLiteralTypeAnnotation = Cy;
g.isBooleanTypeAnnotation = Ay;
g.isBreakStatement = Gd;
g.isCallExpression = zd;
g.isCatchClause = Qd;
g.isClass = Zg;
g.isClassAccessorProperty = gy;
g.isClassBody = Km;
g.isClassDeclaration = Wm;
g.isClassExpression = qm;
g.isClassImplements = wy;
g.isClassMethod = iy;
g.isClassPrivateMethod = Sy;
g.isClassPrivateProperty = by;
g.isClassProperty = Ty;
g.isCompletionStatement = _g;
g.isConditional = kg;
g.isConditionalExpression = Zd;
g.isContinueStatement = em;
g.isDebuggerStatement = tm;
g.isDecimalLiteral = a0;
g.isDeclaration = $g;
g.isDeclareClass = Oy;
g.isDeclareExportAllDeclaration = jy;
g.isDeclareExportDeclaration = Fy;
g.isDeclareFunction = Ny;
g.isDeclareInterface = _y;
g.isDeclareModule = ky;
g.isDeclareModuleExports = Dy;
g.isDeclareOpaqueType = My;
g.isDeclareTypeAlias = Ly;
g.isDeclareVariable = By;
g.isDeclaredPredicate = Ry;
g.isDecorator = t0;
g.isDirective = Xd;
g.isDirectiveLiteral = Yd;
g.isDoExpression = r0;
g.isDoWhileStatement = rm;
g.isEmptyStatement = im;
g.isEmptyTypeAnnotation = Gy;
g.isEnumBody = ub;
g.isEnumBooleanBody = vT;
g.isEnumBooleanMember = wT;
g.isEnumDeclaration = xT;
g.isEnumDefaultedMember = _T;
g.isEnumMember = cb;
g.isEnumNumberBody = AT;
g.isEnumNumberMember = OT;
g.isEnumStringBody = CT;
g.isEnumStringMember = NT;
g.isEnumSymbolBody = IT;
g.isExistsTypeAnnotation = Uy;
g.isExportAllDeclaration = Jm;
g.isExportDeclaration = eb;
g.isExportDefaultDeclaration = Xm;
g.isExportDefaultSpecifier = i0;
g.isExportNamedDeclaration = Ym;
g.isExportNamespaceSpecifier = dy;
g.isExportSpecifier = Hm;
g.isExpression = vg;
g.isExpressionStatement = sm;
g.isExpressionWrapper = Mg;
g.isFile = nm;
g.isFlow = sb;
g.isFlowBaseAnnotation = ab;
g.isFlowDeclaration = ob;
g.isFlowPredicate = lb;
g.isFlowType = nb;
g.isFor = Bg;
g.isForInStatement = am;
g.isForOfStatement = Gm;
g.isForStatement = om;
g.isForXStatement = Fg;
g.isFunction = jg;
g.isFunctionDeclaration = lm;
g.isFunctionExpression = um;
g.isFunctionParent = Rg;
g.isFunctionTypeAnnotation = $y;
g.isFunctionTypeParam = Vy;
g.isGenericTypeAnnotation = Ky;
g.isIdentifier = cm;
g.isIfStatement = fm;
g.isImmutable = Jg;
g.isImport = py;
g.isImportAttribute = e0;
g.isImportDeclaration = zm;
g.isImportDefaultSpecifier = Qm;
g.isImportExpression = ty;
g.isImportNamespaceSpecifier = Zm;
g.isImportOrExportDeclaration = Cu;
g.isImportSpecifier = ey;
g.isIndexedAccessType = kT;
g.isInferredPredicate = qy;
g.isInterfaceDeclaration = Jy;
g.isInterfaceExtends = Wy;
g.isInterfaceTypeAnnotation = Xy;
g.isInterpreterDirective = Jd;
g.isIntersectionTypeAnnotation = Yy;
g.isJSX = fb;
g.isJSXAttribute = LT;
g.isJSXClosingElement = MT;
g.isJSXClosingFragment = YT;
g.isJSXElement = BT;
g.isJSXEmptyExpression = FT;
g.isJSXExpressionContainer = jT;
g.isJSXFragment = JT;
g.isJSXIdentifier = UT;
g.isJSXMemberExpression = $T;
g.isJSXNamespacedName = VT;
g.isJSXOpeningElement = KT;
g.isJSXOpeningFragment = XT;
g.isJSXSpreadAttribute = qT;
g.isJSXSpreadChild = RT;
g.isJSXText = WT;
g.isLVal = Kg;
g.isLabeledStatement = pm;
g.isLiteral = Wg;
g.isLogicalExpression = gm;
g.isLoop = Dg;
g.isMemberExpression = bm;
g.isMetaProperty = ry;
g.isMethod = Yg;
g.isMiscellaneous = pb;
g.isMixedTypeAnnotation = Hy;
g.isModuleDeclaration = Eb;
g.isModuleExpression = o0;
g.isModuleSpecifier = tb;
g.isNewExpression = Sm;
g.isNoop = HT;
g.isNullLiteral = mm;
g.isNullLiteralTypeAnnotation = Iy;
g.isNullableTypeAnnotation = zy;
g.isNumberLiteral = Tb;
g.isNumberLiteralTypeAnnotation = Qy;
g.isNumberTypeAnnotation = Zy;
g.isNumericLiteral = dm;
g.isObjectExpression = Pm;
g.isObjectMember = Hg;
g.isObjectMethod = xm;
g.isObjectPattern = sy;
g.isObjectProperty = vm;
g.isObjectTypeAnnotation = eT;
g.isObjectTypeCallProperty = rT;
g.isObjectTypeIndexer = iT;
g.isObjectTypeInternalSlot = tT;
g.isObjectTypeProperty = sT;
g.isObjectTypeSpreadProperty = nT;
g.isOpaqueType = aT;
g.isOptionalCallExpression = yy;
g.isOptionalIndexedAccessType = DT;
g.isOptionalMemberExpression = my;
g.isParenthesizedExpression = wm;
g.isPattern = Qg;
g.isPatternLike = Vg;
g.isPipelineBareFunction = c0;
g.isPipelinePrimaryTopicReference = f0;
g.isPipelineTopicExpression = u0;
g.isPlaceholder = GT;
g.isPrivate = ib;
g.isPrivateName = Ey;
g.isProgram = Em;
g.isProperty = Gg;
g.isPureish = Ug;
g.isQualifiedTypeIdentifier = oT;
g.isRecordExpression = s0;
g.isRegExpLiteral = Tm;
g.isRegexLiteral = gb;
g.isRestElement = Am;
g.isRestProperty = bb;
g.isReturnStatement = Cm;
g.isScopable = Cg;
g.isSequenceExpression = Im;
g.isSpreadElement = ny;
g.isSpreadProperty = Sb;
g.isStandardized = xg;
g.isStatement = Og;
g.isStaticBlock = Py;
g.isStringLiteral = hm;
g.isStringLiteralTypeAnnotation = lT;
g.isStringTypeAnnotation = uT;
g.isSuper = ay;
g.isSwitchCase = Om;
g.isSwitchStatement = Nm;
g.isSymbolTypeAnnotation = cT;
g.isTSAnyKeyword = E0;
g.isTSArrayType = $0;
g.isTSAsExpression = ag;
g.isTSBaseType = yb;
g.isTSBigIntKeyword = x0;
g.isTSBooleanKeyword = P0;
g.isTSCallSignatureDeclaration = y0;
g.isTSConditionalType = Y0;
g.isTSConstructSignatureDeclaration = T0;
g.isTSConstructorType = B0;
g.isTSDeclareFunction = h0;
g.isTSDeclareMethod = d0;
g.isTSEntityName = qg;
g.isTSEnumDeclaration = ug;
g.isTSEnumMember = cg;
g.isTSExportAssignment = Tg;
g.isTSExpressionWithTypeArguments = tg;
g.isTSExternalModuleReference = mg;
g.isTSFunctionType = M0;
g.isTSImportEqualsDeclaration = dg;
g.isTSImportType = hg;
g.isTSIndexSignature = S0;
g.isTSIndexedAccessType = Q0;
g.isTSInferType = H0;
g.isTSInstantiationExpression = ng;
g.isTSInterfaceBody = ig;
g.isTSInterfaceDeclaration = rg;
g.isTSIntersectionType = X0;
g.isTSIntrinsicKeyword = v0;
g.isTSLiteralType = eg;
g.isTSMappedType = Z0;
g.isTSMethodSignature = b0;
g.isTSModuleBlock = pg;
g.isTSModuleDeclaration = fg;
g.isTSNamedTupleMember = W0;
g.isTSNamespaceExportDeclaration = gg;
g.isTSNeverKeyword = A0;
g.isTSNonNullExpression = yg;
g.isTSNullKeyword = C0;
g.isTSNumberKeyword = I0;
g.isTSObjectKeyword = w0;
g.isTSOptionalType = K0;
g.isTSParameterProperty = p0;
g.isTSParenthesizedType = G0;
g.isTSPropertySignature = g0;
g.isTSQualifiedName = m0;
g.isTSRestType = q0;
g.isTSSatisfiesExpression = og;
g.isTSStringKeyword = O0;
g.isTSSymbolKeyword = N0;
g.isTSThisType = L0;
g.isTSTupleType = V0;
g.isTSType = mb;
g.isTSTypeAliasDeclaration = sg;
g.isTSTypeAnnotation = bg;
g.isTSTypeAssertion = lg;
g.isTSTypeElement = db;
g.isTSTypeLiteral = U0;
g.isTSTypeOperator = z0;
g.isTSTypeParameter = Pg;
g.isTSTypeParameterDeclaration = Eg;
g.isTSTypeParameterInstantiation = Sg;
g.isTSTypePredicate = j0;
g.isTSTypeQuery = R0;
g.isTSTypeReference = F0;
g.isTSUndefinedKeyword = _0;
g.isTSUnionType = J0;
g.isTSUnknownKeyword = k0;
g.isTSVoidKeyword = D0;
g.isTaggedTemplateExpression = oy;
g.isTemplateElement = ly;
g.isTemplateLiteral = uy;
g.isTerminatorless = Ng;
g.isThisExpression = _m;
g.isThisTypeAnnotation = fT;
g.isThrowStatement = km;
g.isTopicReference = l0;
g.isTryStatement = Dm;
g.isTupleExpression = n0;
g.isTupleTypeAnnotation = pT;
g.isTypeAlias = dT;
g.isTypeAnnotation = mT;
g.isTypeCastExpression = yT;
g.isTypeParameter = TT;
g.isTypeParameterDeclaration = gT;
g.isTypeParameterInstantiation = bT;
g.isTypeScript = hb;
g.isTypeofTypeAnnotation = hT;
g.isUnaryExpression = Lm;
g.isUnaryLike = zg;
g.isUnionTypeAnnotation = ST;
g.isUpdateExpression = Mm;
g.isUserWhitespacable = Xg;
g.isV8IntrinsicIdentifier = zT;
g.isVariableDeclaration = Bm;
g.isVariableDeclarator = Fm;
g.isVariance = ET;
g.isVoidTypeAnnotation = PT;
g.isWhile = Lg;
g.isWhileStatement = jm;
g.isWithStatement = Rm;
g.isYieldExpression = cy;
var P = ei, ti = Pr;
function Kd(e, t) {
  return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function qd(e, t) {
  return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Wd(e, t) {
  return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Jd(e, t) {
  return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, P.default)(e, t);
}
function Xd(e, t) {
  return !e || e.type !== "Directive" ? !1 : t == null || (0, P.default)(e, t);
}
function Yd(e, t) {
  return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function Hd(e, t) {
  return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function Gd(e, t) {
  return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function zd(e, t) {
  return !e || e.type !== "CallExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Qd(e, t) {
  return !e || e.type !== "CatchClause" ? !1 : t == null || (0, P.default)(e, t);
}
function Zd(e, t) {
  return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function em(e, t) {
  return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function tm(e, t) {
  return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function rm(e, t) {
  return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function im(e, t) {
  return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function sm(e, t) {
  return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function nm(e, t) {
  return !e || e.type !== "File" ? !1 : t == null || (0, P.default)(e, t);
}
function am(e, t) {
  return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function om(e, t) {
  return !e || e.type !== "ForStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function lm(e, t) {
  return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function um(e, t) {
  return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function cm(e, t) {
  return !e || e.type !== "Identifier" ? !1 : t == null || (0, P.default)(e, t);
}
function fm(e, t) {
  return !e || e.type !== "IfStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function pm(e, t) {
  return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function hm(e, t) {
  return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function dm(e, t) {
  return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function mm(e, t) {
  return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function ym(e, t) {
  return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function Tm(e, t) {
  return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function gm(e, t) {
  return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function bm(e, t) {
  return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Sm(e, t) {
  return !e || e.type !== "NewExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Em(e, t) {
  return !e || e.type !== "Program" ? !1 : t == null || (0, P.default)(e, t);
}
function Pm(e, t) {
  return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function xm(e, t) {
  return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, P.default)(e, t);
}
function vm(e, t) {
  return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, P.default)(e, t);
}
function Am(e, t) {
  return !e || e.type !== "RestElement" ? !1 : t == null || (0, P.default)(e, t);
}
function Cm(e, t) {
  return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function Im(e, t) {
  return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function wm(e, t) {
  return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Om(e, t) {
  return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, P.default)(e, t);
}
function Nm(e, t) {
  return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function _m(e, t) {
  return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function km(e, t) {
  return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function Dm(e, t) {
  return !e || e.type !== "TryStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function Lm(e, t) {
  return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Mm(e, t) {
  return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Bm(e, t) {
  return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function Fm(e, t) {
  return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, P.default)(e, t);
}
function jm(e, t) {
  return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function Rm(e, t) {
  return !e || e.type !== "WithStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function Um(e, t) {
  return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, P.default)(e, t);
}
function $m(e, t) {
  return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, P.default)(e, t);
}
function Vm(e, t) {
  return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Km(e, t) {
  return !e || e.type !== "ClassBody" ? !1 : t == null || (0, P.default)(e, t);
}
function qm(e, t) {
  return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Wm(e, t) {
  return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function Jm(e, t) {
  return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function Xm(e, t) {
  return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function Ym(e, t) {
  return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function Hm(e, t) {
  return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, P.default)(e, t);
}
function Gm(e, t) {
  return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, P.default)(e, t);
}
function zm(e, t) {
  return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function Qm(e, t) {
  return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, P.default)(e, t);
}
function Zm(e, t) {
  return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, P.default)(e, t);
}
function ey(e, t) {
  return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, P.default)(e, t);
}
function ty(e, t) {
  return !e || e.type !== "ImportExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function ry(e, t) {
  return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, P.default)(e, t);
}
function iy(e, t) {
  return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, P.default)(e, t);
}
function sy(e, t) {
  return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, P.default)(e, t);
}
function ny(e, t) {
  return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, P.default)(e, t);
}
function ay(e, t) {
  return !e || e.type !== "Super" ? !1 : t == null || (0, P.default)(e, t);
}
function oy(e, t) {
  return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function ly(e, t) {
  return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, P.default)(e, t);
}
function uy(e, t) {
  return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function cy(e, t) {
  return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function fy(e, t) {
  return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function py(e, t) {
  return !e || e.type !== "Import" ? !1 : t == null || (0, P.default)(e, t);
}
function hy(e, t) {
  return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function dy(e, t) {
  return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, P.default)(e, t);
}
function my(e, t) {
  return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function yy(e, t) {
  return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Ty(e, t) {
  return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, P.default)(e, t);
}
function gy(e, t) {
  return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, P.default)(e, t);
}
function by(e, t) {
  return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, P.default)(e, t);
}
function Sy(e, t) {
  return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, P.default)(e, t);
}
function Ey(e, t) {
  return !e || e.type !== "PrivateName" ? !1 : t == null || (0, P.default)(e, t);
}
function Py(e, t) {
  return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, P.default)(e, t);
}
function xy(e, t) {
  return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function vy(e, t) {
  return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function Ay(e, t) {
  return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function Cy(e, t) {
  return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function Iy(e, t) {
  return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function wy(e, t) {
  return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, P.default)(e, t);
}
function Oy(e, t) {
  return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, P.default)(e, t);
}
function Ny(e, t) {
  return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, P.default)(e, t);
}
function _y(e, t) {
  return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, P.default)(e, t);
}
function ky(e, t) {
  return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, P.default)(e, t);
}
function Dy(e, t) {
  return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, P.default)(e, t);
}
function Ly(e, t) {
  return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, P.default)(e, t);
}
function My(e, t) {
  return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, P.default)(e, t);
}
function By(e, t) {
  return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, P.default)(e, t);
}
function Fy(e, t) {
  return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function jy(e, t) {
  return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function Ry(e, t) {
  return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, P.default)(e, t);
}
function Uy(e, t) {
  return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function $y(e, t) {
  return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function Vy(e, t) {
  return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, P.default)(e, t);
}
function Ky(e, t) {
  return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function qy(e, t) {
  return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, P.default)(e, t);
}
function Wy(e, t) {
  return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, P.default)(e, t);
}
function Jy(e, t) {
  return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function Xy(e, t) {
  return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function Yy(e, t) {
  return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function Hy(e, t) {
  return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function Gy(e, t) {
  return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function zy(e, t) {
  return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function Qy(e, t) {
  return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function Zy(e, t) {
  return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function eT(e, t) {
  return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function tT(e, t) {
  return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, P.default)(e, t);
}
function rT(e, t) {
  return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, P.default)(e, t);
}
function iT(e, t) {
  return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, P.default)(e, t);
}
function sT(e, t) {
  return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, P.default)(e, t);
}
function nT(e, t) {
  return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, P.default)(e, t);
}
function aT(e, t) {
  return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, P.default)(e, t);
}
function oT(e, t) {
  return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, P.default)(e, t);
}
function lT(e, t) {
  return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function uT(e, t) {
  return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function cT(e, t) {
  return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function fT(e, t) {
  return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function pT(e, t) {
  return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function hT(e, t) {
  return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function dT(e, t) {
  return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, P.default)(e, t);
}
function mT(e, t) {
  return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function yT(e, t) {
  return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function TT(e, t) {
  return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, P.default)(e, t);
}
function gT(e, t) {
  return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function bT(e, t) {
  return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, P.default)(e, t);
}
function ST(e, t) {
  return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function ET(e, t) {
  return !e || e.type !== "Variance" ? !1 : t == null || (0, P.default)(e, t);
}
function PT(e, t) {
  return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function xT(e, t) {
  return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function vT(e, t) {
  return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, P.default)(e, t);
}
function AT(e, t) {
  return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, P.default)(e, t);
}
function CT(e, t) {
  return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, P.default)(e, t);
}
function IT(e, t) {
  return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, P.default)(e, t);
}
function wT(e, t) {
  return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, P.default)(e, t);
}
function OT(e, t) {
  return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, P.default)(e, t);
}
function NT(e, t) {
  return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, P.default)(e, t);
}
function _T(e, t) {
  return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, P.default)(e, t);
}
function kT(e, t) {
  return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, P.default)(e, t);
}
function DT(e, t) {
  return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, P.default)(e, t);
}
function LT(e, t) {
  return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, P.default)(e, t);
}
function MT(e, t) {
  return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, P.default)(e, t);
}
function BT(e, t) {
  return !e || e.type !== "JSXElement" ? !1 : t == null || (0, P.default)(e, t);
}
function FT(e, t) {
  return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function jT(e, t) {
  return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, P.default)(e, t);
}
function RT(e, t) {
  return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, P.default)(e, t);
}
function UT(e, t) {
  return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, P.default)(e, t);
}
function $T(e, t) {
  return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function VT(e, t) {
  return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, P.default)(e, t);
}
function KT(e, t) {
  return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, P.default)(e, t);
}
function qT(e, t) {
  return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, P.default)(e, t);
}
function WT(e, t) {
  return !e || e.type !== "JSXText" ? !1 : t == null || (0, P.default)(e, t);
}
function JT(e, t) {
  return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, P.default)(e, t);
}
function XT(e, t) {
  return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, P.default)(e, t);
}
function YT(e, t) {
  return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, P.default)(e, t);
}
function HT(e, t) {
  return !e || e.type !== "Noop" ? !1 : t == null || (0, P.default)(e, t);
}
function GT(e, t) {
  return !e || e.type !== "Placeholder" ? !1 : t == null || (0, P.default)(e, t);
}
function zT(e, t) {
  return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, P.default)(e, t);
}
function QT(e, t) {
  return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, P.default)(e, t);
}
function ZT(e, t) {
  return !e || e.type !== "BindExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function e0(e, t) {
  return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, P.default)(e, t);
}
function t0(e, t) {
  return !e || e.type !== "Decorator" ? !1 : t == null || (0, P.default)(e, t);
}
function r0(e, t) {
  return !e || e.type !== "DoExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function i0(e, t) {
  return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, P.default)(e, t);
}
function s0(e, t) {
  return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function n0(e, t) {
  return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function a0(e, t) {
  return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function o0(e, t) {
  return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function l0(e, t) {
  return !e || e.type !== "TopicReference" ? !1 : t == null || (0, P.default)(e, t);
}
function u0(e, t) {
  return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function c0(e, t) {
  return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, P.default)(e, t);
}
function f0(e, t) {
  return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, P.default)(e, t);
}
function p0(e, t) {
  return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, P.default)(e, t);
}
function h0(e, t) {
  return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, P.default)(e, t);
}
function d0(e, t) {
  return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, P.default)(e, t);
}
function m0(e, t) {
  return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, P.default)(e, t);
}
function y0(e, t) {
  return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function T0(e, t) {
  return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function g0(e, t) {
  return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, P.default)(e, t);
}
function b0(e, t) {
  return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, P.default)(e, t);
}
function S0(e, t) {
  return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, P.default)(e, t);
}
function E0(e, t) {
  return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function P0(e, t) {
  return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function x0(e, t) {
  return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function v0(e, t) {
  return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function A0(e, t) {
  return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function C0(e, t) {
  return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function I0(e, t) {
  return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function w0(e, t) {
  return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function O0(e, t) {
  return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function N0(e, t) {
  return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function _0(e, t) {
  return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function k0(e, t) {
  return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function D0(e, t) {
  return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, P.default)(e, t);
}
function L0(e, t) {
  return !e || e.type !== "TSThisType" ? !1 : t == null || (0, P.default)(e, t);
}
function M0(e, t) {
  return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, P.default)(e, t);
}
function B0(e, t) {
  return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, P.default)(e, t);
}
function F0(e, t) {
  return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, P.default)(e, t);
}
function j0(e, t) {
  return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, P.default)(e, t);
}
function R0(e, t) {
  return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, P.default)(e, t);
}
function U0(e, t) {
  return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function $0(e, t) {
  return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, P.default)(e, t);
}
function V0(e, t) {
  return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, P.default)(e, t);
}
function K0(e, t) {
  return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, P.default)(e, t);
}
function q0(e, t) {
  return !e || e.type !== "TSRestType" ? !1 : t == null || (0, P.default)(e, t);
}
function W0(e, t) {
  return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, P.default)(e, t);
}
function J0(e, t) {
  return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, P.default)(e, t);
}
function X0(e, t) {
  return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, P.default)(e, t);
}
function Y0(e, t) {
  return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, P.default)(e, t);
}
function H0(e, t) {
  return !e || e.type !== "TSInferType" ? !1 : t == null || (0, P.default)(e, t);
}
function G0(e, t) {
  return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, P.default)(e, t);
}
function z0(e, t) {
  return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, P.default)(e, t);
}
function Q0(e, t) {
  return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, P.default)(e, t);
}
function Z0(e, t) {
  return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, P.default)(e, t);
}
function eg(e, t) {
  return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, P.default)(e, t);
}
function tg(e, t) {
  return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, P.default)(e, t);
}
function rg(e, t) {
  return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function ig(e, t) {
  return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, P.default)(e, t);
}
function sg(e, t) {
  return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function ng(e, t) {
  return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function ag(e, t) {
  return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function og(e, t) {
  return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function lg(e, t) {
  return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, P.default)(e, t);
}
function ug(e, t) {
  return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function cg(e, t) {
  return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, P.default)(e, t);
}
function fg(e, t) {
  return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function pg(e, t) {
  return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, P.default)(e, t);
}
function hg(e, t) {
  return !e || e.type !== "TSImportType" ? !1 : t == null || (0, P.default)(e, t);
}
function dg(e, t) {
  return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function mg(e, t) {
  return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, P.default)(e, t);
}
function yg(e, t) {
  return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, P.default)(e, t);
}
function Tg(e, t) {
  return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, P.default)(e, t);
}
function gg(e, t) {
  return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function bg(e, t) {
  return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, P.default)(e, t);
}
function Sg(e, t) {
  return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, P.default)(e, t);
}
function Eg(e, t) {
  return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, P.default)(e, t);
}
function Pg(e, t) {
  return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, P.default)(e, t);
}
function xg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ArrayExpression":
    case "AssignmentExpression":
    case "BinaryExpression":
    case "InterpreterDirective":
    case "Directive":
    case "DirectiveLiteral":
    case "BlockStatement":
    case "BreakStatement":
    case "CallExpression":
    case "CatchClause":
    case "ConditionalExpression":
    case "ContinueStatement":
    case "DebuggerStatement":
    case "DoWhileStatement":
    case "EmptyStatement":
    case "ExpressionStatement":
    case "File":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "Identifier":
    case "IfStatement":
    case "LabeledStatement":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "LogicalExpression":
    case "MemberExpression":
    case "NewExpression":
    case "Program":
    case "ObjectExpression":
    case "ObjectMethod":
    case "ObjectProperty":
    case "RestElement":
    case "ReturnStatement":
    case "SequenceExpression":
    case "ParenthesizedExpression":
    case "SwitchCase":
    case "SwitchStatement":
    case "ThisExpression":
    case "ThrowStatement":
    case "TryStatement":
    case "UnaryExpression":
    case "UpdateExpression":
    case "VariableDeclaration":
    case "VariableDeclarator":
    case "WhileStatement":
    case "WithStatement":
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ArrowFunctionExpression":
    case "ClassBody":
    case "ClassExpression":
    case "ClassDeclaration":
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ExportSpecifier":
    case "ForOfStatement":
    case "ImportDeclaration":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
    case "ImportExpression":
    case "MetaProperty":
    case "ClassMethod":
    case "ObjectPattern":
    case "SpreadElement":
    case "Super":
    case "TaggedTemplateExpression":
    case "TemplateElement":
    case "TemplateLiteral":
    case "YieldExpression":
    case "AwaitExpression":
    case "Import":
    case "BigIntLiteral":
    case "ExportNamespaceSpecifier":
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "ClassProperty":
    case "ClassAccessorProperty":
    case "ClassPrivateProperty":
    case "ClassPrivateMethod":
    case "PrivateName":
    case "StaticBlock":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Identifier":
        case "StringLiteral":
        case "BlockStatement":
        case "ClassBody":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function vg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ArrayExpression":
    case "AssignmentExpression":
    case "BinaryExpression":
    case "CallExpression":
    case "ConditionalExpression":
    case "FunctionExpression":
    case "Identifier":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "LogicalExpression":
    case "MemberExpression":
    case "NewExpression":
    case "ObjectExpression":
    case "SequenceExpression":
    case "ParenthesizedExpression":
    case "ThisExpression":
    case "UnaryExpression":
    case "UpdateExpression":
    case "ArrowFunctionExpression":
    case "ClassExpression":
    case "ImportExpression":
    case "MetaProperty":
    case "Super":
    case "TaggedTemplateExpression":
    case "TemplateLiteral":
    case "YieldExpression":
    case "AwaitExpression":
    case "Import":
    case "BigIntLiteral":
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "TypeCastExpression":
    case "JSXElement":
    case "JSXFragment":
    case "BindExpression":
    case "DoExpression":
    case "RecordExpression":
    case "TupleExpression":
    case "DecimalLiteral":
    case "ModuleExpression":
    case "TopicReference":
    case "PipelineTopicExpression":
    case "PipelineBareFunction":
    case "PipelinePrimaryTopicReference":
    case "TSInstantiationExpression":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSNonNullExpression":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Expression":
        case "Identifier":
        case "StringLiteral":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Ag(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "BinaryExpression":
    case "LogicalExpression":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Cg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "BlockStatement":
    case "CatchClause":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "Program":
    case "ObjectMethod":
    case "SwitchStatement":
    case "WhileStatement":
    case "ArrowFunctionExpression":
    case "ClassExpression":
    case "ClassDeclaration":
    case "ForOfStatement":
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "StaticBlock":
    case "TSModuleBlock":
      break;
    case "Placeholder":
      if (e.expectedNode === "BlockStatement") break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Ig(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "BlockStatement":
    case "CatchClause":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "Program":
    case "ObjectMethod":
    case "SwitchStatement":
    case "WhileStatement":
    case "ArrowFunctionExpression":
    case "ForOfStatement":
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "StaticBlock":
    case "TSModuleBlock":
      break;
    case "Placeholder":
      if (e.expectedNode === "BlockStatement") break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function wg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "BlockStatement":
    case "Program":
    case "TSModuleBlock":
      break;
    case "Placeholder":
      if (e.expectedNode === "BlockStatement") break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Og(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "BlockStatement":
    case "BreakStatement":
    case "ContinueStatement":
    case "DebuggerStatement":
    case "DoWhileStatement":
    case "EmptyStatement":
    case "ExpressionStatement":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "IfStatement":
    case "LabeledStatement":
    case "ReturnStatement":
    case "SwitchStatement":
    case "ThrowStatement":
    case "TryStatement":
    case "VariableDeclaration":
    case "WhileStatement":
    case "WithStatement":
    case "ClassDeclaration":
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ForOfStatement":
    case "ImportDeclaration":
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TypeAlias":
    case "EnumDeclaration":
    case "TSDeclareFunction":
    case "TSInterfaceDeclaration":
    case "TSTypeAliasDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration":
    case "TSImportEqualsDeclaration":
    case "TSExportAssignment":
    case "TSNamespaceExportDeclaration":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Statement":
        case "Declaration":
        case "BlockStatement":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Ng(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "BreakStatement":
    case "ContinueStatement":
    case "ReturnStatement":
    case "ThrowStatement":
    case "YieldExpression":
    case "AwaitExpression":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function _g(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "BreakStatement":
    case "ContinueStatement":
    case "ReturnStatement":
    case "ThrowStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function kg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ConditionalExpression":
    case "IfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Dg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForStatement":
    case "WhileStatement":
    case "ForOfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Lg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "DoWhileStatement":
    case "WhileStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Mg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ExpressionStatement":
    case "ParenthesizedExpression":
    case "TypeCastExpression":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Bg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ForInStatement":
    case "ForStatement":
    case "ForOfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Fg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ForInStatement":
    case "ForOfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function jg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ObjectMethod":
    case "ArrowFunctionExpression":
    case "ClassMethod":
    case "ClassPrivateMethod":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Rg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ObjectMethod":
    case "ArrowFunctionExpression":
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "StaticBlock":
    case "TSModuleBlock":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Ug(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "ArrowFunctionExpression":
    case "BigIntLiteral":
    case "DecimalLiteral":
      break;
    case "Placeholder":
      if (e.expectedNode === "StringLiteral") break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function $g(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "VariableDeclaration":
    case "ClassDeclaration":
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ImportDeclaration":
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TypeAlias":
    case "EnumDeclaration":
    case "TSDeclareFunction":
    case "TSInterfaceDeclaration":
    case "TSTypeAliasDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration":
      break;
    case "Placeholder":
      if (e.expectedNode === "Declaration") break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Vg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "Identifier":
    case "RestElement":
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ObjectPattern":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSNonNullExpression":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Pattern":
        case "Identifier":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Kg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "Identifier":
    case "MemberExpression":
    case "RestElement":
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ObjectPattern":
    case "TSParameterProperty":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSNonNullExpression":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Pattern":
        case "Identifier":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function qg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "Identifier":
    case "TSQualifiedName":
      break;
    case "Placeholder":
      if (e.expectedNode === "Identifier") break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Wg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "TemplateLiteral":
    case "BigIntLiteral":
    case "DecimalLiteral":
      break;
    case "Placeholder":
      if (e.expectedNode === "StringLiteral") break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Jg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "BigIntLiteral":
    case "JSXAttribute":
    case "JSXClosingElement":
    case "JSXElement":
    case "JSXExpressionContainer":
    case "JSXSpreadChild":
    case "JSXOpeningElement":
    case "JSXText":
    case "JSXFragment":
    case "JSXOpeningFragment":
    case "JSXClosingFragment":
    case "DecimalLiteral":
      break;
    case "Placeholder":
      if (e.expectedNode === "StringLiteral") break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Xg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ObjectMethod":
    case "ObjectProperty":
    case "ObjectTypeInternalSlot":
    case "ObjectTypeCallProperty":
    case "ObjectTypeIndexer":
    case "ObjectTypeProperty":
    case "ObjectTypeSpreadProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Yg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ObjectMethod":
    case "ClassMethod":
    case "ClassPrivateMethod":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Hg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ObjectMethod":
    case "ObjectProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Gg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ObjectProperty":
    case "ClassProperty":
    case "ClassAccessorProperty":
    case "ClassPrivateProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function zg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "UnaryExpression":
    case "SpreadElement":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Qg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ObjectPattern":
      break;
    case "Placeholder":
      if (e.expectedNode === "Pattern") break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Zg(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ClassExpression":
    case "ClassDeclaration":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Cu(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ImportDeclaration":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function eb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function tb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ExportSpecifier":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function rb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ClassAccessorProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function ib(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ClassPrivateProperty":
    case "ClassPrivateMethod":
    case "PrivateName":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function sb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "AnyTypeAnnotation":
    case "ArrayTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "BooleanLiteralTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "ClassImplements":
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "DeclaredPredicate":
    case "ExistsTypeAnnotation":
    case "FunctionTypeAnnotation":
    case "FunctionTypeParam":
    case "GenericTypeAnnotation":
    case "InferredPredicate":
    case "InterfaceExtends":
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
    case "IntersectionTypeAnnotation":
    case "MixedTypeAnnotation":
    case "EmptyTypeAnnotation":
    case "NullableTypeAnnotation":
    case "NumberLiteralTypeAnnotation":
    case "NumberTypeAnnotation":
    case "ObjectTypeAnnotation":
    case "ObjectTypeInternalSlot":
    case "ObjectTypeCallProperty":
    case "ObjectTypeIndexer":
    case "ObjectTypeProperty":
    case "ObjectTypeSpreadProperty":
    case "OpaqueType":
    case "QualifiedTypeIdentifier":
    case "StringLiteralTypeAnnotation":
    case "StringTypeAnnotation":
    case "SymbolTypeAnnotation":
    case "ThisTypeAnnotation":
    case "TupleTypeAnnotation":
    case "TypeofTypeAnnotation":
    case "TypeAlias":
    case "TypeAnnotation":
    case "TypeCastExpression":
    case "TypeParameter":
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
    case "UnionTypeAnnotation":
    case "Variance":
    case "VoidTypeAnnotation":
    case "EnumDeclaration":
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function nb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "AnyTypeAnnotation":
    case "ArrayTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "BooleanLiteralTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "ExistsTypeAnnotation":
    case "FunctionTypeAnnotation":
    case "GenericTypeAnnotation":
    case "InterfaceTypeAnnotation":
    case "IntersectionTypeAnnotation":
    case "MixedTypeAnnotation":
    case "EmptyTypeAnnotation":
    case "NullableTypeAnnotation":
    case "NumberLiteralTypeAnnotation":
    case "NumberTypeAnnotation":
    case "ObjectTypeAnnotation":
    case "StringLiteralTypeAnnotation":
    case "StringTypeAnnotation":
    case "SymbolTypeAnnotation":
    case "ThisTypeAnnotation":
    case "TupleTypeAnnotation":
    case "TypeofTypeAnnotation":
    case "UnionTypeAnnotation":
    case "VoidTypeAnnotation":
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function ab(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "AnyTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "MixedTypeAnnotation":
    case "EmptyTypeAnnotation":
    case "NumberTypeAnnotation":
    case "StringTypeAnnotation":
    case "SymbolTypeAnnotation":
    case "ThisTypeAnnotation":
    case "VoidTypeAnnotation":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function ob(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TypeAlias":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function lb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "DeclaredPredicate":
    case "InferredPredicate":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function ub(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function cb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function fb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "JSXAttribute":
    case "JSXClosingElement":
    case "JSXElement":
    case "JSXEmptyExpression":
    case "JSXExpressionContainer":
    case "JSXSpreadChild":
    case "JSXIdentifier":
    case "JSXMemberExpression":
    case "JSXNamespacedName":
    case "JSXOpeningElement":
    case "JSXSpreadAttribute":
    case "JSXText":
    case "JSXFragment":
    case "JSXOpeningFragment":
    case "JSXClosingFragment":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function pb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "Noop":
    case "Placeholder":
    case "V8IntrinsicIdentifier":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function hb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "TSParameterProperty":
    case "TSDeclareFunction":
    case "TSDeclareMethod":
    case "TSQualifiedName":
    case "TSCallSignatureDeclaration":
    case "TSConstructSignatureDeclaration":
    case "TSPropertySignature":
    case "TSMethodSignature":
    case "TSIndexSignature":
    case "TSAnyKeyword":
    case "TSBooleanKeyword":
    case "TSBigIntKeyword":
    case "TSIntrinsicKeyword":
    case "TSNeverKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSObjectKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSUnknownKeyword":
    case "TSVoidKeyword":
    case "TSThisType":
    case "TSFunctionType":
    case "TSConstructorType":
    case "TSTypeReference":
    case "TSTypePredicate":
    case "TSTypeQuery":
    case "TSTypeLiteral":
    case "TSArrayType":
    case "TSTupleType":
    case "TSOptionalType":
    case "TSRestType":
    case "TSNamedTupleMember":
    case "TSUnionType":
    case "TSIntersectionType":
    case "TSConditionalType":
    case "TSInferType":
    case "TSParenthesizedType":
    case "TSTypeOperator":
    case "TSIndexedAccessType":
    case "TSMappedType":
    case "TSLiteralType":
    case "TSExpressionWithTypeArguments":
    case "TSInterfaceDeclaration":
    case "TSInterfaceBody":
    case "TSTypeAliasDeclaration":
    case "TSInstantiationExpression":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSEnumDeclaration":
    case "TSEnumMember":
    case "TSModuleDeclaration":
    case "TSModuleBlock":
    case "TSImportType":
    case "TSImportEqualsDeclaration":
    case "TSExternalModuleReference":
    case "TSNonNullExpression":
    case "TSExportAssignment":
    case "TSNamespaceExportDeclaration":
    case "TSTypeAnnotation":
    case "TSTypeParameterInstantiation":
    case "TSTypeParameterDeclaration":
    case "TSTypeParameter":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function db(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "TSCallSignatureDeclaration":
    case "TSConstructSignatureDeclaration":
    case "TSPropertySignature":
    case "TSMethodSignature":
    case "TSIndexSignature":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function mb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "TSAnyKeyword":
    case "TSBooleanKeyword":
    case "TSBigIntKeyword":
    case "TSIntrinsicKeyword":
    case "TSNeverKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSObjectKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSUnknownKeyword":
    case "TSVoidKeyword":
    case "TSThisType":
    case "TSFunctionType":
    case "TSConstructorType":
    case "TSTypeReference":
    case "TSTypePredicate":
    case "TSTypeQuery":
    case "TSTypeLiteral":
    case "TSArrayType":
    case "TSTupleType":
    case "TSOptionalType":
    case "TSRestType":
    case "TSUnionType":
    case "TSIntersectionType":
    case "TSConditionalType":
    case "TSInferType":
    case "TSParenthesizedType":
    case "TSTypeOperator":
    case "TSIndexedAccessType":
    case "TSMappedType":
    case "TSLiteralType":
    case "TSExpressionWithTypeArguments":
    case "TSImportType":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function yb(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "TSAnyKeyword":
    case "TSBooleanKeyword":
    case "TSBigIntKeyword":
    case "TSIntrinsicKeyword":
    case "TSNeverKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSObjectKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSUnknownKeyword":
    case "TSVoidKeyword":
    case "TSThisType":
    case "TSLiteralType":
      break;
    default:
      return !1;
  }
  return t == null || (0, P.default)(e, t);
}
function Tb(e, t) {
  return (0, ti.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function gb(e, t) {
  return (0, ti.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, P.default)(e, t);
}
function bb(e, t) {
  return (0, ti.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, P.default)(e, t);
}
function Sb(e, t) {
  return (0, ti.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, P.default)(e, t);
}
function Eb(e, t) {
  return (0, ti.default)("isModuleDeclaration", "isImportOrExportDeclaration"), Cu(e, t);
}
Object.defineProperty(os, "__esModule", {
  value: !0
});
os.default = Pb;
var wr = g;
function Pb(e, t, r) {
  if (!(0, wr.isMemberExpression)(e)) return !1;
  const i = Array.isArray(t) ? t : t.split("."), s = [];
  let n;
  for (n = e; (0, wr.isMemberExpression)(n); n = n.object)
    s.push(n.property);
  if (s.push(n), s.length < i.length || !r && s.length > i.length) return !1;
  for (let a = 0, o = s.length - 1; a < i.length; a++, o--) {
    const l = s[o];
    let u;
    if ((0, wr.isIdentifier)(l))
      u = l.name;
    else if ((0, wr.isStringLiteral)(l))
      u = l.value;
    else if ((0, wr.isThisExpression)(l))
      u = "this";
    else
      return !1;
    if (i[a] !== u) return !1;
  }
  return !0;
}
Object.defineProperty(as, "__esModule", {
  value: !0
});
as.default = vb;
var xb = os;
function vb(e, t) {
  const r = e.split(".");
  return (i) => (0, xb.default)(i, r, t);
}
Object.defineProperty(ns, "__esModule", {
  value: !0
});
ns.default = void 0;
var Ab = as;
const Cb = (0, Ab.default)("React.Component");
ns.default = Cb;
var Vn = {};
Object.defineProperty(Vn, "__esModule", {
  value: !0
});
Vn.default = Ib;
function Ib(e) {
  return !!e && /^[a-z]/.test(e);
}
var Pi = {}, xi = {}, T = {}, vi = {}, Tr = {}, Ws = {};
let Or = null;
function Xr(e) {
  if (Or !== null && typeof Or.property) {
    const t = Or;
    return Or = Xr.prototype = null, t;
  }
  return Or = Xr.prototype = e ?? /* @__PURE__ */ Object.create(null), new Xr();
}
Xr();
var wb = function(t) {
  return Xr(t);
}, ct = {}, Ai = {}, Ci = {}, Qa;
function Kn() {
  if (Qa) return Ci;
  Qa = 1, Object.defineProperty(Ci, "__esModule", {
    value: !0
  }), Ci.default = t;
  var e = It();
  function t(r, i) {
    if (r === i) return !0;
    if (r == null || e.ALIAS_KEYS[i]) return !1;
    const s = e.FLIPPED_ALIAS_KEYS[i];
    if (s) {
      if (s[0] === r) return !0;
      for (const n of s)
        if (r === n) return !0;
    }
    return !1;
  }
  return Ci;
}
var Ii = {}, Za;
function Iu() {
  if (Za) return Ii;
  Za = 1, Object.defineProperty(Ii, "__esModule", {
    value: !0
  }), Ii.default = t;
  var e = It();
  function t(r, i) {
    if (r === i) return !0;
    const s = e.PLACEHOLDERS_ALIAS[r];
    if (s) {
      for (const n of s)
        if (i === n) return !0;
    }
    return !1;
  }
  return Ii;
}
var eo;
function ri() {
  if (eo) return Ai;
  eo = 1, Object.defineProperty(Ai, "__esModule", {
    value: !0
  }), Ai.default = s;
  var e = ei, t = Kn(), r = Iu(), i = It();
  function s(n, a, o) {
    return a ? (0, t.default)(a.type, n) ? typeof o > "u" ? !0 : (0, e.default)(a, o) : !o && a.type === "Placeholder" && n in i.FLIPPED_ALIAS_KEYS ? (0, r.default)(a.expectedNode, n) : !1 : !1;
  }
  return Ai;
}
var cr = {}, ii = {}, si = {};
Object.defineProperty(si, "__esModule", {
  value: !0
});
si.isIdentifierChar = _u;
si.isIdentifierName = kb;
si.isIdentifierStart = Nu;
let qn = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", wu = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
const Ob = new RegExp("[" + qn + "]"), Nb = new RegExp("[" + qn + wu + "]");
qn = wu = null;
const Ou = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], _b = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function Sn(e, t) {
  let r = 65536;
  for (let i = 0, s = t.length; i < s; i += 2) {
    if (r += t[i], r > e) return !1;
    if (r += t[i + 1], r >= e) return !0;
  }
  return !1;
}
function Nu(e) {
  return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && Ob.test(String.fromCharCode(e)) : Sn(e, Ou);
}
function _u(e) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && Nb.test(String.fromCharCode(e)) : Sn(e, Ou) || Sn(e, _b);
}
function kb(e) {
  let t = !0;
  for (let r = 0; r < e.length; r++) {
    let i = e.charCodeAt(r);
    if ((i & 64512) === 55296 && r + 1 < e.length) {
      const s = e.charCodeAt(++r);
      (s & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (s & 1023));
    }
    if (t) {
      if (t = !1, !Nu(i))
        return !1;
    } else if (!_u(i))
      return !1;
  }
  return !t;
}
var fr = {};
Object.defineProperty(fr, "__esModule", {
  value: !0
});
fr.isKeyword = Fb;
fr.isReservedWord = ku;
fr.isStrictBindOnlyReservedWord = Lu;
fr.isStrictBindReservedWord = Bb;
fr.isStrictReservedWord = Du;
const Wn = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
}, Db = new Set(Wn.keyword), Lb = new Set(Wn.strict), Mb = new Set(Wn.strictBind);
function ku(e, t) {
  return t && e === "await" || e === "enum";
}
function Du(e, t) {
  return ku(e, t) || Lb.has(e);
}
function Lu(e) {
  return Mb.has(e);
}
function Bb(e, t) {
  return Du(e, t) || Lu(e);
}
function Fb(e) {
  return Db.has(e);
}
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), Object.defineProperty(e, "isIdentifierChar", {
    enumerable: !0,
    get: function() {
      return t.isIdentifierChar;
    }
  }), Object.defineProperty(e, "isIdentifierName", {
    enumerable: !0,
    get: function() {
      return t.isIdentifierName;
    }
  }), Object.defineProperty(e, "isIdentifierStart", {
    enumerable: !0,
    get: function() {
      return t.isIdentifierStart;
    }
  }), Object.defineProperty(e, "isKeyword", {
    enumerable: !0,
    get: function() {
      return r.isKeyword;
    }
  }), Object.defineProperty(e, "isReservedWord", {
    enumerable: !0,
    get: function() {
      return r.isReservedWord;
    }
  }), Object.defineProperty(e, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: function() {
      return r.isStrictBindOnlyReservedWord;
    }
  }), Object.defineProperty(e, "isStrictBindReservedWord", {
    enumerable: !0,
    get: function() {
      return r.isStrictBindReservedWord;
    }
  }), Object.defineProperty(e, "isStrictReservedWord", {
    enumerable: !0,
    get: function() {
      return r.isStrictReservedWord;
    }
  });
  var t = si, r = fr;
})(ii);
Object.defineProperty(cr, "__esModule", {
  value: !0
});
cr.default = jb;
var Js = ii;
function jb(e, t = !0) {
  return typeof e != "string" || t && ((0, Js.isKeyword)(e) || (0, Js.isStrictReservedWord)(e, !0)) ? !1 : (0, Js.isIdentifierName)(e);
}
var ni = {};
Object.defineProperty(ni, "__esModule", {
  value: !0
});
ni.readCodePoint = Bu;
ni.readInt = Mu;
ni.readStringContents = Ub;
var Rb = function(t) {
  return t >= 48 && t <= 57;
};
const to = {
  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
}, wi = {
  bin: (e) => e === 48 || e === 49,
  oct: (e) => e >= 48 && e <= 55,
  dec: (e) => e >= 48 && e <= 57,
  hex: (e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102
};
function Ub(e, t, r, i, s, n) {
  const a = r, o = i, l = s;
  let u = "", c = null, f = r;
  const {
    length: p
  } = t;
  for (; ; ) {
    if (r >= p) {
      n.unterminated(a, o, l), u += t.slice(f, r);
      break;
    }
    const h = t.charCodeAt(r);
    if ($b(e, h, t, r)) {
      u += t.slice(f, r);
      break;
    }
    if (h === 92) {
      u += t.slice(f, r);
      const y = Vb(t, r, i, s, e === "template", n);
      y.ch === null && !c ? c = {
        pos: r,
        lineStart: i,
        curLine: s
      } : u += y.ch, {
        pos: r,
        lineStart: i,
        curLine: s
      } = y, f = r;
    } else h === 8232 || h === 8233 ? (++r, ++s, i = r) : h === 10 || h === 13 ? e === "template" ? (u += t.slice(f, r) + `
`, ++r, h === 13 && t.charCodeAt(r) === 10 && ++r, ++s, f = i = r) : n.unterminated(a, o, l) : ++r;
  }
  return {
    pos: r,
    str: u,
    firstInvalidLoc: c,
    lineStart: i,
    curLine: s,
    containsInvalid: !!c
  };
}
function $b(e, t, r, i) {
  return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
}
function Vb(e, t, r, i, s, n) {
  const a = !s;
  t++;
  const o = (u) => ({
    pos: t,
    ch: u,
    lineStart: r,
    curLine: i
  }), l = e.charCodeAt(t++);
  switch (l) {
    case 110:
      return o(`
`);
    case 114:
      return o("\r");
    case 120: {
      let u;
      return {
        code: u,
        pos: t
      } = En(e, t, r, i, 2, !1, a, n), o(u === null ? null : String.fromCharCode(u));
    }
    case 117: {
      let u;
      return {
        code: u,
        pos: t
      } = Bu(e, t, r, i, a, n), o(u === null ? null : String.fromCodePoint(u));
    }
    case 116:
      return o("	");
    case 98:
      return o("\b");
    case 118:
      return o("\v");
    case 102:
      return o("\f");
    case 13:
      e.charCodeAt(t) === 10 && ++t;
    case 10:
      r = t, ++i;
    case 8232:
    case 8233:
      return o("");
    case 56:
    case 57:
      if (s)
        return o(null);
      n.strictNumericEscape(t - 1, r, i);
    default:
      if (l >= 48 && l <= 55) {
        const u = t - 1;
        let f = /^[0-7]+/.exec(e.slice(u, t + 2))[0], p = parseInt(f, 8);
        p > 255 && (f = f.slice(0, -1), p = parseInt(f, 8)), t += f.length - 1;
        const h = e.charCodeAt(t);
        if (f !== "0" || h === 56 || h === 57) {
          if (s)
            return o(null);
          n.strictNumericEscape(u, r, i);
        }
        return o(String.fromCharCode(p));
      }
      return o(String.fromCharCode(l));
  }
}
function En(e, t, r, i, s, n, a, o) {
  const l = t;
  let u;
  return {
    n: u,
    pos: t
  } = Mu(e, t, r, i, 16, s, n, !1, o, !a), u === null && (a ? o.invalidEscapeSequence(l, r, i) : t = l - 1), {
    code: u,
    pos: t
  };
}
function Mu(e, t, r, i, s, n, a, o, l, u) {
  const c = t, f = s === 16 ? to.hex : to.decBinOct, p = s === 16 ? wi.hex : s === 10 ? wi.dec : s === 8 ? wi.oct : wi.bin;
  let h = !1, y = 0;
  for (let b = 0, A = n ?? 1 / 0; b < A; ++b) {
    const I = e.charCodeAt(t);
    let _;
    if (I === 95 && o !== "bail") {
      const j = e.charCodeAt(t - 1), G = e.charCodeAt(t + 1);
      if (o) {
        if (Number.isNaN(G) || !p(G) || f.has(j) || f.has(G)) {
          if (u) return {
            n: null,
            pos: t
          };
          l.unexpectedNumericSeparator(t, r, i);
        }
      } else {
        if (u) return {
          n: null,
          pos: t
        };
        l.numericSeparatorInEscapeSequence(t, r, i);
      }
      ++t;
      continue;
    }
    if (I >= 97 ? _ = I - 97 + 10 : I >= 65 ? _ = I - 65 + 10 : Rb(I) ? _ = I - 48 : _ = 1 / 0, _ >= s) {
      if (_ <= 9 && u)
        return {
          n: null,
          pos: t
        };
      if (_ <= 9 && l.invalidDigit(t, r, i, s))
        _ = 0;
      else if (a)
        _ = 0, h = !0;
      else
        break;
    }
    ++t, y = y * s + _;
  }
  return t === c || n != null && t - c !== n || h ? {
    n: null,
    pos: t
  } : {
    n: y,
    pos: t
  };
}
function Bu(e, t, r, i, s, n) {
  const a = e.charCodeAt(t);
  let o;
  if (a === 123) {
    if (++t, {
      code: o,
      pos: t
    } = En(e, t, r, i, e.indexOf("}", t) - t, !0, s, n), ++t, o !== null && o > 1114111)
      if (s)
        n.invalidCodePoint(t, r, i);
      else
        return {
          code: null,
          pos: t
        };
  } else
    ({
      code: o,
      pos: t
    } = En(e, t, r, i, 4, !1, s, n));
  return {
    code: o,
    pos: t
  };
}
var be = {};
Object.defineProperty(be, "__esModule", {
  value: !0
});
be.UPDATE_OPERATORS = be.UNARY_OPERATORS = be.STRING_UNARY_OPERATORS = be.STATEMENT_OR_BLOCK_KEYS = be.NUMBER_UNARY_OPERATORS = be.NUMBER_BINARY_OPERATORS = be.NOT_LOCAL_BINDING = be.LOGICAL_OPERATORS = be.INHERIT_KEYS = be.FOR_INIT_KEYS = be.FLATTENABLE_KEYS = be.EQUALITY_BINARY_OPERATORS = be.COMPARISON_BINARY_OPERATORS = be.COMMENT_KEYS = be.BOOLEAN_UNARY_OPERATORS = be.BOOLEAN_NUMBER_BINARY_OPERATORS = be.BOOLEAN_BINARY_OPERATORS = be.BLOCK_SCOPED_SYMBOL = be.BINARY_OPERATORS = be.ASSIGNMENT_OPERATORS = void 0;
be.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
be.FLATTENABLE_KEYS = ["body", "expressions"];
be.FOR_INIT_KEYS = ["left", "init"];
be.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
const Kb = be.LOGICAL_OPERATORS = ["||", "&&", "??"];
be.UPDATE_OPERATORS = ["++", "--"];
const qb = be.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], Wb = be.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], Jb = be.COMPARISON_BINARY_OPERATORS = [...Wb, "in", "instanceof"], Xb = be.BOOLEAN_BINARY_OPERATORS = [...Jb, ...qb], Fu = be.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
be.BINARY_OPERATORS = ["+", ...Fu, ...Xb, "|>"];
be.ASSIGNMENT_OPERATORS = ["=", "+=", ...Fu.map((e) => e + "="), ...Kb.map((e) => e + "=")];
const Yb = be.BOOLEAN_UNARY_OPERATORS = ["delete", "!"], Hb = be.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], Gb = be.STRING_UNARY_OPERATORS = ["typeof"];
be.UNARY_OPERATORS = ["void", "throw", ...Yb, ...Hb, ...Gb];
be.INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"]
};
be.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
be.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
var ke = {}, ro;
function Qt() {
  if (ro) return ke;
  ro = 1, Object.defineProperty(ke, "__esModule", {
    value: !0
  }), ke.VISITOR_KEYS = ke.NODE_PARENT_VALIDATIONS = ke.NODE_FIELDS = ke.FLIPPED_ALIAS_KEYS = ke.DEPRECATED_KEYS = ke.BUILDER_KEYS = ke.ALIAS_KEYS = void 0, ke.arrayOf = b, ke.arrayOfType = A, ke.assertEach = _, ke.assertNodeOrValueType = ce, ke.assertNodeType = G, ke.assertOneOf = j, ke.assertOptionalChainStart = q, ke.assertShape = ae, ke.assertValueType = te, ke.chain = Y, ke.default = L, ke.defineAliasedType = U, ke.typeIs = f, ke.validate = c, ke.validateArrayOfType = I, ke.validateOptional = h, ke.validateOptionalType = y, ke.validateType = p;
  var e = ri(), t = Jn();
  const r = ke.VISITOR_KEYS = {}, i = ke.ALIAS_KEYS = {}, s = ke.FLIPPED_ALIAS_KEYS = {}, n = ke.NODE_FIELDS = {}, a = ke.BUILDER_KEYS = {}, o = ke.DEPRECATED_KEYS = {}, l = ke.NODE_PARENT_VALIDATIONS = {};
  function u(k) {
    return Array.isArray(k) ? "array" : k === null ? "null" : typeof k;
  }
  function c(k) {
    return {
      validate: k
    };
  }
  function f(k) {
    return typeof k == "string" ? G(k) : G(...k);
  }
  function p(k) {
    return c(f(k));
  }
  function h(k) {
    return {
      validate: k,
      optional: !0
    };
  }
  function y(k) {
    return {
      validate: f(k),
      optional: !0
    };
  }
  function b(k) {
    return Y(te("array"), _(k));
  }
  function A(k) {
    return b(f(k));
  }
  function I(k) {
    return c(A(k));
  }
  function _(k) {
    function F(B, N, D) {
      if (Array.isArray(D))
        for (let R = 0; R < D.length; R++) {
          const V = `${N}[${R}]`, $ = D[R];
          k(B, V, $), process.env.BABEL_TYPES_8_BREAKING && (0, t.validateChild)(B, V, $);
        }
    }
    return F.each = k, F;
  }
  function j(...k) {
    function F(B, N, D) {
      if (!k.includes(D))
        throw new TypeError(`Property ${N} expected value to be one of ${JSON.stringify(k)} but got ${JSON.stringify(D)}`);
    }
    return F.oneOf = k, F;
  }
  function G(...k) {
    function F(B, N, D) {
      for (const R of k)
        if ((0, e.default)(R, D)) {
          (0, t.validateChild)(B, N, D);
          return;
        }
      throw new TypeError(`Property ${N} of ${B.type} expected node to be of a type ${JSON.stringify(k)} but instead got ${JSON.stringify(D == null ? void 0 : D.type)}`);
    }
    return F.oneOfNodeTypes = k, F;
  }
  function ce(...k) {
    function F(B, N, D) {
      for (const R of k)
        if (u(D) === R || (0, e.default)(R, D)) {
          (0, t.validateChild)(B, N, D);
          return;
        }
      throw new TypeError(`Property ${N} of ${B.type} expected node to be of a type ${JSON.stringify(k)} but instead got ${JSON.stringify(D == null ? void 0 : D.type)}`);
    }
    return F.oneOfNodeOrValueTypes = k, F;
  }
  function te(k) {
    function F(B, N, D) {
      if (!(u(D) === k))
        throw new TypeError(`Property ${N} expected type of ${k} but got ${u(D)}`);
    }
    return F.type = k, F;
  }
  function ae(k) {
    function F(B, N, D) {
      const R = [];
      for (const V of Object.keys(k))
        try {
          (0, t.validateField)(B, V, D[V], k[V]);
        } catch ($) {
          if ($ instanceof TypeError) {
            R.push($.message);
            continue;
          }
          throw $;
        }
      if (R.length)
        throw new TypeError(`Property ${N} of ${B.type} expected to have the following:
${R.join(`
`)}`);
    }
    return F.shapeOf = k, F;
  }
  function q() {
    function k(F) {
      var B;
      let N = F;
      for (; F; ) {
        const {
          type: D
        } = N;
        if (D === "OptionalCallExpression") {
          if (N.optional) return;
          N = N.callee;
          continue;
        }
        if (D === "OptionalMemberExpression") {
          if (N.optional) return;
          N = N.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${F.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(B = N) == null ? void 0 : B.type}`);
    }
    return k;
  }
  function Y(...k) {
    function F(...B) {
      for (const N of k)
        N(...B);
    }
    if (F.chainOf = k, k.length >= 2 && "type" in k[0] && k[0].type === "array" && !("each" in k[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return F;
  }
  const re = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], W = ["default", "optional", "deprecated", "validate"], Q = {};
  function U(...k) {
    return (F, B = {}) => {
      let N = B.aliases;
      if (!N) {
        var D, R;
        B.inherits && (N = (D = Q[B.inherits].aliases) == null ? void 0 : D.slice()), (R = N) != null || (N = []), B.aliases = N;
      }
      const V = k.filter(($) => !N.includes($));
      N.unshift(...V), L(F, B);
    };
  }
  function L(k, F = {}) {
    const B = F.inherits && Q[F.inherits] || {};
    let N = F.fields;
    if (!N && (N = {}, B.fields)) {
      const $ = Object.getOwnPropertyNames(B.fields);
      for (const H of $) {
        const se = B.fields[H], oe = se.default;
        if (Array.isArray(oe) ? oe.length > 0 : oe && typeof oe == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        N[H] = {
          default: Array.isArray(oe) ? [] : oe,
          optional: se.optional,
          deprecated: se.deprecated,
          validate: se.validate
        };
      }
    }
    const D = F.visitor || B.visitor || [], R = F.aliases || B.aliases || [], V = F.builder || B.builder || F.visitor || [];
    for (const $ of Object.keys(F))
      if (!re.includes($))
        throw new Error(`Unknown type option "${$}" on ${k}`);
    F.deprecatedAlias && (o[F.deprecatedAlias] = k);
    for (const $ of D.concat(V))
      N[$] = N[$] || {};
    for (const $ of Object.keys(N)) {
      const H = N[$];
      H.default !== void 0 && !V.includes($) && (H.optional = !0), H.default === void 0 ? H.default = null : !H.validate && H.default != null && (H.validate = te(u(H.default)));
      for (const se of Object.keys(H))
        if (!W.includes(se))
          throw new Error(`Unknown field key "${se}" on ${k}.${$}`);
    }
    r[k] = F.visitor = D, a[k] = F.builder = V, n[k] = F.fields = N, i[k] = F.aliases = R, R.forEach(($) => {
      s[$] = s[$] || [], s[$].push(k);
    }), F.validate && (l[k] = F.validate), Q[k] = F;
  }
  return ke;
}
var io;
function ju() {
  if (io) return ct;
  io = 1, Object.defineProperty(ct, "__esModule", {
    value: !0
  }), ct.patternLikeCommon = ct.functionTypeAnnotationCommon = ct.functionDeclarationCommon = ct.functionCommon = ct.classMethodOrPropertyCommon = ct.classMethodOrDeclareMethodCommon = void 0;
  var e = ri(), t = cr, r = ii, i = ni, s = be, n = Qt();
  const a = (0, n.defineAliasedType)("Standardized");
  a("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  }), a("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, n.assertValueType)("string");
          const h = (0, n.assertOneOf)(...s.ASSIGNMENT_OPERATORS), y = (0, n.assertOneOf)("=");
          return function(b, A, I) {
            ((0, e.default)("Pattern", b.left) ? y : h)(b, A, I);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, n.assertNodeType)("LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  }), a("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, n.assertOneOf)(...s.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          const h = (0, n.assertNodeType)("Expression"), y = (0, n.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(A, I, _) {
            (A.operator === "in" ? y : h)(A, I, _);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  }), a("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, n.assertValueType)("string")
      }
    }
  }), a("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, n.assertNodeType)("DirectiveLiteral")
      }
    }
  }), a("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, n.assertValueType)("string")
      }
    }
  }), a("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  }), a("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, n.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  }), a("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, n.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression", "SpreadElement", "ArgumentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, n.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, n.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, n.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  }), a("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, n.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  }), a("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, n.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, n.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, n.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  }), a("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, n.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  }), a("DebuggerStatement", {
    aliases: ["Statement"]
  }), a("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, n.assertNodeType)("Expression")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  }), a("EmptyStatement", {
    aliases: ["Statement"]
  }), a("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, n.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  }), a("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, n.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertEach)((0, n.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, n.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  }), a("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, n.assertNodeType)("VariableDeclaration", "LVal")
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  }), a("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, n.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  });
  const o = () => ({
    params: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  });
  ct.functionCommon = o;
  const l = () => ({
    returnType: {
      validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, n.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  });
  ct.functionTypeAnnotationCommon = l;
  const u = () => Object.assign({}, o(), {
    declare: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, n.assertNodeType)("Identifier"),
      optional: !0
    }
  });
  ct.functionDeclarationCommon = u, a("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, u(), l(), {
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, n.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {
      };
      const h = (0, n.assertNodeType)("Identifier");
      return function(y, b, A) {
        (0, e.default)("ExportDefaultDeclaration", y) || h(A, "id", A.id);
      };
    }()
  }), a("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, o(), l(), {
      id: {
        validate: (0, n.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, n.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  const c = () => ({
    typeAnnotation: {
      validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    }
  });
  ct.patternLikeCommon = c, a("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, c(), {
      name: {
        validate: (0, n.chain)((0, n.assertValueType)("string"), Object.assign(function(h, y, b) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, t.default)(b, !1))
            throw new TypeError(`"${b}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      }
    }),
    validate(h, y, b) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const A = /\.(\w+)$/.exec(y);
      if (!A) return;
      const [, I] = A, _ = {
        computed: !1
      };
      if (I === "property") {
        if ((0, e.default)("MemberExpression", h, _) || (0, e.default)("OptionalMemberExpression", h, _)) return;
      } else if (I === "key") {
        if ((0, e.default)("Property", h, _) || (0, e.default)("Method", h, _)) return;
      } else if (I === "exported") {
        if ((0, e.default)("ExportSpecifier", h)) return;
      } else if (I === "imported") {
        if ((0, e.default)("ImportSpecifier", h, {
          imported: b
        })) return;
      } else if (I === "meta" && (0, e.default)("MetaProperty", h, {
        meta: b
      }))
        return;
      if (((0, r.isKeyword)(b.name) || (0, r.isReservedWord)(b.name, !1)) && b.name !== "this")
        throw new TypeError(`"${b.name}" is not a valid identifier`);
    }
  }), a("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, n.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, n.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  }), a("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, n.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  }), a("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, n.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), a("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, n.chain)((0, n.assertValueType)("number"), Object.assign(function(h, y, b) {
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), a("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), a("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, n.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), a("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, n.assertValueType)("string")
      },
      flags: {
        validate: (0, n.chain)((0, n.assertValueType)("string"), Object.assign(function(h, y, b) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          const A = /[^gimsuy]/.exec(b);
          if (A)
            throw new TypeError(`"${A[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  }), a("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, n.assertOneOf)(...s.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, n.assertNodeType)("Expression")
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, n.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          const h = (0, n.assertNodeType)("Identifier", "PrivateName"), y = (0, n.assertNodeType)("Expression"), b = function(A, I, _) {
            (A.computed ? y : h)(A, I, _);
          };
          return b.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], b;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, n.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  }), a("NewExpression", {
    inherits: "CallExpression"
  }), a("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, n.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, n.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  }), a("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  }), a("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, o(), l(), {
      kind: Object.assign({
        validate: (0, n.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const h = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), y = (0, n.assertNodeType)("Expression"), b = function(A, I, _) {
            (A.computed ? y : h)(A, I, _);
          };
          return b.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], b;
        }()
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  }), a("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const h = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), y = (0, n.assertNodeType)("Expression");
          return Object.assign(function(A, I, _) {
            (A.computed ? y : h)(A, I, _);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, n.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, n.chain)((0, n.assertValueType)("boolean"), Object.assign(function(h, y, b) {
          if (process.env.BABEL_TYPES_8_BREAKING && b && h.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(h, y, b) {
          if (process.env.BABEL_TYPES_8_BREAKING && b && !(0, e.default)("Identifier", h.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: !1
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      const h = (0, n.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), y = (0, n.assertNodeType)("Expression");
      return function(b, A, I) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        ((0, e.default)("ObjectPattern", b) ? h : y)(I, "value", I.value);
      };
    }()
  }), a("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, c(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, n.assertNodeType)("LVal")
      }
    }),
    validate(h, y) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const b = /(\w+)\[(\d+)\]/.exec(y);
      if (!b) throw new Error("Internal Babel error: malformed key.");
      const [, A, I] = b;
      if (h[A].length > +I + 1)
        throw new TypeError(`RestElement must be last element of ${A}`);
    }
  }), a("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      }
    }
  }), a("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  }), a("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
      }
    }
  }), a("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, n.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("SwitchCase")))
      }
    }
  }), a("ThisExpression", {
    aliases: ["Expression"]
  }), a("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, n.chain)((0, n.assertNodeType)("BlockStatement"), Object.assign(function(h) {
          if (process.env.BABEL_TYPES_8_BREAKING && !h.handler && !h.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, n.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, n.assertNodeType)("BlockStatement")
      }
    }
  }), a("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, n.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, n.assertOneOf)(...s.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  }), a("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("Identifier", "MemberExpression") : (0, n.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, n.assertOneOf)(...s.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  }), a("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, n.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(h, y, b) {
      if (process.env.BABEL_TYPES_8_BREAKING && (0, e.default)("ForXStatement", h, {
        left: b
      }) && b.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${h.type}`);
    }
  }), a("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, n.assertNodeType)("LVal");
          const h = (0, n.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), y = (0, n.assertNodeType)("Identifier");
          return function(b, A, I) {
            (b.init ? h : y)(b, A, I);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: (0, n.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, n.assertNodeType)("Expression")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  }), a("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, n.assertNodeType)("Expression")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  }), a("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, c(), {
      left: {
        validate: (0, n.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  }), a("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, c(), {
      elements: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  }), a("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, o(), l(), {
      expression: {
        validate: (0, n.assertValueType)("boolean")
      },
      body: {
        validate: (0, n.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, n.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  }), a("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  }), a("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, n.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, n.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, n.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, n.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  }), a("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, n.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, n.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, n.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, n.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      const h = (0, n.assertNodeType)("Identifier");
      return function(y, b, A) {
        process.env.BABEL_TYPES_8_BREAKING && ((0, e.default)("ExportDefaultDeclaration", y) || h(A, "id", A.id));
      };
    }()
  }), a("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, n.assertNodeType)("StringLiteral")
      },
      exportKind: (0, n.validateOptional)((0, n.assertOneOf)("type", "value")),
      attributes: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      }
    }
  }), a("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, n.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, n.validateOptional)((0, n.assertOneOf)("value"))
    }
  }), a("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertNodeType)("Declaration"), Object.assign(function(h, y, b) {
          if (process.env.BABEL_TYPES_8_BREAKING && b && h.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(h, y, b) {
          if (process.env.BABEL_TYPES_8_BREAKING && b && h.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      attributes: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)(function() {
          const h = (0, n.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), y = (0, n.assertNodeType)("ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(b, A, I) {
            (b.source ? h : y)(b, A, I);
          } : h;
        }()))
      },
      source: {
        validate: (0, n.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, n.validateOptional)((0, n.assertOneOf)("type", "value"))
    }
  }), a("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, n.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, n.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, n.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  }), a("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, n.assertNodeType)("VariableDeclaration", "LVal");
          const h = (0, n.assertNodeType)("VariableDeclaration"), y = (0, n.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(b, A, I) {
            (0, e.default)("VariableDeclaration", I) ? h(b, A, I) : y(b, A, I);
          };
        }()
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  }), a("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: (0, n.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, n.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, n.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, n.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  }), a("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, n.assertNodeType)("Identifier")
      }
    }
  }), a("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, n.assertNodeType)("Identifier")
      }
    }
  }), a("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, n.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, n.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, n.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  }), a("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, n.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, n.assertNodeType)("Expression")
      },
      options: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      }
    }
  }), a("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, n.chain)((0, n.assertNodeType)("Identifier"), Object.assign(function(h, y, b) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let A;
          switch (b.name) {
            case "function":
              A = "sent";
              break;
            case "new":
              A = "target";
              break;
            case "import":
              A = "meta";
              break;
          }
          if (!(0, e.default)("Identifier", h.property, {
            name: A
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, n.assertNodeType)("Identifier")
      }
    }
  });
  const f = () => ({
    abstract: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, n.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, n.chain)(function() {
        const h = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), y = (0, n.assertNodeType)("Expression");
        return function(b, A, I) {
          (b.computed ? y : h)(b, A, I);
        };
      }(), (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  });
  ct.classMethodOrPropertyCommon = f;
  const p = () => Object.assign({}, o(), f(), {
    params: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
      validate: (0, n.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, n.chain)((0, n.assertValueType)("string"), (0, n.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    }
  });
  return ct.classMethodOrDeclareMethodCommon = p, a("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, p(), l(), {
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      }
    })
  }), a("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, c(), {
      properties: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  }), a("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("Super", {
    aliases: ["Expression"]
  }), a("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, n.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, n.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), a("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, n.chain)((0, n.assertShape)({
          raw: {
            validate: (0, n.assertValueType)("string")
          },
          cooked: {
            validate: (0, n.assertValueType)("string"),
            optional: !0
          }
        }), function(y) {
          const b = y.value.raw;
          let A = !1;
          const I = () => {
            throw new Error("Internal @babel/types error.");
          }, {
            str: _,
            firstInvalidLoc: j
          } = (0, i.readStringContents)("template", b, 0, 0, 0, {
            unterminated() {
              A = !0;
            },
            strictNumericEscape: I,
            invalidEscapeSequence: I,
            numericSeparatorInEscapeSequence: I,
            unexpectedNumericSeparator: I,
            invalidDigit: I,
            invalidCodePoint: I
          });
          if (!A) throw new Error("Invalid raw");
          y.value.cooked = j ? null : _;
        })
      },
      tail: {
        default: !1
      }
    }
  }), a("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression", "TSType")), function(h, y, b) {
          if (h.quasis.length !== b.length + 1)
            throw new TypeError(`Number of ${h.type} quasis should be exactly one more than the number of expressions.
Expected ${b.length + 1} quasis but got ${h.quasis.length}`);
        })
      }
    }
  }), a("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, n.chain)((0, n.assertValueType)("boolean"), Object.assign(function(h, y, b) {
          if (process.env.BABEL_TYPES_8_BREAKING && b && !h.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("Import", {
    aliases: ["Expression"]
  }), a("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, n.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), a("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, n.assertNodeType)("Identifier")
      }
    }
  }), a("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, n.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          const h = (0, n.assertNodeType)("Identifier"), y = (0, n.assertNodeType)("Expression");
          return Object.assign(function(A, I, _) {
            (A.computed ? y : h)(A, I, _);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.chain)((0, n.assertValueType)("boolean"), (0, n.assertOptionalChainStart)()) : (0, n.assertValueType)("boolean")
      }
    }
  }), a("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, n.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression", "SpreadElement", "ArgumentPlaceholder")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.chain)((0, n.assertValueType)("boolean"), (0, n.assertOptionalChainStart)()) : (0, n.assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, n.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, n.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), a("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, f(), {
      value: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, n.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }), a("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, f(), {
      key: {
        validate: (0, n.chain)(function() {
          const h = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), y = (0, n.assertNodeType)("Expression");
          return function(b, A, I) {
            (b.computed ? y : h)(b, A, I);
          };
        }(), (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, n.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }), a("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, n.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      static: {
        validate: (0, n.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, n.assertNodeType)("Variance"),
        optional: !0
      }
    }
  }), a("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, p(), l(), {
      kind: {
        validate: (0, n.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, n.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      }
    })
  }), a("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, n.assertNodeType)("Identifier")
      }
    }
  }), a("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  }), ct;
}
var so = {}, no;
function zb() {
  if (no) return so;
  no = 1;
  var e = Qt();
  const t = (0, e.defineAliasedType)("Flow"), r = (i) => {
    const s = i === "DeclareClass";
    t(i, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...s ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, e.validateType)("Identifier"),
        typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends"))
      }, s ? {
        mixins: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends")),
        implements: (0, e.validateOptional)((0, e.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, e.validateType)("ObjectTypeAnnotation")
      })
    });
  };
  return t("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, e.validateType)("FlowType")
    }
  }), t("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
    }
  }), r("DeclareClass"), t("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      predicate: (0, e.validateOptionalType)("DeclaredPredicate")
    }
  }), r("DeclareInterface"), t("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)(["Identifier", "StringLiteral"]),
      body: (0, e.validateType)("BlockStatement"),
      kind: (0, e.validateOptional)((0, e.assertOneOf)("CommonJS", "ES"))
    }
  }), t("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, e.validateType)("TypeAnnotation")
    }
  }), t("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, e.validateType)("FlowType")
    }
  }), t("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, e.validateOptionalType)("FlowType"),
      impltype: (0, e.validateOptionalType)("FlowType")
    }
  }), t("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier")
    }
  }), t("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, e.validateOptionalType)("Flow"),
      specifiers: (0, e.validateOptional)((0, e.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, e.validateOptionalType)("StringLiteral"),
      default: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
    }
  }), t("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, e.validateType)("StringLiteral"),
      exportKind: (0, e.validateOptional)((0, e.assertOneOf)("type", "value"))
    }
  }), t("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, e.validateType)("Flow")
    }
  }), t("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  }), t("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, e.validate)((0, e.arrayOfType)("FunctionTypeParam")),
      rest: (0, e.validateOptionalType)("FunctionTypeParam"),
      this: (0, e.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, e.validateType)("FlowType")
    }
  }), t("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, e.validateOptionalType)("Identifier"),
      typeAnnotation: (0, e.validateType)("FlowType"),
      optional: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
    }
  }), t("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
    }
  }), t("InferredPredicate", {
    aliases: ["FlowPredicate"]
  }), t("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
    }
  }), r("InterfaceDeclaration"), t("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends")),
      body: (0, e.validateType)("ObjectTypeAnnotation")
    }
  }), t("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, e.validateType)("FlowType")
    }
  }), t("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, e.validate)((0, e.assertValueType)("number"))
    }
  }), t("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, e.validate)((0, e.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, e.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, e.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, e.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, e.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      value: (0, e.validateType)("FlowType"),
      optional: (0, e.validate)((0, e.assertValueType)("boolean")),
      static: (0, e.validate)((0, e.assertValueType)("boolean")),
      method: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, e.validateType)("FlowType"),
      static: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, e.validateOptionalType)("Identifier"),
      key: (0, e.validateType)("FlowType"),
      value: (0, e.validateType)("FlowType"),
      static: (0, e.validate)((0, e.assertValueType)("boolean")),
      variance: (0, e.validateOptionalType)("Variance")
    }
  }), t("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, e.validateType)(["Identifier", "StringLiteral"]),
      value: (0, e.validateType)("FlowType"),
      kind: (0, e.validate)((0, e.assertOneOf)("init", "get", "set")),
      static: (0, e.validate)((0, e.assertValueType)("boolean")),
      proto: (0, e.validate)((0, e.assertValueType)("boolean")),
      optional: (0, e.validate)((0, e.assertValueType)("boolean")),
      variance: (0, e.validateOptionalType)("Variance"),
      method: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, e.validateType)("FlowType")
    }
  }), t("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, e.validateOptionalType)("FlowType"),
      impltype: (0, e.validateType)("FlowType")
    }
  }), t("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      qualification: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  }), t("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, e.validate)((0, e.assertValueType)("string"))
    }
  }), t("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, e.validateType)("FlowType")
    }
  }), t("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, e.validateType)("FlowType")
    }
  }), t("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("FlowType")
    }
  }), t("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, e.validateType)("Expression"),
      typeAnnotation: (0, e.validateType)("TypeAnnotation")
    }
  }), t("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, e.validate)((0, e.assertValueType)("string")),
      bound: (0, e.validateOptionalType)("TypeAnnotation"),
      default: (0, e.validateOptionalType)("FlowType"),
      variance: (0, e.validateOptionalType)("Variance")
    }
  }), t("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, e.validate)((0, e.arrayOfType)("TypeParameter"))
    }
  }), t("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, e.validate)((0, e.assertOneOf)("minus", "plus"))
    }
  }), t("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      body: (0, e.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  }), t("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
      members: (0, e.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
      members: (0, e.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
      members: (0, e.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, e.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      init: (0, e.validateType)("BooleanLiteral")
    }
  }), t("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      init: (0, e.validateType)("NumericLiteral")
    }
  }), t("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      init: (0, e.validateType)("StringLiteral")
    }
  }), t("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, e.validateType)("Identifier")
    }
  }), t("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, e.validateType)("FlowType"),
      indexType: (0, e.validateType)("FlowType")
    }
  }), t("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, e.validateType)("FlowType"),
      indexType: (0, e.validateType)("FlowType"),
      optional: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), so;
}
var ao = {}, oo;
function Qb() {
  if (oo) return ao;
  oo = 1;
  var e = Qt();
  const t = (0, e.defineAliasedType)("JSX");
  return t("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, e.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  }), t("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  }), t("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, e.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, e.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      }
    })
  }), t("JSXEmptyExpression", {}), t("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  }), t("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression")
      }
    }
  }), t("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, e.assertValueType)("string")
      }
    }
  }), t("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, e.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, e.assertNodeType)("JSXIdentifier")
      }
    }
  }), t("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, e.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier")
      }
    }
  }), t("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: (0, e.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), t("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, e.assertNodeType)("Expression")
      }
    }
  }), t("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, e.assertValueType)("string")
      }
    }
  }), t("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, e.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, e.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  }), t("JSXOpeningFragment", {
    aliases: ["Immutable"]
  }), t("JSXClosingFragment", {
    aliases: ["Immutable"]
  }), ao;
}
var lo = {}, Nt = {}, uo;
function Ru() {
  if (uo) return Nt;
  uo = 1, Object.defineProperty(Nt, "__esModule", {
    value: !0
  }), Nt.PLACEHOLDERS_FLIPPED_ALIAS = Nt.PLACEHOLDERS_ALIAS = Nt.PLACEHOLDERS = void 0;
  var e = Qt();
  const t = Nt.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], r = Nt.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (const s of t) {
    const n = e.ALIAS_KEYS[s];
    n != null && n.length && (r[s] = n);
  }
  const i = Nt.PLACEHOLDERS_FLIPPED_ALIAS = {};
  return Object.keys(r).forEach((s) => {
    r[s].forEach((n) => {
      hasOwnProperty.call(i, n) || (i[n] = []), i[n].push(s);
    });
  }), Nt;
}
var co;
function Zb() {
  if (co) return lo;
  co = 1;
  var e = Qt(), t = Ru();
  const r = (0, e.defineAliasedType)("Miscellaneous");
  return r("Noop", {
    visitor: []
  }), r("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, e.assertOneOf)(...t.PLACEHOLDERS)
      }
    }
  }), r("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, e.assertValueType)("string")
      }
    }
  }), lo;
}
var fo = {}, po;
function eS() {
  if (po) return fo;
  po = 1;
  var e = Qt();
  return (0, e.default)("ArgumentPlaceholder", {}), (0, e.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, e.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, e.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  }), (0, e.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, e.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, e.assertNodeType)("StringLiteral")
      }
    }
  }), (0, e.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression")
      }
    }
  }), (0, e.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, e.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, e.assertValueType)("boolean"),
        default: !1
      }
    }
  }), (0, e.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, e.assertNodeType)("Identifier")
      }
    }
  }), (0, e.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  }), (0, e.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  }), (0, e.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, e.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), (0, e.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, e.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  }), (0, e.default)("TopicReference", {
    aliases: ["Expression"]
  }), (0, e.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  }), (0, e.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, e.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  }), (0, e.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  }), fo;
}
var ho = {}, mo;
function tS() {
  if (mo) return ho;
  mo = 1;
  var e = Qt(), t = ju(), r = ri();
  const i = (0, e.defineAliasedType)("TypeScript"), s = (0, e.assertValueType)("boolean"), n = () => ({
    returnType: {
      validate: (0, e.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, e.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  });
  i("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, e.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, e.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  }), i("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, t.functionDeclarationCommon)(), n())
  }), i("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, t.classMethodOrDeclareMethodCommon)(), n())
  }), i("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, e.validateType)("TSEntityName"),
      right: (0, e.validateType)("Identifier")
    }
  });
  const a = () => ({
    typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, e.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation")
  }), o = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: a()
  };
  i("TSCallSignatureDeclaration", o), i("TSConstructSignatureDeclaration", o);
  const l = () => ({
    key: (0, e.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, e.validateOptional)(s)
  });
  i("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, l(), {
      readonly: (0, e.validateOptional)(s),
      typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        validate: (0, e.assertOneOf)("get", "set")
      }
    })
  }), i("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, a(), l(), {
      kind: {
        validate: (0, e.assertOneOf)("method", "get", "set")
      }
    })
  }), i("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, e.validateOptional)(s),
      static: (0, e.validateOptional)(s),
      parameters: (0, e.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation")
    }
  });
  const u = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const h of u)
    i(h, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  i("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  const c = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  i("TSFunctionType", Object.assign({}, c, {
    fields: a()
  })), i("TSConstructorType", Object.assign({}, c, {
    fields: Object.assign({}, a(), {
      abstract: (0, e.validateOptional)(s)
    })
  })), i("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, e.validateType)("TSEntityName"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), i("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, e.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, e.validateOptional)(s)
    }
  }), i("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, e.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), i("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, e.validateArrayOfType)("TSTypeElement")
    }
  }), i("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, e.validateType)("TSType")
    }
  }), i("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, e.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  }), i("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, e.validateType)("Identifier"),
      optional: {
        validate: s,
        default: !1
      },
      elementType: (0, e.validateType)("TSType")
    }
  });
  const f = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, e.validateArrayOfType)("TSType")
    }
  };
  i("TSUnionType", f), i("TSIntersectionType", f), i("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, e.validateType)("TSType"),
      extendsType: (0, e.validateType)("TSType"),
      trueType: (0, e.validateType)("TSType"),
      falseType: (0, e.validateType)("TSType")
    }
  }), i("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, e.validateType)("TSTypeParameter")
    }
  }), i("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, e.validate)((0, e.assertValueType)("string")),
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, e.validateType)("TSType"),
      indexType: (0, e.validateType)("TSType")
    }
  }), i("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, e.validateOptional)((0, e.assertOneOf)(!0, !1, "+", "-")),
      typeParameter: (0, e.validateType)("TSTypeParameter"),
      optional: (0, e.validateOptional)((0, e.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, e.validateOptionalType)("TSType"),
      nameType: (0, e.validateOptionalType)("TSType")
    }
  }), i("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          const h = (0, e.assertNodeType)("NumericLiteral", "BigIntLiteral"), y = (0, e.assertOneOf)("-"), b = (0, e.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function A(I, _, j) {
            (0, r.default)("UnaryExpression", j) ? (y(j, "operator", j.operator), h(j, "argument", j.argument)) : b(I, _, j);
          }
          return A.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], A;
        }()
      }
    }
  }), i("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, e.validateType)("TSEntityName"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), i("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, e.validateOptional)(s),
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, e.validateOptional)((0, e.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, e.validateType)("TSInterfaceBody")
    }
  }), i("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, e.validateArrayOfType)("TSTypeElement")
    }
  }), i("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, e.validateOptional)(s),
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, e.validateType)("Expression"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  const p = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, e.validateType)("Expression"),
      typeAnnotation: (0, e.validateType)("TSType")
    }
  };
  return i("TSAsExpression", p), i("TSSatisfiesExpression", p), i("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType"),
      expression: (0, e.validateType)("Expression")
    }
  }), i("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, e.validateOptional)(s),
      const: (0, e.validateOptional)(s),
      id: (0, e.validateType)("Identifier"),
      members: (0, e.validateArrayOfType)("TSEnumMember"),
      initializer: (0, e.validateOptionalType)("Expression")
    }
  }), i("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, e.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, e.validateOptionalType)("Expression")
    }
  }), i("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, e.validateOptional)(s),
      global: (0, e.validateOptional)(s),
      id: (0, e.validateType)(["Identifier", "StringLiteral"]),
      body: (0, e.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  }), i("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, e.validateArrayOfType)("Statement")
    }
  }), i("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, e.validateType)("StringLiteral"),
      qualifier: (0, e.validateOptionalType)("TSEntityName"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, e.assertNodeType)("Expression"),
        optional: !0
      }
    }
  }), i("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, e.validate)(s),
      id: (0, e.validateType)("Identifier"),
      moduleReference: (0, e.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, e.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  }), i("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, e.validateType)("StringLiteral")
    }
  }), i("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, e.validateType)("Expression")
    }
  }), i("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, e.validateType)("Expression")
    }
  }), i("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, e.validateType)("Identifier")
    }
  }), i("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, e.assertNodeType)("TSType")
      }
    }
  }), i("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("TSType")))
      }
    }
  }), i("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("TSTypeParameter")))
      }
    }
  }), i("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, e.assertValueType)("string")
      },
      in: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, e.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, e.assertNodeType)("TSType"),
        optional: !0
      }
    }
  }), ho;
}
var ls = {};
Object.defineProperty(ls, "__esModule", {
  value: !0
});
ls.DEPRECATED_ALIASES = void 0;
ls.DEPRECATED_ALIASES = {
  ModuleDeclaration: "ImportOrExportDeclaration"
};
var yo;
function It() {
  return yo || (yo = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "ALIAS_KEYS", {
      enumerable: !0,
      get: function() {
        return r.ALIAS_KEYS;
      }
    }), Object.defineProperty(e, "BUILDER_KEYS", {
      enumerable: !0,
      get: function() {
        return r.BUILDER_KEYS;
      }
    }), Object.defineProperty(e, "DEPRECATED_ALIASES", {
      enumerable: !0,
      get: function() {
        return s.DEPRECATED_ALIASES;
      }
    }), Object.defineProperty(e, "DEPRECATED_KEYS", {
      enumerable: !0,
      get: function() {
        return r.DEPRECATED_KEYS;
      }
    }), Object.defineProperty(e, "FLIPPED_ALIAS_KEYS", {
      enumerable: !0,
      get: function() {
        return r.FLIPPED_ALIAS_KEYS;
      }
    }), Object.defineProperty(e, "NODE_FIELDS", {
      enumerable: !0,
      get: function() {
        return r.NODE_FIELDS;
      }
    }), Object.defineProperty(e, "NODE_PARENT_VALIDATIONS", {
      enumerable: !0,
      get: function() {
        return r.NODE_PARENT_VALIDATIONS;
      }
    }), Object.defineProperty(e, "PLACEHOLDERS", {
      enumerable: !0,
      get: function() {
        return i.PLACEHOLDERS;
      }
    }), Object.defineProperty(e, "PLACEHOLDERS_ALIAS", {
      enumerable: !0,
      get: function() {
        return i.PLACEHOLDERS_ALIAS;
      }
    }), Object.defineProperty(e, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: !0,
      get: function() {
        return i.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    }), e.TYPES = void 0, Object.defineProperty(e, "VISITOR_KEYS", {
      enumerable: !0,
      get: function() {
        return r.VISITOR_KEYS;
      }
    });
    var t = wb;
    ju(), zb(), Qb(), Zb(), eS(), tS();
    var r = Qt(), i = Ru(), s = ls;
    Object.keys(s.DEPRECATED_ALIASES).forEach((n) => {
      r.FLIPPED_ALIAS_KEYS[n] = r.FLIPPED_ALIAS_KEYS[s.DEPRECATED_ALIASES[n]];
    }), t(r.VISITOR_KEYS), t(r.ALIAS_KEYS), t(r.FLIPPED_ALIAS_KEYS), t(r.NODE_FIELDS), t(r.BUILDER_KEYS), t(r.DEPRECATED_KEYS), t(i.PLACEHOLDERS_ALIAS), t(i.PLACEHOLDERS_FLIPPED_ALIAS), e.TYPES = [].concat(Object.keys(r.VISITOR_KEYS), Object.keys(r.FLIPPED_ALIAS_KEYS), Object.keys(r.DEPRECATED_KEYS));
  }(Ws)), Ws;
}
var To;
function Jn() {
  if (To) return Tr;
  To = 1, Object.defineProperty(Tr, "__esModule", {
    value: !0
  }), Tr.default = t, Tr.validateChild = i, Tr.validateField = r;
  var e = It();
  function t(s, n, a) {
    if (!s) return;
    const o = e.NODE_FIELDS[s.type];
    if (!o) return;
    const l = o[n];
    r(s, n, a, l), i(s, n, a);
  }
  function r(s, n, a, o) {
    o != null && o.validate && (o.optional && a == null || o.validate(s, n, a));
  }
  function i(s, n, a) {
    if (a == null) return;
    const o = e.NODE_PARENT_VALIDATIONS[a.type];
    o && o(s, n, a);
  }
  return Tr;
}
var go;
function rS() {
  if (go) return vi;
  go = 1, Object.defineProperty(vi, "__esModule", {
    value: !0
  }), vi.default = r;
  var e = Jn(), t = Ae();
  function r(i) {
    const s = t.BUILDER_KEYS[i.type];
    for (const n of s)
      (0, e.default)(i, n, i[n]);
    return i;
  }
  return vi;
}
var bo;
function Tt() {
  if (bo) return T;
  bo = 1, Object.defineProperty(T, "__esModule", {
    value: !0
  }), T.anyTypeAnnotation = Of, T.argumentPlaceholder = sh, T.arrayExpression = r, T.arrayPattern = ve, T.arrayTypeAnnotation = Nf, T.arrowFunctionExpression = Re, T.assignmentExpression = i, T.assignmentPattern = Be, T.awaitExpression = mt, T.bigIntLiteral = Ti, T.binaryExpression = s, T.bindExpression = nh, T.blockStatement = l, T.booleanLiteral = U, T.booleanLiteralTypeAnnotation = kf, T.booleanTypeAnnotation = _f, T.breakStatement = u, T.callExpression = c, T.catchClause = f, T.classAccessorProperty = yr, T.classBody = lt, T.classDeclaration = J, T.classExpression = He, T.classImplements = Lf, T.classMethod = Ve, T.classPrivateMethod = Si, T.classPrivateProperty = bi, T.classProperty = Ot, T.conditionalExpression = p, T.continueStatement = h, T.debuggerStatement = y, T.decimalLiteral = ph, T.declareClass = Mf, T.declareExportAllDeclaration = qf, T.declareExportDeclaration = Kf, T.declareFunction = Bf, T.declareInterface = Ff, T.declareModule = jf, T.declareModuleExports = Rf, T.declareOpaqueType = $f, T.declareTypeAlias = Uf, T.declareVariable = Vf, T.declaredPredicate = Wf, T.decorator = oh, T.directive = a, T.directiveLiteral = o, T.doExpression = lh, T.doWhileStatement = b, T.emptyStatement = A, T.emptyTypeAnnotation = rp, T.enumBooleanBody = Np, T.enumBooleanMember = Lp, T.enumDeclaration = Op, T.enumDefaultedMember = Fp, T.enumNumberBody = _p, T.enumNumberMember = Mp, T.enumStringBody = kp, T.enumStringMember = Bp, T.enumSymbolBody = Dp, T.existsTypeAnnotation = Jf, T.exportAllDeclaration = d, T.exportDefaultDeclaration = x, T.exportDefaultSpecifier = uh, T.exportNamedDeclaration = O, T.exportNamespaceSpecifier = $s, T.exportSpecifier = M, T.expressionStatement = I, T.file = _, T.forInStatement = j, T.forOfStatement = Z, T.forStatement = G, T.functionDeclaration = ce, T.functionExpression = te, T.functionTypeAnnotation = Xf, T.functionTypeParam = Yf, T.genericTypeAnnotation = Hf, T.identifier = ae, T.ifStatement = q, T.import = Cr, T.importAttribute = ah, T.importDeclaration = ee, T.importDefaultSpecifier = ge, T.importExpression = X, T.importNamespaceSpecifier = xe, T.importSpecifier = ye, T.indexedAccessType = jp, T.inferredPredicate = Gf, T.interfaceDeclaration = Qf, T.interfaceExtends = zf, T.interfaceTypeAnnotation = Zf, T.interpreterDirective = n, T.intersectionTypeAnnotation = ep, T.jSXAttribute = T.jsxAttribute = Up, T.jSXClosingElement = T.jsxClosingElement = $p, T.jSXClosingFragment = T.jsxClosingFragment = eh, T.jSXElement = T.jsxElement = Vp, T.jSXEmptyExpression = T.jsxEmptyExpression = Kp, T.jSXExpressionContainer = T.jsxExpressionContainer = qp, T.jSXFragment = T.jsxFragment = Qp, T.jSXIdentifier = T.jsxIdentifier = Jp, T.jSXMemberExpression = T.jsxMemberExpression = Xp, T.jSXNamespacedName = T.jsxNamespacedName = Yp, T.jSXOpeningElement = T.jsxOpeningElement = Hp, T.jSXOpeningFragment = T.jsxOpeningFragment = Zp, T.jSXSpreadAttribute = T.jsxSpreadAttribute = Gp, T.jSXSpreadChild = T.jsxSpreadChild = Wp, T.jSXText = T.jsxText = zp, T.labeledStatement = Y, T.logicalExpression = k, T.memberExpression = F, T.metaProperty = rt, T.mixedTypeAnnotation = tp, T.moduleExpression = hh, T.newExpression = B, T.noop = th, T.nullLiteral = Q, T.nullLiteralTypeAnnotation = Df, T.nullableTypeAnnotation = ip, T.numberLiteral = Od, T.numberLiteralTypeAnnotation = sp, T.numberTypeAnnotation = np, T.numericLiteral = W, T.objectExpression = D, T.objectMethod = R, T.objectPattern = We, T.objectProperty = V, T.objectTypeAnnotation = ap, T.objectTypeCallProperty = lp, T.objectTypeIndexer = up, T.objectTypeInternalSlot = op, T.objectTypeProperty = cp, T.objectTypeSpreadProperty = fp, T.opaqueType = pp, T.optionalCallExpression = Ir, T.optionalIndexedAccessType = Rp, T.optionalMemberExpression = gi, T.parenthesizedExpression = oe, T.pipelineBareFunction = yh, T.pipelinePrimaryTopicReference = Th, T.pipelineTopicExpression = mh, T.placeholder = rh, T.privateName = Ei, T.program = N, T.qualifiedTypeIdentifier = hp, T.recordExpression = ch, T.regExpLiteral = L, T.regexLiteral = Nd, T.restElement = $, T.restProperty = _d, T.returnStatement = H, T.sequenceExpression = se, T.spreadElement = it, T.spreadProperty = kd, T.staticBlock = wf, T.stringLiteral = re, T.stringLiteralTypeAnnotation = dp, T.stringTypeAnnotation = mp, T.super = dt, T.switchCase = Ue, T.switchStatement = fe, T.symbolTypeAnnotation = yp, T.taggedTemplateExpression = v, T.templateElement = he, T.templateLiteral = Fe, T.thisExpression = pe, T.thisTypeAnnotation = Tp, T.throwStatement = Se, T.topicReference = dh, T.tryStatement = Ce, T.tSAnyKeyword = T.tsAnyKeyword = Ih, T.tSArrayType = T.tsArrayType = Xh, T.tSAsExpression = T.tsAsExpression = pd, T.tSBigIntKeyword = T.tsBigIntKeyword = Oh, T.tSBooleanKeyword = T.tsBooleanKeyword = wh, T.tSCallSignatureDeclaration = T.tsCallSignatureDeclaration = Ph, T.tSConditionalType = T.tsConditionalType = ed, T.tSConstructSignatureDeclaration = T.tsConstructSignatureDeclaration = xh, T.tSConstructorType = T.tsConstructorType = Vh, T.tSDeclareFunction = T.tsDeclareFunction = bh, T.tSDeclareMethod = T.tsDeclareMethod = Sh, T.tSEnumDeclaration = T.tsEnumDeclaration = md, T.tSEnumMember = T.tsEnumMember = yd, T.tSExportAssignment = T.tsExportAssignment = xd, T.tSExpressionWithTypeArguments = T.tsExpressionWithTypeArguments = od, T.tSExternalModuleReference = T.tsExternalModuleReference = Ed, T.tSFunctionType = T.tsFunctionType = $h, T.tSImportEqualsDeclaration = T.tsImportEqualsDeclaration = Sd, T.tSImportType = T.tsImportType = bd, T.tSIndexSignature = T.tsIndexSignature = Ch, T.tSIndexedAccessType = T.tsIndexedAccessType = sd, T.tSInferType = T.tsInferType = td, T.tSInstantiationExpression = T.tsInstantiationExpression = fd, T.tSInterfaceBody = T.tsInterfaceBody = ud, T.tSInterfaceDeclaration = T.tsInterfaceDeclaration = ld, T.tSIntersectionType = T.tsIntersectionType = Zh, T.tSIntrinsicKeyword = T.tsIntrinsicKeyword = Nh, T.tSLiteralType = T.tsLiteralType = ad, T.tSMappedType = T.tsMappedType = nd, T.tSMethodSignature = T.tsMethodSignature = Ah, T.tSModuleBlock = T.tsModuleBlock = gd, T.tSModuleDeclaration = T.tsModuleDeclaration = Td, T.tSNamedTupleMember = T.tsNamedTupleMember = zh, T.tSNamespaceExportDeclaration = T.tsNamespaceExportDeclaration = vd, T.tSNeverKeyword = T.tsNeverKeyword = _h, T.tSNonNullExpression = T.tsNonNullExpression = Pd, T.tSNullKeyword = T.tsNullKeyword = kh, T.tSNumberKeyword = T.tsNumberKeyword = Dh, T.tSObjectKeyword = T.tsObjectKeyword = Lh, T.tSOptionalType = T.tsOptionalType = Hh, T.tSParameterProperty = T.tsParameterProperty = gh, T.tSParenthesizedType = T.tsParenthesizedType = rd, T.tSPropertySignature = T.tsPropertySignature = vh, T.tSQualifiedName = T.tsQualifiedName = Eh, T.tSRestType = T.tsRestType = Gh, T.tSSatisfiesExpression = T.tsSatisfiesExpression = hd, T.tSStringKeyword = T.tsStringKeyword = Mh, T.tSSymbolKeyword = T.tsSymbolKeyword = Bh, T.tSThisType = T.tsThisType = Uh, T.tSTupleType = T.tsTupleType = Yh, T.tSTypeAliasDeclaration = T.tsTypeAliasDeclaration = cd, T.tSTypeAnnotation = T.tsTypeAnnotation = Ad, T.tSTypeAssertion = T.tsTypeAssertion = dd, T.tSTypeLiteral = T.tsTypeLiteral = Jh, T.tSTypeOperator = T.tsTypeOperator = id, T.tSTypeParameter = T.tsTypeParameter = wd, T.tSTypeParameterDeclaration = T.tsTypeParameterDeclaration = Id, T.tSTypeParameterInstantiation = T.tsTypeParameterInstantiation = Cd, T.tSTypePredicate = T.tsTypePredicate = qh, T.tSTypeQuery = T.tsTypeQuery = Wh, T.tSTypeReference = T.tsTypeReference = Kh, T.tSUndefinedKeyword = T.tsUndefinedKeyword = Fh, T.tSUnionType = T.tsUnionType = Qh, T.tSUnknownKeyword = T.tsUnknownKeyword = jh, T.tSVoidKeyword = T.tsVoidKeyword = Rh, T.tupleExpression = fh, T.tupleTypeAnnotation = gp, T.typeAlias = Sp, T.typeAnnotation = Ep, T.typeCastExpression = Pp, T.typeParameter = xp, T.typeParameterDeclaration = vp, T.typeParameterInstantiation = Ap, T.typeofTypeAnnotation = bp, T.unaryExpression = Ee, T.unionTypeAnnotation = Cp, T.updateExpression = Ne, T.v8IntrinsicIdentifier = ih, T.variableDeclaration = _e, T.variableDeclarator = qe, T.variance = Ip, T.voidTypeAnnotation = wp, T.whileStatement = tt, T.withStatement = Pe, T.yieldExpression = bt;
  var e = rS(), t = Pr;
  function r(m = []) {
    return (0, e.default)({
      type: "ArrayExpression",
      elements: m
    });
  }
  function i(m, C, K) {
    return (0, e.default)({
      type: "AssignmentExpression",
      operator: m,
      left: C,
      right: K
    });
  }
  function s(m, C, K) {
    return (0, e.default)({
      type: "BinaryExpression",
      operator: m,
      left: C,
      right: K
    });
  }
  function n(m) {
    return (0, e.default)({
      type: "InterpreterDirective",
      value: m
    });
  }
  function a(m) {
    return (0, e.default)({
      type: "Directive",
      value: m
    });
  }
  function o(m) {
    return (0, e.default)({
      type: "DirectiveLiteral",
      value: m
    });
  }
  function l(m, C = []) {
    return (0, e.default)({
      type: "BlockStatement",
      body: m,
      directives: C
    });
  }
  function u(m = null) {
    return (0, e.default)({
      type: "BreakStatement",
      label: m
    });
  }
  function c(m, C) {
    return (0, e.default)({
      type: "CallExpression",
      callee: m,
      arguments: C
    });
  }
  function f(m = null, C) {
    return (0, e.default)({
      type: "CatchClause",
      param: m,
      body: C
    });
  }
  function p(m, C, K) {
    return (0, e.default)({
      type: "ConditionalExpression",
      test: m,
      consequent: C,
      alternate: K
    });
  }
  function h(m = null) {
    return (0, e.default)({
      type: "ContinueStatement",
      label: m
    });
  }
  function y() {
    return {
      type: "DebuggerStatement"
    };
  }
  function b(m, C) {
    return (0, e.default)({
      type: "DoWhileStatement",
      test: m,
      body: C
    });
  }
  function A() {
    return {
      type: "EmptyStatement"
    };
  }
  function I(m) {
    return (0, e.default)({
      type: "ExpressionStatement",
      expression: m
    });
  }
  function _(m, C = null, K = null) {
    return (0, e.default)({
      type: "File",
      program: m,
      comments: C,
      tokens: K
    });
  }
  function j(m, C, K) {
    return (0, e.default)({
      type: "ForInStatement",
      left: m,
      right: C,
      body: K
    });
  }
  function G(m = null, C = null, K = null, ue) {
    return (0, e.default)({
      type: "ForStatement",
      init: m,
      test: C,
      update: K,
      body: ue
    });
  }
  function ce(m = null, C, K, ue = !1, Ze = !1) {
    return (0, e.default)({
      type: "FunctionDeclaration",
      id: m,
      params: C,
      body: K,
      generator: ue,
      async: Ze
    });
  }
  function te(m = null, C, K, ue = !1, Ze = !1) {
    return (0, e.default)({
      type: "FunctionExpression",
      id: m,
      params: C,
      body: K,
      generator: ue,
      async: Ze
    });
  }
  function ae(m) {
    return (0, e.default)({
      type: "Identifier",
      name: m
    });
  }
  function q(m, C, K = null) {
    return (0, e.default)({
      type: "IfStatement",
      test: m,
      consequent: C,
      alternate: K
    });
  }
  function Y(m, C) {
    return (0, e.default)({
      type: "LabeledStatement",
      label: m,
      body: C
    });
  }
  function re(m) {
    return (0, e.default)({
      type: "StringLiteral",
      value: m
    });
  }
  function W(m) {
    return (0, e.default)({
      type: "NumericLiteral",
      value: m
    });
  }
  function Q() {
    return {
      type: "NullLiteral"
    };
  }
  function U(m) {
    return (0, e.default)({
      type: "BooleanLiteral",
      value: m
    });
  }
  function L(m, C = "") {
    return (0, e.default)({
      type: "RegExpLiteral",
      pattern: m,
      flags: C
    });
  }
  function k(m, C, K) {
    return (0, e.default)({
      type: "LogicalExpression",
      operator: m,
      left: C,
      right: K
    });
  }
  function F(m, C, K = !1, ue = null) {
    return (0, e.default)({
      type: "MemberExpression",
      object: m,
      property: C,
      computed: K,
      optional: ue
    });
  }
  function B(m, C) {
    return (0, e.default)({
      type: "NewExpression",
      callee: m,
      arguments: C
    });
  }
  function N(m, C = [], K = "script", ue = null) {
    return (0, e.default)({
      type: "Program",
      body: m,
      directives: C,
      sourceType: K,
      interpreter: ue
    });
  }
  function D(m) {
    return (0, e.default)({
      type: "ObjectExpression",
      properties: m
    });
  }
  function R(m = "method", C, K, ue, Ze = !1, er = !1, Vs = !1) {
    return (0, e.default)({
      type: "ObjectMethod",
      kind: m,
      key: C,
      params: K,
      body: ue,
      computed: Ze,
      generator: er,
      async: Vs
    });
  }
  function V(m, C, K = !1, ue = !1, Ze = null) {
    return (0, e.default)({
      type: "ObjectProperty",
      key: m,
      value: C,
      computed: K,
      shorthand: ue,
      decorators: Ze
    });
  }
  function $(m) {
    return (0, e.default)({
      type: "RestElement",
      argument: m
    });
  }
  function H(m = null) {
    return (0, e.default)({
      type: "ReturnStatement",
      argument: m
    });
  }
  function se(m) {
    return (0, e.default)({
      type: "SequenceExpression",
      expressions: m
    });
  }
  function oe(m) {
    return (0, e.default)({
      type: "ParenthesizedExpression",
      expression: m
    });
  }
  function Ue(m = null, C) {
    return (0, e.default)({
      type: "SwitchCase",
      test: m,
      consequent: C
    });
  }
  function fe(m, C) {
    return (0, e.default)({
      type: "SwitchStatement",
      discriminant: m,
      cases: C
    });
  }
  function pe() {
    return {
      type: "ThisExpression"
    };
  }
  function Se(m) {
    return (0, e.default)({
      type: "ThrowStatement",
      argument: m
    });
  }
  function Ce(m, C = null, K = null) {
    return (0, e.default)({
      type: "TryStatement",
      block: m,
      handler: C,
      finalizer: K
    });
  }
  function Ee(m, C, K = !0) {
    return (0, e.default)({
      type: "UnaryExpression",
      operator: m,
      argument: C,
      prefix: K
    });
  }
  function Ne(m, C, K = !1) {
    return (0, e.default)({
      type: "UpdateExpression",
      operator: m,
      argument: C,
      prefix: K
    });
  }
  function _e(m, C) {
    return (0, e.default)({
      type: "VariableDeclaration",
      kind: m,
      declarations: C
    });
  }
  function qe(m, C = null) {
    return (0, e.default)({
      type: "VariableDeclarator",
      id: m,
      init: C
    });
  }
  function tt(m, C) {
    return (0, e.default)({
      type: "WhileStatement",
      test: m,
      body: C
    });
  }
  function Pe(m, C) {
    return (0, e.default)({
      type: "WithStatement",
      object: m,
      body: C
    });
  }
  function Be(m, C) {
    return (0, e.default)({
      type: "AssignmentPattern",
      left: m,
      right: C
    });
  }
  function ve(m) {
    return (0, e.default)({
      type: "ArrayPattern",
      elements: m
    });
  }
  function Re(m, C, K = !1) {
    return (0, e.default)({
      type: "ArrowFunctionExpression",
      params: m,
      body: C,
      async: K,
      expression: null
    });
  }
  function lt(m) {
    return (0, e.default)({
      type: "ClassBody",
      body: m
    });
  }
  function He(m = null, C = null, K, ue = null) {
    return (0, e.default)({
      type: "ClassExpression",
      id: m,
      superClass: C,
      body: K,
      decorators: ue
    });
  }
  function J(m = null, C = null, K, ue = null) {
    return (0, e.default)({
      type: "ClassDeclaration",
      id: m,
      superClass: C,
      body: K,
      decorators: ue
    });
  }
  function d(m) {
    return (0, e.default)({
      type: "ExportAllDeclaration",
      source: m
    });
  }
  function x(m) {
    return (0, e.default)({
      type: "ExportDefaultDeclaration",
      declaration: m
    });
  }
  function O(m = null, C = [], K = null) {
    return (0, e.default)({
      type: "ExportNamedDeclaration",
      declaration: m,
      specifiers: C,
      source: K
    });
  }
  function M(m, C) {
    return (0, e.default)({
      type: "ExportSpecifier",
      local: m,
      exported: C
    });
  }
  function Z(m, C, K, ue = !1) {
    return (0, e.default)({
      type: "ForOfStatement",
      left: m,
      right: C,
      body: K,
      await: ue
    });
  }
  function ee(m, C) {
    return (0, e.default)({
      type: "ImportDeclaration",
      specifiers: m,
      source: C
    });
  }
  function ge(m) {
    return (0, e.default)({
      type: "ImportDefaultSpecifier",
      local: m
    });
  }
  function xe(m) {
    return (0, e.default)({
      type: "ImportNamespaceSpecifier",
      local: m
    });
  }
  function ye(m, C) {
    return (0, e.default)({
      type: "ImportSpecifier",
      local: m,
      imported: C
    });
  }
  function X(m, C = null) {
    return (0, e.default)({
      type: "ImportExpression",
      source: m,
      options: C
    });
  }
  function rt(m, C) {
    return (0, e.default)({
      type: "MetaProperty",
      meta: m,
      property: C
    });
  }
  function Ve(m = "method", C, K, ue, Ze = !1, er = !1, Vs = !1, Dd = !1) {
    return (0, e.default)({
      type: "ClassMethod",
      kind: m,
      key: C,
      params: K,
      body: ue,
      computed: Ze,
      static: er,
      generator: Vs,
      async: Dd
    });
  }
  function We(m) {
    return (0, e.default)({
      type: "ObjectPattern",
      properties: m
    });
  }
  function it(m) {
    return (0, e.default)({
      type: "SpreadElement",
      argument: m
    });
  }
  function dt() {
    return {
      type: "Super"
    };
  }
  function v(m, C) {
    return (0, e.default)({
      type: "TaggedTemplateExpression",
      tag: m,
      quasi: C
    });
  }
  function he(m, C = !1) {
    return (0, e.default)({
      type: "TemplateElement",
      value: m,
      tail: C
    });
  }
  function Fe(m, C) {
    return (0, e.default)({
      type: "TemplateLiteral",
      quasis: m,
      expressions: C
    });
  }
  function bt(m = null, C = !1) {
    return (0, e.default)({
      type: "YieldExpression",
      argument: m,
      delegate: C
    });
  }
  function mt(m) {
    return (0, e.default)({
      type: "AwaitExpression",
      argument: m
    });
  }
  function Cr() {
    return {
      type: "Import"
    };
  }
  function Ti(m) {
    return (0, e.default)({
      type: "BigIntLiteral",
      value: m
    });
  }
  function $s(m) {
    return (0, e.default)({
      type: "ExportNamespaceSpecifier",
      exported: m
    });
  }
  function gi(m, C, K = !1, ue) {
    return (0, e.default)({
      type: "OptionalMemberExpression",
      object: m,
      property: C,
      computed: K,
      optional: ue
    });
  }
  function Ir(m, C, K) {
    return (0, e.default)({
      type: "OptionalCallExpression",
      callee: m,
      arguments: C,
      optional: K
    });
  }
  function Ot(m, C = null, K = null, ue = null, Ze = !1, er = !1) {
    return (0, e.default)({
      type: "ClassProperty",
      key: m,
      value: C,
      typeAnnotation: K,
      decorators: ue,
      computed: Ze,
      static: er
    });
  }
  function yr(m, C = null, K = null, ue = null, Ze = !1, er = !1) {
    return (0, e.default)({
      type: "ClassAccessorProperty",
      key: m,
      value: C,
      typeAnnotation: K,
      decorators: ue,
      computed: Ze,
      static: er
    });
  }
  function bi(m, C = null, K = null, ue = !1) {
    return (0, e.default)({
      type: "ClassPrivateProperty",
      key: m,
      value: C,
      decorators: K,
      static: ue
    });
  }
  function Si(m = "method", C, K, ue, Ze = !1) {
    return (0, e.default)({
      type: "ClassPrivateMethod",
      kind: m,
      key: C,
      params: K,
      body: ue,
      static: Ze
    });
  }
  function Ei(m) {
    return (0, e.default)({
      type: "PrivateName",
      id: m
    });
  }
  function wf(m) {
    return (0, e.default)({
      type: "StaticBlock",
      body: m
    });
  }
  function Of() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  function Nf(m) {
    return (0, e.default)({
      type: "ArrayTypeAnnotation",
      elementType: m
    });
  }
  function _f() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  function kf(m) {
    return (0, e.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: m
    });
  }
  function Df() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  function Lf(m, C = null) {
    return (0, e.default)({
      type: "ClassImplements",
      id: m,
      typeParameters: C
    });
  }
  function Mf(m, C = null, K = null, ue) {
    return (0, e.default)({
      type: "DeclareClass",
      id: m,
      typeParameters: C,
      extends: K,
      body: ue
    });
  }
  function Bf(m) {
    return (0, e.default)({
      type: "DeclareFunction",
      id: m
    });
  }
  function Ff(m, C = null, K = null, ue) {
    return (0, e.default)({
      type: "DeclareInterface",
      id: m,
      typeParameters: C,
      extends: K,
      body: ue
    });
  }
  function jf(m, C, K = null) {
    return (0, e.default)({
      type: "DeclareModule",
      id: m,
      body: C,
      kind: K
    });
  }
  function Rf(m) {
    return (0, e.default)({
      type: "DeclareModuleExports",
      typeAnnotation: m
    });
  }
  function Uf(m, C = null, K) {
    return (0, e.default)({
      type: "DeclareTypeAlias",
      id: m,
      typeParameters: C,
      right: K
    });
  }
  function $f(m, C = null, K = null) {
    return (0, e.default)({
      type: "DeclareOpaqueType",
      id: m,
      typeParameters: C,
      supertype: K
    });
  }
  function Vf(m) {
    return (0, e.default)({
      type: "DeclareVariable",
      id: m
    });
  }
  function Kf(m = null, C = null, K = null) {
    return (0, e.default)({
      type: "DeclareExportDeclaration",
      declaration: m,
      specifiers: C,
      source: K
    });
  }
  function qf(m) {
    return (0, e.default)({
      type: "DeclareExportAllDeclaration",
      source: m
    });
  }
  function Wf(m) {
    return (0, e.default)({
      type: "DeclaredPredicate",
      value: m
    });
  }
  function Jf() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  function Xf(m = null, C, K = null, ue) {
    return (0, e.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: m,
      params: C,
      rest: K,
      returnType: ue
    });
  }
  function Yf(m = null, C) {
    return (0, e.default)({
      type: "FunctionTypeParam",
      name: m,
      typeAnnotation: C
    });
  }
  function Hf(m, C = null) {
    return (0, e.default)({
      type: "GenericTypeAnnotation",
      id: m,
      typeParameters: C
    });
  }
  function Gf() {
    return {
      type: "InferredPredicate"
    };
  }
  function zf(m, C = null) {
    return (0, e.default)({
      type: "InterfaceExtends",
      id: m,
      typeParameters: C
    });
  }
  function Qf(m, C = null, K = null, ue) {
    return (0, e.default)({
      type: "InterfaceDeclaration",
      id: m,
      typeParameters: C,
      extends: K,
      body: ue
    });
  }
  function Zf(m = null, C) {
    return (0, e.default)({
      type: "InterfaceTypeAnnotation",
      extends: m,
      body: C
    });
  }
  function ep(m) {
    return (0, e.default)({
      type: "IntersectionTypeAnnotation",
      types: m
    });
  }
  function tp() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  function rp() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  function ip(m) {
    return (0, e.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: m
    });
  }
  function sp(m) {
    return (0, e.default)({
      type: "NumberLiteralTypeAnnotation",
      value: m
    });
  }
  function np() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  function ap(m, C = [], K = [], ue = [], Ze = !1) {
    return (0, e.default)({
      type: "ObjectTypeAnnotation",
      properties: m,
      indexers: C,
      callProperties: K,
      internalSlots: ue,
      exact: Ze
    });
  }
  function op(m, C, K, ue, Ze) {
    return (0, e.default)({
      type: "ObjectTypeInternalSlot",
      id: m,
      value: C,
      optional: K,
      static: ue,
      method: Ze
    });
  }
  function lp(m) {
    return (0, e.default)({
      type: "ObjectTypeCallProperty",
      value: m,
      static: null
    });
  }
  function up(m = null, C, K, ue = null) {
    return (0, e.default)({
      type: "ObjectTypeIndexer",
      id: m,
      key: C,
      value: K,
      variance: ue,
      static: null
    });
  }
  function cp(m, C, K = null) {
    return (0, e.default)({
      type: "ObjectTypeProperty",
      key: m,
      value: C,
      variance: K,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  function fp(m) {
    return (0, e.default)({
      type: "ObjectTypeSpreadProperty",
      argument: m
    });
  }
  function pp(m, C = null, K = null, ue) {
    return (0, e.default)({
      type: "OpaqueType",
      id: m,
      typeParameters: C,
      supertype: K,
      impltype: ue
    });
  }
  function hp(m, C) {
    return (0, e.default)({
      type: "QualifiedTypeIdentifier",
      id: m,
      qualification: C
    });
  }
  function dp(m) {
    return (0, e.default)({
      type: "StringLiteralTypeAnnotation",
      value: m
    });
  }
  function mp() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  function yp() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  function Tp() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  function gp(m) {
    return (0, e.default)({
      type: "TupleTypeAnnotation",
      types: m
    });
  }
  function bp(m) {
    return (0, e.default)({
      type: "TypeofTypeAnnotation",
      argument: m
    });
  }
  function Sp(m, C = null, K) {
    return (0, e.default)({
      type: "TypeAlias",
      id: m,
      typeParameters: C,
      right: K
    });
  }
  function Ep(m) {
    return (0, e.default)({
      type: "TypeAnnotation",
      typeAnnotation: m
    });
  }
  function Pp(m, C) {
    return (0, e.default)({
      type: "TypeCastExpression",
      expression: m,
      typeAnnotation: C
    });
  }
  function xp(m = null, C = null, K = null) {
    return (0, e.default)({
      type: "TypeParameter",
      bound: m,
      default: C,
      variance: K,
      name: null
    });
  }
  function vp(m) {
    return (0, e.default)({
      type: "TypeParameterDeclaration",
      params: m
    });
  }
  function Ap(m) {
    return (0, e.default)({
      type: "TypeParameterInstantiation",
      params: m
    });
  }
  function Cp(m) {
    return (0, e.default)({
      type: "UnionTypeAnnotation",
      types: m
    });
  }
  function Ip(m) {
    return (0, e.default)({
      type: "Variance",
      kind: m
    });
  }
  function wp() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  function Op(m, C) {
    return (0, e.default)({
      type: "EnumDeclaration",
      id: m,
      body: C
    });
  }
  function Np(m) {
    return (0, e.default)({
      type: "EnumBooleanBody",
      members: m,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function _p(m) {
    return (0, e.default)({
      type: "EnumNumberBody",
      members: m,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function kp(m) {
    return (0, e.default)({
      type: "EnumStringBody",
      members: m,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function Dp(m) {
    return (0, e.default)({
      type: "EnumSymbolBody",
      members: m,
      hasUnknownMembers: null
    });
  }
  function Lp(m) {
    return (0, e.default)({
      type: "EnumBooleanMember",
      id: m,
      init: null
    });
  }
  function Mp(m, C) {
    return (0, e.default)({
      type: "EnumNumberMember",
      id: m,
      init: C
    });
  }
  function Bp(m, C) {
    return (0, e.default)({
      type: "EnumStringMember",
      id: m,
      init: C
    });
  }
  function Fp(m) {
    return (0, e.default)({
      type: "EnumDefaultedMember",
      id: m
    });
  }
  function jp(m, C) {
    return (0, e.default)({
      type: "IndexedAccessType",
      objectType: m,
      indexType: C
    });
  }
  function Rp(m, C) {
    return (0, e.default)({
      type: "OptionalIndexedAccessType",
      objectType: m,
      indexType: C,
      optional: null
    });
  }
  function Up(m, C = null) {
    return (0, e.default)({
      type: "JSXAttribute",
      name: m,
      value: C
    });
  }
  function $p(m) {
    return (0, e.default)({
      type: "JSXClosingElement",
      name: m
    });
  }
  function Vp(m, C = null, K, ue = null) {
    return (0, e.default)({
      type: "JSXElement",
      openingElement: m,
      closingElement: C,
      children: K,
      selfClosing: ue
    });
  }
  function Kp() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  function qp(m) {
    return (0, e.default)({
      type: "JSXExpressionContainer",
      expression: m
    });
  }
  function Wp(m) {
    return (0, e.default)({
      type: "JSXSpreadChild",
      expression: m
    });
  }
  function Jp(m) {
    return (0, e.default)({
      type: "JSXIdentifier",
      name: m
    });
  }
  function Xp(m, C) {
    return (0, e.default)({
      type: "JSXMemberExpression",
      object: m,
      property: C
    });
  }
  function Yp(m, C) {
    return (0, e.default)({
      type: "JSXNamespacedName",
      namespace: m,
      name: C
    });
  }
  function Hp(m, C, K = !1) {
    return (0, e.default)({
      type: "JSXOpeningElement",
      name: m,
      attributes: C,
      selfClosing: K
    });
  }
  function Gp(m) {
    return (0, e.default)({
      type: "JSXSpreadAttribute",
      argument: m
    });
  }
  function zp(m) {
    return (0, e.default)({
      type: "JSXText",
      value: m
    });
  }
  function Qp(m, C, K) {
    return (0, e.default)({
      type: "JSXFragment",
      openingFragment: m,
      closingFragment: C,
      children: K
    });
  }
  function Zp() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  function eh() {
    return {
      type: "JSXClosingFragment"
    };
  }
  function th() {
    return {
      type: "Noop"
    };
  }
  function rh(m, C) {
    return (0, e.default)({
      type: "Placeholder",
      expectedNode: m,
      name: C
    });
  }
  function ih(m) {
    return (0, e.default)({
      type: "V8IntrinsicIdentifier",
      name: m
    });
  }
  function sh() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  function nh(m, C) {
    return (0, e.default)({
      type: "BindExpression",
      object: m,
      callee: C
    });
  }
  function ah(m, C) {
    return (0, e.default)({
      type: "ImportAttribute",
      key: m,
      value: C
    });
  }
  function oh(m) {
    return (0, e.default)({
      type: "Decorator",
      expression: m
    });
  }
  function lh(m, C = !1) {
    return (0, e.default)({
      type: "DoExpression",
      body: m,
      async: C
    });
  }
  function uh(m) {
    return (0, e.default)({
      type: "ExportDefaultSpecifier",
      exported: m
    });
  }
  function ch(m) {
    return (0, e.default)({
      type: "RecordExpression",
      properties: m
    });
  }
  function fh(m = []) {
    return (0, e.default)({
      type: "TupleExpression",
      elements: m
    });
  }
  function ph(m) {
    return (0, e.default)({
      type: "DecimalLiteral",
      value: m
    });
  }
  function hh(m) {
    return (0, e.default)({
      type: "ModuleExpression",
      body: m
    });
  }
  function dh() {
    return {
      type: "TopicReference"
    };
  }
  function mh(m) {
    return (0, e.default)({
      type: "PipelineTopicExpression",
      expression: m
    });
  }
  function yh(m) {
    return (0, e.default)({
      type: "PipelineBareFunction",
      callee: m
    });
  }
  function Th() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  function gh(m) {
    return (0, e.default)({
      type: "TSParameterProperty",
      parameter: m
    });
  }
  function bh(m = null, C = null, K, ue = null) {
    return (0, e.default)({
      type: "TSDeclareFunction",
      id: m,
      typeParameters: C,
      params: K,
      returnType: ue
    });
  }
  function Sh(m = null, C, K = null, ue, Ze = null) {
    return (0, e.default)({
      type: "TSDeclareMethod",
      decorators: m,
      key: C,
      typeParameters: K,
      params: ue,
      returnType: Ze
    });
  }
  function Eh(m, C) {
    return (0, e.default)({
      type: "TSQualifiedName",
      left: m,
      right: C
    });
  }
  function Ph(m = null, C, K = null) {
    return (0, e.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: m,
      parameters: C,
      typeAnnotation: K
    });
  }
  function xh(m = null, C, K = null) {
    return (0, e.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: m,
      parameters: C,
      typeAnnotation: K
    });
  }
  function vh(m, C = null) {
    return (0, e.default)({
      type: "TSPropertySignature",
      key: m,
      typeAnnotation: C,
      kind: null
    });
  }
  function Ah(m, C = null, K, ue = null) {
    return (0, e.default)({
      type: "TSMethodSignature",
      key: m,
      typeParameters: C,
      parameters: K,
      typeAnnotation: ue,
      kind: null
    });
  }
  function Ch(m, C = null) {
    return (0, e.default)({
      type: "TSIndexSignature",
      parameters: m,
      typeAnnotation: C
    });
  }
  function Ih() {
    return {
      type: "TSAnyKeyword"
    };
  }
  function wh() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  function Oh() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  function Nh() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  function _h() {
    return {
      type: "TSNeverKeyword"
    };
  }
  function kh() {
    return {
      type: "TSNullKeyword"
    };
  }
  function Dh() {
    return {
      type: "TSNumberKeyword"
    };
  }
  function Lh() {
    return {
      type: "TSObjectKeyword"
    };
  }
  function Mh() {
    return {
      type: "TSStringKeyword"
    };
  }
  function Bh() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  function Fh() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  function jh() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  function Rh() {
    return {
      type: "TSVoidKeyword"
    };
  }
  function Uh() {
    return {
      type: "TSThisType"
    };
  }
  function $h(m = null, C, K = null) {
    return (0, e.default)({
      type: "TSFunctionType",
      typeParameters: m,
      parameters: C,
      typeAnnotation: K
    });
  }
  function Vh(m = null, C, K = null) {
    return (0, e.default)({
      type: "TSConstructorType",
      typeParameters: m,
      parameters: C,
      typeAnnotation: K
    });
  }
  function Kh(m, C = null) {
    return (0, e.default)({
      type: "TSTypeReference",
      typeName: m,
      typeParameters: C
    });
  }
  function qh(m, C = null, K = null) {
    return (0, e.default)({
      type: "TSTypePredicate",
      parameterName: m,
      typeAnnotation: C,
      asserts: K
    });
  }
  function Wh(m, C = null) {
    return (0, e.default)({
      type: "TSTypeQuery",
      exprName: m,
      typeParameters: C
    });
  }
  function Jh(m) {
    return (0, e.default)({
      type: "TSTypeLiteral",
      members: m
    });
  }
  function Xh(m) {
    return (0, e.default)({
      type: "TSArrayType",
      elementType: m
    });
  }
  function Yh(m) {
    return (0, e.default)({
      type: "TSTupleType",
      elementTypes: m
    });
  }
  function Hh(m) {
    return (0, e.default)({
      type: "TSOptionalType",
      typeAnnotation: m
    });
  }
  function Gh(m) {
    return (0, e.default)({
      type: "TSRestType",
      typeAnnotation: m
    });
  }
  function zh(m, C, K = !1) {
    return (0, e.default)({
      type: "TSNamedTupleMember",
      label: m,
      elementType: C,
      optional: K
    });
  }
  function Qh(m) {
    return (0, e.default)({
      type: "TSUnionType",
      types: m
    });
  }
  function Zh(m) {
    return (0, e.default)({
      type: "TSIntersectionType",
      types: m
    });
  }
  function ed(m, C, K, ue) {
    return (0, e.default)({
      type: "TSConditionalType",
      checkType: m,
      extendsType: C,
      trueType: K,
      falseType: ue
    });
  }
  function td(m) {
    return (0, e.default)({
      type: "TSInferType",
      typeParameter: m
    });
  }
  function rd(m) {
    return (0, e.default)({
      type: "TSParenthesizedType",
      typeAnnotation: m
    });
  }
  function id(m) {
    return (0, e.default)({
      type: "TSTypeOperator",
      typeAnnotation: m,
      operator: null
    });
  }
  function sd(m, C) {
    return (0, e.default)({
      type: "TSIndexedAccessType",
      objectType: m,
      indexType: C
    });
  }
  function nd(m, C = null, K = null) {
    return (0, e.default)({
      type: "TSMappedType",
      typeParameter: m,
      typeAnnotation: C,
      nameType: K
    });
  }
  function ad(m) {
    return (0, e.default)({
      type: "TSLiteralType",
      literal: m
    });
  }
  function od(m, C = null) {
    return (0, e.default)({
      type: "TSExpressionWithTypeArguments",
      expression: m,
      typeParameters: C
    });
  }
  function ld(m, C = null, K = null, ue) {
    return (0, e.default)({
      type: "TSInterfaceDeclaration",
      id: m,
      typeParameters: C,
      extends: K,
      body: ue
    });
  }
  function ud(m) {
    return (0, e.default)({
      type: "TSInterfaceBody",
      body: m
    });
  }
  function cd(m, C = null, K) {
    return (0, e.default)({
      type: "TSTypeAliasDeclaration",
      id: m,
      typeParameters: C,
      typeAnnotation: K
    });
  }
  function fd(m, C = null) {
    return (0, e.default)({
      type: "TSInstantiationExpression",
      expression: m,
      typeParameters: C
    });
  }
  function pd(m, C) {
    return (0, e.default)({
      type: "TSAsExpression",
      expression: m,
      typeAnnotation: C
    });
  }
  function hd(m, C) {
    return (0, e.default)({
      type: "TSSatisfiesExpression",
      expression: m,
      typeAnnotation: C
    });
  }
  function dd(m, C) {
    return (0, e.default)({
      type: "TSTypeAssertion",
      typeAnnotation: m,
      expression: C
    });
  }
  function md(m, C) {
    return (0, e.default)({
      type: "TSEnumDeclaration",
      id: m,
      members: C
    });
  }
  function yd(m, C = null) {
    return (0, e.default)({
      type: "TSEnumMember",
      id: m,
      initializer: C
    });
  }
  function Td(m, C) {
    return (0, e.default)({
      type: "TSModuleDeclaration",
      id: m,
      body: C
    });
  }
  function gd(m) {
    return (0, e.default)({
      type: "TSModuleBlock",
      body: m
    });
  }
  function bd(m, C = null, K = null) {
    return (0, e.default)({
      type: "TSImportType",
      argument: m,
      qualifier: C,
      typeParameters: K
    });
  }
  function Sd(m, C) {
    return (0, e.default)({
      type: "TSImportEqualsDeclaration",
      id: m,
      moduleReference: C,
      isExport: null
    });
  }
  function Ed(m) {
    return (0, e.default)({
      type: "TSExternalModuleReference",
      expression: m
    });
  }
  function Pd(m) {
    return (0, e.default)({
      type: "TSNonNullExpression",
      expression: m
    });
  }
  function xd(m) {
    return (0, e.default)({
      type: "TSExportAssignment",
      expression: m
    });
  }
  function vd(m) {
    return (0, e.default)({
      type: "TSNamespaceExportDeclaration",
      id: m
    });
  }
  function Ad(m) {
    return (0, e.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: m
    });
  }
  function Cd(m) {
    return (0, e.default)({
      type: "TSTypeParameterInstantiation",
      params: m
    });
  }
  function Id(m) {
    return (0, e.default)({
      type: "TSTypeParameterDeclaration",
      params: m
    });
  }
  function wd(m = null, C = null, K) {
    return (0, e.default)({
      type: "TSTypeParameter",
      constraint: m,
      default: C,
      name: K
    });
  }
  function Od(m) {
    return (0, t.default)("NumberLiteral", "NumericLiteral", "The node type "), W(m);
  }
  function Nd(m, C = "") {
    return (0, t.default)("RegexLiteral", "RegExpLiteral", "The node type "), L(m, C);
  }
  function _d(m) {
    return (0, t.default)("RestProperty", "RestElement", "The node type "), $(m);
  }
  function kd(m) {
    return (0, t.default)("SpreadProperty", "SpreadElement", "The node type "), it(m);
  }
  return T;
}
var So;
function iS() {
  if (So) return xi;
  So = 1, Object.defineProperty(xi, "__esModule", {
    value: !0
  }), xi.default = r;
  var e = Tt(), t = Ae();
  function r(i, s) {
    const n = i.value.split(/\r\n|\n|\r/);
    let a = 0;
    for (let l = 0; l < n.length; l++)
      /[^ \t]/.exec(n[l]) && (a = l);
    let o = "";
    for (let l = 0; l < n.length; l++) {
      const u = n[l], c = l === 0, f = l === n.length - 1, p = l === a;
      let h = u.replace(/\t/g, " ");
      c || (h = h.replace(/^[ ]+/, "")), f || (h = h.replace(/[ ]+$/, "")), h && (p || (h += " "), o += h);
    }
    o && s.push((0, t.inherits)((0, e.stringLiteral)(o), i));
  }
  return xi;
}
var Eo;
function sS() {
  if (Eo) return Pi;
  Eo = 1, Object.defineProperty(Pi, "__esModule", {
    value: !0
  }), Pi.default = r;
  var e = g, t = iS();
  function r(i) {
    const s = [];
    for (let n = 0; n < i.children.length; n++) {
      let a = i.children[n];
      if ((0, e.isJSXText)(a)) {
        (0, t.default)(a, s);
        continue;
      }
      (0, e.isJSXExpressionContainer)(a) && (a = a.expression), !(0, e.isJSXEmptyExpression)(a) && s.push(a);
    }
    return s;
  }
  return Pi;
}
var Xn = {}, us = {};
Object.defineProperty(us, "__esModule", {
  value: !0
});
us.default = aS;
var nS = It();
function aS(e) {
  return !!(e && nS.VISITOR_KEYS[e.type]);
}
Object.defineProperty(Xn, "__esModule", {
  value: !0
});
Xn.default = lS;
var oS = us;
function lS(e) {
  if (!(0, oS.default)(e)) {
    var t;
    const r = (t = e == null ? void 0 : e.type) != null ? t : JSON.stringify(e);
    throw new TypeError(`Not a valid node of type "${r}"`);
  }
}
var S = {};
Object.defineProperty(S, "__esModule", {
  value: !0
});
S.assertAccessor = vA;
S.assertAnyTypeAnnotation = qE;
S.assertArgumentPlaceholder = bx;
S.assertArrayExpression = cS;
S.assertArrayPattern = lE;
S.assertArrayTypeAnnotation = WE;
S.assertArrowFunctionExpression = uE;
S.assertAssignmentExpression = fS;
S.assertAssignmentPattern = oE;
S.assertAwaitExpression = kE;
S.assertBigIntLiteral = LE;
S.assertBinary = Jv;
S.assertBinaryExpression = pS;
S.assertBindExpression = Sx;
S.assertBlock = Hv;
S.assertBlockParent = Yv;
S.assertBlockStatement = yS;
S.assertBooleanLiteral = FS;
S.assertBooleanLiteralTypeAnnotation = XE;
S.assertBooleanTypeAnnotation = JE;
S.assertBreakStatement = TS;
S.assertCallExpression = gS;
S.assertCatchClause = bS;
S.assertClass = SA;
S.assertClassAccessorProperty = RE;
S.assertClassBody = cE;
S.assertClassDeclaration = pE;
S.assertClassExpression = fE;
S.assertClassImplements = HE;
S.assertClassMethod = vE;
S.assertClassPrivateMethod = $E;
S.assertClassPrivateProperty = UE;
S.assertClassProperty = jE;
S.assertCompletionStatement = Qv;
S.assertConditional = Zv;
S.assertConditionalExpression = SS;
S.assertContinueStatement = ES;
S.assertDebuggerStatement = PS;
S.assertDecimalLiteral = Ix;
S.assertDeclaration = lA;
S.assertDeclareClass = GE;
S.assertDeclareExportAllDeclaration = nP;
S.assertDeclareExportDeclaration = sP;
S.assertDeclareFunction = zE;
S.assertDeclareInterface = QE;
S.assertDeclareModule = ZE;
S.assertDeclareModuleExports = eP;
S.assertDeclareOpaqueType = rP;
S.assertDeclareTypeAlias = tP;
S.assertDeclareVariable = iP;
S.assertDeclaredPredicate = aP;
S.assertDecorator = Px;
S.assertDirective = dS;
S.assertDirectiveLiteral = mS;
S.assertDoExpression = xx;
S.assertDoWhileStatement = xS;
S.assertEmptyStatement = vS;
S.assertEmptyTypeAnnotation = TP;
S.assertEnumBody = _A;
S.assertEnumBooleanBody = WP;
S.assertEnumBooleanMember = HP;
S.assertEnumDeclaration = qP;
S.assertEnumDefaultedMember = QP;
S.assertEnumMember = kA;
S.assertEnumNumberBody = JP;
S.assertEnumNumberMember = GP;
S.assertEnumStringBody = XP;
S.assertEnumStringMember = zP;
S.assertEnumSymbolBody = YP;
S.assertExistsTypeAnnotation = oP;
S.assertExportAllDeclaration = hE;
S.assertExportDeclaration = PA;
S.assertExportDefaultDeclaration = dE;
S.assertExportDefaultSpecifier = vx;
S.assertExportNamedDeclaration = mE;
S.assertExportNamespaceSpecifier = ME;
S.assertExportSpecifier = yE;
S.assertExpression = Wv;
S.assertExpressionStatement = AS;
S.assertExpressionWrapper = rA;
S.assertFile = CS;
S.assertFlow = CA;
S.assertFlowBaseAnnotation = wA;
S.assertFlowDeclaration = OA;
S.assertFlowPredicate = NA;
S.assertFlowType = IA;
S.assertFor = iA;
S.assertForInStatement = IS;
S.assertForOfStatement = TE;
S.assertForStatement = wS;
S.assertForXStatement = sA;
S.assertFunction = nA;
S.assertFunctionDeclaration = OS;
S.assertFunctionExpression = NS;
S.assertFunctionParent = aA;
S.assertFunctionTypeAnnotation = lP;
S.assertFunctionTypeParam = uP;
S.assertGenericTypeAnnotation = cP;
S.assertIdentifier = _S;
S.assertIfStatement = kS;
S.assertImmutable = hA;
S.assertImport = DE;
S.assertImportAttribute = Ex;
S.assertImportDeclaration = gE;
S.assertImportDefaultSpecifier = bE;
S.assertImportExpression = PE;
S.assertImportNamespaceSpecifier = SE;
S.assertImportOrExportDeclaration = EA;
S.assertImportSpecifier = EE;
S.assertIndexedAccessType = ZP;
S.assertInferredPredicate = fP;
S.assertInterfaceDeclaration = hP;
S.assertInterfaceExtends = pP;
S.assertInterfaceTypeAnnotation = dP;
S.assertInterpreterDirective = hS;
S.assertIntersectionTypeAnnotation = mP;
S.assertJSX = DA;
S.assertJSXAttribute = tx;
S.assertJSXClosingElement = rx;
S.assertJSXClosingFragment = mx;
S.assertJSXElement = ix;
S.assertJSXEmptyExpression = sx;
S.assertJSXExpressionContainer = nx;
S.assertJSXFragment = hx;
S.assertJSXIdentifier = ox;
S.assertJSXMemberExpression = lx;
S.assertJSXNamespacedName = ux;
S.assertJSXOpeningElement = cx;
S.assertJSXOpeningFragment = dx;
S.assertJSXSpreadAttribute = fx;
S.assertJSXSpreadChild = ax;
S.assertJSXText = px;
S.assertLVal = cA;
S.assertLabeledStatement = DS;
S.assertLiteral = pA;
S.assertLogicalExpression = RS;
S.assertLoop = eA;
S.assertMemberExpression = US;
S.assertMetaProperty = xE;
S.assertMethod = mA;
S.assertMiscellaneous = LA;
S.assertMixedTypeAnnotation = yP;
S.assertModuleDeclaration = KA;
S.assertModuleExpression = wx;
S.assertModuleSpecifier = xA;
S.assertNewExpression = $S;
S.assertNoop = yx;
S.assertNullLiteral = BS;
S.assertNullLiteralTypeAnnotation = YE;
S.assertNullableTypeAnnotation = gP;
S.assertNumberLiteral = RA;
S.assertNumberLiteralTypeAnnotation = bP;
S.assertNumberTypeAnnotation = SP;
S.assertNumericLiteral = MS;
S.assertObjectExpression = KS;
S.assertObjectMember = yA;
S.assertObjectMethod = qS;
S.assertObjectPattern = AE;
S.assertObjectProperty = WS;
S.assertObjectTypeAnnotation = EP;
S.assertObjectTypeCallProperty = xP;
S.assertObjectTypeIndexer = vP;
S.assertObjectTypeInternalSlot = PP;
S.assertObjectTypeProperty = AP;
S.assertObjectTypeSpreadProperty = CP;
S.assertOpaqueType = IP;
S.assertOptionalCallExpression = FE;
S.assertOptionalIndexedAccessType = ex;
S.assertOptionalMemberExpression = BE;
S.assertParenthesizedExpression = HS;
S.assertPattern = bA;
S.assertPatternLike = uA;
S.assertPipelineBareFunction = _x;
S.assertPipelinePrimaryTopicReference = kx;
S.assertPipelineTopicExpression = Nx;
S.assertPlaceholder = Tx;
S.assertPrivate = AA;
S.assertPrivateName = VE;
S.assertProgram = VS;
S.assertProperty = TA;
S.assertPureish = oA;
S.assertQualifiedTypeIdentifier = wP;
S.assertRecordExpression = Ax;
S.assertRegExpLiteral = jS;
S.assertRegexLiteral = UA;
S.assertRestElement = JS;
S.assertRestProperty = $A;
S.assertReturnStatement = XS;
S.assertScopable = Xv;
S.assertSequenceExpression = YS;
S.assertSpreadElement = CE;
S.assertSpreadProperty = VA;
S.assertStandardized = qv;
S.assertStatement = Gv;
S.assertStaticBlock = KE;
S.assertStringLiteral = LS;
S.assertStringLiteralTypeAnnotation = OP;
S.assertStringTypeAnnotation = NP;
S.assertSuper = IE;
S.assertSwitchCase = GS;
S.assertSwitchStatement = zS;
S.assertSymbolTypeAnnotation = _P;
S.assertTSAnyKeyword = Vx;
S.assertTSArrayType = lv;
S.assertTSAsExpression = Iv;
S.assertTSBaseType = jA;
S.assertTSBigIntKeyword = qx;
S.assertTSBooleanKeyword = Kx;
S.assertTSCallSignatureDeclaration = Fx;
S.assertTSConditionalType = mv;
S.assertTSConstructSignatureDeclaration = jx;
S.assertTSConstructorType = iv;
S.assertTSDeclareFunction = Lx;
S.assertTSDeclareMethod = Mx;
S.assertTSEntityName = fA;
S.assertTSEnumDeclaration = Nv;
S.assertTSEnumMember = _v;
S.assertTSExportAssignment = jv;
S.assertTSExpressionWithTypeArguments = Pv;
S.assertTSExternalModuleReference = Bv;
S.assertTSFunctionType = rv;
S.assertTSImportEqualsDeclaration = Mv;
S.assertTSImportType = Lv;
S.assertTSIndexSignature = $x;
S.assertTSIndexedAccessType = bv;
S.assertTSInferType = yv;
S.assertTSInstantiationExpression = Cv;
S.assertTSInterfaceBody = vv;
S.assertTSInterfaceDeclaration = xv;
S.assertTSIntersectionType = dv;
S.assertTSIntrinsicKeyword = Wx;
S.assertTSLiteralType = Ev;
S.assertTSMappedType = Sv;
S.assertTSMethodSignature = Ux;
S.assertTSModuleBlock = Dv;
S.assertTSModuleDeclaration = kv;
S.assertTSNamedTupleMember = pv;
S.assertTSNamespaceExportDeclaration = Rv;
S.assertTSNeverKeyword = Jx;
S.assertTSNonNullExpression = Fv;
S.assertTSNullKeyword = Xx;
S.assertTSNumberKeyword = Yx;
S.assertTSObjectKeyword = Hx;
S.assertTSOptionalType = cv;
S.assertTSParameterProperty = Dx;
S.assertTSParenthesizedType = Tv;
S.assertTSPropertySignature = Rx;
S.assertTSQualifiedName = Bx;
S.assertTSRestType = fv;
S.assertTSSatisfiesExpression = wv;
S.assertTSStringKeyword = Gx;
S.assertTSSymbolKeyword = zx;
S.assertTSThisType = tv;
S.assertTSTupleType = uv;
S.assertTSType = FA;
S.assertTSTypeAliasDeclaration = Av;
S.assertTSTypeAnnotation = Uv;
S.assertTSTypeAssertion = Ov;
S.assertTSTypeElement = BA;
S.assertTSTypeLiteral = ov;
S.assertTSTypeOperator = gv;
S.assertTSTypeParameter = Kv;
S.assertTSTypeParameterDeclaration = Vv;
S.assertTSTypeParameterInstantiation = $v;
S.assertTSTypePredicate = nv;
S.assertTSTypeQuery = av;
S.assertTSTypeReference = sv;
S.assertTSUndefinedKeyword = Qx;
S.assertTSUnionType = hv;
S.assertTSUnknownKeyword = Zx;
S.assertTSVoidKeyword = ev;
S.assertTaggedTemplateExpression = wE;
S.assertTemplateElement = OE;
S.assertTemplateLiteral = NE;
S.assertTerminatorless = zv;
S.assertThisExpression = QS;
S.assertThisTypeAnnotation = kP;
S.assertThrowStatement = ZS;
S.assertTopicReference = Ox;
S.assertTryStatement = eE;
S.assertTupleExpression = Cx;
S.assertTupleTypeAnnotation = DP;
S.assertTypeAlias = MP;
S.assertTypeAnnotation = BP;
S.assertTypeCastExpression = FP;
S.assertTypeParameter = jP;
S.assertTypeParameterDeclaration = RP;
S.assertTypeParameterInstantiation = UP;
S.assertTypeScript = MA;
S.assertTypeofTypeAnnotation = LP;
S.assertUnaryExpression = tE;
S.assertUnaryLike = gA;
S.assertUnionTypeAnnotation = $P;
S.assertUpdateExpression = rE;
S.assertUserWhitespacable = dA;
S.assertV8IntrinsicIdentifier = gx;
S.assertVariableDeclaration = iE;
S.assertVariableDeclarator = sE;
S.assertVariance = VP;
S.assertVoidTypeAnnotation = KP;
S.assertWhile = tA;
S.assertWhileStatement = nE;
S.assertWithStatement = aE;
S.assertYieldExpression = _E;
var uS = ri(), ai = Pr;
function E(e, t, r) {
  if (!(0, uS.default)(e, t, r))
    throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
}
function cS(e, t) {
  E("ArrayExpression", e, t);
}
function fS(e, t) {
  E("AssignmentExpression", e, t);
}
function pS(e, t) {
  E("BinaryExpression", e, t);
}
function hS(e, t) {
  E("InterpreterDirective", e, t);
}
function dS(e, t) {
  E("Directive", e, t);
}
function mS(e, t) {
  E("DirectiveLiteral", e, t);
}
function yS(e, t) {
  E("BlockStatement", e, t);
}
function TS(e, t) {
  E("BreakStatement", e, t);
}
function gS(e, t) {
  E("CallExpression", e, t);
}
function bS(e, t) {
  E("CatchClause", e, t);
}
function SS(e, t) {
  E("ConditionalExpression", e, t);
}
function ES(e, t) {
  E("ContinueStatement", e, t);
}
function PS(e, t) {
  E("DebuggerStatement", e, t);
}
function xS(e, t) {
  E("DoWhileStatement", e, t);
}
function vS(e, t) {
  E("EmptyStatement", e, t);
}
function AS(e, t) {
  E("ExpressionStatement", e, t);
}
function CS(e, t) {
  E("File", e, t);
}
function IS(e, t) {
  E("ForInStatement", e, t);
}
function wS(e, t) {
  E("ForStatement", e, t);
}
function OS(e, t) {
  E("FunctionDeclaration", e, t);
}
function NS(e, t) {
  E("FunctionExpression", e, t);
}
function _S(e, t) {
  E("Identifier", e, t);
}
function kS(e, t) {
  E("IfStatement", e, t);
}
function DS(e, t) {
  E("LabeledStatement", e, t);
}
function LS(e, t) {
  E("StringLiteral", e, t);
}
function MS(e, t) {
  E("NumericLiteral", e, t);
}
function BS(e, t) {
  E("NullLiteral", e, t);
}
function FS(e, t) {
  E("BooleanLiteral", e, t);
}
function jS(e, t) {
  E("RegExpLiteral", e, t);
}
function RS(e, t) {
  E("LogicalExpression", e, t);
}
function US(e, t) {
  E("MemberExpression", e, t);
}
function $S(e, t) {
  E("NewExpression", e, t);
}
function VS(e, t) {
  E("Program", e, t);
}
function KS(e, t) {
  E("ObjectExpression", e, t);
}
function qS(e, t) {
  E("ObjectMethod", e, t);
}
function WS(e, t) {
  E("ObjectProperty", e, t);
}
function JS(e, t) {
  E("RestElement", e, t);
}
function XS(e, t) {
  E("ReturnStatement", e, t);
}
function YS(e, t) {
  E("SequenceExpression", e, t);
}
function HS(e, t) {
  E("ParenthesizedExpression", e, t);
}
function GS(e, t) {
  E("SwitchCase", e, t);
}
function zS(e, t) {
  E("SwitchStatement", e, t);
}
function QS(e, t) {
  E("ThisExpression", e, t);
}
function ZS(e, t) {
  E("ThrowStatement", e, t);
}
function eE(e, t) {
  E("TryStatement", e, t);
}
function tE(e, t) {
  E("UnaryExpression", e, t);
}
function rE(e, t) {
  E("UpdateExpression", e, t);
}
function iE(e, t) {
  E("VariableDeclaration", e, t);
}
function sE(e, t) {
  E("VariableDeclarator", e, t);
}
function nE(e, t) {
  E("WhileStatement", e, t);
}
function aE(e, t) {
  E("WithStatement", e, t);
}
function oE(e, t) {
  E("AssignmentPattern", e, t);
}
function lE(e, t) {
  E("ArrayPattern", e, t);
}
function uE(e, t) {
  E("ArrowFunctionExpression", e, t);
}
function cE(e, t) {
  E("ClassBody", e, t);
}
function fE(e, t) {
  E("ClassExpression", e, t);
}
function pE(e, t) {
  E("ClassDeclaration", e, t);
}
function hE(e, t) {
  E("ExportAllDeclaration", e, t);
}
function dE(e, t) {
  E("ExportDefaultDeclaration", e, t);
}
function mE(e, t) {
  E("ExportNamedDeclaration", e, t);
}
function yE(e, t) {
  E("ExportSpecifier", e, t);
}
function TE(e, t) {
  E("ForOfStatement", e, t);
}
function gE(e, t) {
  E("ImportDeclaration", e, t);
}
function bE(e, t) {
  E("ImportDefaultSpecifier", e, t);
}
function SE(e, t) {
  E("ImportNamespaceSpecifier", e, t);
}
function EE(e, t) {
  E("ImportSpecifier", e, t);
}
function PE(e, t) {
  E("ImportExpression", e, t);
}
function xE(e, t) {
  E("MetaProperty", e, t);
}
function vE(e, t) {
  E("ClassMethod", e, t);
}
function AE(e, t) {
  E("ObjectPattern", e, t);
}
function CE(e, t) {
  E("SpreadElement", e, t);
}
function IE(e, t) {
  E("Super", e, t);
}
function wE(e, t) {
  E("TaggedTemplateExpression", e, t);
}
function OE(e, t) {
  E("TemplateElement", e, t);
}
function NE(e, t) {
  E("TemplateLiteral", e, t);
}
function _E(e, t) {
  E("YieldExpression", e, t);
}
function kE(e, t) {
  E("AwaitExpression", e, t);
}
function DE(e, t) {
  E("Import", e, t);
}
function LE(e, t) {
  E("BigIntLiteral", e, t);
}
function ME(e, t) {
  E("ExportNamespaceSpecifier", e, t);
}
function BE(e, t) {
  E("OptionalMemberExpression", e, t);
}
function FE(e, t) {
  E("OptionalCallExpression", e, t);
}
function jE(e, t) {
  E("ClassProperty", e, t);
}
function RE(e, t) {
  E("ClassAccessorProperty", e, t);
}
function UE(e, t) {
  E("ClassPrivateProperty", e, t);
}
function $E(e, t) {
  E("ClassPrivateMethod", e, t);
}
function VE(e, t) {
  E("PrivateName", e, t);
}
function KE(e, t) {
  E("StaticBlock", e, t);
}
function qE(e, t) {
  E("AnyTypeAnnotation", e, t);
}
function WE(e, t) {
  E("ArrayTypeAnnotation", e, t);
}
function JE(e, t) {
  E("BooleanTypeAnnotation", e, t);
}
function XE(e, t) {
  E("BooleanLiteralTypeAnnotation", e, t);
}
function YE(e, t) {
  E("NullLiteralTypeAnnotation", e, t);
}
function HE(e, t) {
  E("ClassImplements", e, t);
}
function GE(e, t) {
  E("DeclareClass", e, t);
}
function zE(e, t) {
  E("DeclareFunction", e, t);
}
function QE(e, t) {
  E("DeclareInterface", e, t);
}
function ZE(e, t) {
  E("DeclareModule", e, t);
}
function eP(e, t) {
  E("DeclareModuleExports", e, t);
}
function tP(e, t) {
  E("DeclareTypeAlias", e, t);
}
function rP(e, t) {
  E("DeclareOpaqueType", e, t);
}
function iP(e, t) {
  E("DeclareVariable", e, t);
}
function sP(e, t) {
  E("DeclareExportDeclaration", e, t);
}
function nP(e, t) {
  E("DeclareExportAllDeclaration", e, t);
}
function aP(e, t) {
  E("DeclaredPredicate", e, t);
}
function oP(e, t) {
  E("ExistsTypeAnnotation", e, t);
}
function lP(e, t) {
  E("FunctionTypeAnnotation", e, t);
}
function uP(e, t) {
  E("FunctionTypeParam", e, t);
}
function cP(e, t) {
  E("GenericTypeAnnotation", e, t);
}
function fP(e, t) {
  E("InferredPredicate", e, t);
}
function pP(e, t) {
  E("InterfaceExtends", e, t);
}
function hP(e, t) {
  E("InterfaceDeclaration", e, t);
}
function dP(e, t) {
  E("InterfaceTypeAnnotation", e, t);
}
function mP(e, t) {
  E("IntersectionTypeAnnotation", e, t);
}
function yP(e, t) {
  E("MixedTypeAnnotation", e, t);
}
function TP(e, t) {
  E("EmptyTypeAnnotation", e, t);
}
function gP(e, t) {
  E("NullableTypeAnnotation", e, t);
}
function bP(e, t) {
  E("NumberLiteralTypeAnnotation", e, t);
}
function SP(e, t) {
  E("NumberTypeAnnotation", e, t);
}
function EP(e, t) {
  E("ObjectTypeAnnotation", e, t);
}
function PP(e, t) {
  E("ObjectTypeInternalSlot", e, t);
}
function xP(e, t) {
  E("ObjectTypeCallProperty", e, t);
}
function vP(e, t) {
  E("ObjectTypeIndexer", e, t);
}
function AP(e, t) {
  E("ObjectTypeProperty", e, t);
}
function CP(e, t) {
  E("ObjectTypeSpreadProperty", e, t);
}
function IP(e, t) {
  E("OpaqueType", e, t);
}
function wP(e, t) {
  E("QualifiedTypeIdentifier", e, t);
}
function OP(e, t) {
  E("StringLiteralTypeAnnotation", e, t);
}
function NP(e, t) {
  E("StringTypeAnnotation", e, t);
}
function _P(e, t) {
  E("SymbolTypeAnnotation", e, t);
}
function kP(e, t) {
  E("ThisTypeAnnotation", e, t);
}
function DP(e, t) {
  E("TupleTypeAnnotation", e, t);
}
function LP(e, t) {
  E("TypeofTypeAnnotation", e, t);
}
function MP(e, t) {
  E("TypeAlias", e, t);
}
function BP(e, t) {
  E("TypeAnnotation", e, t);
}
function FP(e, t) {
  E("TypeCastExpression", e, t);
}
function jP(e, t) {
  E("TypeParameter", e, t);
}
function RP(e, t) {
  E("TypeParameterDeclaration", e, t);
}
function UP(e, t) {
  E("TypeParameterInstantiation", e, t);
}
function $P(e, t) {
  E("UnionTypeAnnotation", e, t);
}
function VP(e, t) {
  E("Variance", e, t);
}
function KP(e, t) {
  E("VoidTypeAnnotation", e, t);
}
function qP(e, t) {
  E("EnumDeclaration", e, t);
}
function WP(e, t) {
  E("EnumBooleanBody", e, t);
}
function JP(e, t) {
  E("EnumNumberBody", e, t);
}
function XP(e, t) {
  E("EnumStringBody", e, t);
}
function YP(e, t) {
  E("EnumSymbolBody", e, t);
}
function HP(e, t) {
  E("EnumBooleanMember", e, t);
}
function GP(e, t) {
  E("EnumNumberMember", e, t);
}
function zP(e, t) {
  E("EnumStringMember", e, t);
}
function QP(e, t) {
  E("EnumDefaultedMember", e, t);
}
function ZP(e, t) {
  E("IndexedAccessType", e, t);
}
function ex(e, t) {
  E("OptionalIndexedAccessType", e, t);
}
function tx(e, t) {
  E("JSXAttribute", e, t);
}
function rx(e, t) {
  E("JSXClosingElement", e, t);
}
function ix(e, t) {
  E("JSXElement", e, t);
}
function sx(e, t) {
  E("JSXEmptyExpression", e, t);
}
function nx(e, t) {
  E("JSXExpressionContainer", e, t);
}
function ax(e, t) {
  E("JSXSpreadChild", e, t);
}
function ox(e, t) {
  E("JSXIdentifier", e, t);
}
function lx(e, t) {
  E("JSXMemberExpression", e, t);
}
function ux(e, t) {
  E("JSXNamespacedName", e, t);
}
function cx(e, t) {
  E("JSXOpeningElement", e, t);
}
function fx(e, t) {
  E("JSXSpreadAttribute", e, t);
}
function px(e, t) {
  E("JSXText", e, t);
}
function hx(e, t) {
  E("JSXFragment", e, t);
}
function dx(e, t) {
  E("JSXOpeningFragment", e, t);
}
function mx(e, t) {
  E("JSXClosingFragment", e, t);
}
function yx(e, t) {
  E("Noop", e, t);
}
function Tx(e, t) {
  E("Placeholder", e, t);
}
function gx(e, t) {
  E("V8IntrinsicIdentifier", e, t);
}
function bx(e, t) {
  E("ArgumentPlaceholder", e, t);
}
function Sx(e, t) {
  E("BindExpression", e, t);
}
function Ex(e, t) {
  E("ImportAttribute", e, t);
}
function Px(e, t) {
  E("Decorator", e, t);
}
function xx(e, t) {
  E("DoExpression", e, t);
}
function vx(e, t) {
  E("ExportDefaultSpecifier", e, t);
}
function Ax(e, t) {
  E("RecordExpression", e, t);
}
function Cx(e, t) {
  E("TupleExpression", e, t);
}
function Ix(e, t) {
  E("DecimalLiteral", e, t);
}
function wx(e, t) {
  E("ModuleExpression", e, t);
}
function Ox(e, t) {
  E("TopicReference", e, t);
}
function Nx(e, t) {
  E("PipelineTopicExpression", e, t);
}
function _x(e, t) {
  E("PipelineBareFunction", e, t);
}
function kx(e, t) {
  E("PipelinePrimaryTopicReference", e, t);
}
function Dx(e, t) {
  E("TSParameterProperty", e, t);
}
function Lx(e, t) {
  E("TSDeclareFunction", e, t);
}
function Mx(e, t) {
  E("TSDeclareMethod", e, t);
}
function Bx(e, t) {
  E("TSQualifiedName", e, t);
}
function Fx(e, t) {
  E("TSCallSignatureDeclaration", e, t);
}
function jx(e, t) {
  E("TSConstructSignatureDeclaration", e, t);
}
function Rx(e, t) {
  E("TSPropertySignature", e, t);
}
function Ux(e, t) {
  E("TSMethodSignature", e, t);
}
function $x(e, t) {
  E("TSIndexSignature", e, t);
}
function Vx(e, t) {
  E("TSAnyKeyword", e, t);
}
function Kx(e, t) {
  E("TSBooleanKeyword", e, t);
}
function qx(e, t) {
  E("TSBigIntKeyword", e, t);
}
function Wx(e, t) {
  E("TSIntrinsicKeyword", e, t);
}
function Jx(e, t) {
  E("TSNeverKeyword", e, t);
}
function Xx(e, t) {
  E("TSNullKeyword", e, t);
}
function Yx(e, t) {
  E("TSNumberKeyword", e, t);
}
function Hx(e, t) {
  E("TSObjectKeyword", e, t);
}
function Gx(e, t) {
  E("TSStringKeyword", e, t);
}
function zx(e, t) {
  E("TSSymbolKeyword", e, t);
}
function Qx(e, t) {
  E("TSUndefinedKeyword", e, t);
}
function Zx(e, t) {
  E("TSUnknownKeyword", e, t);
}
function ev(e, t) {
  E("TSVoidKeyword", e, t);
}
function tv(e, t) {
  E("TSThisType", e, t);
}
function rv(e, t) {
  E("TSFunctionType", e, t);
}
function iv(e, t) {
  E("TSConstructorType", e, t);
}
function sv(e, t) {
  E("TSTypeReference", e, t);
}
function nv(e, t) {
  E("TSTypePredicate", e, t);
}
function av(e, t) {
  E("TSTypeQuery", e, t);
}
function ov(e, t) {
  E("TSTypeLiteral", e, t);
}
function lv(e, t) {
  E("TSArrayType", e, t);
}
function uv(e, t) {
  E("TSTupleType", e, t);
}
function cv(e, t) {
  E("TSOptionalType", e, t);
}
function fv(e, t) {
  E("TSRestType", e, t);
}
function pv(e, t) {
  E("TSNamedTupleMember", e, t);
}
function hv(e, t) {
  E("TSUnionType", e, t);
}
function dv(e, t) {
  E("TSIntersectionType", e, t);
}
function mv(e, t) {
  E("TSConditionalType", e, t);
}
function yv(e, t) {
  E("TSInferType", e, t);
}
function Tv(e, t) {
  E("TSParenthesizedType", e, t);
}
function gv(e, t) {
  E("TSTypeOperator", e, t);
}
function bv(e, t) {
  E("TSIndexedAccessType", e, t);
}
function Sv(e, t) {
  E("TSMappedType", e, t);
}
function Ev(e, t) {
  E("TSLiteralType", e, t);
}
function Pv(e, t) {
  E("TSExpressionWithTypeArguments", e, t);
}
function xv(e, t) {
  E("TSInterfaceDeclaration", e, t);
}
function vv(e, t) {
  E("TSInterfaceBody", e, t);
}
function Av(e, t) {
  E("TSTypeAliasDeclaration", e, t);
}
function Cv(e, t) {
  E("TSInstantiationExpression", e, t);
}
function Iv(e, t) {
  E("TSAsExpression", e, t);
}
function wv(e, t) {
  E("TSSatisfiesExpression", e, t);
}
function Ov(e, t) {
  E("TSTypeAssertion", e, t);
}
function Nv(e, t) {
  E("TSEnumDeclaration", e, t);
}
function _v(e, t) {
  E("TSEnumMember", e, t);
}
function kv(e, t) {
  E("TSModuleDeclaration", e, t);
}
function Dv(e, t) {
  E("TSModuleBlock", e, t);
}
function Lv(e, t) {
  E("TSImportType", e, t);
}
function Mv(e, t) {
  E("TSImportEqualsDeclaration", e, t);
}
function Bv(e, t) {
  E("TSExternalModuleReference", e, t);
}
function Fv(e, t) {
  E("TSNonNullExpression", e, t);
}
function jv(e, t) {
  E("TSExportAssignment", e, t);
}
function Rv(e, t) {
  E("TSNamespaceExportDeclaration", e, t);
}
function Uv(e, t) {
  E("TSTypeAnnotation", e, t);
}
function $v(e, t) {
  E("TSTypeParameterInstantiation", e, t);
}
function Vv(e, t) {
  E("TSTypeParameterDeclaration", e, t);
}
function Kv(e, t) {
  E("TSTypeParameter", e, t);
}
function qv(e, t) {
  E("Standardized", e, t);
}
function Wv(e, t) {
  E("Expression", e, t);
}
function Jv(e, t) {
  E("Binary", e, t);
}
function Xv(e, t) {
  E("Scopable", e, t);
}
function Yv(e, t) {
  E("BlockParent", e, t);
}
function Hv(e, t) {
  E("Block", e, t);
}
function Gv(e, t) {
  E("Statement", e, t);
}
function zv(e, t) {
  E("Terminatorless", e, t);
}
function Qv(e, t) {
  E("CompletionStatement", e, t);
}
function Zv(e, t) {
  E("Conditional", e, t);
}
function eA(e, t) {
  E("Loop", e, t);
}
function tA(e, t) {
  E("While", e, t);
}
function rA(e, t) {
  E("ExpressionWrapper", e, t);
}
function iA(e, t) {
  E("For", e, t);
}
function sA(e, t) {
  E("ForXStatement", e, t);
}
function nA(e, t) {
  E("Function", e, t);
}
function aA(e, t) {
  E("FunctionParent", e, t);
}
function oA(e, t) {
  E("Pureish", e, t);
}
function lA(e, t) {
  E("Declaration", e, t);
}
function uA(e, t) {
  E("PatternLike", e, t);
}
function cA(e, t) {
  E("LVal", e, t);
}
function fA(e, t) {
  E("TSEntityName", e, t);
}
function pA(e, t) {
  E("Literal", e, t);
}
function hA(e, t) {
  E("Immutable", e, t);
}
function dA(e, t) {
  E("UserWhitespacable", e, t);
}
function mA(e, t) {
  E("Method", e, t);
}
function yA(e, t) {
  E("ObjectMember", e, t);
}
function TA(e, t) {
  E("Property", e, t);
}
function gA(e, t) {
  E("UnaryLike", e, t);
}
function bA(e, t) {
  E("Pattern", e, t);
}
function SA(e, t) {
  E("Class", e, t);
}
function EA(e, t) {
  E("ImportOrExportDeclaration", e, t);
}
function PA(e, t) {
  E("ExportDeclaration", e, t);
}
function xA(e, t) {
  E("ModuleSpecifier", e, t);
}
function vA(e, t) {
  E("Accessor", e, t);
}
function AA(e, t) {
  E("Private", e, t);
}
function CA(e, t) {
  E("Flow", e, t);
}
function IA(e, t) {
  E("FlowType", e, t);
}
function wA(e, t) {
  E("FlowBaseAnnotation", e, t);
}
function OA(e, t) {
  E("FlowDeclaration", e, t);
}
function NA(e, t) {
  E("FlowPredicate", e, t);
}
function _A(e, t) {
  E("EnumBody", e, t);
}
function kA(e, t) {
  E("EnumMember", e, t);
}
function DA(e, t) {
  E("JSX", e, t);
}
function LA(e, t) {
  E("Miscellaneous", e, t);
}
function MA(e, t) {
  E("TypeScript", e, t);
}
function BA(e, t) {
  E("TSTypeElement", e, t);
}
function FA(e, t) {
  E("TSType", e, t);
}
function jA(e, t) {
  E("TSBaseType", e, t);
}
function RA(e, t) {
  (0, ai.default)("assertNumberLiteral", "assertNumericLiteral"), E("NumberLiteral", e, t);
}
function UA(e, t) {
  (0, ai.default)("assertRegexLiteral", "assertRegExpLiteral"), E("RegexLiteral", e, t);
}
function $A(e, t) {
  (0, ai.default)("assertRestProperty", "assertRestElement"), E("RestProperty", e, t);
}
function VA(e, t) {
  (0, ai.default)("assertSpreadProperty", "assertSpreadElement"), E("SpreadProperty", e, t);
}
function KA(e, t) {
  (0, ai.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), E("ModuleDeclaration", e, t);
}
var Nr = {}, Po;
function qA() {
  if (Po) return Nr;
  Po = 1, Object.defineProperty(Nr, "__esModule", {
    value: !0
  }), Nr.default = void 0;
  var e = Tt();
  Nr.default = t;
  function t(r) {
    switch (r) {
      case "string":
        return (0, e.stringTypeAnnotation)();
      case "number":
        return (0, e.numberTypeAnnotation)();
      case "undefined":
        return (0, e.voidTypeAnnotation)();
      case "boolean":
        return (0, e.booleanTypeAnnotation)();
      case "function":
        return (0, e.genericTypeAnnotation)((0, e.identifier)("Function"));
      case "object":
        return (0, e.genericTypeAnnotation)((0, e.identifier)("Object"));
      case "symbol":
        return (0, e.genericTypeAnnotation)((0, e.identifier)("Symbol"));
      case "bigint":
        return (0, e.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + r);
  }
  return Nr;
}
var Oi = {}, cs = {};
Object.defineProperty(cs, "__esModule", {
  value: !0
});
cs.default = $u;
var Vr = g;
function Uu(e) {
  return (0, Vr.isIdentifier)(e) ? e.name : `${e.id.name}.${Uu(e.qualification)}`;
}
function $u(e) {
  const t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set(), n = [];
  for (let a = 0; a < t.length; a++) {
    const o = t[a];
    if (o && !n.includes(o)) {
      if ((0, Vr.isAnyTypeAnnotation)(o))
        return [o];
      if ((0, Vr.isFlowBaseAnnotation)(o)) {
        i.set(o.type, o);
        continue;
      }
      if ((0, Vr.isUnionTypeAnnotation)(o)) {
        s.has(o.types) || (t.push(...o.types), s.add(o.types));
        continue;
      }
      if ((0, Vr.isGenericTypeAnnotation)(o)) {
        const l = Uu(o.id);
        if (r.has(l)) {
          let u = r.get(l);
          u.typeParameters ? o.typeParameters && (u.typeParameters.params.push(...o.typeParameters.params), u.typeParameters.params = $u(u.typeParameters.params)) : u = o.typeParameters;
        } else
          r.set(l, o);
        continue;
      }
      n.push(o);
    }
  }
  for (const [, a] of i)
    n.push(a);
  for (const [, a] of r)
    n.push(a);
  return n;
}
var xo;
function WA() {
  if (xo) return Oi;
  xo = 1, Object.defineProperty(Oi, "__esModule", {
    value: !0
  }), Oi.default = r;
  var e = Tt(), t = cs;
  function r(i) {
    const s = (0, t.default)(i);
    return s.length === 1 ? s[0] : (0, e.unionTypeAnnotation)(s);
  }
  return Oi;
}
var Ni = {}, Yn = {};
Object.defineProperty(Yn, "__esModule", {
  value: !0
});
Yn.default = Ku;
var Kr = g;
function Vu(e) {
  return (0, Kr.isIdentifier)(e) ? e.name : `${e.right.name}.${Vu(e.left)}`;
}
function Ku(e) {
  const t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set(), n = [];
  for (let a = 0; a < t.length; a++) {
    const o = t[a];
    if (o && !n.includes(o)) {
      if ((0, Kr.isTSAnyKeyword)(o))
        return [o];
      if ((0, Kr.isTSBaseType)(o)) {
        i.set(o.type, o);
        continue;
      }
      if ((0, Kr.isTSUnionType)(o)) {
        s.has(o.types) || (t.push(...o.types), s.add(o.types));
        continue;
      }
      if ((0, Kr.isTSTypeReference)(o) && o.typeParameters) {
        const l = Vu(o.typeName);
        if (r.has(l)) {
          let u = r.get(l);
          u.typeParameters ? o.typeParameters && (u.typeParameters.params.push(...o.typeParameters.params), u.typeParameters.params = Ku(u.typeParameters.params)) : u = o.typeParameters;
        } else
          r.set(l, o);
        continue;
      }
      n.push(o);
    }
  }
  for (const [, a] of i)
    n.push(a);
  for (const [, a] of r)
    n.push(a);
  return n;
}
var vo;
function JA() {
  if (vo) return Ni;
  vo = 1, Object.defineProperty(Ni, "__esModule", {
    value: !0
  }), Ni.default = i;
  var e = Tt(), t = Yn, r = g;
  function i(s) {
    const n = s.map((o) => (0, r.isTSTypeAnnotation)(o) ? o.typeAnnotation : o), a = (0, t.default)(n);
    return a.length === 1 ? a[0] : (0, e.tsUnionType)(a);
  }
  return Ni;
}
var Xs = {}, Ao;
function XA() {
  return Ao || (Ao = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "AnyTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.anyTypeAnnotation;
      }
    }), Object.defineProperty(e, "ArgumentPlaceholder", {
      enumerable: !0,
      get: function() {
        return t.argumentPlaceholder;
      }
    }), Object.defineProperty(e, "ArrayExpression", {
      enumerable: !0,
      get: function() {
        return t.arrayExpression;
      }
    }), Object.defineProperty(e, "ArrayPattern", {
      enumerable: !0,
      get: function() {
        return t.arrayPattern;
      }
    }), Object.defineProperty(e, "ArrayTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.arrayTypeAnnotation;
      }
    }), Object.defineProperty(e, "ArrowFunctionExpression", {
      enumerable: !0,
      get: function() {
        return t.arrowFunctionExpression;
      }
    }), Object.defineProperty(e, "AssignmentExpression", {
      enumerable: !0,
      get: function() {
        return t.assignmentExpression;
      }
    }), Object.defineProperty(e, "AssignmentPattern", {
      enumerable: !0,
      get: function() {
        return t.assignmentPattern;
      }
    }), Object.defineProperty(e, "AwaitExpression", {
      enumerable: !0,
      get: function() {
        return t.awaitExpression;
      }
    }), Object.defineProperty(e, "BigIntLiteral", {
      enumerable: !0,
      get: function() {
        return t.bigIntLiteral;
      }
    }), Object.defineProperty(e, "BinaryExpression", {
      enumerable: !0,
      get: function() {
        return t.binaryExpression;
      }
    }), Object.defineProperty(e, "BindExpression", {
      enumerable: !0,
      get: function() {
        return t.bindExpression;
      }
    }), Object.defineProperty(e, "BlockStatement", {
      enumerable: !0,
      get: function() {
        return t.blockStatement;
      }
    }), Object.defineProperty(e, "BooleanLiteral", {
      enumerable: !0,
      get: function() {
        return t.booleanLiteral;
      }
    }), Object.defineProperty(e, "BooleanLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.booleanLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "BooleanTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.booleanTypeAnnotation;
      }
    }), Object.defineProperty(e, "BreakStatement", {
      enumerable: !0,
      get: function() {
        return t.breakStatement;
      }
    }), Object.defineProperty(e, "CallExpression", {
      enumerable: !0,
      get: function() {
        return t.callExpression;
      }
    }), Object.defineProperty(e, "CatchClause", {
      enumerable: !0,
      get: function() {
        return t.catchClause;
      }
    }), Object.defineProperty(e, "ClassAccessorProperty", {
      enumerable: !0,
      get: function() {
        return t.classAccessorProperty;
      }
    }), Object.defineProperty(e, "ClassBody", {
      enumerable: !0,
      get: function() {
        return t.classBody;
      }
    }), Object.defineProperty(e, "ClassDeclaration", {
      enumerable: !0,
      get: function() {
        return t.classDeclaration;
      }
    }), Object.defineProperty(e, "ClassExpression", {
      enumerable: !0,
      get: function() {
        return t.classExpression;
      }
    }), Object.defineProperty(e, "ClassImplements", {
      enumerable: !0,
      get: function() {
        return t.classImplements;
      }
    }), Object.defineProperty(e, "ClassMethod", {
      enumerable: !0,
      get: function() {
        return t.classMethod;
      }
    }), Object.defineProperty(e, "ClassPrivateMethod", {
      enumerable: !0,
      get: function() {
        return t.classPrivateMethod;
      }
    }), Object.defineProperty(e, "ClassPrivateProperty", {
      enumerable: !0,
      get: function() {
        return t.classPrivateProperty;
      }
    }), Object.defineProperty(e, "ClassProperty", {
      enumerable: !0,
      get: function() {
        return t.classProperty;
      }
    }), Object.defineProperty(e, "ConditionalExpression", {
      enumerable: !0,
      get: function() {
        return t.conditionalExpression;
      }
    }), Object.defineProperty(e, "ContinueStatement", {
      enumerable: !0,
      get: function() {
        return t.continueStatement;
      }
    }), Object.defineProperty(e, "DebuggerStatement", {
      enumerable: !0,
      get: function() {
        return t.debuggerStatement;
      }
    }), Object.defineProperty(e, "DecimalLiteral", {
      enumerable: !0,
      get: function() {
        return t.decimalLiteral;
      }
    }), Object.defineProperty(e, "DeclareClass", {
      enumerable: !0,
      get: function() {
        return t.declareClass;
      }
    }), Object.defineProperty(e, "DeclareExportAllDeclaration", {
      enumerable: !0,
      get: function() {
        return t.declareExportAllDeclaration;
      }
    }), Object.defineProperty(e, "DeclareExportDeclaration", {
      enumerable: !0,
      get: function() {
        return t.declareExportDeclaration;
      }
    }), Object.defineProperty(e, "DeclareFunction", {
      enumerable: !0,
      get: function() {
        return t.declareFunction;
      }
    }), Object.defineProperty(e, "DeclareInterface", {
      enumerable: !0,
      get: function() {
        return t.declareInterface;
      }
    }), Object.defineProperty(e, "DeclareModule", {
      enumerable: !0,
      get: function() {
        return t.declareModule;
      }
    }), Object.defineProperty(e, "DeclareModuleExports", {
      enumerable: !0,
      get: function() {
        return t.declareModuleExports;
      }
    }), Object.defineProperty(e, "DeclareOpaqueType", {
      enumerable: !0,
      get: function() {
        return t.declareOpaqueType;
      }
    }), Object.defineProperty(e, "DeclareTypeAlias", {
      enumerable: !0,
      get: function() {
        return t.declareTypeAlias;
      }
    }), Object.defineProperty(e, "DeclareVariable", {
      enumerable: !0,
      get: function() {
        return t.declareVariable;
      }
    }), Object.defineProperty(e, "DeclaredPredicate", {
      enumerable: !0,
      get: function() {
        return t.declaredPredicate;
      }
    }), Object.defineProperty(e, "Decorator", {
      enumerable: !0,
      get: function() {
        return t.decorator;
      }
    }), Object.defineProperty(e, "Directive", {
      enumerable: !0,
      get: function() {
        return t.directive;
      }
    }), Object.defineProperty(e, "DirectiveLiteral", {
      enumerable: !0,
      get: function() {
        return t.directiveLiteral;
      }
    }), Object.defineProperty(e, "DoExpression", {
      enumerable: !0,
      get: function() {
        return t.doExpression;
      }
    }), Object.defineProperty(e, "DoWhileStatement", {
      enumerable: !0,
      get: function() {
        return t.doWhileStatement;
      }
    }), Object.defineProperty(e, "EmptyStatement", {
      enumerable: !0,
      get: function() {
        return t.emptyStatement;
      }
    }), Object.defineProperty(e, "EmptyTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.emptyTypeAnnotation;
      }
    }), Object.defineProperty(e, "EnumBooleanBody", {
      enumerable: !0,
      get: function() {
        return t.enumBooleanBody;
      }
    }), Object.defineProperty(e, "EnumBooleanMember", {
      enumerable: !0,
      get: function() {
        return t.enumBooleanMember;
      }
    }), Object.defineProperty(e, "EnumDeclaration", {
      enumerable: !0,
      get: function() {
        return t.enumDeclaration;
      }
    }), Object.defineProperty(e, "EnumDefaultedMember", {
      enumerable: !0,
      get: function() {
        return t.enumDefaultedMember;
      }
    }), Object.defineProperty(e, "EnumNumberBody", {
      enumerable: !0,
      get: function() {
        return t.enumNumberBody;
      }
    }), Object.defineProperty(e, "EnumNumberMember", {
      enumerable: !0,
      get: function() {
        return t.enumNumberMember;
      }
    }), Object.defineProperty(e, "EnumStringBody", {
      enumerable: !0,
      get: function() {
        return t.enumStringBody;
      }
    }), Object.defineProperty(e, "EnumStringMember", {
      enumerable: !0,
      get: function() {
        return t.enumStringMember;
      }
    }), Object.defineProperty(e, "EnumSymbolBody", {
      enumerable: !0,
      get: function() {
        return t.enumSymbolBody;
      }
    }), Object.defineProperty(e, "ExistsTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.existsTypeAnnotation;
      }
    }), Object.defineProperty(e, "ExportAllDeclaration", {
      enumerable: !0,
      get: function() {
        return t.exportAllDeclaration;
      }
    }), Object.defineProperty(e, "ExportDefaultDeclaration", {
      enumerable: !0,
      get: function() {
        return t.exportDefaultDeclaration;
      }
    }), Object.defineProperty(e, "ExportDefaultSpecifier", {
      enumerable: !0,
      get: function() {
        return t.exportDefaultSpecifier;
      }
    }), Object.defineProperty(e, "ExportNamedDeclaration", {
      enumerable: !0,
      get: function() {
        return t.exportNamedDeclaration;
      }
    }), Object.defineProperty(e, "ExportNamespaceSpecifier", {
      enumerable: !0,
      get: function() {
        return t.exportNamespaceSpecifier;
      }
    }), Object.defineProperty(e, "ExportSpecifier", {
      enumerable: !0,
      get: function() {
        return t.exportSpecifier;
      }
    }), Object.defineProperty(e, "ExpressionStatement", {
      enumerable: !0,
      get: function() {
        return t.expressionStatement;
      }
    }), Object.defineProperty(e, "File", {
      enumerable: !0,
      get: function() {
        return t.file;
      }
    }), Object.defineProperty(e, "ForInStatement", {
      enumerable: !0,
      get: function() {
        return t.forInStatement;
      }
    }), Object.defineProperty(e, "ForOfStatement", {
      enumerable: !0,
      get: function() {
        return t.forOfStatement;
      }
    }), Object.defineProperty(e, "ForStatement", {
      enumerable: !0,
      get: function() {
        return t.forStatement;
      }
    }), Object.defineProperty(e, "FunctionDeclaration", {
      enumerable: !0,
      get: function() {
        return t.functionDeclaration;
      }
    }), Object.defineProperty(e, "FunctionExpression", {
      enumerable: !0,
      get: function() {
        return t.functionExpression;
      }
    }), Object.defineProperty(e, "FunctionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.functionTypeAnnotation;
      }
    }), Object.defineProperty(e, "FunctionTypeParam", {
      enumerable: !0,
      get: function() {
        return t.functionTypeParam;
      }
    }), Object.defineProperty(e, "GenericTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.genericTypeAnnotation;
      }
    }), Object.defineProperty(e, "Identifier", {
      enumerable: !0,
      get: function() {
        return t.identifier;
      }
    }), Object.defineProperty(e, "IfStatement", {
      enumerable: !0,
      get: function() {
        return t.ifStatement;
      }
    }), Object.defineProperty(e, "Import", {
      enumerable: !0,
      get: function() {
        return t.import;
      }
    }), Object.defineProperty(e, "ImportAttribute", {
      enumerable: !0,
      get: function() {
        return t.importAttribute;
      }
    }), Object.defineProperty(e, "ImportDeclaration", {
      enumerable: !0,
      get: function() {
        return t.importDeclaration;
      }
    }), Object.defineProperty(e, "ImportDefaultSpecifier", {
      enumerable: !0,
      get: function() {
        return t.importDefaultSpecifier;
      }
    }), Object.defineProperty(e, "ImportExpression", {
      enumerable: !0,
      get: function() {
        return t.importExpression;
      }
    }), Object.defineProperty(e, "ImportNamespaceSpecifier", {
      enumerable: !0,
      get: function() {
        return t.importNamespaceSpecifier;
      }
    }), Object.defineProperty(e, "ImportSpecifier", {
      enumerable: !0,
      get: function() {
        return t.importSpecifier;
      }
    }), Object.defineProperty(e, "IndexedAccessType", {
      enumerable: !0,
      get: function() {
        return t.indexedAccessType;
      }
    }), Object.defineProperty(e, "InferredPredicate", {
      enumerable: !0,
      get: function() {
        return t.inferredPredicate;
      }
    }), Object.defineProperty(e, "InterfaceDeclaration", {
      enumerable: !0,
      get: function() {
        return t.interfaceDeclaration;
      }
    }), Object.defineProperty(e, "InterfaceExtends", {
      enumerable: !0,
      get: function() {
        return t.interfaceExtends;
      }
    }), Object.defineProperty(e, "InterfaceTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.interfaceTypeAnnotation;
      }
    }), Object.defineProperty(e, "InterpreterDirective", {
      enumerable: !0,
      get: function() {
        return t.interpreterDirective;
      }
    }), Object.defineProperty(e, "IntersectionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.intersectionTypeAnnotation;
      }
    }), Object.defineProperty(e, "JSXAttribute", {
      enumerable: !0,
      get: function() {
        return t.jsxAttribute;
      }
    }), Object.defineProperty(e, "JSXClosingElement", {
      enumerable: !0,
      get: function() {
        return t.jsxClosingElement;
      }
    }), Object.defineProperty(e, "JSXClosingFragment", {
      enumerable: !0,
      get: function() {
        return t.jsxClosingFragment;
      }
    }), Object.defineProperty(e, "JSXElement", {
      enumerable: !0,
      get: function() {
        return t.jsxElement;
      }
    }), Object.defineProperty(e, "JSXEmptyExpression", {
      enumerable: !0,
      get: function() {
        return t.jsxEmptyExpression;
      }
    }), Object.defineProperty(e, "JSXExpressionContainer", {
      enumerable: !0,
      get: function() {
        return t.jsxExpressionContainer;
      }
    }), Object.defineProperty(e, "JSXFragment", {
      enumerable: !0,
      get: function() {
        return t.jsxFragment;
      }
    }), Object.defineProperty(e, "JSXIdentifier", {
      enumerable: !0,
      get: function() {
        return t.jsxIdentifier;
      }
    }), Object.defineProperty(e, "JSXMemberExpression", {
      enumerable: !0,
      get: function() {
        return t.jsxMemberExpression;
      }
    }), Object.defineProperty(e, "JSXNamespacedName", {
      enumerable: !0,
      get: function() {
        return t.jsxNamespacedName;
      }
    }), Object.defineProperty(e, "JSXOpeningElement", {
      enumerable: !0,
      get: function() {
        return t.jsxOpeningElement;
      }
    }), Object.defineProperty(e, "JSXOpeningFragment", {
      enumerable: !0,
      get: function() {
        return t.jsxOpeningFragment;
      }
    }), Object.defineProperty(e, "JSXSpreadAttribute", {
      enumerable: !0,
      get: function() {
        return t.jsxSpreadAttribute;
      }
    }), Object.defineProperty(e, "JSXSpreadChild", {
      enumerable: !0,
      get: function() {
        return t.jsxSpreadChild;
      }
    }), Object.defineProperty(e, "JSXText", {
      enumerable: !0,
      get: function() {
        return t.jsxText;
      }
    }), Object.defineProperty(e, "LabeledStatement", {
      enumerable: !0,
      get: function() {
        return t.labeledStatement;
      }
    }), Object.defineProperty(e, "LogicalExpression", {
      enumerable: !0,
      get: function() {
        return t.logicalExpression;
      }
    }), Object.defineProperty(e, "MemberExpression", {
      enumerable: !0,
      get: function() {
        return t.memberExpression;
      }
    }), Object.defineProperty(e, "MetaProperty", {
      enumerable: !0,
      get: function() {
        return t.metaProperty;
      }
    }), Object.defineProperty(e, "MixedTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.mixedTypeAnnotation;
      }
    }), Object.defineProperty(e, "ModuleExpression", {
      enumerable: !0,
      get: function() {
        return t.moduleExpression;
      }
    }), Object.defineProperty(e, "NewExpression", {
      enumerable: !0,
      get: function() {
        return t.newExpression;
      }
    }), Object.defineProperty(e, "Noop", {
      enumerable: !0,
      get: function() {
        return t.noop;
      }
    }), Object.defineProperty(e, "NullLiteral", {
      enumerable: !0,
      get: function() {
        return t.nullLiteral;
      }
    }), Object.defineProperty(e, "NullLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.nullLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "NullableTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.nullableTypeAnnotation;
      }
    }), Object.defineProperty(e, "NumberLiteral", {
      enumerable: !0,
      get: function() {
        return t.numberLiteral;
      }
    }), Object.defineProperty(e, "NumberLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.numberLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "NumberTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.numberTypeAnnotation;
      }
    }), Object.defineProperty(e, "NumericLiteral", {
      enumerable: !0,
      get: function() {
        return t.numericLiteral;
      }
    }), Object.defineProperty(e, "ObjectExpression", {
      enumerable: !0,
      get: function() {
        return t.objectExpression;
      }
    }), Object.defineProperty(e, "ObjectMethod", {
      enumerable: !0,
      get: function() {
        return t.objectMethod;
      }
    }), Object.defineProperty(e, "ObjectPattern", {
      enumerable: !0,
      get: function() {
        return t.objectPattern;
      }
    }), Object.defineProperty(e, "ObjectProperty", {
      enumerable: !0,
      get: function() {
        return t.objectProperty;
      }
    }), Object.defineProperty(e, "ObjectTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.objectTypeAnnotation;
      }
    }), Object.defineProperty(e, "ObjectTypeCallProperty", {
      enumerable: !0,
      get: function() {
        return t.objectTypeCallProperty;
      }
    }), Object.defineProperty(e, "ObjectTypeIndexer", {
      enumerable: !0,
      get: function() {
        return t.objectTypeIndexer;
      }
    }), Object.defineProperty(e, "ObjectTypeInternalSlot", {
      enumerable: !0,
      get: function() {
        return t.objectTypeInternalSlot;
      }
    }), Object.defineProperty(e, "ObjectTypeProperty", {
      enumerable: !0,
      get: function() {
        return t.objectTypeProperty;
      }
    }), Object.defineProperty(e, "ObjectTypeSpreadProperty", {
      enumerable: !0,
      get: function() {
        return t.objectTypeSpreadProperty;
      }
    }), Object.defineProperty(e, "OpaqueType", {
      enumerable: !0,
      get: function() {
        return t.opaqueType;
      }
    }), Object.defineProperty(e, "OptionalCallExpression", {
      enumerable: !0,
      get: function() {
        return t.optionalCallExpression;
      }
    }), Object.defineProperty(e, "OptionalIndexedAccessType", {
      enumerable: !0,
      get: function() {
        return t.optionalIndexedAccessType;
      }
    }), Object.defineProperty(e, "OptionalMemberExpression", {
      enumerable: !0,
      get: function() {
        return t.optionalMemberExpression;
      }
    }), Object.defineProperty(e, "ParenthesizedExpression", {
      enumerable: !0,
      get: function() {
        return t.parenthesizedExpression;
      }
    }), Object.defineProperty(e, "PipelineBareFunction", {
      enumerable: !0,
      get: function() {
        return t.pipelineBareFunction;
      }
    }), Object.defineProperty(e, "PipelinePrimaryTopicReference", {
      enumerable: !0,
      get: function() {
        return t.pipelinePrimaryTopicReference;
      }
    }), Object.defineProperty(e, "PipelineTopicExpression", {
      enumerable: !0,
      get: function() {
        return t.pipelineTopicExpression;
      }
    }), Object.defineProperty(e, "Placeholder", {
      enumerable: !0,
      get: function() {
        return t.placeholder;
      }
    }), Object.defineProperty(e, "PrivateName", {
      enumerable: !0,
      get: function() {
        return t.privateName;
      }
    }), Object.defineProperty(e, "Program", {
      enumerable: !0,
      get: function() {
        return t.program;
      }
    }), Object.defineProperty(e, "QualifiedTypeIdentifier", {
      enumerable: !0,
      get: function() {
        return t.qualifiedTypeIdentifier;
      }
    }), Object.defineProperty(e, "RecordExpression", {
      enumerable: !0,
      get: function() {
        return t.recordExpression;
      }
    }), Object.defineProperty(e, "RegExpLiteral", {
      enumerable: !0,
      get: function() {
        return t.regExpLiteral;
      }
    }), Object.defineProperty(e, "RegexLiteral", {
      enumerable: !0,
      get: function() {
        return t.regexLiteral;
      }
    }), Object.defineProperty(e, "RestElement", {
      enumerable: !0,
      get: function() {
        return t.restElement;
      }
    }), Object.defineProperty(e, "RestProperty", {
      enumerable: !0,
      get: function() {
        return t.restProperty;
      }
    }), Object.defineProperty(e, "ReturnStatement", {
      enumerable: !0,
      get: function() {
        return t.returnStatement;
      }
    }), Object.defineProperty(e, "SequenceExpression", {
      enumerable: !0,
      get: function() {
        return t.sequenceExpression;
      }
    }), Object.defineProperty(e, "SpreadElement", {
      enumerable: !0,
      get: function() {
        return t.spreadElement;
      }
    }), Object.defineProperty(e, "SpreadProperty", {
      enumerable: !0,
      get: function() {
        return t.spreadProperty;
      }
    }), Object.defineProperty(e, "StaticBlock", {
      enumerable: !0,
      get: function() {
        return t.staticBlock;
      }
    }), Object.defineProperty(e, "StringLiteral", {
      enumerable: !0,
      get: function() {
        return t.stringLiteral;
      }
    }), Object.defineProperty(e, "StringLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.stringLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "StringTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.stringTypeAnnotation;
      }
    }), Object.defineProperty(e, "Super", {
      enumerable: !0,
      get: function() {
        return t.super;
      }
    }), Object.defineProperty(e, "SwitchCase", {
      enumerable: !0,
      get: function() {
        return t.switchCase;
      }
    }), Object.defineProperty(e, "SwitchStatement", {
      enumerable: !0,
      get: function() {
        return t.switchStatement;
      }
    }), Object.defineProperty(e, "SymbolTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.symbolTypeAnnotation;
      }
    }), Object.defineProperty(e, "TSAnyKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsAnyKeyword;
      }
    }), Object.defineProperty(e, "TSArrayType", {
      enumerable: !0,
      get: function() {
        return t.tsArrayType;
      }
    }), Object.defineProperty(e, "TSAsExpression", {
      enumerable: !0,
      get: function() {
        return t.tsAsExpression;
      }
    }), Object.defineProperty(e, "TSBigIntKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsBigIntKeyword;
      }
    }), Object.defineProperty(e, "TSBooleanKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsBooleanKeyword;
      }
    }), Object.defineProperty(e, "TSCallSignatureDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsCallSignatureDeclaration;
      }
    }), Object.defineProperty(e, "TSConditionalType", {
      enumerable: !0,
      get: function() {
        return t.tsConditionalType;
      }
    }), Object.defineProperty(e, "TSConstructSignatureDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsConstructSignatureDeclaration;
      }
    }), Object.defineProperty(e, "TSConstructorType", {
      enumerable: !0,
      get: function() {
        return t.tsConstructorType;
      }
    }), Object.defineProperty(e, "TSDeclareFunction", {
      enumerable: !0,
      get: function() {
        return t.tsDeclareFunction;
      }
    }), Object.defineProperty(e, "TSDeclareMethod", {
      enumerable: !0,
      get: function() {
        return t.tsDeclareMethod;
      }
    }), Object.defineProperty(e, "TSEnumDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsEnumDeclaration;
      }
    }), Object.defineProperty(e, "TSEnumMember", {
      enumerable: !0,
      get: function() {
        return t.tsEnumMember;
      }
    }), Object.defineProperty(e, "TSExportAssignment", {
      enumerable: !0,
      get: function() {
        return t.tsExportAssignment;
      }
    }), Object.defineProperty(e, "TSExpressionWithTypeArguments", {
      enumerable: !0,
      get: function() {
        return t.tsExpressionWithTypeArguments;
      }
    }), Object.defineProperty(e, "TSExternalModuleReference", {
      enumerable: !0,
      get: function() {
        return t.tsExternalModuleReference;
      }
    }), Object.defineProperty(e, "TSFunctionType", {
      enumerable: !0,
      get: function() {
        return t.tsFunctionType;
      }
    }), Object.defineProperty(e, "TSImportEqualsDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsImportEqualsDeclaration;
      }
    }), Object.defineProperty(e, "TSImportType", {
      enumerable: !0,
      get: function() {
        return t.tsImportType;
      }
    }), Object.defineProperty(e, "TSIndexSignature", {
      enumerable: !0,
      get: function() {
        return t.tsIndexSignature;
      }
    }), Object.defineProperty(e, "TSIndexedAccessType", {
      enumerable: !0,
      get: function() {
        return t.tsIndexedAccessType;
      }
    }), Object.defineProperty(e, "TSInferType", {
      enumerable: !0,
      get: function() {
        return t.tsInferType;
      }
    }), Object.defineProperty(e, "TSInstantiationExpression", {
      enumerable: !0,
      get: function() {
        return t.tsInstantiationExpression;
      }
    }), Object.defineProperty(e, "TSInterfaceBody", {
      enumerable: !0,
      get: function() {
        return t.tsInterfaceBody;
      }
    }), Object.defineProperty(e, "TSInterfaceDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsInterfaceDeclaration;
      }
    }), Object.defineProperty(e, "TSIntersectionType", {
      enumerable: !0,
      get: function() {
        return t.tsIntersectionType;
      }
    }), Object.defineProperty(e, "TSIntrinsicKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsIntrinsicKeyword;
      }
    }), Object.defineProperty(e, "TSLiteralType", {
      enumerable: !0,
      get: function() {
        return t.tsLiteralType;
      }
    }), Object.defineProperty(e, "TSMappedType", {
      enumerable: !0,
      get: function() {
        return t.tsMappedType;
      }
    }), Object.defineProperty(e, "TSMethodSignature", {
      enumerable: !0,
      get: function() {
        return t.tsMethodSignature;
      }
    }), Object.defineProperty(e, "TSModuleBlock", {
      enumerable: !0,
      get: function() {
        return t.tsModuleBlock;
      }
    }), Object.defineProperty(e, "TSModuleDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsModuleDeclaration;
      }
    }), Object.defineProperty(e, "TSNamedTupleMember", {
      enumerable: !0,
      get: function() {
        return t.tsNamedTupleMember;
      }
    }), Object.defineProperty(e, "TSNamespaceExportDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsNamespaceExportDeclaration;
      }
    }), Object.defineProperty(e, "TSNeverKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsNeverKeyword;
      }
    }), Object.defineProperty(e, "TSNonNullExpression", {
      enumerable: !0,
      get: function() {
        return t.tsNonNullExpression;
      }
    }), Object.defineProperty(e, "TSNullKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsNullKeyword;
      }
    }), Object.defineProperty(e, "TSNumberKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsNumberKeyword;
      }
    }), Object.defineProperty(e, "TSObjectKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsObjectKeyword;
      }
    }), Object.defineProperty(e, "TSOptionalType", {
      enumerable: !0,
      get: function() {
        return t.tsOptionalType;
      }
    }), Object.defineProperty(e, "TSParameterProperty", {
      enumerable: !0,
      get: function() {
        return t.tsParameterProperty;
      }
    }), Object.defineProperty(e, "TSParenthesizedType", {
      enumerable: !0,
      get: function() {
        return t.tsParenthesizedType;
      }
    }), Object.defineProperty(e, "TSPropertySignature", {
      enumerable: !0,
      get: function() {
        return t.tsPropertySignature;
      }
    }), Object.defineProperty(e, "TSQualifiedName", {
      enumerable: !0,
      get: function() {
        return t.tsQualifiedName;
      }
    }), Object.defineProperty(e, "TSRestType", {
      enumerable: !0,
      get: function() {
        return t.tsRestType;
      }
    }), Object.defineProperty(e, "TSSatisfiesExpression", {
      enumerable: !0,
      get: function() {
        return t.tsSatisfiesExpression;
      }
    }), Object.defineProperty(e, "TSStringKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsStringKeyword;
      }
    }), Object.defineProperty(e, "TSSymbolKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsSymbolKeyword;
      }
    }), Object.defineProperty(e, "TSThisType", {
      enumerable: !0,
      get: function() {
        return t.tsThisType;
      }
    }), Object.defineProperty(e, "TSTupleType", {
      enumerable: !0,
      get: function() {
        return t.tsTupleType;
      }
    }), Object.defineProperty(e, "TSTypeAliasDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsTypeAliasDeclaration;
      }
    }), Object.defineProperty(e, "TSTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.tsTypeAnnotation;
      }
    }), Object.defineProperty(e, "TSTypeAssertion", {
      enumerable: !0,
      get: function() {
        return t.tsTypeAssertion;
      }
    }), Object.defineProperty(e, "TSTypeLiteral", {
      enumerable: !0,
      get: function() {
        return t.tsTypeLiteral;
      }
    }), Object.defineProperty(e, "TSTypeOperator", {
      enumerable: !0,
      get: function() {
        return t.tsTypeOperator;
      }
    }), Object.defineProperty(e, "TSTypeParameter", {
      enumerable: !0,
      get: function() {
        return t.tsTypeParameter;
      }
    }), Object.defineProperty(e, "TSTypeParameterDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsTypeParameterDeclaration;
      }
    }), Object.defineProperty(e, "TSTypeParameterInstantiation", {
      enumerable: !0,
      get: function() {
        return t.tsTypeParameterInstantiation;
      }
    }), Object.defineProperty(e, "TSTypePredicate", {
      enumerable: !0,
      get: function() {
        return t.tsTypePredicate;
      }
    }), Object.defineProperty(e, "TSTypeQuery", {
      enumerable: !0,
      get: function() {
        return t.tsTypeQuery;
      }
    }), Object.defineProperty(e, "TSTypeReference", {
      enumerable: !0,
      get: function() {
        return t.tsTypeReference;
      }
    }), Object.defineProperty(e, "TSUndefinedKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsUndefinedKeyword;
      }
    }), Object.defineProperty(e, "TSUnionType", {
      enumerable: !0,
      get: function() {
        return t.tsUnionType;
      }
    }), Object.defineProperty(e, "TSUnknownKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsUnknownKeyword;
      }
    }), Object.defineProperty(e, "TSVoidKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsVoidKeyword;
      }
    }), Object.defineProperty(e, "TaggedTemplateExpression", {
      enumerable: !0,
      get: function() {
        return t.taggedTemplateExpression;
      }
    }), Object.defineProperty(e, "TemplateElement", {
      enumerable: !0,
      get: function() {
        return t.templateElement;
      }
    }), Object.defineProperty(e, "TemplateLiteral", {
      enumerable: !0,
      get: function() {
        return t.templateLiteral;
      }
    }), Object.defineProperty(e, "ThisExpression", {
      enumerable: !0,
      get: function() {
        return t.thisExpression;
      }
    }), Object.defineProperty(e, "ThisTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.thisTypeAnnotation;
      }
    }), Object.defineProperty(e, "ThrowStatement", {
      enumerable: !0,
      get: function() {
        return t.throwStatement;
      }
    }), Object.defineProperty(e, "TopicReference", {
      enumerable: !0,
      get: function() {
        return t.topicReference;
      }
    }), Object.defineProperty(e, "TryStatement", {
      enumerable: !0,
      get: function() {
        return t.tryStatement;
      }
    }), Object.defineProperty(e, "TupleExpression", {
      enumerable: !0,
      get: function() {
        return t.tupleExpression;
      }
    }), Object.defineProperty(e, "TupleTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.tupleTypeAnnotation;
      }
    }), Object.defineProperty(e, "TypeAlias", {
      enumerable: !0,
      get: function() {
        return t.typeAlias;
      }
    }), Object.defineProperty(e, "TypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.typeAnnotation;
      }
    }), Object.defineProperty(e, "TypeCastExpression", {
      enumerable: !0,
      get: function() {
        return t.typeCastExpression;
      }
    }), Object.defineProperty(e, "TypeParameter", {
      enumerable: !0,
      get: function() {
        return t.typeParameter;
      }
    }), Object.defineProperty(e, "TypeParameterDeclaration", {
      enumerable: !0,
      get: function() {
        return t.typeParameterDeclaration;
      }
    }), Object.defineProperty(e, "TypeParameterInstantiation", {
      enumerable: !0,
      get: function() {
        return t.typeParameterInstantiation;
      }
    }), Object.defineProperty(e, "TypeofTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.typeofTypeAnnotation;
      }
    }), Object.defineProperty(e, "UnaryExpression", {
      enumerable: !0,
      get: function() {
        return t.unaryExpression;
      }
    }), Object.defineProperty(e, "UnionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.unionTypeAnnotation;
      }
    }), Object.defineProperty(e, "UpdateExpression", {
      enumerable: !0,
      get: function() {
        return t.updateExpression;
      }
    }), Object.defineProperty(e, "V8IntrinsicIdentifier", {
      enumerable: !0,
      get: function() {
        return t.v8IntrinsicIdentifier;
      }
    }), Object.defineProperty(e, "VariableDeclaration", {
      enumerable: !0,
      get: function() {
        return t.variableDeclaration;
      }
    }), Object.defineProperty(e, "VariableDeclarator", {
      enumerable: !0,
      get: function() {
        return t.variableDeclarator;
      }
    }), Object.defineProperty(e, "Variance", {
      enumerable: !0,
      get: function() {
        return t.variance;
      }
    }), Object.defineProperty(e, "VoidTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.voidTypeAnnotation;
      }
    }), Object.defineProperty(e, "WhileStatement", {
      enumerable: !0,
      get: function() {
        return t.whileStatement;
      }
    }), Object.defineProperty(e, "WithStatement", {
      enumerable: !0,
      get: function() {
        return t.withStatement;
      }
    }), Object.defineProperty(e, "YieldExpression", {
      enumerable: !0,
      get: function() {
        return t.yieldExpression;
      }
    });
    var t = Tt();
  }(Xs)), Xs;
}
var _i = {}, Co;
function qu() {
  if (Co) return _i;
  Co = 1, Object.defineProperty(_i, "__esModule", {
    value: !0
  }), _i.buildUndefinedNode = t;
  var e = Tt();
  function t() {
    return (0, e.unaryExpression)("void", (0, e.numericLiteral)(0), !0);
  }
  return _i;
}
var Kt = {};
Object.defineProperty(Kt, "__esModule", {
  value: !0
});
Kt.default = YA;
var Io = It(), wo = g;
const {
  hasOwn: _t
} = {
  hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
};
function Oo(e, t, r, i) {
  return e && typeof e.type == "string" ? Wu(e, t, r, i) : e;
}
function No(e, t, r, i) {
  return Array.isArray(e) ? e.map((s) => Oo(s, t, r, i)) : Oo(e, t, r, i);
}
function YA(e, t = !0, r = !1) {
  return Wu(e, t, r, /* @__PURE__ */ new Map());
}
function Wu(e, t = !0, r = !1, i) {
  if (!e) return e;
  const {
    type: s
  } = e, n = {
    type: e.type
  };
  if ((0, wo.isIdentifier)(e))
    n.name = e.name, _t(e, "optional") && typeof e.optional == "boolean" && (n.optional = e.optional), _t(e, "typeAnnotation") && (n.typeAnnotation = t ? No(e.typeAnnotation, !0, r, i) : e.typeAnnotation);
  else if (_t(Io.NODE_FIELDS, s))
    for (const a of Object.keys(Io.NODE_FIELDS[s]))
      _t(e, a) && (t ? n[a] = (0, wo.isFile)(e) && a === "comments" ? ki(e.comments, t, r, i) : No(e[a], !0, r, i) : n[a] = e[a]);
  else
    throw new Error(`Unknown node type: "${s}"`);
  return _t(e, "loc") && (r ? n.loc = null : n.loc = e.loc), _t(e, "leadingComments") && (n.leadingComments = ki(e.leadingComments, t, r, i)), _t(e, "innerComments") && (n.innerComments = ki(e.innerComments, t, r, i)), _t(e, "trailingComments") && (n.trailingComments = ki(e.trailingComments, t, r, i)), _t(e, "extra") && (n.extra = Object.assign({}, e.extra)), n;
}
function ki(e, t, r, i) {
  return !e || !t ? e : e.map((s) => {
    const n = i.get(s);
    if (n) return n;
    const {
      type: a,
      value: o,
      loc: l
    } = s, u = {
      type: a,
      value: o,
      loc: l
    };
    return r && (u.loc = null), i.set(s, u), u;
  });
}
var Hn = {};
Object.defineProperty(Hn, "__esModule", {
  value: !0
});
Hn.default = GA;
var HA = Kt;
function GA(e) {
  return (0, HA.default)(e, !1);
}
var Gn = {};
Object.defineProperty(Gn, "__esModule", {
  value: !0
});
Gn.default = QA;
var zA = Kt;
function QA(e) {
  return (0, zA.default)(e);
}
var zn = {};
Object.defineProperty(zn, "__esModule", {
  value: !0
});
zn.default = e1;
var ZA = Kt;
function e1(e) {
  return (0, ZA.default)(e, !0, !0);
}
var Qn = {};
Object.defineProperty(Qn, "__esModule", {
  value: !0
});
Qn.default = r1;
var t1 = Kt;
function r1(e) {
  return (0, t1.default)(e, !1, !0);
}
var Zn = {}, fs = {};
Object.defineProperty(fs, "__esModule", {
  value: !0
});
fs.default = i1;
function i1(e, t, r) {
  if (!r || !e) return e;
  const i = `${t}Comments`;
  return e[i] ? t === "leading" ? e[i] = r.concat(e[i]) : e[i].push(...r) : e[i] = r, e;
}
Object.defineProperty(Zn, "__esModule", {
  value: !0
});
Zn.default = n1;
var s1 = fs;
function n1(e, t, r, i) {
  return (0, s1.default)(e, t, [{
    type: i ? "CommentLine" : "CommentBlock",
    value: r
  }]);
}
var ps = {}, oi = {};
Object.defineProperty(oi, "__esModule", {
  value: !0
});
oi.default = a1;
function a1(e, t, r) {
  t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
}
Object.defineProperty(ps, "__esModule", {
  value: !0
});
ps.default = l1;
var o1 = oi;
function l1(e, t) {
  (0, o1.default)("innerComments", e, t);
}
var hs = {};
Object.defineProperty(hs, "__esModule", {
  value: !0
});
hs.default = c1;
var u1 = oi;
function c1(e, t) {
  (0, u1.default)("leadingComments", e, t);
}
var ds = {}, ms = {};
Object.defineProperty(ms, "__esModule", {
  value: !0
});
ms.default = p1;
var f1 = oi;
function p1(e, t) {
  (0, f1.default)("trailingComments", e, t);
}
Object.defineProperty(ds, "__esModule", {
  value: !0
});
ds.default = y1;
var h1 = ms, d1 = hs, m1 = ps;
function y1(e, t) {
  return (0, h1.default)(e, t), (0, d1.default)(e, t), (0, m1.default)(e, t), e;
}
var ea = {};
Object.defineProperty(ea, "__esModule", {
  value: !0
});
ea.default = g1;
var T1 = be;
function g1(e) {
  return T1.COMMENT_KEYS.forEach((t) => {
    e[t] = null;
  }), e;
}
var z = {};
Object.defineProperty(z, "__esModule", {
  value: !0
});
z.WHILE_TYPES = z.USERWHITESPACABLE_TYPES = z.UNARYLIKE_TYPES = z.TYPESCRIPT_TYPES = z.TSTYPE_TYPES = z.TSTYPEELEMENT_TYPES = z.TSENTITYNAME_TYPES = z.TSBASETYPE_TYPES = z.TERMINATORLESS_TYPES = z.STATEMENT_TYPES = z.STANDARDIZED_TYPES = z.SCOPABLE_TYPES = z.PUREISH_TYPES = z.PROPERTY_TYPES = z.PRIVATE_TYPES = z.PATTERN_TYPES = z.PATTERNLIKE_TYPES = z.OBJECTMEMBER_TYPES = z.MODULESPECIFIER_TYPES = z.MODULEDECLARATION_TYPES = z.MISCELLANEOUS_TYPES = z.METHOD_TYPES = z.LVAL_TYPES = z.LOOP_TYPES = z.LITERAL_TYPES = z.JSX_TYPES = z.IMPORTOREXPORTDECLARATION_TYPES = z.IMMUTABLE_TYPES = z.FUNCTION_TYPES = z.FUNCTIONPARENT_TYPES = z.FOR_TYPES = z.FORXSTATEMENT_TYPES = z.FLOW_TYPES = z.FLOWTYPE_TYPES = z.FLOWPREDICATE_TYPES = z.FLOWDECLARATION_TYPES = z.FLOWBASEANNOTATION_TYPES = z.EXPRESSION_TYPES = z.EXPRESSIONWRAPPER_TYPES = z.EXPORTDECLARATION_TYPES = z.ENUMMEMBER_TYPES = z.ENUMBODY_TYPES = z.DECLARATION_TYPES = z.CONDITIONAL_TYPES = z.COMPLETIONSTATEMENT_TYPES = z.CLASS_TYPES = z.BLOCK_TYPES = z.BLOCKPARENT_TYPES = z.BINARY_TYPES = z.ACCESSOR_TYPES = void 0;
var Te = It();
z.STANDARDIZED_TYPES = Te.FLIPPED_ALIAS_KEYS.Standardized;
z.EXPRESSION_TYPES = Te.FLIPPED_ALIAS_KEYS.Expression;
z.BINARY_TYPES = Te.FLIPPED_ALIAS_KEYS.Binary;
z.SCOPABLE_TYPES = Te.FLIPPED_ALIAS_KEYS.Scopable;
z.BLOCKPARENT_TYPES = Te.FLIPPED_ALIAS_KEYS.BlockParent;
z.BLOCK_TYPES = Te.FLIPPED_ALIAS_KEYS.Block;
z.STATEMENT_TYPES = Te.FLIPPED_ALIAS_KEYS.Statement;
z.TERMINATORLESS_TYPES = Te.FLIPPED_ALIAS_KEYS.Terminatorless;
z.COMPLETIONSTATEMENT_TYPES = Te.FLIPPED_ALIAS_KEYS.CompletionStatement;
z.CONDITIONAL_TYPES = Te.FLIPPED_ALIAS_KEYS.Conditional;
z.LOOP_TYPES = Te.FLIPPED_ALIAS_KEYS.Loop;
z.WHILE_TYPES = Te.FLIPPED_ALIAS_KEYS.While;
z.EXPRESSIONWRAPPER_TYPES = Te.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
z.FOR_TYPES = Te.FLIPPED_ALIAS_KEYS.For;
z.FORXSTATEMENT_TYPES = Te.FLIPPED_ALIAS_KEYS.ForXStatement;
z.FUNCTION_TYPES = Te.FLIPPED_ALIAS_KEYS.Function;
z.FUNCTIONPARENT_TYPES = Te.FLIPPED_ALIAS_KEYS.FunctionParent;
z.PUREISH_TYPES = Te.FLIPPED_ALIAS_KEYS.Pureish;
z.DECLARATION_TYPES = Te.FLIPPED_ALIAS_KEYS.Declaration;
z.PATTERNLIKE_TYPES = Te.FLIPPED_ALIAS_KEYS.PatternLike;
z.LVAL_TYPES = Te.FLIPPED_ALIAS_KEYS.LVal;
z.TSENTITYNAME_TYPES = Te.FLIPPED_ALIAS_KEYS.TSEntityName;
z.LITERAL_TYPES = Te.FLIPPED_ALIAS_KEYS.Literal;
z.IMMUTABLE_TYPES = Te.FLIPPED_ALIAS_KEYS.Immutable;
z.USERWHITESPACABLE_TYPES = Te.FLIPPED_ALIAS_KEYS.UserWhitespacable;
z.METHOD_TYPES = Te.FLIPPED_ALIAS_KEYS.Method;
z.OBJECTMEMBER_TYPES = Te.FLIPPED_ALIAS_KEYS.ObjectMember;
z.PROPERTY_TYPES = Te.FLIPPED_ALIAS_KEYS.Property;
z.UNARYLIKE_TYPES = Te.FLIPPED_ALIAS_KEYS.UnaryLike;
z.PATTERN_TYPES = Te.FLIPPED_ALIAS_KEYS.Pattern;
z.CLASS_TYPES = Te.FLIPPED_ALIAS_KEYS.Class;
const b1 = z.IMPORTOREXPORTDECLARATION_TYPES = Te.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
z.EXPORTDECLARATION_TYPES = Te.FLIPPED_ALIAS_KEYS.ExportDeclaration;
z.MODULESPECIFIER_TYPES = Te.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
z.ACCESSOR_TYPES = Te.FLIPPED_ALIAS_KEYS.Accessor;
z.PRIVATE_TYPES = Te.FLIPPED_ALIAS_KEYS.Private;
z.FLOW_TYPES = Te.FLIPPED_ALIAS_KEYS.Flow;
z.FLOWTYPE_TYPES = Te.FLIPPED_ALIAS_KEYS.FlowType;
z.FLOWBASEANNOTATION_TYPES = Te.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
z.FLOWDECLARATION_TYPES = Te.FLIPPED_ALIAS_KEYS.FlowDeclaration;
z.FLOWPREDICATE_TYPES = Te.FLIPPED_ALIAS_KEYS.FlowPredicate;
z.ENUMBODY_TYPES = Te.FLIPPED_ALIAS_KEYS.EnumBody;
z.ENUMMEMBER_TYPES = Te.FLIPPED_ALIAS_KEYS.EnumMember;
z.JSX_TYPES = Te.FLIPPED_ALIAS_KEYS.JSX;
z.MISCELLANEOUS_TYPES = Te.FLIPPED_ALIAS_KEYS.Miscellaneous;
z.TYPESCRIPT_TYPES = Te.FLIPPED_ALIAS_KEYS.TypeScript;
z.TSTYPEELEMENT_TYPES = Te.FLIPPED_ALIAS_KEYS.TSTypeElement;
z.TSTYPE_TYPES = Te.FLIPPED_ALIAS_KEYS.TSType;
z.TSBASETYPE_TYPES = Te.FLIPPED_ALIAS_KEYS.TSBaseType;
z.MODULEDECLARATION_TYPES = b1;
var Di = {}, Li = {}, _o;
function Ju() {
  if (_o) return Li;
  _o = 1, Object.defineProperty(Li, "__esModule", {
    value: !0
  }), Li.default = r;
  var e = g, t = Tt();
  function r(i, s) {
    if ((0, e.isBlockStatement)(i))
      return i;
    let n = [];
    return (0, e.isEmptyStatement)(i) ? n = [] : ((0, e.isStatement)(i) || ((0, e.isFunction)(s) ? i = (0, t.returnStatement)(i) : i = (0, t.expressionStatement)(i)), n = [i]), (0, t.blockStatement)(n);
  }
  return Li;
}
var ko;
function S1() {
  if (ko) return Di;
  ko = 1, Object.defineProperty(Di, "__esModule", {
    value: !0
  }), Di.default = t;
  var e = Ju();
  function t(r, i = "body") {
    const s = (0, e.default)(r[i], r);
    return r[i] = s, s;
  }
  return Di;
}
var ta = {}, ys = {};
Object.defineProperty(ys, "__esModule", {
  value: !0
});
ys.default = x1;
var E1 = cr, P1 = ii;
function x1(e) {
  e = e + "";
  let t = "";
  for (const r of e)
    t += (0, P1.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
  return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(r, i) {
    return i ? i.toUpperCase() : "";
  }), (0, E1.default)(t) || (t = `_${t}`), t || "_";
}
Object.defineProperty(ta, "__esModule", {
  value: !0
});
ta.default = A1;
var v1 = ys;
function A1(e) {
  return e = (0, v1.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
}
var Mi = {}, Do;
function C1() {
  if (Do) return Mi;
  Do = 1, Object.defineProperty(Mi, "__esModule", {
    value: !0
  }), Mi.default = r;
  var e = g, t = Tt();
  function r(i, s = i.key || i.property) {
    return !i.computed && (0, e.isIdentifier)(s) && (s = (0, t.stringLiteral)(s.name)), s;
  }
  return Mi;
}
var Ts = {};
Object.defineProperty(Ts, "__esModule", {
  value: !0
});
Ts.default = void 0;
var _r = g;
Ts.default = I1;
function I1(e) {
  if ((0, _r.isExpressionStatement)(e) && (e = e.expression), (0, _r.isExpression)(e))
    return e;
  if ((0, _r.isClass)(e) ? e.type = "ClassExpression" : (0, _r.isFunction)(e) && (e.type = "FunctionExpression"), !(0, _r.isExpression)(e))
    throw new Error(`cannot turn ${e.type} to an expression`);
  return e;
}
var ra = {}, gs = {}, bs = {};
Object.defineProperty(bs, "__esModule", {
  value: !0
});
bs.default = Pn;
var w1 = It();
function Pn(e, t, r) {
  if (!e) return;
  const i = w1.VISITOR_KEYS[e.type];
  if (i) {
    r = r || {}, t(e, r);
    for (const s of i) {
      const n = e[s];
      if (Array.isArray(n))
        for (const a of n)
          Pn(a, t, r);
      else
        Pn(n, t, r);
    }
  }
}
var Ss = {};
Object.defineProperty(Ss, "__esModule", {
  value: !0
});
Ss.default = _1;
var O1 = be;
const Xu = ["tokens", "start", "end", "loc", "raw", "rawValue"], N1 = [...O1.COMMENT_KEYS, "comments", ...Xu];
function _1(e, t = {}) {
  const r = t.preserveComments ? Xu : N1;
  for (const s of r)
    e[s] != null && (e[s] = void 0);
  for (const s of Object.keys(e))
    s[0] === "_" && e[s] != null && (e[s] = void 0);
  const i = Object.getOwnPropertySymbols(e);
  for (const s of i)
    e[s] = null;
}
Object.defineProperty(gs, "__esModule", {
  value: !0
});
gs.default = L1;
var k1 = bs, D1 = Ss;
function L1(e, t) {
  return (0, k1.default)(e, D1.default, t), e;
}
Object.defineProperty(ra, "__esModule", {
  value: !0
});
ra.default = nr;
var Lo = g, M1 = Kt, B1 = gs;
function nr(e, t = e.key) {
  let r;
  return e.kind === "method" ? nr.increment() + "" : ((0, Lo.isIdentifier)(t) ? r = t.name : (0, Lo.isStringLiteral)(t) ? r = JSON.stringify(t.value) : r = JSON.stringify((0, B1.default)((0, M1.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
}
nr.uid = 0;
nr.increment = function() {
  return nr.uid >= Number.MAX_SAFE_INTEGER ? nr.uid = 0 : nr.uid++;
};
var kr = {}, Mo;
function F1() {
  if (Mo) return kr;
  Mo = 1, Object.defineProperty(kr, "__esModule", {
    value: !0
  }), kr.default = void 0;
  var e = g, t = Tt();
  kr.default = r;
  function r(i, s) {
    if ((0, e.isStatement)(i))
      return i;
    let n = !1, a;
    if ((0, e.isClass)(i))
      n = !0, a = "ClassDeclaration";
    else if ((0, e.isFunction)(i))
      n = !0, a = "FunctionDeclaration";
    else if ((0, e.isAssignmentExpression)(i))
      return (0, t.expressionStatement)(i);
    if (n && !i.id && (a = !1), !a) {
      if (s)
        return !1;
      throw new Error(`cannot turn ${i.type} to a statement`);
    }
    return i.type = a, i;
  }
  return kr;
}
var Dr = {}, Bo;
function j1() {
  if (Bo) return Dr;
  Bo = 1, Object.defineProperty(Dr, "__esModule", {
    value: !0
  }), Dr.default = void 0;
  var e = cr, t = Tt();
  Dr.default = n;
  const r = Function.call.bind(Object.prototype.toString);
  function i(a) {
    return r(a) === "[object RegExp]";
  }
  function s(a) {
    if (typeof a != "object" || a === null || Object.prototype.toString.call(a) !== "[object Object]")
      return !1;
    const o = Object.getPrototypeOf(a);
    return o === null || Object.getPrototypeOf(o) === null;
  }
  function n(a) {
    if (a === void 0)
      return (0, t.identifier)("undefined");
    if (a === !0 || a === !1)
      return (0, t.booleanLiteral)(a);
    if (a === null)
      return (0, t.nullLiteral)();
    if (typeof a == "string")
      return (0, t.stringLiteral)(a);
    if (typeof a == "number") {
      let o;
      if (Number.isFinite(a))
        o = (0, t.numericLiteral)(Math.abs(a));
      else {
        let l;
        Number.isNaN(a) ? l = (0, t.numericLiteral)(0) : l = (0, t.numericLiteral)(1), o = (0, t.binaryExpression)("/", l, (0, t.numericLiteral)(0));
      }
      return (a < 0 || Object.is(a, -0)) && (o = (0, t.unaryExpression)("-", o)), o;
    }
    if (i(a)) {
      const o = a.source, l = /\/([a-z]+|)$/.exec(a.toString())[1];
      return (0, t.regExpLiteral)(o, l);
    }
    if (Array.isArray(a))
      return (0, t.arrayExpression)(a.map(n));
    if (s(a)) {
      const o = [];
      for (const l of Object.keys(a)) {
        let u;
        (0, e.default)(l) ? u = (0, t.identifier)(l) : u = (0, t.stringLiteral)(l), o.push((0, t.objectProperty)(u, n(a[l])));
      }
      return (0, t.objectExpression)(o);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  return Dr;
}
var Bi = {}, Fo;
function R1() {
  if (Fo) return Bi;
  Fo = 1, Object.defineProperty(Bi, "__esModule", {
    value: !0
  }), Bi.default = t;
  var e = Tt();
  function t(r, i, s = !1) {
    return r.object = (0, e.memberExpression)(r.object, r.property, r.computed), r.property = i, r.computed = !!s, r;
  }
  return Bi;
}
var ia = {};
Object.defineProperty(ia, "__esModule", {
  value: !0
});
ia.default = $1;
var jo = be, U1 = ds;
function $1(e, t) {
  if (!e || !t) return e;
  for (const r of jo.INHERIT_KEYS.optional)
    e[r] == null && (e[r] = t[r]);
  for (const r of Object.keys(t))
    r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
  for (const r of jo.INHERIT_KEYS.force)
    e[r] = t[r];
  return (0, U1.default)(e, t), e;
}
var Fi = {}, Ro;
function V1() {
  if (Ro) return Fi;
  Ro = 1, Object.defineProperty(Fi, "__esModule", {
    value: !0
  }), Fi.default = r;
  var e = Tt(), t = Ae();
  function r(i, s) {
    if ((0, t.isSuper)(i.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return i.object = (0, e.memberExpression)(s, i.object), i;
  }
  return Fi;
}
var xr = {};
Object.defineProperty(xr, "__esModule", {
  value: !0
});
xr.default = sa;
var kt = g;
function sa(e, t, r, i) {
  const s = [].concat(e), n = /* @__PURE__ */ Object.create(null);
  for (; s.length; ) {
    const a = s.shift();
    if (!a || i && ((0, kt.isAssignmentExpression)(a) || (0, kt.isUnaryExpression)(a) || (0, kt.isUpdateExpression)(a)))
      continue;
    if ((0, kt.isIdentifier)(a)) {
      t ? (n[a.name] = n[a.name] || []).push(a) : n[a.name] = a;
      continue;
    }
    if ((0, kt.isExportDeclaration)(a) && !(0, kt.isExportAllDeclaration)(a)) {
      (0, kt.isDeclaration)(a.declaration) && s.push(a.declaration);
      continue;
    }
    if (r) {
      if ((0, kt.isFunctionDeclaration)(a)) {
        s.push(a.id);
        continue;
      }
      if ((0, kt.isFunctionExpression)(a))
        continue;
    }
    const o = sa.keys[a.type];
    if (o)
      for (let l = 0; l < o.length; l++) {
        const u = o[l], c = a[u];
        c && (Array.isArray(c) ? s.push(...c) : s.push(c));
      }
  }
  return n;
}
const K1 = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  DeclareInterface: ["id"],
  DeclareTypeAlias: ["id"],
  DeclareOpaqueType: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],
  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],
  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],
  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],
  ArrowFunctionExpression: ["params"],
  ObjectMethod: ["params"],
  ClassMethod: ["params"],
  ClassPrivateMethod: ["params"],
  ForInStatement: ["left"],
  ForOfStatement: ["left"],
  ClassDeclaration: ["id"],
  ClassExpression: ["id"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  ObjectProperty: ["value"],
  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],
  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"]
};
sa.keys = K1;
var Es = {};
Object.defineProperty(Es, "__esModule", {
  value: !0
});
Es.default = void 0;
var q1 = xr;
Es.default = W1;
function W1(e, t) {
  return (0, q1.default)(e, t, !0);
}
var na = {};
Object.defineProperty(na, "__esModule", {
  value: !0
});
na.default = X1;
var J1 = It();
function X1(e, t, r) {
  typeof t == "function" && (t = {
    enter: t
  });
  const {
    enter: i,
    exit: s
  } = t;
  xn(e, i, s, r, []);
}
function xn(e, t, r, i, s) {
  const n = J1.VISITOR_KEYS[e.type];
  if (n) {
    t && t(e, s, i);
    for (const a of n) {
      const o = e[a];
      if (Array.isArray(o))
        for (let l = 0; l < o.length; l++) {
          const u = o[l];
          u && (s.push({
            node: e,
            key: a,
            index: l
          }), xn(u, t, r, i, s), s.pop());
        }
      else o && (s.push({
        node: e,
        key: a
      }), xn(o, t, r, i, s), s.pop());
    }
    r && r(e, s, i);
  }
}
var aa = {};
Object.defineProperty(aa, "__esModule", {
  value: !0
});
aa.default = H1;
var Y1 = xr;
function H1(e, t, r) {
  if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression")
    return !1;
  const i = Y1.default.keys[t.type];
  if (i)
    for (let s = 0; s < i.length; s++) {
      const n = i[s], a = t[n];
      if (Array.isArray(a)) {
        if (a.includes(e)) return !0;
      } else if (a === e) return !0;
    }
  return !1;
}
var oa = {}, Ps = {};
Object.defineProperty(Ps, "__esModule", {
  value: !0
});
Ps.default = Q1;
var G1 = g, z1 = be;
function Q1(e) {
  return (0, G1.isVariableDeclaration)(e) && (e.kind !== "var" || e[z1.BLOCK_SCOPED_SYMBOL]);
}
Object.defineProperty(oa, "__esModule", {
  value: !0
});
oa.default = eC;
var Uo = g, Z1 = Ps;
function eC(e) {
  return (0, Uo.isFunctionDeclaration)(e) || (0, Uo.isClassDeclaration)(e) || (0, Z1.default)(e);
}
var la = {};
Object.defineProperty(la, "__esModule", {
  value: !0
});
la.default = iC;
var tC = Kn(), rC = g;
function iC(e) {
  return (0, tC.default)(e.type, "Immutable") ? !0 : (0, rC.isIdentifier)(e) ? e.name === "undefined" : !1;
}
var ua = {};
Object.defineProperty(ua, "__esModule", {
  value: !0
});
ua.default = vn;
var $o = It();
function vn(e, t) {
  if (typeof e != "object" || typeof t != "object" || e == null || t == null)
    return e === t;
  if (e.type !== t.type)
    return !1;
  const r = Object.keys($o.NODE_FIELDS[e.type] || e.type), i = $o.VISITOR_KEYS[e.type];
  for (const s of r) {
    const n = e[s], a = t[s];
    if (typeof n != typeof a)
      return !1;
    if (!(n == null && a == null)) {
      if (n == null || a == null)
        return !1;
      if (Array.isArray(n)) {
        if (!Array.isArray(a) || n.length !== a.length)
          return !1;
        for (let o = 0; o < n.length; o++)
          if (!vn(n[o], a[o]))
            return !1;
        continue;
      }
      if (typeof n == "object" && !(i != null && i.includes(s))) {
        for (const o of Object.keys(n))
          if (n[o] !== a[o])
            return !1;
        continue;
      }
      if (!vn(n, a))
        return !1;
    }
  }
  return !0;
}
var ca = {};
Object.defineProperty(ca, "__esModule", {
  value: !0
});
ca.default = sC;
function sC(e, t, r) {
  switch (t.type) {
    case "MemberExpression":
    case "OptionalMemberExpression":
      return t.property === e ? !!t.computed : t.object === e;
    case "JSXMemberExpression":
      return t.object === e;
    case "VariableDeclarator":
      return t.init === e;
    case "ArrowFunctionExpression":
      return t.body === e;
    case "PrivateName":
      return !1;
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      return t.key === e ? !!t.computed : !1;
    case "ObjectProperty":
      return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
    case "ClassProperty":
    case "ClassAccessorProperty":
      return t.key === e ? !!t.computed : !0;
    case "ClassPrivateProperty":
      return t.key !== e;
    case "ClassDeclaration":
    case "ClassExpression":
      return t.superClass === e;
    case "AssignmentExpression":
      return t.right === e;
    case "AssignmentPattern":
      return t.right === e;
    case "LabeledStatement":
      return !1;
    case "CatchClause":
      return !1;
    case "RestElement":
      return !1;
    case "BreakStatement":
    case "ContinueStatement":
      return !1;
    case "FunctionDeclaration":
    case "FunctionExpression":
      return !1;
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return !1;
    case "ExportSpecifier":
      return r != null && r.source ? !1 : t.local === e;
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return !1;
    case "ImportAttribute":
      return !1;
    case "JSXAttribute":
      return !1;
    case "ObjectPattern":
    case "ArrayPattern":
      return !1;
    case "MetaProperty":
      return !1;
    case "ObjectTypeProperty":
      return t.key !== e;
    case "TSEnumMember":
      return t.id !== e;
    case "TSPropertySignature":
      return t.key === e ? !!t.computed : !0;
  }
  return !0;
}
var fa = {};
Object.defineProperty(fa, "__esModule", {
  value: !0
});
fa.default = nC;
var tr = g;
function nC(e, t) {
  return (0, tr.isBlockStatement)(e) && ((0, tr.isFunction)(t) || (0, tr.isCatchClause)(t)) ? !1 : (0, tr.isPattern)(e) && ((0, tr.isFunction)(t) || (0, tr.isCatchClause)(t)) ? !0 : (0, tr.isScopable)(e);
}
var pa = {};
Object.defineProperty(pa, "__esModule", {
  value: !0
});
pa.default = aC;
var Vo = g;
function aC(e) {
  return (0, Vo.isImportDefaultSpecifier)(e) || (0, Vo.isIdentifier)(e.imported || e.exported, {
    name: "default"
  });
}
var ha = {};
Object.defineProperty(ha, "__esModule", {
  value: !0
});
ha.default = uC;
var oC = cr;
const lC = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
function uC(e) {
  return (0, oC.default)(e) && !lC.has(e);
}
var da = {};
Object.defineProperty(da, "__esModule", {
  value: !0
});
da.default = pC;
var cC = g, fC = be;
function pC(e) {
  return (0, cC.isVariableDeclaration)(e, {
    kind: "var"
  }) && !e[fC.BLOCK_SCOPED_SYMBOL];
}
var ji = {}, Ri = {}, Ko;
function hC() {
  if (Ko) return Ri;
  Ko = 1, Object.defineProperty(Ri, "__esModule", {
    value: !0
  }), Ri.default = n;
  var e = xr, t = g, r = Tt(), i = qu(), s = Kt;
  function n(a, o) {
    const l = [];
    let u = !0;
    for (const c of a)
      if ((0, t.isEmptyStatement)(c) || (u = !1), (0, t.isExpression)(c))
        l.push(c);
      else if ((0, t.isExpressionStatement)(c))
        l.push(c.expression);
      else if ((0, t.isVariableDeclaration)(c)) {
        if (c.kind !== "var") return;
        for (const f of c.declarations) {
          const p = (0, e.default)(f);
          for (const h of Object.keys(p))
            o.push({
              kind: c.kind,
              id: (0, s.default)(p[h])
            });
          f.init && l.push((0, r.assignmentExpression)("=", f.id, f.init));
        }
        u = !0;
      } else if ((0, t.isIfStatement)(c)) {
        const f = c.consequent ? n([c.consequent], o) : (0, i.buildUndefinedNode)(), p = c.alternate ? n([c.alternate], o) : (0, i.buildUndefinedNode)();
        if (!f || !p) return;
        l.push((0, r.conditionalExpression)(c.test, f, p));
      } else if ((0, t.isBlockStatement)(c)) {
        const f = n(c.body, o);
        if (!f) return;
        l.push(f);
      } else if ((0, t.isEmptyStatement)(c))
        a.indexOf(c) === 0 && (u = !0);
      else
        return;
    return u && l.push((0, i.buildUndefinedNode)()), l.length === 1 ? l[0] : (0, r.sequenceExpression)(l);
  }
  return Ri;
}
var qo;
function dC() {
  if (qo) return ji;
  qo = 1, Object.defineProperty(ji, "__esModule", {
    value: !0
  }), ji.default = t;
  var e = hC();
  function t(r, i) {
    if (!(r != null && r.length)) return;
    const s = [], n = (0, e.default)(r, s);
    if (n) {
      for (const a of s)
        i.push(a);
      return n;
    }
  }
  return ji;
}
var Wo;
function Ae() {
  return Wo || (Wo = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    });
    var t = {
      react: !0,
      assertNode: !0,
      createTypeAnnotationBasedOnTypeof: !0,
      createUnionTypeAnnotation: !0,
      createFlowUnionType: !0,
      createTSUnionType: !0,
      cloneNode: !0,
      clone: !0,
      cloneDeep: !0,
      cloneDeepWithoutLoc: !0,
      cloneWithoutLoc: !0,
      addComment: !0,
      addComments: !0,
      inheritInnerComments: !0,
      inheritLeadingComments: !0,
      inheritsComments: !0,
      inheritTrailingComments: !0,
      removeComments: !0,
      ensureBlock: !0,
      toBindingIdentifierName: !0,
      toBlock: !0,
      toComputedKey: !0,
      toExpression: !0,
      toIdentifier: !0,
      toKeyAlias: !0,
      toStatement: !0,
      valueToNode: !0,
      appendToMemberExpression: !0,
      inherits: !0,
      prependToMemberExpression: !0,
      removeProperties: !0,
      removePropertiesDeep: !0,
      removeTypeDuplicates: !0,
      getBindingIdentifiers: !0,
      getOuterBindingIdentifiers: !0,
      traverse: !0,
      traverseFast: !0,
      shallowEqual: !0,
      is: !0,
      isBinding: !0,
      isBlockScoped: !0,
      isImmutable: !0,
      isLet: !0,
      isNode: !0,
      isNodesEquivalent: !0,
      isPlaceholderType: !0,
      isReferenced: !0,
      isScope: !0,
      isSpecifierDefault: !0,
      isType: !0,
      isValidES3Identifier: !0,
      isValidIdentifier: !0,
      isVar: !0,
      matchesPattern: !0,
      validate: !0,
      buildMatchMemberExpression: !0,
      __internal__deprecationWarning: !0
    };
    Object.defineProperty(e, "__internal__deprecationWarning", {
      enumerable: !0,
      get: function() {
        return ye.default;
      }
    }), Object.defineProperty(e, "addComment", {
      enumerable: !0,
      get: function() {
        return _.default;
      }
    }), Object.defineProperty(e, "addComments", {
      enumerable: !0,
      get: function() {
        return j.default;
      }
    }), Object.defineProperty(e, "appendToMemberExpression", {
      enumerable: !0,
      get: function() {
        return V.default;
      }
    }), Object.defineProperty(e, "assertNode", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "buildMatchMemberExpression", {
      enumerable: !0,
      get: function() {
        return ge.default;
      }
    }), Object.defineProperty(e, "clone", {
      enumerable: !0,
      get: function() {
        return y.default;
      }
    }), Object.defineProperty(e, "cloneDeep", {
      enumerable: !0,
      get: function() {
        return b.default;
      }
    }), Object.defineProperty(e, "cloneDeepWithoutLoc", {
      enumerable: !0,
      get: function() {
        return A.default;
      }
    }), Object.defineProperty(e, "cloneNode", {
      enumerable: !0,
      get: function() {
        return h.default;
      }
    }), Object.defineProperty(e, "cloneWithoutLoc", {
      enumerable: !0,
      get: function() {
        return I.default;
      }
    }), Object.defineProperty(e, "createFlowUnionType", {
      enumerable: !0,
      get: function() {
        return l.default;
      }
    }), Object.defineProperty(e, "createTSUnionType", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    }), Object.defineProperty(e, "createTypeAnnotationBasedOnTypeof", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "createUnionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.default;
      }
    }), Object.defineProperty(e, "ensureBlock", {
      enumerable: !0,
      get: function() {
        return W.default;
      }
    }), Object.defineProperty(e, "getBindingIdentifiers", {
      enumerable: !0,
      get: function() {
        return fe.default;
      }
    }), Object.defineProperty(e, "getOuterBindingIdentifiers", {
      enumerable: !0,
      get: function() {
        return pe.default;
      }
    }), Object.defineProperty(e, "inheritInnerComments", {
      enumerable: !0,
      get: function() {
        return G.default;
      }
    }), Object.defineProperty(e, "inheritLeadingComments", {
      enumerable: !0,
      get: function() {
        return ce.default;
      }
    }), Object.defineProperty(e, "inheritTrailingComments", {
      enumerable: !0,
      get: function() {
        return ae.default;
      }
    }), Object.defineProperty(e, "inherits", {
      enumerable: !0,
      get: function() {
        return $.default;
      }
    }), Object.defineProperty(e, "inheritsComments", {
      enumerable: !0,
      get: function() {
        return te.default;
      }
    }), Object.defineProperty(e, "is", {
      enumerable: !0,
      get: function() {
        return Ne.default;
      }
    }), Object.defineProperty(e, "isBinding", {
      enumerable: !0,
      get: function() {
        return _e.default;
      }
    }), Object.defineProperty(e, "isBlockScoped", {
      enumerable: !0,
      get: function() {
        return qe.default;
      }
    }), Object.defineProperty(e, "isImmutable", {
      enumerable: !0,
      get: function() {
        return tt.default;
      }
    }), Object.defineProperty(e, "isLet", {
      enumerable: !0,
      get: function() {
        return Pe.default;
      }
    }), Object.defineProperty(e, "isNode", {
      enumerable: !0,
      get: function() {
        return Be.default;
      }
    }), Object.defineProperty(e, "isNodesEquivalent", {
      enumerable: !0,
      get: function() {
        return ve.default;
      }
    }), Object.defineProperty(e, "isPlaceholderType", {
      enumerable: !0,
      get: function() {
        return Re.default;
      }
    }), Object.defineProperty(e, "isReferenced", {
      enumerable: !0,
      get: function() {
        return lt.default;
      }
    }), Object.defineProperty(e, "isScope", {
      enumerable: !0,
      get: function() {
        return He.default;
      }
    }), Object.defineProperty(e, "isSpecifierDefault", {
      enumerable: !0,
      get: function() {
        return J.default;
      }
    }), Object.defineProperty(e, "isType", {
      enumerable: !0,
      get: function() {
        return d.default;
      }
    }), Object.defineProperty(e, "isValidES3Identifier", {
      enumerable: !0,
      get: function() {
        return x.default;
      }
    }), Object.defineProperty(e, "isValidIdentifier", {
      enumerable: !0,
      get: function() {
        return O.default;
      }
    }), Object.defineProperty(e, "isVar", {
      enumerable: !0,
      get: function() {
        return M.default;
      }
    }), Object.defineProperty(e, "matchesPattern", {
      enumerable: !0,
      get: function() {
        return Z.default;
      }
    }), Object.defineProperty(e, "prependToMemberExpression", {
      enumerable: !0,
      get: function() {
        return H.default;
      }
    }), e.react = void 0, Object.defineProperty(e, "removeComments", {
      enumerable: !0,
      get: function() {
        return q.default;
      }
    }), Object.defineProperty(e, "removeProperties", {
      enumerable: !0,
      get: function() {
        return se.default;
      }
    }), Object.defineProperty(e, "removePropertiesDeep", {
      enumerable: !0,
      get: function() {
        return oe.default;
      }
    }), Object.defineProperty(e, "removeTypeDuplicates", {
      enumerable: !0,
      get: function() {
        return Ue.default;
      }
    }), Object.defineProperty(e, "shallowEqual", {
      enumerable: !0,
      get: function() {
        return Ee.default;
      }
    }), Object.defineProperty(e, "toBindingIdentifierName", {
      enumerable: !0,
      get: function() {
        return Q.default;
      }
    }), Object.defineProperty(e, "toBlock", {
      enumerable: !0,
      get: function() {
        return U.default;
      }
    }), Object.defineProperty(e, "toComputedKey", {
      enumerable: !0,
      get: function() {
        return L.default;
      }
    }), Object.defineProperty(e, "toExpression", {
      enumerable: !0,
      get: function() {
        return k.default;
      }
    }), Object.defineProperty(e, "toIdentifier", {
      enumerable: !0,
      get: function() {
        return F.default;
      }
    }), Object.defineProperty(e, "toKeyAlias", {
      enumerable: !0,
      get: function() {
        return B.default;
      }
    }), Object.defineProperty(e, "toStatement", {
      enumerable: !0,
      get: function() {
        return N.default;
      }
    }), Object.defineProperty(e, "traverse", {
      enumerable: !0,
      get: function() {
        return Se.default;
      }
    }), Object.defineProperty(e, "traverseFast", {
      enumerable: !0,
      get: function() {
        return Ce.default;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return ee.default;
      }
    }), Object.defineProperty(e, "valueToNode", {
      enumerable: !0,
      get: function() {
        return D.default;
      }
    });
    var r = ns, i = Vn, s = sS(), n = Xn, a = S;
    Object.keys(a).forEach(function(X) {
      X === "default" || X === "__esModule" || Object.prototype.hasOwnProperty.call(t, X) || X in e && e[X] === a[X] || Object.defineProperty(e, X, {
        enumerable: !0,
        get: function() {
          return a[X];
        }
      });
    });
    var o = qA(), l = WA(), u = JA(), c = Tt();
    Object.keys(c).forEach(function(X) {
      X === "default" || X === "__esModule" || Object.prototype.hasOwnProperty.call(t, X) || X in e && e[X] === c[X] || Object.defineProperty(e, X, {
        enumerable: !0,
        get: function() {
          return c[X];
        }
      });
    });
    var f = XA();
    Object.keys(f).forEach(function(X) {
      X === "default" || X === "__esModule" || Object.prototype.hasOwnProperty.call(t, X) || X in e && e[X] === f[X] || Object.defineProperty(e, X, {
        enumerable: !0,
        get: function() {
          return f[X];
        }
      });
    });
    var p = qu();
    Object.keys(p).forEach(function(X) {
      X === "default" || X === "__esModule" || Object.prototype.hasOwnProperty.call(t, X) || X in e && e[X] === p[X] || Object.defineProperty(e, X, {
        enumerable: !0,
        get: function() {
          return p[X];
        }
      });
    });
    var h = Kt, y = Hn, b = Gn, A = zn, I = Qn, _ = Zn, j = fs, G = ps, ce = hs, te = ds, ae = ms, q = ea, Y = z;
    Object.keys(Y).forEach(function(X) {
      X === "default" || X === "__esModule" || Object.prototype.hasOwnProperty.call(t, X) || X in e && e[X] === Y[X] || Object.defineProperty(e, X, {
        enumerable: !0,
        get: function() {
          return Y[X];
        }
      });
    });
    var re = be;
    Object.keys(re).forEach(function(X) {
      X === "default" || X === "__esModule" || Object.prototype.hasOwnProperty.call(t, X) || X in e && e[X] === re[X] || Object.defineProperty(e, X, {
        enumerable: !0,
        get: function() {
          return re[X];
        }
      });
    });
    var W = S1(), Q = ta, U = Ju(), L = C1(), k = Ts, F = ys, B = ra, N = F1(), D = j1(), R = It();
    Object.keys(R).forEach(function(X) {
      X === "default" || X === "__esModule" || Object.prototype.hasOwnProperty.call(t, X) || X in e && e[X] === R[X] || Object.defineProperty(e, X, {
        enumerable: !0,
        get: function() {
          return R[X];
        }
      });
    });
    var V = R1(), $ = ia, H = V1(), se = Ss, oe = gs, Ue = cs, fe = xr, pe = Es, Se = na;
    Object.keys(Se).forEach(function(X) {
      X === "default" || X === "__esModule" || Object.prototype.hasOwnProperty.call(t, X) || X in e && e[X] === Se[X] || Object.defineProperty(e, X, {
        enumerable: !0,
        get: function() {
          return Se[X];
        }
      });
    });
    var Ce = bs, Ee = ei, Ne = ri(), _e = aa, qe = oa, tt = la, Pe = Ps, Be = us, ve = ua, Re = Iu(), lt = ca, He = fa, J = pa, d = Kn(), x = ha, O = cr, M = da, Z = os, ee = Jn(), ge = as, xe = g;
    Object.keys(xe).forEach(function(X) {
      X === "default" || X === "__esModule" || Object.prototype.hasOwnProperty.call(t, X) || X in e && e[X] === xe[X] || Object.defineProperty(e, X, {
        enumerable: !0,
        get: function() {
          return xe[X];
        }
      });
    });
    var ye = Pr;
    e.react = {
      isReactComponent: r.default,
      isCompatTag: i.default,
      buildChildren: s.default
    }, e.toSequenceExpression = dC().default;
  }(qs)), qs;
}
Object.defineProperty(et, "__esModule", {
  value: !0
});
et.isBindingIdentifier = FC;
et.isBlockScoped = VC;
et.isExpression = RC;
et.isFlow = XC;
et.isForAwaitStatement = GC;
et.isGenerated = WC;
et.isPure = JC;
et.isReferenced = $C;
et.isReferencedIdentifier = MC;
et.isReferencedMemberExpression = BC;
et.isRestProperty = YC;
et.isScope = UC;
et.isSpreadProperty = HC;
et.isStatement = jC;
et.isUser = qC;
et.isVar = KC;
var mC = Ae();
const {
  isBinding: yC,
  isBlockScoped: TC,
  isExportDeclaration: gC,
  isExpression: bC,
  isFlow: SC,
  isForStatement: EC,
  isForXStatement: PC,
  isIdentifier: Yu,
  isImportDeclaration: xC,
  isImportSpecifier: vC,
  isJSXIdentifier: AC,
  isJSXMemberExpression: CC,
  isMemberExpression: IC,
  isRestElement: Hu,
  isReferenced: ma,
  isScope: wC,
  isStatement: OC,
  isVar: NC,
  isVariableDeclaration: _C,
  react: kC,
  isForOfStatement: DC
} = mC, {
  isCompatTag: LC
} = kC;
function MC(e) {
  const {
    node: t,
    parent: r
  } = this;
  if (!Yu(t, e) && !CC(r, e))
    if (AC(t, e)) {
      if (LC(t.name)) return !1;
    } else
      return !1;
  return ma(t, r, this.parentPath.parent);
}
function BC() {
  const {
    node: e,
    parent: t
  } = this;
  return IC(e) && ma(e, t);
}
function FC() {
  const {
    node: e,
    parent: t
  } = this, r = this.parentPath.parent;
  return Yu(e) && yC(e, t, r);
}
function jC() {
  const {
    node: e,
    parent: t
  } = this;
  return OC(e) ? !(_C(e) && (PC(t, {
    left: e
  }) || EC(t, {
    init: e
  }))) : !1;
}
function RC() {
  return this.isIdentifier() ? this.isReferencedIdentifier() : bC(this.node);
}
function UC() {
  return wC(this.node, this.parent);
}
function $C() {
  return ma(this.node, this.parent);
}
function VC() {
  return TC(this.node);
}
function KC() {
  return NC(this.node);
}
function qC() {
  return this.node && !!this.node.loc;
}
function WC() {
  return !this.isUser();
}
function JC(e) {
  return this.scope.isPure(this.node, e);
}
function XC() {
  const {
    node: e
  } = this;
  return SC(e) ? !0 : xC(e) ? e.importKind === "type" || e.importKind === "typeof" : gC(e) ? e.exportKind === "type" : vC(e) ? e.importKind === "type" || e.importKind === "typeof" : !1;
}
function YC() {
  var e;
  return Hu(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectPattern());
}
function HC() {
  var e;
  return Hu(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectExpression());
}
function GC() {
  return DC(this.node, {
    await: !0
  });
}
et.isExistentialTypeParam = function() {
  throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
}, et.isNumericLiteralTypeAnnotation = function() {
  throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
};
Object.defineProperty(Vt, "__esModule", {
  value: !0
});
Vt.explode = Qu;
Vt.isExplodedVisitor = zu;
Vt.merge = tI;
Vt.verify = Zu;
var Gu = Oe, zC = et, QC = Ae();
const {
  DEPRECATED_KEYS: Jo,
  DEPRECATED_ALIASES: Xo,
  FLIPPED_ALIAS_KEYS: Yo,
  TYPES: ZC,
  __internal__deprecationWarning: Ho
} = QC;
function eI(e) {
  return e in Gu;
}
function zu(e) {
  return e == null ? void 0 : e._exploded;
}
function Qu(e) {
  if (zu(e)) return e;
  e._exploded = !0;
  for (const t of Object.keys(e)) {
    if (ar(t)) continue;
    const r = t.split("|");
    if (r.length === 1) continue;
    const i = e[t];
    delete e[t];
    for (const s of r)
      e[s] = i;
  }
  Zu(e), delete e.__esModule, rI(e), Qo(e);
  for (const t of Object.keys(e)) {
    if (ar(t) || !eI(t)) continue;
    const r = e[t];
    for (const s of Object.keys(r))
      r[s] = iI(t, r[s]);
    delete e[t];
    const i = Gu[t];
    if (i !== null)
      for (const s of i)
        e[s] ? Yr(e[s], r) : e[s] = r;
    else
      Yr(e, r);
  }
  for (const t of Object.keys(e)) {
    if (ar(t)) continue;
    let r = Yo[t];
    if (t in Jo) {
      const s = Jo[t];
      Ho(t, s, "Visitor "), r = [s];
    } else if (t in Xo) {
      const s = Xo[t];
      Ho(t, s, "Visitor "), r = Yo[s];
    }
    if (!r) continue;
    const i = e[t];
    delete e[t];
    for (const s of r) {
      const n = e[s];
      n ? Yr(n, i) : e[s] = Object.assign({}, i);
    }
  }
  for (const t of Object.keys(e))
    ar(t) || Qo(e[t]);
  return e;
}
function Zu(e) {
  if (!e._verified) {
    if (typeof e == "function")
      throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
    for (const t of Object.keys(e)) {
      if ((t === "enter" || t === "exit") && Go(t, e[t]), ar(t)) continue;
      if (!ZC.includes(t))
        throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type`);
      const r = e[t];
      if (typeof r == "object")
        for (const i of Object.keys(r))
          if (i === "enter" || i === "exit")
            Go(`${t}.${i}`, r[i]);
          else
            throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${i}`);
    }
    e._verified = !0;
  }
}
function Go(e, t) {
  const r = [].concat(t);
  for (const i of r)
    if (typeof i != "function")
      throw new TypeError(`Non-function found defined in ${e} with type ${typeof i}`);
}
function tI(e, t = [], r) {
  const i = {};
  for (let s = 0; s < e.length; s++) {
    const n = Qu(e[s]), a = t[s];
    let o = n;
    (a || r) && (o = zo(o, a, r)), Yr(i, o);
    for (const l of Object.keys(n)) {
      if (ar(l)) continue;
      let u = n[l];
      (a || r) && (u = zo(u, a, r));
      const c = i[l] || (i[l] = {});
      Yr(c, u);
    }
  }
  return i;
}
function zo(e, t, r) {
  const i = {};
  for (const s of ["enter", "exit"]) {
    let n = e[s];
    Array.isArray(n) && (n = n.map(function(a) {
      let o = a;
      return t && (o = function(l) {
        a.call(t, l, t);
      }), r && (o = r(t == null ? void 0 : t.key, s, o)), o !== a && (o.toString = () => a.toString()), o;
    }), i[s] = n);
  }
  return i;
}
function rI(e) {
  for (const t of Object.keys(e)) {
    if (ar(t)) continue;
    const r = e[t];
    typeof r == "function" && (e[t] = {
      enter: r
    });
  }
}
function Qo(e) {
  e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]), e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
}
function iI(e, t) {
  const r = `is${e}`, i = zC[r], s = function(n) {
    if (i.call(n))
      return t.apply(this, arguments);
  };
  return s.toString = () => t.toString(), s;
}
function ar(e) {
  return e[0] === "_" || e === "enter" || e === "exit" || e === "shouldSkip" || e === "denylist" || e === "noScope" || e === "skipKeys" || e === "blacklist";
}
function Yr(e, t) {
  for (const r of ["enter", "exit"])
    t[r] && (e[r] = [].concat(e[r] || [], t[r]));
}
var nt = {};
Object.defineProperty(nt, "__esModule", {
  value: !0
});
nt.clear = sI;
nt.clearPath = ec;
nt.clearScope = tc;
nt.getCachedPaths = nI;
nt.getOrCreateCachedPaths = aI;
nt.scope = nt.path = void 0;
let Zi = nt.path = /* @__PURE__ */ new WeakMap();
nt.scope = /* @__PURE__ */ new WeakMap();
function sI() {
  ec(), tc();
}
function ec() {
  nt.path = Zi = /* @__PURE__ */ new WeakMap();
}
function tc() {
  nt.scope = /* @__PURE__ */ new WeakMap();
}
const An = Object.freeze({});
function nI(e, t) {
  var r, i;
  return e = null, (r = Zi.get((i = e) != null ? i : An)) == null ? void 0 : r.get(t);
}
function aI(e, t) {
  var r, i;
  e = null;
  let s = Zi.get((r = e) != null ? r : An);
  s || Zi.set((i = e) != null ? i : An, s = /* @__PURE__ */ new WeakMap());
  let n = s.get(t);
  return n || s.set(t, n = /* @__PURE__ */ new Map()), n;
}
var Ui = {}, Lr = {}, xt = {}, Cn = { exports: {} }, Ys, Zo;
function oI() {
  if (Zo) return Ys;
  Zo = 1;
  var e = 1e3, t = e * 60, r = t * 60, i = r * 24, s = i * 7, n = i * 365.25;
  Ys = function(c, f) {
    f = f || {};
    var p = typeof c;
    if (p === "string" && c.length > 0)
      return a(c);
    if (p === "number" && isFinite(c))
      return f.long ? l(c) : o(c);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(c)
    );
  };
  function a(c) {
    if (c = String(c), !(c.length > 100)) {
      var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        c
      );
      if (f) {
        var p = parseFloat(f[1]), h = (f[2] || "ms").toLowerCase();
        switch (h) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * n;
          case "weeks":
          case "week":
          case "w":
            return p * s;
          case "days":
          case "day":
          case "d":
            return p * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function o(c) {
    var f = Math.abs(c);
    return f >= i ? Math.round(c / i) + "d" : f >= r ? Math.round(c / r) + "h" : f >= t ? Math.round(c / t) + "m" : f >= e ? Math.round(c / e) + "s" : c + "ms";
  }
  function l(c) {
    var f = Math.abs(c);
    return f >= i ? u(c, f, i, "day") : f >= r ? u(c, f, r, "hour") : f >= t ? u(c, f, t, "minute") : f >= e ? u(c, f, e, "second") : c + " ms";
  }
  function u(c, f, p, h) {
    var y = f >= p * 1.5;
    return Math.round(c / p) + " " + h + (y ? "s" : "");
  }
  return Ys;
}
function lI(e) {
  r.debug = r, r.default = r, r.coerce = l, r.disable = n, r.enable = s, r.enabled = a, r.humanize = oI(), r.destroy = u, Object.keys(e).forEach((c) => {
    r[c] = e[c];
  }), r.names = [], r.skips = [], r.formatters = {};
  function t(c) {
    let f = 0;
    for (let p = 0; p < c.length; p++)
      f = (f << 5) - f + c.charCodeAt(p), f |= 0;
    return r.colors[Math.abs(f) % r.colors.length];
  }
  r.selectColor = t;
  function r(c) {
    let f, p = null, h, y;
    function b(...A) {
      if (!b.enabled)
        return;
      const I = b, _ = Number(/* @__PURE__ */ new Date()), j = _ - (f || _);
      I.diff = j, I.prev = f, I.curr = _, f = _, A[0] = r.coerce(A[0]), typeof A[0] != "string" && A.unshift("%O");
      let G = 0;
      A[0] = A[0].replace(/%([a-zA-Z%])/g, (te, ae) => {
        if (te === "%%")
          return "%";
        G++;
        const q = r.formatters[ae];
        if (typeof q == "function") {
          const Y = A[G];
          te = q.call(I, Y), A.splice(G, 1), G--;
        }
        return te;
      }), r.formatArgs.call(I, A), (I.log || r.log).apply(I, A);
    }
    return b.namespace = c, b.useColors = r.useColors(), b.color = r.selectColor(c), b.extend = i, b.destroy = r.destroy, Object.defineProperty(b, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (h !== r.namespaces && (h = r.namespaces, y = r.enabled(c)), y),
      set: (A) => {
        p = A;
      }
    }), typeof r.init == "function" && r.init(b), b;
  }
  function i(c, f) {
    const p = r(this.namespace + (typeof f > "u" ? ":" : f) + c);
    return p.log = this.log, p;
  }
  function s(c) {
    r.save(c), r.namespaces = c, r.names = [], r.skips = [];
    let f;
    const p = (typeof c == "string" ? c : "").split(/[\s,]+/), h = p.length;
    for (f = 0; f < h; f++)
      p[f] && (c = p[f].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
  }
  function n() {
    const c = [
      ...r.names.map(o),
      ...r.skips.map(o).map((f) => "-" + f)
    ].join(",");
    return r.enable(""), c;
  }
  function a(c) {
    if (c[c.length - 1] === "*")
      return !0;
    let f, p;
    for (f = 0, p = r.skips.length; f < p; f++)
      if (r.skips[f].test(c))
        return !1;
    for (f = 0, p = r.names.length; f < p; f++)
      if (r.names[f].test(c))
        return !0;
    return !1;
  }
  function o(c) {
    return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(c) {
    return c instanceof Error ? c.stack || c.message : c;
  }
  function u() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var uI = lI;
(function(e, t) {
  t.formatArgs = i, t.save = s, t.load = n, t.useColors = r, t.storage = a(), t.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const u = "color: " + this.color;
    l.splice(1, 0, u, "color: inherit");
    let c = 0, f = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (c++, p === "%c" && (f = c));
    }), l.splice(f, 0, u);
  }
  t.log = console.debug || console.log || (() => {
  });
  function s(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function n() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
  }
  function a() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = uI(t);
  const { formatters: o } = e.exports;
  o.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (u) {
      return "[UnexpectedJSONParseError]: " + u.message;
    }
  };
})(Cn, Cn.exports);
var cI = Cn.exports, Mr = {}, Br = {}, ya = {};
Object.defineProperty(ya, "__esModule", {
  value: !0
});
ya.default = dI;
var fI = Ae();
const {
  cloneNode: Hs,
  exportNamedDeclaration: el,
  exportSpecifier: tl,
  identifier: Gs,
  variableDeclaration: pI,
  variableDeclarator: hI
} = fI;
function dI(e) {
  if (!e.isExportDeclaration() || e.isExportAllDeclaration())
    throw new Error("Only default and named export declarations can be split.");
  if (e.isExportDefaultDeclaration()) {
    const n = e.get("declaration"), a = n.isFunctionDeclaration() || n.isClassDeclaration(), o = n.isFunctionExpression() || n.isClassExpression(), l = n.isScope() ? n.scope.parent : n.scope;
    let u = n.node.id, c = !1;
    u ? o && l.hasBinding(u.name) && (c = !0, u = l.generateUidIdentifier(u.name)) : (c = !0, u = l.generateUidIdentifier("default"), (a || o) && (n.node.id = Hs(u)));
    const f = a ? n.node : pI("var", [hI(Hs(u), n.node)]), p = el(null, [tl(Hs(u), Gs("default"))]);
    return e.insertAfter(p), e.replaceWith(f), c && l.registerDeclaration(e), e;
  } else if (e.get("specifiers").length > 0)
    throw new Error("It doesn't make sense to split exported specifiers.");
  const t = e.get("declaration"), r = t.getOuterBindingIdentifiers(), i = Object.keys(r).map((n) => tl(Gs(n), Gs(n))), s = el(null, i);
  return e.insertAfter(s), e.replaceWith(t.node), e;
}
var pr = {};
Object.defineProperty(pr, "__esModule", {
  value: !0
});
pr.default = void 0;
pr.requeueComputedKeyAndDecorators = In;
pr.skipAllButComputedKey = function(t) {
  t.skip(), t.node.computed && t.context.maybeQueue(t.get("key"));
};
function In(e) {
  const {
    context: t,
    node: r
  } = e;
  if (r.computed && t.maybeQueue(e.get("key")), r.decorators)
    for (const i of e.get("decorators"))
      t.maybeQueue(i);
}
const mI = {
  FunctionParent(e) {
    e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && In(e));
  },
  Property(e) {
    e.isObjectProperty() || (e.skip(), In(e));
  }
};
pr.default = mI;
var rl;
function yI() {
  if (rl) return Br;
  rl = 1, Object.defineProperty(Br, "__esModule", {
    value: !0
  }), Br.default = void 0;
  var e = ya, t = Ae(), r = pr, i = Ha(), s = Vt;
  const n = {
    ReferencedIdentifier({
      node: o
    }, l) {
      o.name === l.oldName && (o.name = l.newName);
    },
    Scope(o, l) {
      o.scope.bindingIdentifierEquals(l.oldName, l.binding.identifier) || (o.skip(), o.isMethod() && (0, r.requeueComputedKeyAndDecorators)(o));
    },
    ObjectProperty({
      node: o,
      scope: l
    }, u) {
      const {
        name: c
      } = o.key;
      if (o.shorthand && (c === u.oldName || c === u.newName) && l.getBindingIdentifier(c) === u.binding.identifier) {
        o.shorthand = !1;
        {
          var f;
          (f = o.extra) != null && f.shorthand && (o.extra.shorthand = !1);
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(o, l) {
      if (o.isVariableDeclaration()) return;
      const u = o.getOuterBindingIdentifiers();
      for (const c in u)
        c === l.oldName && (u[c].name = l.newName);
    }
  };
  class a {
    constructor(l, u, c) {
      this.newName = c, this.oldName = u, this.binding = l;
    }
    maybeConvertFromExportDeclaration(l) {
      const u = l.parentPath;
      if (u.isExportDeclaration()) {
        if (u.isExportDefaultDeclaration()) {
          const {
            declaration: c
          } = u.node;
          if (t.isDeclaration(c) && !c.id)
            return;
        }
        u.isExportAllDeclaration() || (0, e.default)(u);
      }
    }
    maybeConvertFromClassFunctionDeclaration(l) {
      return l;
    }
    maybeConvertFromClassFunctionExpression(l) {
      return l;
    }
    rename() {
      const {
        binding: l,
        oldName: u,
        newName: c
      } = this, {
        scope: f,
        path: p
      } = l, h = p.find((b) => b.isDeclaration() || b.isFunctionExpression() || b.isClassExpression());
      h && h.getOuterBindingIdentifiers()[u] === l.identifier && this.maybeConvertFromExportDeclaration(h);
      const y = arguments[0] || f.block;
      (0, i.traverseNode)(y, (0, s.explode)(n), f, this, f.path, {
        discriminant: !0
      }), arguments[0] || (f.removeOwnBinding(u), f.bindings[c] = l, this.binding.identifier.name = c), h && (this.maybeConvertFromClassFunctionDeclaration(p), this.maybeConvertFromClassFunctionExpression(p));
    }
  }
  return Br.default = a, Br;
}
var xs = {};
Object.defineProperty(xs, "__esModule", {
  value: !0
});
xs.default = void 0;
class TI {
  constructor({
    identifier: t,
    scope: r,
    path: i,
    kind: s
  }) {
    this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = t, this.scope = r, this.path = i, this.kind = s, (s === "var" || s === "hoisted") && gI(i) && this.reassign(i), this.clearValue();
  }
  deoptValue() {
    this.clearValue(), this.hasDeoptedValue = !0;
  }
  setValue(t) {
    this.hasDeoptedValue || (this.hasValue = !0, this.value = t);
  }
  clearValue() {
    this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
  }
  reassign(t) {
    this.constant = !1, !this.constantViolations.includes(t) && this.constantViolations.push(t);
  }
  reference(t) {
    this.referencePaths.includes(t) || (this.referenced = !0, this.references++, this.referencePaths.push(t));
  }
  dereference() {
    this.references--, this.referenced = !!this.references;
  }
}
xs.default = TI;
function gI(e) {
  for (let {
    parentPath: t,
    key: r
  } = e; t; {
    parentPath: t,
    key: r
  } = t) {
    if (t.isFunctionParent()) return !1;
    if (t.isWhile() || t.isForXStatement() || t.isForStatement() && r === "body")
      return !0;
  }
  return !1;
}
const bI = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, SI = {
  Array: !1,
  Boolean: !1,
  constructor: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  propertyIsEnumerable: !1,
  RangeError: !1,
  ReferenceError: !1,
  RegExp: !1,
  String: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1
}, EI = {
  Array: !1,
  ArrayBuffer: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, PI = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, xI = {
  AbortController: !1,
  AbortSignal: !1,
  addEventListener: !1,
  alert: !1,
  AnalyserNode: !1,
  Animation: !1,
  AnimationEffectReadOnly: !1,
  AnimationEffectTiming: !1,
  AnimationEffectTimingReadOnly: !1,
  AnimationEvent: !1,
  AnimationPlaybackEvent: !1,
  AnimationTimeline: !1,
  applicationCache: !1,
  ApplicationCache: !1,
  ApplicationCacheErrorEvent: !1,
  atob: !1,
  Attr: !1,
  Audio: !1,
  AudioBuffer: !1,
  AudioBufferSourceNode: !1,
  AudioContext: !1,
  AudioDestinationNode: !1,
  AudioListener: !1,
  AudioNode: !1,
  AudioParam: !1,
  AudioProcessingEvent: !1,
  AudioScheduledSourceNode: !1,
  "AudioWorkletGlobalScope ": !1,
  AudioWorkletNode: !1,
  AudioWorkletProcessor: !1,
  BarProp: !1,
  BaseAudioContext: !1,
  BatteryManager: !1,
  BeforeUnloadEvent: !1,
  BiquadFilterNode: !1,
  Blob: !1,
  BlobEvent: !1,
  blur: !1,
  BroadcastChannel: !1,
  btoa: !1,
  BudgetService: !1,
  ByteLengthQueuingStrategy: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  cancelAnimationFrame: !1,
  cancelIdleCallback: !1,
  CanvasCaptureMediaStreamTrack: !1,
  CanvasGradient: !1,
  CanvasPattern: !1,
  CanvasRenderingContext2D: !1,
  ChannelMergerNode: !1,
  ChannelSplitterNode: !1,
  CharacterData: !1,
  clearInterval: !1,
  clearTimeout: !1,
  clientInformation: !1,
  ClipboardEvent: !1,
  close: !1,
  closed: !1,
  CloseEvent: !1,
  Comment: !1,
  CompositionEvent: !1,
  confirm: !1,
  console: !1,
  ConstantSourceNode: !1,
  ConvolverNode: !1,
  CountQueuingStrategy: !1,
  createImageBitmap: !1,
  Credential: !1,
  CredentialsContainer: !1,
  crypto: !1,
  Crypto: !1,
  CryptoKey: !1,
  CSS: !1,
  CSSConditionRule: !1,
  CSSFontFaceRule: !1,
  CSSGroupingRule: !1,
  CSSImportRule: !1,
  CSSKeyframeRule: !1,
  CSSKeyframesRule: !1,
  CSSMediaRule: !1,
  CSSNamespaceRule: !1,
  CSSPageRule: !1,
  CSSRule: !1,
  CSSRuleList: !1,
  CSSStyleDeclaration: !1,
  CSSStyleRule: !1,
  CSSStyleSheet: !1,
  CSSSupportsRule: !1,
  CustomElementRegistry: !1,
  customElements: !1,
  CustomEvent: !1,
  DataTransfer: !1,
  DataTransferItem: !1,
  DataTransferItemList: !1,
  defaultstatus: !1,
  defaultStatus: !1,
  DelayNode: !1,
  DeviceMotionEvent: !1,
  DeviceOrientationEvent: !1,
  devicePixelRatio: !1,
  dispatchEvent: !1,
  document: !1,
  Document: !1,
  DocumentFragment: !1,
  DocumentType: !1,
  DOMError: !1,
  DOMException: !1,
  DOMImplementation: !1,
  DOMMatrix: !1,
  DOMMatrixReadOnly: !1,
  DOMParser: !1,
  DOMPoint: !1,
  DOMPointReadOnly: !1,
  DOMQuad: !1,
  DOMRect: !1,
  DOMRectReadOnly: !1,
  DOMStringList: !1,
  DOMStringMap: !1,
  DOMTokenList: !1,
  DragEvent: !1,
  DynamicsCompressorNode: !1,
  Element: !1,
  ErrorEvent: !1,
  event: !1,
  Event: !1,
  EventSource: !1,
  EventTarget: !1,
  external: !1,
  fetch: !1,
  File: !1,
  FileList: !1,
  FileReader: !1,
  find: !1,
  focus: !1,
  FocusEvent: !1,
  FontFace: !1,
  FontFaceSetLoadEvent: !1,
  FormData: !1,
  frameElement: !1,
  frames: !1,
  GainNode: !1,
  Gamepad: !1,
  GamepadButton: !1,
  GamepadEvent: !1,
  getComputedStyle: !1,
  getSelection: !1,
  HashChangeEvent: !1,
  Headers: !1,
  history: !1,
  History: !1,
  HTMLAllCollection: !1,
  HTMLAnchorElement: !1,
  HTMLAreaElement: !1,
  HTMLAudioElement: !1,
  HTMLBaseElement: !1,
  HTMLBodyElement: !1,
  HTMLBRElement: !1,
  HTMLButtonElement: !1,
  HTMLCanvasElement: !1,
  HTMLCollection: !1,
  HTMLContentElement: !1,
  HTMLDataElement: !1,
  HTMLDataListElement: !1,
  HTMLDetailsElement: !1,
  HTMLDialogElement: !1,
  HTMLDirectoryElement: !1,
  HTMLDivElement: !1,
  HTMLDListElement: !1,
  HTMLDocument: !1,
  HTMLElement: !1,
  HTMLEmbedElement: !1,
  HTMLFieldSetElement: !1,
  HTMLFontElement: !1,
  HTMLFormControlsCollection: !1,
  HTMLFormElement: !1,
  HTMLFrameElement: !1,
  HTMLFrameSetElement: !1,
  HTMLHeadElement: !1,
  HTMLHeadingElement: !1,
  HTMLHRElement: !1,
  HTMLHtmlElement: !1,
  HTMLIFrameElement: !1,
  HTMLImageElement: !1,
  HTMLInputElement: !1,
  HTMLLabelElement: !1,
  HTMLLegendElement: !1,
  HTMLLIElement: !1,
  HTMLLinkElement: !1,
  HTMLMapElement: !1,
  HTMLMarqueeElement: !1,
  HTMLMediaElement: !1,
  HTMLMenuElement: !1,
  HTMLMetaElement: !1,
  HTMLMeterElement: !1,
  HTMLModElement: !1,
  HTMLObjectElement: !1,
  HTMLOListElement: !1,
  HTMLOptGroupElement: !1,
  HTMLOptionElement: !1,
  HTMLOptionsCollection: !1,
  HTMLOutputElement: !1,
  HTMLParagraphElement: !1,
  HTMLParamElement: !1,
  HTMLPictureElement: !1,
  HTMLPreElement: !1,
  HTMLProgressElement: !1,
  HTMLQuoteElement: !1,
  HTMLScriptElement: !1,
  HTMLSelectElement: !1,
  HTMLShadowElement: !1,
  HTMLSlotElement: !1,
  HTMLSourceElement: !1,
  HTMLSpanElement: !1,
  HTMLStyleElement: !1,
  HTMLTableCaptionElement: !1,
  HTMLTableCellElement: !1,
  HTMLTableColElement: !1,
  HTMLTableElement: !1,
  HTMLTableRowElement: !1,
  HTMLTableSectionElement: !1,
  HTMLTemplateElement: !1,
  HTMLTextAreaElement: !1,
  HTMLTimeElement: !1,
  HTMLTitleElement: !1,
  HTMLTrackElement: !1,
  HTMLUListElement: !1,
  HTMLUnknownElement: !1,
  HTMLVideoElement: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  IdleDeadline: !1,
  IIRFilterNode: !1,
  Image: !1,
  ImageBitmap: !1,
  ImageBitmapRenderingContext: !1,
  ImageCapture: !1,
  ImageData: !1,
  indexedDB: !1,
  innerHeight: !1,
  innerWidth: !1,
  InputEvent: !1,
  IntersectionObserver: !1,
  IntersectionObserverEntry: !1,
  Intl: !1,
  isSecureContext: !1,
  KeyboardEvent: !1,
  KeyframeEffect: !1,
  KeyframeEffectReadOnly: !1,
  length: !1,
  localStorage: !1,
  location: !0,
  Location: !1,
  locationbar: !1,
  matchMedia: !1,
  MediaDeviceInfo: !1,
  MediaDevices: !1,
  MediaElementAudioSourceNode: !1,
  MediaEncryptedEvent: !1,
  MediaError: !1,
  MediaKeyMessageEvent: !1,
  MediaKeySession: !1,
  MediaKeyStatusMap: !1,
  MediaKeySystemAccess: !1,
  MediaList: !1,
  MediaQueryList: !1,
  MediaQueryListEvent: !1,
  MediaRecorder: !1,
  MediaSettingsRange: !1,
  MediaSource: !1,
  MediaStream: !1,
  MediaStreamAudioDestinationNode: !1,
  MediaStreamAudioSourceNode: !1,
  MediaStreamEvent: !1,
  MediaStreamTrack: !1,
  MediaStreamTrackEvent: !1,
  menubar: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  MIDIAccess: !1,
  MIDIConnectionEvent: !1,
  MIDIInput: !1,
  MIDIInputMap: !1,
  MIDIMessageEvent: !1,
  MIDIOutput: !1,
  MIDIOutputMap: !1,
  MIDIPort: !1,
  MimeType: !1,
  MimeTypeArray: !1,
  MouseEvent: !1,
  moveBy: !1,
  moveTo: !1,
  MutationEvent: !1,
  MutationObserver: !1,
  MutationRecord: !1,
  name: !1,
  NamedNodeMap: !1,
  NavigationPreloadManager: !1,
  navigator: !1,
  Navigator: !1,
  NetworkInformation: !1,
  Node: !1,
  NodeFilter: !1,
  NodeIterator: !1,
  NodeList: !1,
  Notification: !1,
  OfflineAudioCompletionEvent: !1,
  OfflineAudioContext: !1,
  offscreenBuffering: !1,
  OffscreenCanvas: !0,
  onabort: !0,
  onafterprint: !0,
  onanimationend: !0,
  onanimationiteration: !0,
  onanimationstart: !0,
  onappinstalled: !0,
  onauxclick: !0,
  onbeforeinstallprompt: !0,
  onbeforeprint: !0,
  onbeforeunload: !0,
  onblur: !0,
  oncancel: !0,
  oncanplay: !0,
  oncanplaythrough: !0,
  onchange: !0,
  onclick: !0,
  onclose: !0,
  oncontextmenu: !0,
  oncuechange: !0,
  ondblclick: !0,
  ondevicemotion: !0,
  ondeviceorientation: !0,
  ondeviceorientationabsolute: !0,
  ondrag: !0,
  ondragend: !0,
  ondragenter: !0,
  ondragleave: !0,
  ondragover: !0,
  ondragstart: !0,
  ondrop: !0,
  ondurationchange: !0,
  onemptied: !0,
  onended: !0,
  onerror: !0,
  onfocus: !0,
  ongotpointercapture: !0,
  onhashchange: !0,
  oninput: !0,
  oninvalid: !0,
  onkeydown: !0,
  onkeypress: !0,
  onkeyup: !0,
  onlanguagechange: !0,
  onload: !0,
  onloadeddata: !0,
  onloadedmetadata: !0,
  onloadstart: !0,
  onlostpointercapture: !0,
  onmessage: !0,
  onmessageerror: !0,
  onmousedown: !0,
  onmouseenter: !0,
  onmouseleave: !0,
  onmousemove: !0,
  onmouseout: !0,
  onmouseover: !0,
  onmouseup: !0,
  onmousewheel: !0,
  onoffline: !0,
  ononline: !0,
  onpagehide: !0,
  onpageshow: !0,
  onpause: !0,
  onplay: !0,
  onplaying: !0,
  onpointercancel: !0,
  onpointerdown: !0,
  onpointerenter: !0,
  onpointerleave: !0,
  onpointermove: !0,
  onpointerout: !0,
  onpointerover: !0,
  onpointerup: !0,
  onpopstate: !0,
  onprogress: !0,
  onratechange: !0,
  onrejectionhandled: !0,
  onreset: !0,
  onresize: !0,
  onscroll: !0,
  onsearch: !0,
  onseeked: !0,
  onseeking: !0,
  onselect: !0,
  onstalled: !0,
  onstorage: !0,
  onsubmit: !0,
  onsuspend: !0,
  ontimeupdate: !0,
  ontoggle: !0,
  ontransitionend: !0,
  onunhandledrejection: !0,
  onunload: !0,
  onvolumechange: !0,
  onwaiting: !0,
  onwheel: !0,
  open: !1,
  openDatabase: !1,
  opener: !1,
  Option: !1,
  origin: !1,
  OscillatorNode: !1,
  outerHeight: !1,
  outerWidth: !1,
  PageTransitionEvent: !1,
  pageXOffset: !1,
  pageYOffset: !1,
  PannerNode: !1,
  parent: !1,
  Path2D: !1,
  PaymentAddress: !1,
  PaymentRequest: !1,
  PaymentRequestUpdateEvent: !1,
  PaymentResponse: !1,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceLongTaskTiming: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceNavigationTiming: !1,
  PerformanceObserver: !1,
  PerformanceObserverEntryList: !1,
  PerformancePaintTiming: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  PeriodicWave: !1,
  Permissions: !1,
  PermissionStatus: !1,
  personalbar: !1,
  PhotoCapabilities: !1,
  Plugin: !1,
  PluginArray: !1,
  PointerEvent: !1,
  PopStateEvent: !1,
  postMessage: !1,
  Presentation: !1,
  PresentationAvailability: !1,
  PresentationConnection: !1,
  PresentationConnectionAvailableEvent: !1,
  PresentationConnectionCloseEvent: !1,
  PresentationConnectionList: !1,
  PresentationReceiver: !1,
  PresentationRequest: !1,
  print: !1,
  ProcessingInstruction: !1,
  ProgressEvent: !1,
  PromiseRejectionEvent: !1,
  prompt: !1,
  PushManager: !1,
  PushSubscription: !1,
  PushSubscriptionOptions: !1,
  queueMicrotask: !1,
  RadioNodeList: !1,
  Range: !1,
  ReadableStream: !1,
  registerProcessor: !1,
  RemotePlayback: !1,
  removeEventListener: !1,
  Request: !1,
  requestAnimationFrame: !1,
  requestIdleCallback: !1,
  resizeBy: !1,
  ResizeObserver: !1,
  ResizeObserverEntry: !1,
  resizeTo: !1,
  Response: !1,
  RTCCertificate: !1,
  RTCDataChannel: !1,
  RTCDataChannelEvent: !1,
  RTCDtlsTransport: !1,
  RTCIceCandidate: !1,
  RTCIceGatherer: !1,
  RTCIceTransport: !1,
  RTCPeerConnection: !1,
  RTCPeerConnectionIceEvent: !1,
  RTCRtpContributingSource: !1,
  RTCRtpReceiver: !1,
  RTCRtpSender: !1,
  RTCSctpTransport: !1,
  RTCSessionDescription: !1,
  RTCStatsReport: !1,
  RTCTrackEvent: !1,
  screen: !1,
  Screen: !1,
  screenLeft: !1,
  ScreenOrientation: !1,
  screenTop: !1,
  screenX: !1,
  screenY: !1,
  ScriptProcessorNode: !1,
  scroll: !1,
  scrollbars: !1,
  scrollBy: !1,
  scrollTo: !1,
  scrollX: !1,
  scrollY: !1,
  SecurityPolicyViolationEvent: !1,
  Selection: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerRegistration: !1,
  sessionStorage: !1,
  setInterval: !1,
  setTimeout: !1,
  ShadowRoot: !1,
  SharedWorker: !1,
  SourceBuffer: !1,
  SourceBufferList: !1,
  speechSynthesis: !1,
  SpeechSynthesisEvent: !1,
  SpeechSynthesisUtterance: !1,
  StaticRange: !1,
  status: !1,
  statusbar: !1,
  StereoPannerNode: !1,
  stop: !1,
  Storage: !1,
  StorageEvent: !1,
  StorageManager: !1,
  styleMedia: !1,
  StyleSheet: !1,
  StyleSheetList: !1,
  SubtleCrypto: !1,
  SVGAElement: !1,
  SVGAngle: !1,
  SVGAnimatedAngle: !1,
  SVGAnimatedBoolean: !1,
  SVGAnimatedEnumeration: !1,
  SVGAnimatedInteger: !1,
  SVGAnimatedLength: !1,
  SVGAnimatedLengthList: !1,
  SVGAnimatedNumber: !1,
  SVGAnimatedNumberList: !1,
  SVGAnimatedPreserveAspectRatio: !1,
  SVGAnimatedRect: !1,
  SVGAnimatedString: !1,
  SVGAnimatedTransformList: !1,
  SVGAnimateElement: !1,
  SVGAnimateMotionElement: !1,
  SVGAnimateTransformElement: !1,
  SVGAnimationElement: !1,
  SVGCircleElement: !1,
  SVGClipPathElement: !1,
  SVGComponentTransferFunctionElement: !1,
  SVGDefsElement: !1,
  SVGDescElement: !1,
  SVGDiscardElement: !1,
  SVGElement: !1,
  SVGEllipseElement: !1,
  SVGFEBlendElement: !1,
  SVGFEColorMatrixElement: !1,
  SVGFEComponentTransferElement: !1,
  SVGFECompositeElement: !1,
  SVGFEConvolveMatrixElement: !1,
  SVGFEDiffuseLightingElement: !1,
  SVGFEDisplacementMapElement: !1,
  SVGFEDistantLightElement: !1,
  SVGFEDropShadowElement: !1,
  SVGFEFloodElement: !1,
  SVGFEFuncAElement: !1,
  SVGFEFuncBElement: !1,
  SVGFEFuncGElement: !1,
  SVGFEFuncRElement: !1,
  SVGFEGaussianBlurElement: !1,
  SVGFEImageElement: !1,
  SVGFEMergeElement: !1,
  SVGFEMergeNodeElement: !1,
  SVGFEMorphologyElement: !1,
  SVGFEOffsetElement: !1,
  SVGFEPointLightElement: !1,
  SVGFESpecularLightingElement: !1,
  SVGFESpotLightElement: !1,
  SVGFETileElement: !1,
  SVGFETurbulenceElement: !1,
  SVGFilterElement: !1,
  SVGForeignObjectElement: !1,
  SVGGElement: !1,
  SVGGeometryElement: !1,
  SVGGradientElement: !1,
  SVGGraphicsElement: !1,
  SVGImageElement: !1,
  SVGLength: !1,
  SVGLengthList: !1,
  SVGLinearGradientElement: !1,
  SVGLineElement: !1,
  SVGMarkerElement: !1,
  SVGMaskElement: !1,
  SVGMatrix: !1,
  SVGMetadataElement: !1,
  SVGMPathElement: !1,
  SVGNumber: !1,
  SVGNumberList: !1,
  SVGPathElement: !1,
  SVGPatternElement: !1,
  SVGPoint: !1,
  SVGPointList: !1,
  SVGPolygonElement: !1,
  SVGPolylineElement: !1,
  SVGPreserveAspectRatio: !1,
  SVGRadialGradientElement: !1,
  SVGRect: !1,
  SVGRectElement: !1,
  SVGScriptElement: !1,
  SVGSetElement: !1,
  SVGStopElement: !1,
  SVGStringList: !1,
  SVGStyleElement: !1,
  SVGSVGElement: !1,
  SVGSwitchElement: !1,
  SVGSymbolElement: !1,
  SVGTextContentElement: !1,
  SVGTextElement: !1,
  SVGTextPathElement: !1,
  SVGTextPositioningElement: !1,
  SVGTitleElement: !1,
  SVGTransform: !1,
  SVGTransformList: !1,
  SVGTSpanElement: !1,
  SVGUnitTypes: !1,
  SVGUseElement: !1,
  SVGViewElement: !1,
  TaskAttributionTiming: !1,
  Text: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  TextEvent: !1,
  TextMetrics: !1,
  TextTrack: !1,
  TextTrackCue: !1,
  TextTrackCueList: !1,
  TextTrackList: !1,
  TimeRanges: !1,
  toolbar: !1,
  top: !1,
  Touch: !1,
  TouchEvent: !1,
  TouchList: !1,
  TrackEvent: !1,
  TransitionEvent: !1,
  TreeWalker: !1,
  UIEvent: !1,
  URL: !1,
  URLSearchParams: !1,
  ValidityState: !1,
  visualViewport: !1,
  VisualViewport: !1,
  VTTCue: !1,
  WaveShaperNode: !1,
  WebAssembly: !1,
  WebGL2RenderingContext: !1,
  WebGLActiveInfo: !1,
  WebGLBuffer: !1,
  WebGLContextEvent: !1,
  WebGLFramebuffer: !1,
  WebGLProgram: !1,
  WebGLQuery: !1,
  WebGLRenderbuffer: !1,
  WebGLRenderingContext: !1,
  WebGLSampler: !1,
  WebGLShader: !1,
  WebGLShaderPrecisionFormat: !1,
  WebGLSync: !1,
  WebGLTexture: !1,
  WebGLTransformFeedback: !1,
  WebGLUniformLocation: !1,
  WebGLVertexArrayObject: !1,
  WebSocket: !1,
  WheelEvent: !1,
  window: !1,
  Window: !1,
  Worker: !1,
  WritableStream: !1,
  XMLDocument: !1,
  XMLHttpRequest: !1,
  XMLHttpRequestEventTarget: !1,
  XMLHttpRequestUpload: !1,
  XMLSerializer: !1,
  XPathEvaluator: !1,
  XPathExpression: !1,
  XPathResult: !1,
  XSLTProcessor: !1
}, vI = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Cache: !1,
  caches: !1,
  clearInterval: !1,
  clearTimeout: !1,
  close: !0,
  console: !1,
  fetch: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !0,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onoffline: !0,
  ononline: !0,
  onrejectionhandled: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  removeEventListener: !1,
  Request: !1,
  Response: !1,
  self: !0,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1,
  WebSocket: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  XMLHttpRequest: !1
}, AI = {
  __dirname: !1,
  __filename: !1,
  Buffer: !1,
  clearImmediate: !1,
  clearInterval: !1,
  clearTimeout: !1,
  console: !1,
  exports: !0,
  global: !1,
  Intl: !1,
  module: !1,
  process: !1,
  queueMicrotask: !1,
  require: !1,
  setImmediate: !1,
  setInterval: !1,
  setTimeout: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1
}, CI = {
  exports: !0,
  global: !1,
  module: !1,
  require: !1
}, II = {
  define: !1,
  require: !1
}, wI = {
  after: !1,
  afterEach: !1,
  before: !1,
  beforeEach: !1,
  context: !1,
  describe: !1,
  it: !1,
  mocha: !1,
  run: !1,
  setup: !1,
  specify: !1,
  suite: !1,
  suiteSetup: !1,
  suiteTeardown: !1,
  teardown: !1,
  test: !1,
  xcontext: !1,
  xdescribe: !1,
  xit: !1,
  xspecify: !1
}, OI = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  fail: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jasmine: !1,
  pending: !1,
  runs: !1,
  spyOn: !1,
  spyOnProperty: !1,
  waits: !1,
  waitsFor: !1,
  xdescribe: !1,
  xit: !1
}, NI = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jest: !1,
  pit: !1,
  require: !1,
  test: !1,
  xdescribe: !1,
  xit: !1,
  xtest: !1
}, _I = {
  asyncTest: !1,
  deepEqual: !1,
  equal: !1,
  expect: !1,
  module: !1,
  notDeepEqual: !1,
  notEqual: !1,
  notOk: !1,
  notPropEqual: !1,
  notStrictEqual: !1,
  ok: !1,
  propEqual: !1,
  QUnit: !1,
  raises: !1,
  start: !1,
  stop: !1,
  strictEqual: !1,
  test: !1,
  throws: !1
}, kI = {
  console: !0,
  exports: !0,
  phantom: !0,
  require: !0,
  WebPage: !0
}, DI = {
  emit: !1,
  exports: !1,
  getRow: !1,
  log: !1,
  module: !1,
  provides: !1,
  require: !1,
  respond: !1,
  send: !1,
  start: !1,
  sum: !1
}, LI = {
  defineClass: !1,
  deserialize: !1,
  gc: !1,
  help: !1,
  importClass: !1,
  importPackage: !1,
  java: !1,
  load: !1,
  loadClass: !1,
  Packages: !1,
  print: !1,
  quit: !1,
  readFile: !1,
  readUrl: !1,
  runCommand: !1,
  seal: !1,
  serialize: !1,
  spawn: !1,
  sync: !1,
  toint32: !1,
  version: !1
}, MI = {
  __DIR__: !1,
  __FILE__: !1,
  __LINE__: !1,
  com: !1,
  edu: !1,
  exit: !1,
  java: !1,
  Java: !1,
  javafx: !1,
  JavaImporter: !1,
  javax: !1,
  JSAdapter: !1,
  load: !1,
  loadWithNewGlobal: !1,
  org: !1,
  Packages: !1,
  print: !1,
  quit: !1
}, BI = {
  ActiveXObject: !0,
  Enumerator: !0,
  GetObject: !0,
  ScriptEngine: !0,
  ScriptEngineBuildVersion: !0,
  ScriptEngineMajorVersion: !0,
  ScriptEngineMinorVersion: !0,
  VBArray: !0,
  WScript: !0,
  WSH: !0,
  XDomainRequest: !0
}, FI = {
  $: !1,
  jQuery: !1
}, jI = {
  YAHOO: !1,
  YAHOO_config: !1,
  YUI: !1,
  YUI_config: !1
}, RI = {
  cat: !1,
  cd: !1,
  chmod: !1,
  config: !1,
  cp: !1,
  dirs: !1,
  echo: !1,
  env: !1,
  error: !1,
  exec: !1,
  exit: !1,
  find: !1,
  grep: !1,
  ln: !1,
  ls: !1,
  mkdir: !1,
  mv: !1,
  popd: !1,
  pushd: !1,
  pwd: !1,
  rm: !1,
  sed: !1,
  set: !1,
  target: !1,
  tempdir: !1,
  test: !1,
  touch: !1,
  which: !1
}, UI = {
  $: !1,
  $$: !1,
  $A: !1,
  $break: !1,
  $continue: !1,
  $F: !1,
  $H: !1,
  $R: !1,
  $w: !1,
  Abstract: !1,
  Ajax: !1,
  Autocompleter: !1,
  Builder: !1,
  Class: !1,
  Control: !1,
  Draggable: !1,
  Draggables: !1,
  Droppables: !1,
  Effect: !1,
  Element: !1,
  Enumerable: !1,
  Event: !1,
  Field: !1,
  Form: !1,
  Hash: !1,
  Insertion: !1,
  ObjectRange: !1,
  PeriodicalExecuter: !1,
  Position: !1,
  Prototype: !1,
  Scriptaculous: !1,
  Selector: !1,
  Sortable: !1,
  SortableObserver: !1,
  Sound: !1,
  Template: !1,
  Toggle: !1,
  Try: !1
}, $I = {
  _: !1,
  $: !1,
  Accounts: !1,
  AccountsClient: !1,
  AccountsCommon: !1,
  AccountsServer: !1,
  App: !1,
  Assets: !1,
  Blaze: !1,
  check: !1,
  Cordova: !1,
  DDP: !1,
  DDPRateLimiter: !1,
  DDPServer: !1,
  Deps: !1,
  EJSON: !1,
  Email: !1,
  HTTP: !1,
  Log: !1,
  Match: !1,
  Meteor: !1,
  Mongo: !1,
  MongoInternals: !1,
  Npm: !1,
  Package: !1,
  Plugin: !1,
  process: !1,
  Random: !1,
  ReactiveDict: !1,
  ReactiveVar: !1,
  Router: !1,
  ServiceConfiguration: !1,
  Session: !1,
  share: !1,
  Spacebars: !1,
  Template: !1,
  Tinytest: !1,
  Tracker: !1,
  UI: !1,
  Utils: !1,
  WebApp: !1,
  WebAppInternals: !1
}, VI = {
  _isWindows: !1,
  _rand: !1,
  BulkWriteResult: !1,
  cat: !1,
  cd: !1,
  connect: !1,
  db: !1,
  getHostName: !1,
  getMemInfo: !1,
  hostname: !1,
  ISODate: !1,
  listFiles: !1,
  load: !1,
  ls: !1,
  md5sumFile: !1,
  mkdir: !1,
  Mongo: !1,
  NumberInt: !1,
  NumberLong: !1,
  ObjectId: !1,
  PlanCache: !1,
  print: !1,
  printjson: !1,
  pwd: !1,
  quit: !1,
  removeFile: !1,
  rs: !1,
  sh: !1,
  UUID: !1,
  version: !1,
  WriteResult: !1
}, KI = {
  $: !1,
  Application: !1,
  Automation: !1,
  console: !1,
  delay: !1,
  Library: !1,
  ObjC: !1,
  ObjectSpecifier: !1,
  Path: !1,
  Progress: !1,
  Ref: !1
}, qI = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  clearInterval: !1,
  clearTimeout: !1,
  Client: !1,
  clients: !1,
  Clients: !1,
  close: !0,
  console: !1,
  ExtendableEvent: !1,
  ExtendableMessageEvent: !1,
  fetch: !1,
  FetchEvent: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !1,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onfetch: !0,
  oninstall: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onmessageerror: !0,
  onnotificationclick: !0,
  onnotificationclose: !0,
  onoffline: !0,
  ononline: !0,
  onpush: !0,
  onpushsubscriptionchange: !0,
  onrejectionhandled: !0,
  onsync: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  registration: !1,
  removeEventListener: !1,
  Request: !1,
  Response: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerGlobalScope: !1,
  ServiceWorkerMessageEvent: !1,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  skipWaiting: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1,
  WebSocket: !1,
  WindowClient: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  XMLHttpRequest: !1
}, WI = {
  advanceClock: !1,
  fakeClearInterval: !1,
  fakeClearTimeout: !1,
  fakeSetInterval: !1,
  fakeSetTimeout: !1,
  resetTimeouts: !1,
  waitsForPromise: !1
}, JI = {
  andThen: !1,
  click: !1,
  currentPath: !1,
  currentRouteName: !1,
  currentURL: !1,
  fillIn: !1,
  find: !1,
  findAll: !1,
  findWithAssert: !1,
  keyEvent: !1,
  pauseTest: !1,
  resumeTest: !1,
  triggerEvent: !1,
  visit: !1,
  wait: !1
}, XI = {
  $: !1,
  $$: !1,
  browser: !1,
  by: !1,
  By: !1,
  DartObject: !1,
  element: !1,
  protractor: !1
}, YI = {
  browser: !1,
  chrome: !1,
  opr: !1
}, HI = {
  cloneInto: !1,
  createObjectIn: !1,
  exportFunction: !1,
  GM: !1,
  GM_addStyle: !1,
  GM_deleteValue: !1,
  GM_getResourceText: !1,
  GM_getResourceURL: !1,
  GM_getValue: !1,
  GM_info: !1,
  GM_listValues: !1,
  GM_log: !1,
  GM_openInTab: !1,
  GM_registerMenuCommand: !1,
  GM_setClipboard: !1,
  GM_setValue: !1,
  GM_xmlhttpRequest: !1,
  unsafeWindow: !1
}, GI = {
  $: !1,
  $_: !1,
  $$: !1,
  $0: !1,
  $1: !1,
  $2: !1,
  $3: !1,
  $4: !1,
  $x: !1,
  chrome: !1,
  clear: !1,
  copy: !1,
  debug: !1,
  dir: !1,
  dirxml: !1,
  getEventListeners: !1,
  inspect: !1,
  keys: !1,
  monitor: !1,
  monitorEvents: !1,
  profile: !1,
  profileEnd: !1,
  queryObjects: !1,
  table: !1,
  undebug: !1,
  unmonitor: !1,
  unmonitorEvents: !1,
  values: !1
}, zI = {
  builtin: bI,
  es5: SI,
  es2015: EI,
  es2017: PI,
  browser: xI,
  worker: vI,
  node: AI,
  commonjs: CI,
  amd: II,
  mocha: wI,
  jasmine: OI,
  jest: NI,
  qunit: _I,
  phantomjs: kI,
  couch: DI,
  rhino: LI,
  nashorn: MI,
  wsh: BI,
  jquery: FI,
  yui: jI,
  shelljs: RI,
  prototypejs: UI,
  meteor: $I,
  mongo: VI,
  applescript: KI,
  serviceworker: qI,
  atomtest: WI,
  embertest: JI,
  protractor: XI,
  "shared-node-browser": {
    clearInterval: !1,
    clearTimeout: !1,
    console: !1,
    setInterval: !1,
    setTimeout: !1,
    URL: !1,
    URLSearchParams: !1
  },
  webextensions: YI,
  greasemonkey: HI,
  devtools: GI
};
var QI = zI, il;
function rc() {
  if (il) return Mr;
  il = 1, Object.defineProperty(Mr, "__esModule", {
    value: !0
  }), Mr.default = void 0;
  var e = yI(), t = Us(), r = xs, i = QI, s = Ae(), n = s, a = nt, o = Vt;
  const {
    NOT_LOCAL_BINDING: l,
    callExpression: u,
    cloneNode: c,
    getBindingIdentifiers: f,
    identifier: p,
    isArrayExpression: h,
    isBinary: y,
    isCallExpression: b,
    isClass: A,
    isClassBody: I,
    isClassDeclaration: _,
    isExportAllDeclaration: j,
    isExportDefaultDeclaration: G,
    isExportNamedDeclaration: ce,
    isFunctionDeclaration: te,
    isIdentifier: ae,
    isImportDeclaration: q,
    isLiteral: Y,
    isMemberExpression: re,
    isMethod: W,
    isModuleSpecifier: Q,
    isNullLiteral: U,
    isObjectExpression: L,
    isProperty: k,
    isPureish: F,
    isRegExpLiteral: B,
    isSuper: N,
    isTaggedTemplateExpression: D,
    isTemplateLiteral: R,
    isThisExpression: V,
    isUnaryExpression: $,
    isVariableDeclaration: H,
    matchesPattern: se,
    memberExpression: oe,
    numericLiteral: Ue,
    toIdentifier: fe,
    variableDeclaration: pe,
    variableDeclarator: Se,
    isRecordExpression: Ce,
    isTupleExpression: Ee,
    isObjectProperty: Ne,
    isTopicReference: _e,
    isMetaProperty: qe,
    isPrivateName: tt,
    isExportDeclaration: Pe,
    buildUndefinedNode: Be
  } = s;
  function ve(J, d) {
    switch (J == null ? void 0 : J.type) {
      default:
        if (q(J) || Pe(J)) {
          var x;
          if ((j(J) || ce(J) || q(J)) && J.source)
            ve(J.source, d);
          else if ((ce(J) || q(J)) && (x = J.specifiers) != null && x.length)
            for (const O of J.specifiers) ve(O, d);
          else (G(J) || ce(J)) && J.declaration && ve(J.declaration, d);
        } else Q(J) ? ve(J.local, d) : Y(J) && !U(J) && !B(J) && !R(J) && d.push(J.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        ve(J.object, d), ve(J.property, d);
        break;
      case "Identifier":
      case "JSXIdentifier":
        d.push(J.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        ve(J.callee, d);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (const O of J.properties)
          ve(O, d);
        break;
      case "SpreadElement":
      case "RestElement":
        ve(J.argument, d);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        ve(J.key, d);
        break;
      case "ThisExpression":
        d.push("this");
        break;
      case "Super":
        d.push("super");
        break;
      case "Import":
        d.push("import");
        break;
      case "DoExpression":
        d.push("do");
        break;
      case "YieldExpression":
        d.push("yield"), ve(J.argument, d);
        break;
      case "AwaitExpression":
        d.push("await"), ve(J.argument, d);
        break;
      case "AssignmentExpression":
        ve(J.left, d);
        break;
      case "VariableDeclarator":
        ve(J.id, d);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        ve(J.id, d);
        break;
      case "PrivateName":
        ve(J.id, d);
        break;
      case "ParenthesizedExpression":
        ve(J.expression, d);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        ve(J.argument, d);
        break;
      case "MetaProperty":
        ve(J.meta, d), ve(J.property, d);
        break;
      case "JSXElement":
        ve(J.openingElement, d);
        break;
      case "JSXOpeningElement":
        ve(J.name, d);
        break;
      case "JSXFragment":
        ve(J.openingFragment, d);
        break;
      case "JSXOpeningFragment":
        d.push("Fragment");
        break;
      case "JSXNamespacedName":
        ve(J.namespace, d), ve(J.name, d);
        break;
    }
  }
  const Re = {
    ForStatement(J) {
      const d = J.get("init");
      if (d.isVar()) {
        const {
          scope: x
        } = J;
        (x.getFunctionParent() || x.getProgramParent()).registerBinding("var", d);
      }
    },
    Declaration(J) {
      if (J.isBlockScoped() || J.isImportDeclaration() || J.isExportDeclaration()) return;
      (J.scope.getFunctionParent() || J.scope.getProgramParent()).registerDeclaration(J);
    },
    ImportDeclaration(J) {
      J.scope.getBlockParent().registerDeclaration(J);
    },
    ReferencedIdentifier(J, d) {
      d.references.push(J);
    },
    ForXStatement(J, d) {
      const x = J.get("left");
      if (x.isPattern() || x.isIdentifier())
        d.constantViolations.push(J);
      else if (x.isVar()) {
        const {
          scope: O
        } = J;
        (O.getFunctionParent() || O.getProgramParent()).registerBinding("var", x);
      }
    },
    ExportDeclaration: {
      exit(J) {
        const {
          node: d,
          scope: x
        } = J;
        if (j(d)) return;
        const O = d.declaration;
        if (_(O) || te(O)) {
          const M = O.id;
          if (!M) return;
          const Z = x.getBinding(M.name);
          Z == null || Z.reference(J);
        } else if (H(O))
          for (const M of O.declarations)
            for (const Z of Object.keys(f(M))) {
              const ee = x.getBinding(Z);
              ee == null || ee.reference(J);
            }
      }
    },
    LabeledStatement(J) {
      J.scope.getBlockParent().registerDeclaration(J);
    },
    AssignmentExpression(J, d) {
      d.assignments.push(J);
    },
    UpdateExpression(J, d) {
      d.constantViolations.push(J);
    },
    UnaryExpression(J, d) {
      J.node.operator === "delete" && d.constantViolations.push(J);
    },
    BlockScoped(J) {
      let d = J.scope;
      if (d.path === J && (d = d.parent), d.getBlockParent().registerDeclaration(J), J.isClassDeclaration() && J.node.id) {
        const M = J.node.id.name;
        J.scope.bindings[M] = J.scope.parent.getBinding(M);
      }
    },
    CatchClause(J) {
      J.scope.registerBinding("let", J);
    },
    Function(J) {
      const d = J.get("params");
      for (const x of d)
        J.scope.registerBinding("param", x);
      J.isFunctionExpression() && J.has("id") && !J.get("id").node[l] && J.scope.registerBinding("local", J.get("id"), J);
    },
    ClassExpression(J) {
      J.has("id") && !J.get("id").node[l] && J.scope.registerBinding("local", J.get("id"), J);
    },
    TSTypeAnnotation(J) {
      J.skip();
    }
  };
  let lt = 0;
  class He {
    constructor(d) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      const {
        node: x
      } = d, O = a.scope.get(x);
      if ((O == null ? void 0 : O.path) === d)
        return O;
      a.scope.set(x, this), this.uid = lt++, this.block = x, this.path = d, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var d;
      let x, O = this.path;
      do {
        var M;
        const Z = O.key === "key" || O.listKey === "decorators";
        O = O.parentPath, Z && O.isMethod() && (O = O.parentPath), (M = O) != null && M.isScope() && (x = O);
      } while (O && !x);
      return (d = x) == null ? void 0 : d.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(d, x, O) {
      (0, t.default)(d, x, this, O, this.path);
    }
    generateDeclaredUidIdentifier(d) {
      const x = this.generateUidIdentifier(d);
      return this.push({
        id: x
      }), c(x);
    }
    generateUidIdentifier(d) {
      return p(this.generateUid(d));
    }
    generateUid(d = "temp") {
      d = fe(d).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let x, O = 1;
      do
        x = this._generateUid(d, O), O++;
      while (this.hasLabel(x) || this.hasBinding(x) || this.hasGlobal(x) || this.hasReference(x));
      const M = this.getProgramParent();
      return M.references[x] = !0, M.uids[x] = !0, x;
    }
    _generateUid(d, x) {
      let O = d;
      return x > 1 && (O += x), `_${O}`;
    }
    generateUidBasedOnNode(d, x) {
      const O = [];
      ve(d, O);
      let M = O.join("$");
      return M = M.replace(/^_/, "") || x || "ref", this.generateUid(M.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(d, x) {
      return p(this.generateUidBasedOnNode(d, x));
    }
    isStatic(d) {
      if (V(d) || N(d) || _e(d))
        return !0;
      if (ae(d)) {
        const x = this.getBinding(d.name);
        return x ? x.constant : this.hasBinding(d.name);
      }
      return !1;
    }
    maybeGenerateMemoised(d, x) {
      if (this.isStatic(d))
        return null;
      {
        const O = this.generateUidIdentifierBasedOnNode(d);
        return x ? O : (this.push({
          id: O
        }), c(O));
      }
    }
    checkBlockScopedCollisions(d, x, O, M) {
      if (x === "param" || d.kind === "local") return;
      if (x === "let" || d.kind === "let" || d.kind === "const" || d.kind === "module" || d.kind === "param" && x === "const")
        throw this.hub.buildError(M, `Duplicate declaration "${O}"`, TypeError);
    }
    rename(d, x) {
      const O = this.getBinding(d);
      O && (x || (x = this.generateUidIdentifier(d).name), new e.default(O, d, x).rename(arguments[2]));
    }
    _renameFromMap(d, x, O, M) {
      d[x] && (d[O] = M, d[x] = null);
    }
    dump() {
      const d = "-".repeat(60);
      console.log(d);
      let x = this;
      do {
        console.log("#", x.block.type);
        for (const O of Object.keys(x.bindings)) {
          const M = x.bindings[O];
          console.log(" -", O, {
            constant: M.constant,
            references: M.references,
            violations: M.constantViolations.length,
            kind: M.kind
          });
        }
      } while (x = x.parent);
      console.log(d);
    }
    toArray(d, x, O) {
      if (ae(d)) {
        const ee = this.getBinding(d.name);
        if (ee != null && ee.constant && ee.path.isGenericType("Array"))
          return d;
      }
      if (h(d))
        return d;
      if (ae(d, {
        name: "arguments"
      }))
        return u(oe(oe(oe(p("Array"), p("prototype")), p("slice")), p("call")), [d]);
      let M;
      const Z = [d];
      return x === !0 ? M = "toConsumableArray" : typeof x == "number" ? (Z.push(Ue(x)), M = "slicedToArray") : M = "toArray", O && (Z.unshift(this.hub.addHelper(M)), M = "maybeArrayLike"), u(this.hub.addHelper(M), Z);
    }
    hasLabel(d) {
      return !!this.getLabel(d);
    }
    getLabel(d) {
      return this.labels.get(d);
    }
    registerLabel(d) {
      this.labels.set(d.node.label.name, d);
    }
    registerDeclaration(d) {
      if (d.isLabeledStatement())
        this.registerLabel(d);
      else if (d.isFunctionDeclaration())
        this.registerBinding("hoisted", d.get("id"), d);
      else if (d.isVariableDeclaration()) {
        const x = d.get("declarations"), {
          kind: O
        } = d.node;
        for (const M of x)
          this.registerBinding(O === "using" || O === "await using" ? "const" : O, M);
      } else if (d.isClassDeclaration()) {
        if (d.node.declare) return;
        this.registerBinding("let", d);
      } else if (d.isImportDeclaration()) {
        const x = d.node.importKind === "type" || d.node.importKind === "typeof", O = d.get("specifiers");
        for (const M of O) {
          const Z = x || M.isImportSpecifier() && (M.node.importKind === "type" || M.node.importKind === "typeof");
          this.registerBinding(Z ? "unknown" : "module", M);
        }
      } else if (d.isExportDeclaration()) {
        const x = d.get("declaration");
        (x.isClassDeclaration() || x.isFunctionDeclaration() || x.isVariableDeclaration()) && this.registerDeclaration(x);
      } else
        this.registerBinding("unknown", d);
    }
    buildUndefinedNode() {
      return Be();
    }
    registerConstantViolation(d) {
      const x = d.getBindingIdentifiers();
      for (const M of Object.keys(x)) {
        var O;
        (O = this.getBinding(M)) == null || O.reassign(d);
      }
    }
    registerBinding(d, x, O = x) {
      if (!d) throw new ReferenceError("no `kind`");
      if (x.isVariableDeclaration()) {
        const ee = x.get("declarations");
        for (const ge of ee)
          this.registerBinding(d, ge);
        return;
      }
      const M = this.getProgramParent(), Z = x.getOuterBindingIdentifiers(!0);
      for (const ee of Object.keys(Z)) {
        M.references[ee] = !0;
        for (const ge of Z[ee]) {
          const xe = this.getOwnBinding(ee);
          if (xe) {
            if (xe.identifier === ge) continue;
            this.checkBlockScopedCollisions(xe, d, ee, ge);
          }
          xe ? xe.reassign(O) : this.bindings[ee] = new r.default({
            identifier: ge,
            scope: this,
            path: O,
            kind: d
          });
        }
      }
    }
    addGlobal(d) {
      this.globals[d.name] = d;
    }
    hasUid(d) {
      let x = this;
      do
        if (x.uids[d]) return !0;
      while (x = x.parent);
      return !1;
    }
    hasGlobal(d) {
      let x = this;
      do
        if (x.globals[d]) return !0;
      while (x = x.parent);
      return !1;
    }
    hasReference(d) {
      return !!this.getProgramParent().references[d];
    }
    isPure(d, x) {
      if (ae(d)) {
        const ee = this.getBinding(d.name);
        return ee ? x ? ee.constant : !0 : !1;
      } else {
        if (V(d) || qe(d) || _e(d) || tt(d))
          return !0;
        if (A(d)) {
          var O;
          return d.superClass && !this.isPure(d.superClass, x) || ((O = d.decorators) == null ? void 0 : O.length) > 0 ? !1 : this.isPure(d.body, x);
        } else if (I(d)) {
          for (const ee of d.body)
            if (!this.isPure(ee, x)) return !1;
          return !0;
        } else {
          if (y(d))
            return this.isPure(d.left, x) && this.isPure(d.right, x);
          if (h(d) || Ee(d)) {
            for (const ee of d.elements)
              if (ee !== null && !this.isPure(ee, x)) return !1;
            return !0;
          } else if (L(d) || Ce(d)) {
            for (const ee of d.properties)
              if (!this.isPure(ee, x)) return !1;
            return !0;
          } else if (W(d)) {
            var M;
            return !(d.computed && !this.isPure(d.key, x) || ((M = d.decorators) == null ? void 0 : M.length) > 0);
          } else if (k(d)) {
            var Z;
            return !(d.computed && !this.isPure(d.key, x) || ((Z = d.decorators) == null ? void 0 : Z.length) > 0 || (Ne(d) || d.static) && d.value !== null && !this.isPure(d.value, x));
          } else {
            if ($(d))
              return this.isPure(d.argument, x);
            if (R(d)) {
              for (const ee of d.expressions)
                if (!this.isPure(ee, x)) return !1;
              return !0;
            } else return D(d) ? se(d.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(d.quasi, x) : re(d) ? !d.computed && ae(d.object) && d.object.name === "Symbol" && ae(d.property) && d.property.name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : b(d) ? se(d.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && d.arguments.length === 1 && n.isStringLiteral(d.arguments[0]) : F(d);
          }
        }
      }
    }
    setData(d, x) {
      return this.data[d] = x;
    }
    getData(d) {
      let x = this;
      do {
        const O = x.data[d];
        if (O != null) return O;
      } while (x = x.parent);
    }
    removeData(d) {
      let x = this;
      do
        x.data[d] != null && (x.data[d] = null);
      while (x = x.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      const d = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      const x = this.getProgramParent();
      if (x.crawling) return;
      const O = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, d.type !== "Program" && (0, o.isExplodedVisitor)(Re)) {
        for (const Z of Re.enter)
          Z.call(O, d, O);
        const M = Re[d.type];
        if (M)
          for (const Z of M.enter)
            Z.call(O, d, O);
      }
      d.traverse(Re, O), this.crawling = !1;
      for (const M of O.assignments) {
        const Z = M.getBindingIdentifiers();
        for (const ee of Object.keys(Z))
          M.scope.getBinding(ee) || x.addGlobal(Z[ee]);
        M.scope.registerConstantViolation(M);
      }
      for (const M of O.references) {
        const Z = M.scope.getBinding(M.node.name);
        Z ? Z.reference(M) : x.addGlobal(M.node);
      }
      for (const M of O.constantViolations)
        M.scope.registerConstantViolation(M);
    }
    push(d) {
      let x = this.path;
      x.isPattern() ? x = this.getPatternParent().path : !x.isBlockStatement() && !x.isProgram() && (x = this.getBlockParent().path), x.isSwitchStatement() && (x = (this.getFunctionParent() || this.getProgramParent()).path);
      const {
        init: O,
        unique: M,
        kind: Z = "var",
        id: ee
      } = d;
      if (!O && !M && (Z === "var" || Z === "let") && x.isFunction() && !x.node.name && b(x.parent, {
        callee: x.node
      }) && x.parent.arguments.length <= x.node.params.length && ae(ee)) {
        x.pushContainer("params", ee), x.scope.registerBinding("param", x.get("params")[x.node.params.length - 1]);
        return;
      }
      (x.isLoop() || x.isCatchClause() || x.isFunction()) && (x.ensureBlock(), x = x.get("body"));
      const ge = d._blockHoist == null ? 2 : d._blockHoist, xe = `declaration:${Z}:${ge}`;
      let ye = !M && x.getData(xe);
      if (!ye) {
        const Ve = pe(Z, []);
        Ve._blockHoist = ge, [ye] = x.unshiftContainer("body", [Ve]), M || x.setData(xe, ye);
      }
      const X = Se(ee, O), rt = ye.node.declarations.push(X);
      x.scope.registerBinding(Z, ye.get("declarations")[rt - 1]);
    }
    getProgramParent() {
      let d = this;
      do
        if (d.path.isProgram())
          return d;
      while (d = d.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let d = this;
      do
        if (d.path.isFunctionParent())
          return d;
      while (d = d.parent);
      return null;
    }
    getBlockParent() {
      let d = this;
      do
        if (d.path.isBlockParent())
          return d;
      while (d = d.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let d = this;
      do
        if (!d.path.isPattern())
          return d.getBlockParent();
      while (d = d.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const d = /* @__PURE__ */ Object.create(null);
      let x = this;
      do {
        for (const O of Object.keys(x.bindings))
          O in d || (d[O] = x.bindings[O]);
        x = x.parent;
      } while (x);
      return d;
    }
    getAllBindingsOfKind(...d) {
      const x = /* @__PURE__ */ Object.create(null);
      for (const O of d) {
        let M = this;
        do {
          for (const Z of Object.keys(M.bindings)) {
            const ee = M.bindings[Z];
            ee.kind === O && (x[Z] = ee);
          }
          M = M.parent;
        } while (M);
      }
      return x;
    }
    bindingIdentifierEquals(d, x) {
      return this.getBindingIdentifier(d) === x;
    }
    getBinding(d) {
      let x = this, O;
      do {
        const Z = x.getOwnBinding(d);
        if (Z) {
          var M;
          if (!((M = O) != null && M.isPattern() && Z.kind !== "param" && Z.kind !== "local")) return Z;
        } else if (!Z && d === "arguments" && x.path.isFunction() && !x.path.isArrowFunctionExpression())
          break;
        O = x.path;
      } while (x = x.parent);
    }
    getOwnBinding(d) {
      return this.bindings[d];
    }
    getBindingIdentifier(d) {
      var x;
      return (x = this.getBinding(d)) == null ? void 0 : x.identifier;
    }
    getOwnBindingIdentifier(d) {
      const x = this.bindings[d];
      return x == null ? void 0 : x.identifier;
    }
    hasOwnBinding(d) {
      return !!this.getOwnBinding(d);
    }
    hasBinding(d, x) {
      if (!d) return !1;
      let O = this;
      do
        if (O.hasOwnBinding(d))
          return !0;
      while (O = O.parent);
      let M, Z;
      return typeof x == "object" ? (M = x.noGlobals, Z = x.noUids) : typeof x == "boolean" && (M = x), !!(!Z && this.hasUid(d) || !M && He.globals.includes(d) || !M && He.contextVariables.includes(d));
    }
    parentHasBinding(d, x) {
      var O;
      return (O = this.parent) == null ? void 0 : O.hasBinding(d, x);
    }
    moveBindingTo(d, x) {
      const O = this.getBinding(d);
      O && (O.scope.removeOwnBinding(d), O.scope = x, x.bindings[d] = O);
    }
    removeOwnBinding(d) {
      delete this.bindings[d];
    }
    removeBinding(d) {
      var x;
      (x = this.getBinding(d)) == null || x.scope.removeOwnBinding(d);
      let O = this;
      do
        O.uids[d] && (O.uids[d] = !1);
      while (O = O.parent);
    }
  }
  return Mr.default = He, He.globals = Object.keys(i.builtin), He.contextVariables = ["arguments", "undefined", "Infinity", "NaN"], Mr;
}
var vs = {}, As = {}, wn = { exports: {} }, $i = { exports: {} }, sl;
function ZI() {
  return sl || (sl = 1, function(e, t) {
    (function(r, i) {
      i(t);
    })(ur, function(r) {
      class i {
        constructor() {
          this._indexes = { __proto__: null }, this.array = [];
        }
      }
      function s(u) {
        return u;
      }
      function n(u, c) {
        return u._indexes[c];
      }
      function a(u, c) {
        const f = n(u, c);
        if (f !== void 0)
          return f;
        const { array: p, _indexes: h } = u, y = p.push(c);
        return h[c] = y - 1;
      }
      function o(u) {
        const { array: c, _indexes: f } = u;
        if (c.length === 0)
          return;
        const p = c.pop();
        f[p] = void 0;
      }
      function l(u, c) {
        const f = n(u, c);
        if (f === void 0)
          return;
        const { array: p, _indexes: h } = u;
        for (let y = f + 1; y < p.length; y++) {
          const b = p[y];
          p[y - 1] = b, h[b]--;
        }
        h[c] = void 0, p.pop();
      }
      r.SetArray = i, r.get = n, r.pop = o, r.put = a, r.remove = l, Object.defineProperty(r, "__esModule", { value: !0 });
    });
  }($i, $i.exports)), $i.exports;
}
var Vi = { exports: {} }, nl;
function ic() {
  return nl || (nl = 1, function(e, t) {
    (function(r, i) {
      i(t);
    })(ur, function(r) {
      const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = new Uint8Array(64), o = new Uint8Array(128);
      for (let W = 0; W < n.length; W++) {
        const Q = n.charCodeAt(W);
        a[W] = Q, o[Q] = W;
      }
      function l(W, Q) {
        let U = 0, L = 0, k = 0;
        do {
          const B = W.next();
          k = o[B], U |= (k & 31) << L, L += 5;
        } while (k & 32);
        const F = U & 1;
        return U >>>= 1, F && (U = -2147483648 | -U), Q + U;
      }
      function u(W, Q, U) {
        let L = Q - U;
        L = L < 0 ? -L << 1 | 1 : L << 1;
        do {
          let k = L & 31;
          L >>>= 5, L > 0 && (k |= 32), W.write(a[k]);
        } while (L > 0);
        return Q;
      }
      function c(W, Q) {
        return W.pos >= Q ? !1 : W.peek() !== 44;
      }
      const f = 1024 * 16, p = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
        decode(W) {
          return Buffer.from(W.buffer, W.byteOffset, W.byteLength).toString();
        }
      } : {
        decode(W) {
          let Q = "";
          for (let U = 0; U < W.length; U++)
            Q += String.fromCharCode(W[U]);
          return Q;
        }
      };
      class h {
        constructor() {
          this.pos = 0, this.out = "", this.buffer = new Uint8Array(f);
        }
        write(Q) {
          const { buffer: U } = this;
          U[this.pos++] = Q, this.pos === f && (this.out += p.decode(U), this.pos = 0);
        }
        flush() {
          const { buffer: Q, out: U, pos: L } = this;
          return L > 0 ? U + p.decode(Q.subarray(0, L)) : U;
        }
      }
      class y {
        constructor(Q) {
          this.pos = 0, this.buffer = Q;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(Q) {
          const { buffer: U, pos: L } = this, k = U.indexOf(Q, L);
          return k === -1 ? U.length : k;
        }
      }
      const b = [];
      function A(W) {
        const { length: Q } = W, U = new y(W), L = [], k = [];
        let F = 0;
        for (; U.pos < Q; U.pos++) {
          F = l(U, F);
          const B = l(U, 0);
          if (!c(U, Q)) {
            const H = k.pop();
            H[2] = F, H[3] = B;
            continue;
          }
          const N = l(U, 0), V = l(U, 0) & 1 ? [F, B, 0, 0, N, l(U, 0)] : [F, B, 0, 0, N];
          let $ = b;
          if (c(U, Q)) {
            $ = [];
            do {
              const H = l(U, 0);
              $.push(H);
            } while (c(U, Q));
          }
          V.vars = $, L.push(V), k.push(V);
        }
        return L;
      }
      function I(W) {
        const Q = new h();
        for (let U = 0; U < W.length; )
          U = _(W, U, Q, [0]);
        return Q.flush();
      }
      function _(W, Q, U, L) {
        const k = W[Q], { 0: F, 1: B, 2: N, 3: D, 4: R, vars: V } = k;
        Q > 0 && U.write(44), L[0] = u(U, F, L[0]), u(U, B, 0), u(U, R, 0);
        const $ = k.length === 6 ? 1 : 0;
        u(U, $, 0), k.length === 6 && u(U, k[5], 0);
        for (const H of V)
          u(U, H, 0);
        for (Q++; Q < W.length; ) {
          const H = W[Q], { 0: se, 1: oe } = H;
          if (se > N || se === N && oe >= D)
            break;
          Q = _(W, Q, U, L);
        }
        return U.write(44), L[0] = u(U, N, L[0]), u(U, D, 0), Q;
      }
      function j(W) {
        const { length: Q } = W, U = new y(W), L = [], k = [];
        let F = 0, B = 0, N = 0, D = 0, R = 0, V = 0, $ = 0, H = 0;
        do {
          const se = U.indexOf(";");
          let oe = 0;
          for (; U.pos < se; U.pos++) {
            if (oe = l(U, oe), !c(U, se)) {
              const _e = k.pop();
              _e[2] = F, _e[3] = oe;
              continue;
            }
            const Ue = l(U, 0), fe = Ue & 1, pe = Ue & 2, Se = Ue & 4;
            let Ce = null, Ee = b, Ne;
            if (fe) {
              const _e = l(U, B);
              N = l(U, B === _e ? N : 0), B = _e, Ne = [F, oe, 0, 0, _e, N];
            } else
              Ne = [F, oe, 0, 0];
            if (Ne.isScope = !!Se, pe) {
              const _e = D, qe = R;
              D = l(U, D);
              const tt = _e === D;
              R = l(U, tt ? R : 0), V = l(U, tt && qe === R ? V : 0), Ce = [D, R, V];
            }
            if (Ne.callsite = Ce, c(U, se)) {
              Ee = [];
              do {
                $ = F, H = oe;
                const _e = l(U, 0);
                let qe;
                if (_e < -1) {
                  qe = [[l(U, 0)]];
                  for (let tt = -1; tt > _e; tt--) {
                    const Pe = $;
                    $ = l(U, $), H = l(U, $ === Pe ? H : 0);
                    const Be = l(U, 0);
                    qe.push([Be, $, H]);
                  }
                } else
                  qe = [[_e]];
                Ee.push(qe);
              } while (c(U, se));
            }
            Ne.bindings = Ee, L.push(Ne), k.push(Ne);
          }
          F++, U.pos = se + 1;
        } while (U.pos < Q);
        return L;
      }
      function G(W) {
        if (W.length === 0)
          return "";
        const Q = new h();
        for (let U = 0; U < W.length; )
          U = ce(W, U, Q, [0, 0, 0, 0, 0, 0, 0]);
        return Q.flush();
      }
      function ce(W, Q, U, L) {
        const k = W[Q], { 0: F, 1: B, 2: N, 3: D, isScope: R, callsite: V, bindings: $ } = k;
        L[0] < F ? (te(U, L[0], F), L[0] = F, L[1] = 0) : Q > 0 && U.write(44), L[1] = u(U, k[1], L[1]);
        const H = (k.length === 6 ? 1 : 0) | (V ? 2 : 0) | (R ? 4 : 0);
        if (u(U, H, 0), k.length === 6) {
          const { 4: se, 5: oe } = k;
          se !== L[2] && (L[3] = 0), L[2] = u(U, se, L[2]), L[3] = u(U, oe, L[3]);
        }
        if (V) {
          const { 0: se, 1: oe, 2: Ue } = k.callsite;
          se !== L[4] ? (L[5] = 0, L[6] = 0) : oe !== L[5] && (L[6] = 0), L[4] = u(U, se, L[4]), L[5] = u(U, oe, L[5]), L[6] = u(U, Ue, L[6]);
        }
        if ($)
          for (const se of $) {
            se.length > 1 && u(U, -se.length, 0);
            const oe = se[0][0];
            u(U, oe, 0);
            let Ue = F, fe = B;
            for (let pe = 1; pe < se.length; pe++) {
              const Se = se[pe];
              Ue = u(U, Se[1], Ue), fe = u(U, Se[2], fe), u(U, Se[0], 0);
            }
          }
        for (Q++; Q < W.length; ) {
          const se = W[Q], { 0: oe, 1: Ue } = se;
          if (oe > N || oe === N && Ue >= D)
            break;
          Q = ce(W, Q, U, L);
        }
        return L[0] < N ? (te(U, L[0], N), L[0] = N, L[1] = 0) : U.write(44), L[1] = u(U, D, L[1]), Q;
      }
      function te(W, Q, U) {
        do
          W.write(59);
        while (++Q < U);
      }
      function ae(W) {
        const { length: Q } = W, U = new y(W), L = [];
        let k = 0, F = 0, B = 0, N = 0, D = 0;
        do {
          const R = U.indexOf(";"), V = [];
          let $ = !0, H = 0;
          for (k = 0; U.pos < R; ) {
            let se;
            k = l(U, k), k < H && ($ = !1), H = k, c(U, R) ? (F = l(U, F), B = l(U, B), N = l(U, N), c(U, R) ? (D = l(U, D), se = [k, F, B, N, D]) : se = [k, F, B, N]) : se = [k], V.push(se), U.pos++;
          }
          $ || q(V), L.push(V), U.pos = R + 1;
        } while (U.pos <= Q);
        return L;
      }
      function q(W) {
        W.sort(Y);
      }
      function Y(W, Q) {
        return W[0] - Q[0];
      }
      function re(W) {
        const Q = new h();
        let U = 0, L = 0, k = 0, F = 0;
        for (let B = 0; B < W.length; B++) {
          const N = W[B];
          if (B > 0 && Q.write(59), N.length === 0)
            continue;
          let D = 0;
          for (let R = 0; R < N.length; R++) {
            const V = N[R];
            R > 0 && Q.write(44), D = u(Q, V[0], D), V.length !== 1 && (U = u(Q, V[1], U), L = u(Q, V[2], L), k = u(Q, V[3], k), V.length !== 4 && (F = u(Q, V[4], F)));
          }
        }
        return Q.flush();
      }
      r.decode = ae, r.decodeGeneratedRanges = j, r.decodeOriginalScopes = A, r.encode = re, r.encodeGeneratedRanges = G, r.encodeOriginalScopes = I, Object.defineProperty(r, "__esModule", { value: !0 });
    });
  }(Vi, Vi.exports)), Vi.exports;
}
var On = { exports: {} }, zs = { exports: {} }, al;
function ew() {
  return al || (al = 1, function(e, t) {
    (function(r, i) {
      e.exports = i();
    })(ur, function() {
      const r = /^[\w+.-]+:\/\//, i = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, s = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function n(_) {
        return r.test(_);
      }
      function a(_) {
        return _.startsWith("//");
      }
      function o(_) {
        return _.startsWith("/");
      }
      function l(_) {
        return _.startsWith("file:");
      }
      function u(_) {
        return /^[.?#]/.test(_);
      }
      function c(_) {
        const j = i.exec(_);
        return p(j[1], j[2] || "", j[3], j[4] || "", j[5] || "/", j[6] || "", j[7] || "");
      }
      function f(_) {
        const j = s.exec(_), G = j[2];
        return p("file:", "", j[1] || "", "", o(G) ? G : "/" + G, j[3] || "", j[4] || "");
      }
      function p(_, j, G, ce, te, ae, q) {
        return {
          scheme: _,
          user: j,
          host: G,
          port: ce,
          path: te,
          query: ae,
          hash: q,
          type: 7
        };
      }
      function h(_) {
        if (a(_)) {
          const G = c("http:" + _);
          return G.scheme = "", G.type = 6, G;
        }
        if (o(_)) {
          const G = c("http://foo.com" + _);
          return G.scheme = "", G.host = "", G.type = 5, G;
        }
        if (l(_))
          return f(_);
        if (n(_))
          return c(_);
        const j = c("http://foo.com/" + _);
        return j.scheme = "", j.host = "", j.type = _ ? _.startsWith("?") ? 3 : _.startsWith("#") ? 2 : 4 : 1, j;
      }
      function y(_) {
        if (_.endsWith("/.."))
          return _;
        const j = _.lastIndexOf("/");
        return _.slice(0, j + 1);
      }
      function b(_, j) {
        A(j, j.type), _.path === "/" ? _.path = j.path : _.path = y(j.path) + _.path;
      }
      function A(_, j) {
        const G = j <= 4, ce = _.path.split("/");
        let te = 1, ae = 0, q = !1;
        for (let re = 1; re < ce.length; re++) {
          const W = ce[re];
          if (!W) {
            q = !0;
            continue;
          }
          if (q = !1, W !== ".") {
            if (W === "..") {
              ae ? (q = !0, ae--, te--) : G && (ce[te++] = W);
              continue;
            }
            ce[te++] = W, ae++;
          }
        }
        let Y = "";
        for (let re = 1; re < te; re++)
          Y += "/" + ce[re];
        (!Y || q && !Y.endsWith("/..")) && (Y += "/"), _.path = Y;
      }
      function I(_, j) {
        if (!_ && !j)
          return "";
        const G = h(_);
        let ce = G.type;
        if (j && ce !== 7) {
          const ae = h(j), q = ae.type;
          switch (ce) {
            case 1:
              G.hash = ae.hash;
            case 2:
              G.query = ae.query;
            case 3:
            case 4:
              b(G, ae);
            case 5:
              G.user = ae.user, G.host = ae.host, G.port = ae.port;
            case 6:
              G.scheme = ae.scheme;
          }
          q > ce && (ce = q);
        }
        A(G, ce);
        const te = G.query + G.hash;
        switch (ce) {
          case 2:
          case 3:
            return te;
          case 4: {
            const ae = G.path.slice(1);
            return ae ? u(j || _) && !u(ae) ? "./" + ae + te : ae + te : te || ".";
          }
          case 5:
            return G.path + te;
          default:
            return G.scheme + "//" + G.user + G.host + G.port + G.path + te;
        }
      }
      return I;
    });
  }(zs)), zs.exports;
}
(function(e, t) {
  (function(r, i) {
    i(t, ic(), ew());
  })(ur, function(r, i, s) {
    function n(d, x) {
      return x && !x.endsWith("/") && (x += "/"), s(d, x);
    }
    function a(d) {
      if (!d)
        return "";
      const x = d.lastIndexOf("/");
      return d.slice(0, x + 1);
    }
    const o = 0, l = 1, u = 2, c = 3, f = 4, p = 1, h = 2;
    function y(d, x) {
      const O = b(d, 0);
      if (O === d.length)
        return d;
      x || (d = d.slice());
      for (let M = O; M < d.length; M = b(d, M + 1))
        d[M] = I(d[M], x);
      return d;
    }
    function b(d, x) {
      for (let O = x; O < d.length; O++)
        if (!A(d[O]))
          return O;
      return d.length;
    }
    function A(d) {
      for (let x = 1; x < d.length; x++)
        if (d[x][o] < d[x - 1][o])
          return !1;
      return !0;
    }
    function I(d, x) {
      return x || (d = d.slice()), d.sort(_);
    }
    function _(d, x) {
      return d[o] - x[o];
    }
    let j = !1;
    function G(d, x, O, M) {
      for (; O <= M; ) {
        const Z = O + (M - O >> 1), ee = d[Z][o] - x;
        if (ee === 0)
          return j = !0, Z;
        ee < 0 ? O = Z + 1 : M = Z - 1;
      }
      return j = !1, O - 1;
    }
    function ce(d, x, O) {
      for (let M = O + 1; M < d.length && d[M][o] === x; O = M++)
        ;
      return O;
    }
    function te(d, x, O) {
      for (let M = O - 1; M >= 0 && d[M][o] === x; O = M--)
        ;
      return O;
    }
    function ae() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    function q(d, x, O, M) {
      const { lastKey: Z, lastNeedle: ee, lastIndex: ge } = O;
      let xe = 0, ye = d.length - 1;
      if (M === Z) {
        if (x === ee)
          return j = ge !== -1 && d[ge][o] === x, ge;
        x >= ee ? xe = ge === -1 ? 0 : ge : ye = ge;
      }
      return O.lastKey = M, O.lastNeedle = x, O.lastIndex = G(d, x, xe, ye);
    }
    function Y(d, x) {
      const O = x.map(W);
      for (let M = 0; M < d.length; M++) {
        const Z = d[M];
        for (let ee = 0; ee < Z.length; ee++) {
          const ge = Z[ee];
          if (ge.length === 1)
            continue;
          const xe = ge[l], ye = ge[u], X = ge[c], rt = O[xe], Ve = rt[ye] || (rt[ye] = []), We = x[xe];
          let it = ce(Ve, X, q(Ve, X, We, ye));
          We.lastIndex = ++it, re(Ve, it, [X, M, ge[o]]);
        }
      }
      return O;
    }
    function re(d, x, O) {
      for (let M = d.length; M > x; M--)
        d[M] = d[M - 1];
      d[x] = O;
    }
    function W() {
      return { __proto__: null };
    }
    const Q = function(d, x) {
      const O = U(d);
      if (!("sections" in O))
        return new $(O, x);
      const M = [], Z = [], ee = [], ge = [], xe = [];
      L(O, x, M, Z, ee, ge, xe, 0, 0, 1 / 0, 1 / 0);
      const ye = {
        version: 3,
        file: O.file,
        names: ge,
        sources: Z,
        sourcesContent: ee,
        mappings: M,
        ignoreList: xe
      };
      return qe(ye);
    };
    function U(d) {
      return typeof d == "string" ? JSON.parse(d) : d;
    }
    function L(d, x, O, M, Z, ee, ge, xe, ye, X, rt) {
      const { sections: Ve } = d;
      for (let We = 0; We < Ve.length; We++) {
        const { map: it, offset: dt } = Ve[We];
        let v = X, he = rt;
        if (We + 1 < Ve.length) {
          const Fe = Ve[We + 1].offset;
          v = Math.min(X, xe + Fe.line), v === X ? he = Math.min(rt, ye + Fe.column) : v < X && (he = ye + Fe.column);
        }
        k(it, x, O, M, Z, ee, ge, xe + dt.line, ye + dt.column, v, he);
      }
    }
    function k(d, x, O, M, Z, ee, ge, xe, ye, X, rt) {
      const Ve = U(d);
      if ("sections" in Ve)
        return L(...arguments);
      const We = new $(Ve, x), it = M.length, dt = ee.length, v = oe(We), { resolvedSources: he, sourcesContent: Fe, ignoreList: bt } = We;
      if (F(M, he), F(ee, We.names), Fe)
        F(Z, Fe);
      else
        for (let mt = 0; mt < he.length; mt++)
          Z.push(null);
      if (bt)
        for (let mt = 0; mt < bt.length; mt++)
          ge.push(bt[mt] + it);
      for (let mt = 0; mt < v.length; mt++) {
        const Cr = xe + mt;
        if (Cr > X)
          return;
        const Ti = B(O, Cr), $s = mt === 0 ? ye : 0, gi = v[mt];
        for (let Ir = 0; Ir < gi.length; Ir++) {
          const Ot = gi[Ir], yr = $s + Ot[o];
          if (Cr === X && yr >= rt)
            return;
          if (Ot.length === 1) {
            Ti.push([yr]);
            continue;
          }
          const bi = it + Ot[l], Si = Ot[u], Ei = Ot[c];
          Ti.push(Ot.length === 4 ? [yr, bi, Si, Ei] : [yr, bi, Si, Ei, dt + Ot[f]]);
        }
      }
    }
    function F(d, x) {
      for (let O = 0; O < x.length; O++)
        d.push(x[O]);
    }
    function B(d, x) {
      for (let O = d.length; O <= x; O++)
        d[O] = [];
      return d[x];
    }
    const N = "`line` must be greater than 0 (lines start at line 1)", D = "`column` must be greater than or equal to 0 (columns start at column 0)", R = -1, V = 1;
    class $ {
      constructor(x, O) {
        const M = typeof x == "string";
        if (!M && x._decodedMemo)
          return x;
        const Z = M ? JSON.parse(x) : x, { version: ee, file: ge, names: xe, sourceRoot: ye, sources: X, sourcesContent: rt } = Z;
        this.version = ee, this.file = ge, this.names = xe || [], this.sourceRoot = ye, this.sources = X, this.sourcesContent = rt, this.ignoreList = Z.ignoreList || Z.x_google_ignoreList || void 0;
        const Ve = n(ye || "", a(O));
        this.resolvedSources = X.map((it) => n(it || "", Ve));
        const { mappings: We } = Z;
        typeof We == "string" ? (this._encoded = We, this._decoded = void 0) : (this._encoded = void 0, this._decoded = y(We, M)), this._decodedMemo = ae(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    function H(d) {
      return d;
    }
    function se(d) {
      var x, O;
      return (x = (O = d)._encoded) !== null && x !== void 0 ? x : O._encoded = i.encode(d._decoded);
    }
    function oe(d) {
      var x;
      return (x = d)._decoded || (x._decoded = i.decode(d._encoded));
    }
    function Ue(d, x, O) {
      const M = oe(d);
      if (x >= M.length)
        return null;
      const Z = M[x], ee = lt(Z, d._decodedMemo, x, O, V);
      return ee === -1 ? null : Z[ee];
    }
    function fe(d, x) {
      let { line: O, column: M, bias: Z } = x;
      if (O--, O < 0)
        throw new Error(N);
      if (M < 0)
        throw new Error(D);
      const ee = oe(d);
      if (O >= ee.length)
        return ve(null, null, null, null);
      const ge = ee[O], xe = lt(ge, d._decodedMemo, O, M, Z || V);
      if (xe === -1)
        return ve(null, null, null, null);
      const ye = ge[xe];
      if (ye.length === 1)
        return ve(null, null, null, null);
      const { names: X, resolvedSources: rt } = d;
      return ve(rt[ye[l]], ye[u] + 1, ye[c], ye.length === 5 ? X[ye[f]] : null);
    }
    function pe(d, x) {
      const { source: O, line: M, column: Z, bias: ee } = x;
      return J(d, O, M, Z, ee || V, !1);
    }
    function Se(d, x) {
      const { source: O, line: M, column: Z, bias: ee } = x;
      return J(d, O, M, Z, ee || R, !0);
    }
    function Ce(d, x) {
      const O = oe(d), { names: M, resolvedSources: Z } = d;
      for (let ee = 0; ee < O.length; ee++) {
        const ge = O[ee];
        for (let xe = 0; xe < ge.length; xe++) {
          const ye = ge[xe], X = ee + 1, rt = ye[0];
          let Ve = null, We = null, it = null, dt = null;
          ye.length !== 1 && (Ve = Z[ye[1]], We = ye[2] + 1, it = ye[3]), ye.length === 5 && (dt = M[ye[4]]), x({
            generatedLine: X,
            generatedColumn: rt,
            source: Ve,
            originalLine: We,
            originalColumn: it,
            name: dt
          });
        }
      }
    }
    function Ee(d, x) {
      const { sources: O, resolvedSources: M } = d;
      let Z = O.indexOf(x);
      return Z === -1 && (Z = M.indexOf(x)), Z;
    }
    function Ne(d, x) {
      const { sourcesContent: O } = d;
      if (O == null)
        return null;
      const M = Ee(d, x);
      return M === -1 ? null : O[M];
    }
    function _e(d, x) {
      const { ignoreList: O } = d;
      if (O == null)
        return !1;
      const M = Ee(d, x);
      return M === -1 ? !1 : O.includes(M);
    }
    function qe(d, x) {
      const O = new $(Be(d, []), x);
      return O._decoded = d.mappings, O;
    }
    function tt(d) {
      return Be(d, oe(d));
    }
    function Pe(d) {
      return Be(d, se(d));
    }
    function Be(d, x) {
      return {
        version: d.version,
        file: d.file,
        names: d.names,
        sourceRoot: d.sourceRoot,
        sources: d.sources,
        sourcesContent: d.sourcesContent,
        mappings: x,
        ignoreList: d.ignoreList || d.x_google_ignoreList
      };
    }
    function ve(d, x, O, M) {
      return { source: d, line: x, column: O, name: M };
    }
    function Re(d, x) {
      return { line: d, column: x };
    }
    function lt(d, x, O, M, Z) {
      let ee = q(d, M, x, O);
      return j ? ee = (Z === R ? ce : te)(d, M, ee) : Z === R && ee++, ee === -1 || ee === d.length ? -1 : ee;
    }
    function He(d, x, O, M, Z) {
      let ee = lt(d, x, O, M, V);
      if (!j && Z === R && ee++, ee === -1 || ee === d.length)
        return [];
      const ge = j ? M : d[ee][o];
      j || (ee = te(d, ge, ee));
      const xe = ce(d, ge, ee), ye = [];
      for (; ee <= xe; ee++) {
        const X = d[ee];
        ye.push(Re(X[p] + 1, X[h]));
      }
      return ye;
    }
    function J(d, x, O, M, Z, ee) {
      var ge;
      if (O--, O < 0)
        throw new Error(N);
      if (M < 0)
        throw new Error(D);
      const { sources: xe, resolvedSources: ye } = d;
      let X = xe.indexOf(x);
      if (X === -1 && (X = ye.indexOf(x)), X === -1)
        return ee ? [] : Re(null, null);
      const Ve = ((ge = d)._bySources || (ge._bySources = Y(oe(d), d._bySourceMemos = xe.map(ae))))[X][O];
      if (Ve == null)
        return ee ? [] : Re(null, null);
      const We = d._bySourceMemos[X];
      if (ee)
        return He(Ve, We, O, M, Z);
      const it = lt(Ve, We, O, M, Z);
      if (it === -1)
        return Re(null, null);
      const dt = Ve[it];
      return Re(dt[p] + 1, dt[h]);
    }
    r.AnyMap = Q, r.GREATEST_LOWER_BOUND = V, r.LEAST_UPPER_BOUND = R, r.TraceMap = $, r.allGeneratedPositionsFor = Se, r.decodedMap = tt, r.decodedMappings = oe, r.eachMapping = Ce, r.encodedMap = Pe, r.encodedMappings = se, r.generatedPositionFor = pe, r.isIgnored = _e, r.originalPositionFor = fe, r.presortedDecodedMap = qe, r.sourceContentFor = Ne, r.traceSegment = Ue;
  });
})(On, On.exports);
var sc = On.exports;
(function(e, t) {
  (function(r, i) {
    i(t, ZI(), ic(), sc);
  })(ur, function(r, i, s, n) {
    class p {
      constructor({ file: N, sourceRoot: D } = {}) {
        this._names = new i.SetArray(), this._sources = new i.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = N, this.sourceRoot = D, this._ignoreList = new i.SetArray();
      }
    }
    function h(B) {
      return B;
    }
    function y(B, N, D, R, V, $, H, se) {
      return q(!1, B, N, D, R, V, $, H, se);
    }
    function b(B, N) {
      return F(!1, B, N);
    }
    const A = (B, N, D, R, V, $, H, se) => q(!0, B, N, D, R, V, $, H, se), I = (B, N) => F(!0, B, N);
    function _(B, N, D) {
      const { _sources: R, _sourcesContent: V } = B, $ = i.put(R, N);
      V[$] = D;
    }
    function j(B, N, D = !0) {
      const { _sources: R, _sourcesContent: V, _ignoreList: $ } = B, H = i.put(R, N);
      H === V.length && (V[H] = null), D ? i.put($, H) : i.remove($, H);
    }
    function G(B) {
      const { _mappings: N, _sources: D, _sourcesContent: R, _names: V, _ignoreList: $ } = B;
      return Q(N), {
        version: 3,
        file: B.file || void 0,
        names: V.array,
        sourceRoot: B.sourceRoot || void 0,
        sources: D.array,
        sourcesContent: R,
        mappings: N,
        ignoreList: $.array
      };
    }
    function ce(B) {
      const N = G(B);
      return Object.assign(Object.assign({}, N), { mappings: s.encode(N.mappings) });
    }
    function te(B) {
      const N = new n.TraceMap(B), D = new p({ file: N.file, sourceRoot: N.sourceRoot });
      return U(D._names, N.names), U(D._sources, N.sources), D._sourcesContent = N.sourcesContent || N.sources.map(() => null), D._mappings = n.decodedMappings(N), N.ignoreList && U(D._ignoreList, N.ignoreList), D;
    }
    function ae(B) {
      const N = [], { _mappings: D, _sources: R, _names: V } = B;
      for (let $ = 0; $ < D.length; $++) {
        const H = D[$];
        for (let se = 0; se < H.length; se++) {
          const oe = H[se], Ue = { line: $ + 1, column: oe[0] };
          let fe, pe, Se;
          oe.length !== 1 && (fe = R.array[oe[1]], pe = { line: oe[2] + 1, column: oe[3] }, oe.length === 5 && (Se = V.array[oe[4]])), N.push({ generated: Ue, source: fe, original: pe, name: Se });
        }
      }
      return N;
    }
    function q(B, N, D, R, V, $, H, se, oe) {
      const { _mappings: Ue, _sources: fe, _sourcesContent: pe, _names: Se } = N, Ce = Y(Ue, D), Ee = re(Ce, R);
      if (!V)
        return B && L(Ce, Ee) ? void 0 : W(Ce, Ee, [R]);
      const Ne = i.put(fe, V), _e = se ? i.put(Se, se) : -1;
      if (Ne === pe.length && (pe[Ne] = oe ?? null), !(B && k(Ce, Ee, Ne, $, H, _e)))
        return W(Ce, Ee, se ? [R, Ne, $, H, _e] : [R, Ne, $, H]);
    }
    function Y(B, N) {
      for (let D = B.length; D <= N; D++)
        B[D] = [];
      return B[N];
    }
    function re(B, N) {
      let D = B.length;
      for (let R = D - 1; R >= 0; D = R--) {
        const V = B[R];
        if (N >= V[0])
          break;
      }
      return D;
    }
    function W(B, N, D) {
      for (let R = B.length; R > N; R--)
        B[R] = B[R - 1];
      B[N] = D;
    }
    function Q(B) {
      const { length: N } = B;
      let D = N;
      for (let R = D - 1; R >= 0 && !(B[R].length > 0); D = R, R--)
        ;
      D < N && (B.length = D);
    }
    function U(B, N) {
      for (let D = 0; D < N.length; D++)
        i.put(B, N[D]);
    }
    function L(B, N) {
      return N === 0 ? !0 : B[N - 1].length === 1;
    }
    function k(B, N, D, R, V, $) {
      if (N === 0)
        return !1;
      const H = B[N - 1];
      return H.length === 1 ? !1 : D === H[1] && R === H[2] && V === H[3] && $ === (H.length === 5 ? H[4] : -1);
    }
    function F(B, N, D) {
      const { generated: R, source: V, original: $, name: H, content: se } = D;
      return V ? q(B, N, R.line - 1, R.column, V, $.line - 1, $.column, H, se) : q(B, N, R.line - 1, R.column, null, null, null, null, null);
    }
    r.GenMapping = p, r.addMapping = b, r.addSegment = y, r.allMappings = ae, r.fromMap = te, r.maybeAddMapping = I, r.maybeAddSegment = A, r.setIgnore = j, r.setSourceContent = _, r.toDecodedMap = G, r.toEncodedMap = ce, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})(wn, wn.exports);
var tw = wn.exports;
Object.defineProperty(As, "__esModule", {
  value: !0
});
As.default = void 0;
var Wt = tw, Qs = sc;
class rw {
  constructor(t, r) {
    var i;
    this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
    const s = this._map = new Wt.GenMapping({
      sourceRoot: t.sourceRoot
    });
    if (this._sourceFileName = (i = t.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
      this._inputMap = new Qs.TraceMap(t.inputSourceMap);
      const a = this._inputMap.resolvedSources;
      if (a.length)
        for (let o = 0; o < a.length; o++) {
          var n;
          (0, Wt.setSourceContent)(s, a[o], (n = this._inputMap.sourcesContent) == null ? void 0 : n[o]);
        }
    }
    if (typeof r == "string" && !t.inputSourceMap)
      (0, Wt.setSourceContent)(s, this._sourceFileName, r);
    else if (typeof r == "object")
      for (const a of Object.keys(r))
        (0, Wt.setSourceContent)(s, a.replace(/\\/g, "/"), r[a]);
  }
  get() {
    return (0, Wt.toEncodedMap)(this._map);
  }
  getDecoded() {
    return (0, Wt.toDecodedMap)(this._map);
  }
  getRawMappings() {
    return this._rawMappings || (this._rawMappings = (0, Wt.allMappings)(this._map));
  }
  mark(t, r, i, s, n, a) {
    var o;
    this._rawMappings = void 0;
    let l;
    if (r != null)
      if (this._inputMap) {
        if (l = (0, Qs.originalPositionFor)(this._inputMap, {
          line: r,
          column: i
        }), !l.name && n) {
          const u = (0, Qs.originalPositionFor)(this._inputMap, n);
          u.name && (s = u.name);
        }
      } else
        l = {
          source: (a == null ? void 0 : a.replace(/\\/g, "/")) || this._sourceFileName,
          line: r,
          column: i
        };
    (0, Wt.maybeAddMapping)(this._map, {
      name: s,
      generated: t,
      source: (o = l) == null ? void 0 : o.source,
      original: l
    });
  }
}
As.default = rw;
var Cs = {}, Is = {};
Object.defineProperty(Is, "__esModule", {
  value: !0
});
Is.default = void 0;
let iw = class {
  constructor(t, r) {
    this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
      line: 1,
      column: 0
    }, this._sourcePosition = {
      identifierName: void 0,
      identifierNamePos: void 0,
      line: void 0,
      column: void 0,
      filename: void 0
    }, this._map = t, this._indentChar = r;
    for (let i = 0; i < 64; i++)
      this._fastIndentations.push(r.repeat(i));
    this._allocQueue();
  }
  _allocQueue() {
    const t = this._queue;
    for (let r = 0; r < 16; r++)
      t.push({
        char: 0,
        repeat: 1,
        line: void 0,
        column: void 0,
        identifierName: void 0,
        identifierNamePos: void 0,
        filename: ""
      });
  }
  _pushQueue(t, r, i, s, n) {
    const a = this._queueCursor;
    a === this._queue.length && this._allocQueue();
    const o = this._queue[a];
    o.char = t, o.repeat = r, o.line = i, o.column = s, o.filename = n, this._queueCursor++;
  }
  _popQueue() {
    if (this._queueCursor === 0)
      throw new Error("Cannot pop from empty queue");
    return this._queue[--this._queueCursor];
  }
  get() {
    this._flush();
    const t = this._map, r = {
      code: (this._buf + this._str).trimRight(),
      decodedMap: t == null ? void 0 : t.getDecoded(),
      get __mergedMap() {
        return this.map;
      },
      get map() {
        const i = t ? t.get() : null;
        return r.map = i, i;
      },
      set map(i) {
        Object.defineProperty(r, "map", {
          value: i,
          writable: !0
        });
      },
      get rawMappings() {
        const i = t == null ? void 0 : t.getRawMappings();
        return r.rawMappings = i, i;
      },
      set rawMappings(i) {
        Object.defineProperty(r, "rawMappings", {
          value: i,
          writable: !0
        });
      }
    };
    return r;
  }
  append(t, r) {
    this._flush(), this._append(t, this._sourcePosition, r);
  }
  appendChar(t) {
    this._flush(), this._appendChar(t, 1, this._sourcePosition);
  }
  queue(t) {
    if (t === 10)
      for (; this._queueCursor !== 0; ) {
        const i = this._queue[this._queueCursor - 1].char;
        if (i !== 32 && i !== 9)
          break;
        this._queueCursor--;
      }
    const r = this._sourcePosition;
    this._pushQueue(t, 1, r.line, r.column, r.filename);
  }
  queueIndentation(t) {
    t !== 0 && this._pushQueue(-1, t, void 0, void 0, void 0);
  }
  _flush() {
    const t = this._queueCursor, r = this._queue;
    for (let i = 0; i < t; i++) {
      const s = r[i];
      this._appendChar(s.char, s.repeat, s);
    }
    this._queueCursor = 0;
  }
  _appendChar(t, r, i) {
    if (this._last = t, t === -1) {
      const s = this._fastIndentations[r];
      s !== void 0 ? this._str += s : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
    } else
      this._str += r > 1 ? String.fromCharCode(t).repeat(r) : String.fromCharCode(t);
    t !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += r) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
  }
  _append(t, r, i) {
    const s = t.length, n = this._position;
    if (this._last = t.charCodeAt(s - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount = 0) : this._str += t, !i && !this._map) {
      n.column += s;
      return;
    }
    const {
      column: a,
      identifierName: o,
      identifierNamePos: l,
      filename: u
    } = r;
    let c = r.line;
    (o != null || l != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
    let f = t.indexOf(`
`), p = 0;
    for (f !== 0 && this._mark(c, a, o, l, u); f !== -1; )
      n.line++, n.column = 0, p = f + 1, p < s && c !== void 0 && this._mark(++c, 0, null, null, u), f = t.indexOf(`
`, p);
    n.column += s - p;
  }
  _mark(t, r, i, s, n) {
    var a;
    (a = this._map) == null || a.mark(this._position, t, r, i, s, n);
  }
  removeTrailingNewline() {
    const t = this._queueCursor;
    t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
  }
  removeLastSemicolon() {
    const t = this._queueCursor;
    t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
  }
  getLastChar() {
    const t = this._queueCursor;
    return t !== 0 ? this._queue[t - 1].char : this._last;
  }
  getNewlineCount() {
    const t = this._queueCursor;
    let r = 0;
    if (t === 0) return this._last === 10 ? 1 : 0;
    for (let i = t - 1; i >= 0 && this._queue[i].char === 10; i--)
      r++;
    return r === t && this._last === 10 ? r + 1 : r;
  }
  endsWithCharAndNewline() {
    const t = this._queue, r = this._queueCursor;
    if (r !== 0)
      return t[r - 1].char !== 10 ? void 0 : r > 1 ? t[r - 2].char : this._last;
  }
  hasContent() {
    return this._queueCursor !== 0 || !!this._last;
  }
  exactSource(t, r) {
    if (!this._map) {
      r();
      return;
    }
    this.source("start", t);
    const i = t.identifierName, s = this._sourcePosition;
    i && (this._canMarkIdName = !1, s.identifierName = i), r(), i && (this._canMarkIdName = !0, s.identifierName = void 0, s.identifierNamePos = void 0), this.source("end", t);
  }
  source(t, r) {
    this._map && this._normalizePosition(t, r, 0);
  }
  sourceWithOffset(t, r, i) {
    this._map && this._normalizePosition(t, r, i);
  }
  _normalizePosition(t, r, i) {
    const s = r[t], n = this._sourcePosition;
    s && (n.line = s.line, n.column = Math.max(s.column + i, 0), n.filename = r.filename);
  }
  getCurrentColumn() {
    const t = this._queue, r = this._queueCursor;
    let i = -1, s = 0;
    for (let n = 0; n < r; n++) {
      const a = t[n];
      a.char === 10 && (i = s), s += a.repeat;
    }
    return i === -1 ? this._position.column + s : s - 1 - i;
  }
  getCurrentLine() {
    let t = 0;
    const r = this._queue;
    for (let i = 0; i < this._queueCursor; i++)
      r[i].char === 10 && t++;
    return this._position.line + t;
  }
};
Is.default = iw;
var vr = {}, ws = {};
Object.defineProperty(ws, "__esModule", {
  value: !0
});
ws.nodes = void 0;
var sw = Ae();
const {
  FLIPPED_ALIAS_KEYS: nw,
  isArrayExpression: aw,
  isAssignmentExpression: nc,
  isBinary: ac,
  isBlockStatement: ow,
  isCallExpression: oc,
  isFunction: qr,
  isIdentifier: es,
  isLiteral: lw,
  isMemberExpression: Ta,
  isObjectExpression: uw,
  isOptionalCallExpression: cw,
  isOptionalMemberExpression: fw,
  isStringLiteral: pw
} = sw;
function gr(e, t) {
  return e && (Ta(e) || fw(e) ? (gr(e.object, t), e.computed && gr(e.property, t)) : ac(e) || nc(e) ? (gr(e.left, t), gr(e.right, t)) : oc(e) || cw(e) ? (t.hasCall = !0, gr(e.callee, t)) : qr(e) ? t.hasFunction = !0 : es(e) && (t.hasHelper = t.hasHelper || e.callee && jt(e.callee))), t;
}
function ol(e) {
  return gr(e, {
    hasCall: !1,
    hasFunction: !1,
    hasHelper: !1
  });
}
function jt(e) {
  return e ? Ta(e) ? jt(e.object) || jt(e.property) : es(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : oc(e) ? jt(e.callee) : ac(e) || nc(e) ? es(e.left) && jt(e.left) || jt(e.right) : !1 : !1;
}
function hw(e) {
  return lw(e) || uw(e) || aw(e) || es(e) || Ta(e);
}
const lr = ws.nodes = {
  AssignmentExpression(e) {
    const t = ol(e.right);
    if (t.hasCall && t.hasHelper || t.hasFunction)
      return t.hasFunction ? 3 : 2;
  },
  SwitchCase(e, t) {
    return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
  },
  LogicalExpression(e) {
    if (qr(e.left) || qr(e.right))
      return 2;
  },
  Literal(e) {
    if (pw(e) && e.value === "use strict")
      return 2;
  },
  CallExpression(e) {
    if (qr(e.callee) || jt(e))
      return 3;
  },
  OptionalCallExpression(e) {
    if (qr(e.callee))
      return 3;
  },
  VariableDeclaration(e) {
    for (let t = 0; t < e.declarations.length; t++) {
      const r = e.declarations[t];
      let i = jt(r.id) && !hw(r.init);
      if (!i && r.init) {
        const s = ol(r.init);
        i = jt(r.init) && s.hasCall || s.hasFunction;
      }
      if (i)
        return 3;
    }
  },
  IfStatement(e) {
    if (ow(e.consequent))
      return 3;
  }
};
lr.ObjectProperty = lr.ObjectTypeProperty = lr.ObjectMethod = function(e, t) {
  if (t.properties[0] === e)
    return 1;
};
lr.ObjectTypeCallProperty = function(e, t) {
  var r;
  if (t.callProperties[0] === e && !((r = t.properties) != null && r.length))
    return 1;
};
lr.ObjectTypeIndexer = function(e, t) {
  var r, i;
  if (t.indexers[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length))
    return 1;
};
lr.ObjectTypeInternalSlot = function(e, t) {
  var r, i, s;
  if (t.internalSlots[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length) && !((s = t.indexers) != null && s.length))
    return 1;
};
[["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([e, t]) {
  [e].concat(nw[e] || []).forEach(function(r) {
    const i = t ? 3 : 0;
    lr[r] = () => i;
  });
});
var Me = {};
Object.defineProperty(Me, "__esModule", {
  value: !0
});
Me.ArrowFunctionExpression = Vw;
Me.AssignmentExpression = qw;
Me.Binary = Nw;
Me.BinaryExpression = Fw;
Me.ClassExpression = Uw;
Me.ConditionalExpression = ba;
Me.DoExpression = Ow;
Me.FunctionExpression = $w;
Me.FunctionTypeAnnotation = Cw;
Me.Identifier = Jw;
Me.LogicalExpression = Ww;
Me.NullableTypeAnnotation = Aw;
Me.ObjectExpression = ww;
Me.OptionalIndexedAccessType = kw;
Me.OptionalCallExpression = Me.OptionalMemberExpression = Kw;
Me.SequenceExpression = jw;
Me.TSTypeAssertion = Me.TSSatisfiesExpression = Me.TSAsExpression = Dw;
Me.TSInferType = Mw;
Me.TSInstantiationExpression = Bw;
Me.TSIntersectionType = Me.TSUnionType = Lw;
Me.UnaryLike = uc;
Me.IntersectionTypeAnnotation = Me.UnionTypeAnnotation = _w;
Me.UpdateExpression = Iw;
Me.AwaitExpression = Me.YieldExpression = Rw;
var dw = Ae();
const {
  isArrayTypeAnnotation: mw,
  isArrowFunctionExpression: yw,
  isBinaryExpression: Tw,
  isCallExpression: gw,
  isExportDeclaration: bw,
  isForOfStatement: Sw,
  isIndexedAccessType: Ew,
  isMemberExpression: lc,
  isObjectPattern: Pw,
  isOptionalMemberExpression: xw,
  isYieldExpression: vw
} = dw, ll = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
function ga(e) {
  return e === "TSAsExpression" || e === "TSSatisfiesExpression" || e === "TSTypeAssertion";
}
const Os = (e, t) => {
  const r = t.type;
  return (r === "ClassDeclaration" || r === "ClassExpression") && t.superClass === e;
}, li = (e, t) => {
  const r = t.type;
  return (r === "MemberExpression" || r === "OptionalMemberExpression") && t.object === e || (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression") && t.callee === e || r === "TaggedTemplateExpression" && t.tag === e || r === "TSNonNullExpression";
};
function Aw(e, t) {
  return mw(t);
}
function Cw(e, t, r) {
  if (r.length < 3) return;
  const i = t.type;
  return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || i === "TypeAnnotation" && yw(r[r.length - 3]);
}
function Iw(e, t) {
  return li(e, t) || Os(e, t);
}
function ww(e, t, r) {
  return ui(r, 3);
}
function Ow(e, t, r) {
  return !e.async && ui(r, 1);
}
function Nw(e, t) {
  const r = t.type;
  if (e.operator === "**" && r === "BinaryExpression" && t.operator === "**")
    return t.left === e;
  if (Os(e, t) || li(e, t) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
    return !0;
  if (r === "BinaryExpression" || r === "LogicalExpression") {
    const i = ll.get(t.operator), s = ll.get(e.operator);
    if (i === s && t.right === e && r !== "LogicalExpression" || i > s)
      return !0;
  }
}
function _w(e, t) {
  const r = t.type;
  return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
}
function kw(e, t) {
  return Ew(t) && t.objectType === e;
}
function Dw() {
  return !0;
}
function Lw(e, t) {
  const r = t.type;
  return r === "TSArrayType" || r === "TSOptionalType" || r === "TSIntersectionType" || r === "TSUnionType" || r === "TSRestType";
}
function Mw(e, t) {
  const r = t.type;
  return r === "TSArrayType" || r === "TSOptionalType";
}
function Bw(e, t) {
  const r = t.type;
  return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!t.typeParameters;
}
function Fw(e, t, r, i) {
  return e.operator === "in" && i;
}
function jw(e, t) {
  const r = t.type;
  return !(r === "ForStatement" || r === "ThrowStatement" || r === "ReturnStatement" || r === "IfStatement" && t.test === e || r === "WhileStatement" && t.test === e || r === "ForInStatement" && t.right === e || r === "SwitchStatement" && t.discriminant === e || r === "ExpressionStatement" && t.expression === e);
}
function Rw(e, t) {
  const r = t.type;
  return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || li(e, t) || r === "AwaitExpression" && vw(e) || r === "ConditionalExpression" && e === t.test || Os(e, t) || ga(r);
}
function Uw(e, t, r) {
  return ui(r, 5);
}
function uc(e, t) {
  return li(e, t) || Tw(t) && t.operator === "**" && t.left === e || Os(e, t);
}
function $w(e, t, r) {
  return ui(r, 5);
}
function Vw(e, t) {
  return bw(t) || ba(e, t);
}
function ba(e, t) {
  const r = t.type;
  return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalExpression" && t.test === e || r === "AwaitExpression" || ga(r) ? !0 : uc(e, t);
}
function Kw(e, t) {
  return gw(t) && t.callee === e || lc(t) && t.object === e;
}
function qw(e, t) {
  return Pw(e.left) ? !0 : ba(e, t);
}
function Ww(e, t) {
  const r = t.type;
  if (ga(r)) return !0;
  if (r !== "LogicalExpression") return !1;
  switch (e.operator) {
    case "||":
      return t.operator === "??" || t.operator === "&&";
    case "&&":
      return t.operator === "??";
    case "??":
      return t.operator !== "??";
  }
}
function Jw(e, t, r) {
  var i;
  const s = t.type;
  if ((i = e.extra) != null && i.parenthesized && s === "AssignmentExpression" && t.left === e) {
    const n = t.right.type;
    if ((n === "FunctionExpression" || n === "ClassExpression") && t.right.id == null)
      return !0;
  }
  if (e.name === "let") {
    const n = lc(t, {
      object: e,
      computed: !0
    }) || xw(t, {
      object: e,
      computed: !0,
      optional: !1
    });
    return ui(r, n ? 57 : 32);
  }
  return e.name === "async" && Sw(t, {
    left: e,
    await: !1
  });
}
function ui(e, t) {
  const r = t & 1, i = t & 2, s = t & 4, n = t & 8, a = t & 16, o = t & 32;
  let l = e.length - 1;
  if (l <= 0) return;
  let u = e[l];
  l--;
  let c = e[l];
  for (; l >= 0; ) {
    const f = c.type;
    if (r && f === "ExpressionStatement" && c.expression === u || s && f === "ExportDefaultDeclaration" && u === c.declaration || i && f === "ArrowFunctionExpression" && c.body === u || n && f === "ForStatement" && c.init === u || a && f === "ForInStatement" && c.left === u || o && f === "ForOfStatement" && c.left === u)
      return !0;
    if (l > 0 && (li(u, c) && f !== "NewExpression" || f === "SequenceExpression" && c.expressions[0] === u || f === "UpdateExpression" && !c.prefix || f === "ConditionalExpression" && c.test === u || (f === "BinaryExpression" || f === "LogicalExpression") && c.left === u || f === "AssignmentExpression" && c.left === u))
      u = c, l--, c = e[l];
    else
      return !1;
  }
  return !1;
}
Object.defineProperty(vr, "__esModule", {
  value: !0
});
vr.needsParens = aO;
vr.needsWhitespace = Sa;
vr.needsWhitespaceAfter = nO;
vr.needsWhitespaceBefore = sO;
var Xw = ws, Yw = Me, Hw = Ae();
const {
  FLIPPED_ALIAS_KEYS: Gw,
  isCallExpression: cc,
  isDecorator: zw,
  isExpressionStatement: Qw,
  isMemberExpression: Zw,
  isNewExpression: eO,
  isParenthesizedExpression: tO
} = Hw;
function fc(e) {
  const t = /* @__PURE__ */ new Map();
  function r(i, s) {
    const n = t.get(i);
    t.set(i, n ? function(a, o, l, u) {
      var c;
      return (c = n(a, o, l, u)) != null ? c : s(a, o, l, u);
    } : s);
  }
  for (const i of Object.keys(e)) {
    const s = Gw[i];
    if (s)
      for (const n of s)
        r(n, e[i]);
    else
      r(i, e[i]);
  }
  return t;
}
const rO = fc(Yw), iO = fc(Xw.nodes);
function pc(e) {
  return cc(e) ? !0 : Zw(e) && pc(e.object);
}
function Sa(e, t, r) {
  var i;
  if (!e) return !1;
  Qw(e) && (e = e.expression);
  const s = (i = iO.get(e.type)) == null ? void 0 : i(e, t);
  return typeof s == "number" ? (s & r) !== 0 : !1;
}
function sO(e, t) {
  return Sa(e, t, 1);
}
function nO(e, t) {
  return Sa(e, t, 2);
}
function aO(e, t, r, i) {
  var s;
  return t ? eO(t) && t.callee === e && pc(e) ? !0 : zw(t) ? !Nn(e) && !(cc(e) && Nn(e.callee)) && !tO(e) : (s = rO.get(e.type)) == null ? void 0 : s(e, t, r, i) : !1;
}
function Nn(e) {
  switch (e.type) {
    case "Identifier":
      return !0;
    case "MemberExpression":
      return !e.computed && e.property.type === "Identifier" && Nn(e.object);
    default:
      return !1;
  }
}
var hc = {}, ci = {};
Object.defineProperty(ci, "__esModule", {
  value: !0
});
ci.TaggedTemplateExpression = oO;
ci.TemplateElement = lO;
ci.TemplateLiteral = uO;
function oO(e) {
  this.print(e.tag, e), this.print(e.typeParameters, e), this.print(e.quasi, e);
}
function lO() {
  throw new Error("TemplateElement printing is handled in TemplateLiteral");
}
function uO(e) {
  const t = e.quasis;
  let r = "`";
  for (let i = 0; i < t.length; i++)
    r += t[i].value.raw, i + 1 < t.length && (this.token(r + "${", !0), this.print(e.expressions[i], e), r = "}");
  this.token(r + "`", !0);
}
var je = {};
Object.defineProperty(je, "__esModule", {
  value: !0
});
je.LogicalExpression = je.BinaryExpression = je.AssignmentExpression = DO;
je.AssignmentPattern = kO;
je.AwaitExpression = wO;
je.BindExpression = LO;
je.CallExpression = CO;
je.ConditionalExpression = TO;
je.Decorator = xO;
je.DoExpression = dO;
je.EmptyStatement = NO;
je.ExpressionStatement = _O;
je.Import = IO;
je.MemberExpression = MO;
je.MetaProperty = BO;
je.ModuleExpression = RO;
je.NewExpression = gO;
je.OptionalCallExpression = AO;
je.OptionalMemberExpression = vO;
je.ParenthesizedExpression = mO;
je.PrivateName = FO;
je.SequenceExpression = bO;
je.Super = EO;
je.ThisExpression = SO;
je.UnaryExpression = hO;
je.UpdateExpression = yO;
je.V8IntrinsicIdentifier = jO;
je.YieldExpression = OO;
je._shouldPrintDecoratorsBeforeExport = PO;
var cO = Ae();
const {
  isCallExpression: fO,
  isLiteral: dc,
  isMemberExpression: Ea,
  isNewExpression: pO
} = cO;
function hO(e) {
  const {
    operator: t
  } = e;
  t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument, e);
}
function dO(e) {
  e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body, e);
}
function mO(e) {
  this.tokenChar(40), this.print(e.expression, e), this.rightParens(e);
}
function yO(e) {
  e.prefix ? (this.token(e.operator), this.print(e.argument, e)) : (this.printTerminatorless(e.argument, e, !0), this.token(e.operator));
}
function TO(e) {
  this.print(e.test, e), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent, e), this.space(), this.tokenChar(58), this.space(), this.print(e.alternate, e);
}
function gO(e, t) {
  if (this.word("new"), this.space(), this.print(e.callee, e), this.format.minified && e.arguments.length === 0 && !e.optional && !fO(t, {
    callee: e
  }) && !Ea(t) && !pO(t))
    return;
  this.print(e.typeArguments, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.tokenChar(40);
  const r = this.enterForStatementInit(!1);
  this.printList(e.arguments, e), r(), this.rightParens(e);
}
function bO(e) {
  this.printList(e.expressions, e);
}
function SO() {
  this.word("this");
}
function EO() {
  this.word("super");
}
function PO(e) {
  return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start === e.declaration.start;
}
function xO(e) {
  this.tokenChar(64), this.print(e.expression, e), this.newline();
}
function vO(e) {
  let {
    computed: t
  } = e;
  const {
    optional: r,
    property: i
  } = e;
  if (this.print(e.object, e), !t && Ea(i))
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  dc(i) && typeof i.value == "number" && (t = !0), r && this.token("?."), t ? (this.tokenChar(91), this.print(i, e), this.tokenChar(93)) : (r || this.tokenChar(46), this.print(i, e));
}
function AO(e) {
  this.print(e.callee, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.print(e.typeArguments, e), this.tokenChar(40);
  const t = this.enterForStatementInit(!1);
  this.printList(e.arguments, e), t(), this.rightParens(e);
}
function CO(e) {
  this.print(e.callee, e), this.print(e.typeArguments, e), this.print(e.typeParameters, e), this.tokenChar(40);
  const t = this.enterForStatementInit(!1);
  this.printList(e.arguments, e), t(), this.rightParens(e);
}
function IO() {
  this.word("import");
}
function wO(e) {
  this.word("await"), e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
}
function OO(e) {
  this.word("yield", !0), e.delegate ? (this.tokenChar(42), e.argument && (this.space(), this.print(e.argument, e))) : e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
}
function NO() {
  this.semicolon(!0);
}
function _O(e) {
  this.print(e.expression, e), this.semicolon();
}
function kO(e) {
  this.print(e.left, e), e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation, e), this.space(), this.tokenChar(61), this.space(), this.print(e.right, e);
}
function DO(e) {
  this.print(e.left, e), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) : this.token(e.operator), this.space(), this.print(e.right, e);
}
function LO(e) {
  this.print(e.object, e), this.token("::"), this.print(e.callee, e);
}
function MO(e) {
  if (this.print(e.object, e), !e.computed && Ea(e.property))
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  let t = e.computed;
  if (dc(e.property) && typeof e.property.value == "number" && (t = !0), t) {
    const r = this.enterForStatementInit(!1);
    this.tokenChar(91), this.print(e.property, e), this.tokenChar(93), r();
  } else
    this.tokenChar(46), this.print(e.property, e);
}
function BO(e) {
  this.print(e.meta, e), this.tokenChar(46), this.print(e.property, e);
}
function FO(e) {
  this.tokenChar(35), this.print(e.id, e);
}
function jO(e) {
  this.tokenChar(37), this.word(e.name);
}
function RO(e) {
  this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
  const {
    body: t
  } = e;
  (t.body.length || t.directives.length) && this.newline(), this.print(t, e), this.dedent(), this.rightBrace(e);
}
var ze = {};
Object.defineProperty(ze, "__esModule", {
  value: !0
});
ze.BreakStatement = HO;
ze.CatchClause = tN;
ze.ContinueStatement = GO;
ze.DebuggerStatement = sN;
ze.DoWhileStatement = YO;
ze.ForOfStatement = ze.ForInStatement = void 0;
ze.ForStatement = JO;
ze.IfStatement = WO;
ze.LabeledStatement = ZO;
ze.ReturnStatement = zO;
ze.SwitchCase = iN;
ze.SwitchStatement = rN;
ze.ThrowStatement = QO;
ze.TryStatement = eN;
ze.VariableDeclaration = nN;
ze.VariableDeclarator = aN;
ze.WhileStatement = XO;
ze.WithStatement = qO;
var UO = Ae();
const {
  isFor: ul,
  isForStatement: $O,
  isIfStatement: VO,
  isStatement: KO
} = UO;
function qO(e) {
  this.word("with"), this.space(), this.tokenChar(40), this.print(e.object, e), this.tokenChar(41), this.printBlock(e);
}
function WO(e) {
  this.word("if"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.space();
  const t = e.alternate && VO(mc(e.consequent));
  t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent, e), t && (this.dedent(), this.newline(), this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(e.alternate, e));
}
function mc(e) {
  const {
    body: t
  } = e;
  return KO(t) === !1 ? e : mc(t);
}
function JO(e) {
  this.word("for"), this.space(), this.tokenChar(40);
  {
    const t = this.enterForStatementInit(!0);
    this.print(e.init, e), t();
  }
  this.tokenChar(59), e.test && (this.space(), this.print(e.test, e)), this.tokenChar(59), e.update && (this.space(), this.print(e.update, e)), this.tokenChar(41), this.printBlock(e);
}
function XO(e) {
  this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.printBlock(e);
}
function yc(e) {
  this.word("for"), this.space();
  const t = e.type === "ForOfStatement";
  t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
  {
    const r = t ? null : this.enterForStatementInit(!0);
    this.print(e.left, e), r == null || r();
  }
  this.space(), this.word(t ? "of" : "in"), this.space(), this.print(e.right, e), this.tokenChar(41), this.printBlock(e);
}
ze.ForInStatement = yc;
ze.ForOfStatement = yc;
function YO(e) {
  this.word("do"), this.space(), this.print(e.body, e), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.semicolon();
}
function Ns(e, t, r, i) {
  t && (e.space(), e.printTerminatorless(t, r, i)), e.semicolon();
}
function HO(e) {
  this.word("break"), Ns(this, e.label, e, !0);
}
function GO(e) {
  this.word("continue"), Ns(this, e.label, e, !0);
}
function zO(e) {
  this.word("return"), Ns(this, e.argument, e, !1);
}
function QO(e) {
  this.word("throw"), Ns(this, e.argument, e, !1);
}
function ZO(e) {
  this.print(e.label, e), this.tokenChar(58), this.space(), this.print(e.body, e);
}
function eN(e) {
  this.word("try"), this.space(), this.print(e.block, e), this.space(), e.handlers ? this.print(e.handlers[0], e) : this.print(e.handler, e), e.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e.finalizer, e));
}
function tN(e) {
  this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param, e), this.print(e.param.typeAnnotation, e), this.tokenChar(41), this.space()), this.print(e.body, e);
}
function rN(e) {
  this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant, e), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(e.cases, e, {
    indent: !0,
    addNewlines(t, r) {
      if (!t && e.cases[e.cases.length - 1] === r) return -1;
    }
  }), this.rightBrace(e);
}
function iN(e) {
  e.test ? (this.word("case"), this.space(), this.print(e.test, e), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.length && (this.newline(), this.printSequence(e.consequent, e, {
    indent: !0
  }));
}
function sN() {
  this.word("debugger"), this.semicolon();
}
function nN(e, t) {
  e.declare && (this.word("declare"), this.space());
  const {
    kind: r
  } = e;
  r === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(r, r === "using"), this.space();
  let i = !1;
  if (!ul(t))
    for (const s of e.declarations)
      s.init && (i = !0);
  if (this.printList(e.declarations, e, {
    separator: i ? function() {
      this.tokenChar(44), this.newline();
    } : void 0,
    indent: e.declarations.length > 1
  }), ul(t)) {
    if ($O(t)) {
      if (t.init === e) return;
    } else if (t.left === e) return;
  }
  this.semicolon();
}
function aN(e) {
  this.print(e.id, e), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation, e), e.init && (this.space(), this.tokenChar(61), this.space(), this.print(e.init, e));
}
var Et = {};
Object.defineProperty(Et, "__esModule", {
  value: !0
});
Et.ClassAccessorProperty = hN;
Et.ClassBody = fN;
Et.ClassExpression = Et.ClassDeclaration = cN;
Et.ClassMethod = mN;
Et.ClassPrivateMethod = yN;
Et.ClassPrivateProperty = dN;
Et.ClassProperty = pN;
Et.StaticBlock = gN;
Et._classMethodHead = TN;
var oN = Ae();
const {
  isExportDefaultDeclaration: lN,
  isExportNamedDeclaration: uN
} = oN;
function cN(e, t) {
  (!(lN(t) || uN(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators, e), e.declare && (this.word("declare"), this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id, e)), this.print(e.typeParameters, e), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass, e), this.print(e.superTypeParameters, e)), e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e)), this.space(), this.print(e.body, e);
}
function fN(e) {
  if (this.tokenChar(123), e.body.length === 0)
    this.tokenChar(125);
  else {
    this.newline();
    const t = this.enterForStatementInit(!1);
    this.printSequence(e.body, e, {
      indent: !0
    }), t(), this.endsWith(10) || this.newline(), this.rightBrace(e);
  }
}
function pN(e) {
  var t;
  this.printJoin(e.decorators, e);
  const r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
  r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function hN(e) {
  var t;
  this.printJoin(e.decorators, e);
  const r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
  r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function dN(e) {
  this.printJoin(e.decorators, e), e.static && (this.word("static"), this.space()), this.print(e.key, e), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function mN(e) {
  this._classMethodHead(e), this.space(), this.print(e.body, e);
}
function yN(e) {
  this._classMethodHead(e), this.space(), this.print(e.body, e);
}
function TN(e) {
  var t;
  this.printJoin(e.decorators, e);
  const r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
  r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this._methodHead(e);
}
function gN(e) {
  this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(e.body, e, {
    indent: !0
  }), this.rightBrace(e));
}
var Ct = {};
Object.defineProperty(Ct, "__esModule", {
  value: !0
});
Ct.ArrowFunctionExpression = wN;
Ct.FunctionDeclaration = Ct.FunctionExpression = IN;
Ct._functionHead = CN;
Ct._methodHead = vN;
Ct._param = xN;
Ct._parameters = PN;
Ct._params = EN;
Ct._predicate = AN;
var bN = Ae();
const {
  isIdentifier: SN
} = bN;
function EN(e, t, r) {
  this.print(e.typeParameters, e);
  const i = NN.call(this, t, r);
  i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(e.params, e), this.tokenChar(41);
  const s = e.type === "ArrowFunctionExpression";
  this.print(e.returnType, e, s), this._noLineTerminator = s;
}
function PN(e, t) {
  const r = this.enterForStatementInit(!1), i = e.length;
  for (let s = 0; s < i; s++)
    this._param(e[s], t), s < e.length - 1 && (this.tokenChar(44), this.space());
  r();
}
function xN(e, t) {
  this.printJoin(e.decorators, e), this.print(e, t), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
}
function vN(e) {
  const t = e.kind, r = e.key;
  (t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t === "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(r, e), this.tokenChar(93)) : this.print(r, e), e.optional && this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key, void 0);
}
function AN(e, t) {
  e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, e, t));
}
function CN(e, t) {
  e.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), e.generator && (this._endsWithInnerRaw = !1, this.tokenChar(42)), this.space(), e.id && this.print(e.id, e), this._params(e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(e);
}
function IN(e, t) {
  this._functionHead(e, t), this.space(), this.print(e.body, e);
}
function wN(e, t) {
  e.async && (this.word("async", !0), this.space());
  let r;
  !this.format.retainLines && e.params.length === 1 && SN(r = e.params[0]) && !ON(e, r) ? this.print(r, e, !0) : this._params(e, void 0, t), this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(e.body, e);
}
function ON(e, t) {
  var r, i;
  return !!(e.typeParameters || e.returnType || e.predicate || t.typeAnnotation || t.optional || (r = t.leadingComments) != null && r.length || (i = t.trailingComments) != null && i.length);
}
function NN(e, t) {
  let r = e;
  if (!r && t) {
    const l = t.type;
    l === "VariableDeclarator" ? r = t.id : l === "AssignmentExpression" || l === "AssignmentPattern" ? r = t.left : l === "ObjectProperty" || l === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (r = t.key) : (l === "ClassPrivateProperty" || l === "ClassAccessorProperty") && (r = t.key);
  }
  if (!r) return;
  let i;
  if (r.type === "Identifier") {
    var s, n;
    i = {
      pos: (s = r.loc) == null ? void 0 : s.start,
      name: ((n = r.loc) == null ? void 0 : n.identifierName) || r.name
    };
  } else if (r.type === "PrivateName") {
    var a;
    i = {
      pos: (a = r.loc) == null ? void 0 : a.start,
      name: "#" + r.id.name
    };
  } else if (r.type === "StringLiteral") {
    var o;
    i = {
      pos: (o = r.loc) == null ? void 0 : o.start,
      name: r.value
    };
  }
  return i;
}
var ut = {};
Object.defineProperty(ut, "__esModule", {
  value: !0
});
ut.ExportAllDeclaration = KN;
ut.ExportDefaultDeclaration = WN;
ut.ExportDefaultSpecifier = RN;
ut.ExportNamedDeclaration = qN;
ut.ExportNamespaceSpecifier = $N;
ut.ExportSpecifier = UN;
ut.ImportAttribute = XN;
ut.ImportDeclaration = JN;
ut.ImportDefaultSpecifier = jN;
ut.ImportExpression = HN;
ut.ImportNamespaceSpecifier = YN;
ut.ImportSpecifier = FN;
ut._printAttributes = VN;
var _N = Ae();
const {
  isClassDeclaration: kN,
  isExportDefaultSpecifier: DN,
  isExportNamespaceSpecifier: LN,
  isImportDefaultSpecifier: MN,
  isImportNamespaceSpecifier: BN,
  isStatement: Tc
} = _N;
function FN(e) {
  (e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported, e), e.local && e.local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local, e));
}
function jN(e) {
  this.print(e.local, e);
}
function RN(e) {
  this.print(e.exported, e);
}
function UN(e) {
  e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local, e), e.exported && e.local.name !== e.exported.name && (this.space(), this.word("as"), this.space(), this.print(e.exported, e));
}
function $N(e) {
  this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported, e);
}
let cl = !1;
function VN(e) {
  const {
    importAttributesKeyword: t
  } = this.format, {
    attributes: r,
    assertions: i
  } = e;
  r && !t && !cl && (cl = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
  const s = t === "assert" || !t && i;
  if (this.word(s ? "assert" : "with"), this.space(), !s && t !== "with") {
    this.printList(r || i, e);
    return;
  }
  this.tokenChar(123), this.space(), this.printList(r || i, e), this.space(), this.tokenChar(125);
}
function KN(e) {
  var t, r;
  this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
}
function gc(e, t) {
  kN(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators, t);
}
function qN(e) {
  if (gc(this, e), this.word("export"), this.space(), e.declaration) {
    const i = e.declaration;
    this.print(i, e), Tc(i) || this.semicolon();
  } else {
    e.exportKind === "type" && (this.word("type"), this.space());
    const i = e.specifiers.slice(0);
    let s = !1;
    for (; ; ) {
      const n = i[0];
      if (DN(n) || LN(n))
        s = !0, this.print(i.shift(), e), i.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    if ((i.length || !i.length && !s) && (this.tokenChar(123), i.length && (this.space(), this.printList(i, e), this.space()), this.tokenChar(125)), e.source) {
      var t, r;
      this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e);
    }
    this.semicolon();
  }
}
function WN(e) {
  gc(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
  const t = e.declaration;
  this.print(t, e), Tc(t) || this.semicolon();
}
function JN(e) {
  var t, r;
  this.word("import"), this.space();
  const i = e.importKind === "type" || e.importKind === "typeof";
  i ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module ? (this.noIndentInnerCommentsHere(), this.word("module"), this.space()) : e.phase && (this.noIndentInnerCommentsHere(), this.word(e.phase), this.space());
  const s = e.specifiers.slice(0), n = !!s.length;
  for (; n; ) {
    const a = s[0];
    if (MN(a) || BN(a))
      this.print(s.shift(), e), s.length && (this.tokenChar(44), this.space());
    else
      break;
  }
  s.length ? (this.tokenChar(123), this.space(), this.printList(s, e), this.space(), this.tokenChar(125)) : i && !n && (this.tokenChar(123), this.tokenChar(125)), (n || i) && (this.space(), this.word("from"), this.space()), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
}
function XN(e) {
  this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
}
function YN(e) {
  this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local, e);
}
function HN(e) {
  this.word("import"), e.phase && (this.tokenChar(46), this.word(e.phase)), this.tokenChar(40), this.print(e.source, e), e.options != null && (this.tokenChar(44), this.space(), this.print(e.options, e)), this.tokenChar(41);
}
var Je = {};
const bc = {}, GN = bc.hasOwnProperty, Sc = (e, t) => {
  for (const r in e)
    GN.call(e, r) && t(r, e[r]);
}, zN = (e, t) => (t && Sc(t, (r, i) => {
  e[r] = i;
}), e), QN = (e, t) => {
  const r = e.length;
  let i = -1;
  for (; ++i < r; )
    t(e[i]);
}, fi = bc.toString, ZN = Array.isArray, e2 = Buffer.isBuffer, t2 = (e) => fi.call(e) == "[object Object]", r2 = (e) => typeof e == "string" || fi.call(e) == "[object String]", i2 = (e) => typeof e == "number" || fi.call(e) == "[object Number]", s2 = (e) => typeof e == "function", n2 = (e) => fi.call(e) == "[object Map]", a2 = (e) => fi.call(e) == "[object Set]", o2 = {
  '"': '\\"',
  "'": "\\'",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
  // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
  // '\v': '\\x0B'
}, l2 = /["'\\\b\f\n\r\t]/, u2 = /[0-9]/, c2 = /[ !#-&\(-\[\]-_a-~]/, Ht = (e, t) => {
  const r = () => {
    u = l, ++t.indentLevel, l = t.indent.repeat(t.indentLevel);
  }, i = {
    escapeEverything: !1,
    minimal: !1,
    isScriptContext: !1,
    quotes: "single",
    wrap: !1,
    es6: !1,
    json: !1,
    compact: !0,
    lowercaseHex: !1,
    numbers: "decimal",
    indent: "	",
    indentLevel: 0,
    __inline1__: !1,
    __inline2__: !1
  }, s = t && t.json;
  s && (i.quotes = "double", i.wrap = !0), t = zN(i, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes = "single");
  const n = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'", a = t.compact, o = t.lowercaseHex;
  let l = t.indent.repeat(t.indentLevel), u = "";
  const c = t.__inline1__, f = t.__inline2__, p = a ? "" : `
`;
  let h, y = !0;
  const b = t.numbers == "binary", A = t.numbers == "octal", I = t.numbers == "decimal", _ = t.numbers == "hexadecimal";
  if (s && e && s2(e.toJSON) && (e = e.toJSON()), !r2(e)) {
    if (n2(e))
      return e.size == 0 ? "new Map()" : (a || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + Ht(Array.from(e), t) + ")");
    if (a2(e))
      return e.size == 0 ? "new Set()" : "new Set(" + Ht(Array.from(e), t) + ")";
    if (e2(e))
      return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + Ht(Array.from(e), t) + ")";
    if (ZN(e))
      return h = [], t.wrap = !0, c && (t.__inline1__ = !1, t.__inline2__ = !0), f || r(), QN(e, (te) => {
        y = !1, f && (t.__inline2__ = !1), h.push(
          (a || f ? "" : l) + Ht(te, t)
        );
      }), y ? "[]" : f ? "[" + h.join(", ") + "]" : "[" + p + h.join("," + p) + p + (a ? "" : u) + "]";
    if (i2(e)) {
      if (s)
        return JSON.stringify(e);
      if (I)
        return String(e);
      if (_) {
        let te = e.toString(16);
        return o || (te = te.toUpperCase()), "0x" + te;
      }
      if (b)
        return "0b" + e.toString(2);
      if (A)
        return "0o" + e.toString(8);
    } else return t2(e) ? (h = [], t.wrap = !0, r(), Sc(e, (te, ae) => {
      y = !1, h.push(
        (a ? "" : l) + Ht(te, t) + ":" + (a ? "" : " ") + Ht(ae, t)
      );
    }), y ? "{}" : "{" + p + h.join("," + p) + p + (a ? "" : u) + "}") : s ? JSON.stringify(e) || "null" : String(e);
  }
  const j = e;
  let G = -1;
  const ce = j.length;
  for (h = ""; ++G < ce; ) {
    const te = j.charAt(G);
    if (t.es6) {
      const W = j.charCodeAt(G);
      if (
        // check if its the start of a surrogate pair
        W >= 55296 && W <= 56319 && // high surrogate
        ce > G + 1
      ) {
        const Q = j.charCodeAt(G + 1);
        if (Q >= 56320 && Q <= 57343) {
          let L = ((W - 55296) * 1024 + Q - 56320 + 65536).toString(16);
          o || (L = L.toUpperCase()), h += "\\u{" + L + "}", ++G;
          continue;
        }
      }
    }
    if (!t.escapeEverything) {
      if (c2.test(te)) {
        h += te;
        continue;
      }
      if (te == '"') {
        h += n == te ? '\\"' : te;
        continue;
      }
      if (te == "`") {
        h += n == te ? "\\`" : te;
        continue;
      }
      if (te == "'") {
        h += n == te ? "\\'" : te;
        continue;
      }
    }
    if (te == "\0" && !s && !u2.test(j.charAt(G + 1))) {
      h += "\\0";
      continue;
    }
    if (l2.test(te)) {
      h += o2[te];
      continue;
    }
    const ae = te.charCodeAt(0);
    if (t.minimal && ae != 8232 && ae != 8233) {
      h += te;
      continue;
    }
    let q = ae.toString(16);
    o || (q = q.toUpperCase());
    const Y = q.length > 2 || s, re = "\\" + (Y ? "u" : "x") + ("0000" + q).slice(Y ? -4 : -2);
    h += re;
  }
  return t.wrap && (h = n + h + n), n == "`" && (h = h.replace(/\$\{/g, "\\${")), t.isScriptContext ? h.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, s ? "\\u003C!--" : "\\x3C!--") : h;
};
Ht.version = "2.5.2";
var f2 = Ht;
Object.defineProperty(Je, "__esModule", {
  value: !0
});
Je.ArgumentPlaceholder = m2;
Je.ArrayPattern = Je.ArrayExpression = S2;
Je.BigIntLiteral = w2;
Je.BooleanLiteral = v2;
Je.DecimalLiteral = O2;
Je.Identifier = d2;
Je.NullLiteral = A2;
Je.NumericLiteral = C2;
Je.ObjectPattern = Je.ObjectExpression = T2;
Je.ObjectMethod = g2;
Je.ObjectProperty = b2;
Je.PipelineBareFunction = k2;
Je.PipelinePrimaryTopicReference = D2;
Je.PipelineTopicExpression = _2;
Je.RecordExpression = E2;
Je.RegExpLiteral = x2;
Je.SpreadElement = Je.RestElement = y2;
Je.StringLiteral = I2;
Je.TopicReference = N2;
Je.TupleExpression = P2;
var p2 = Ae(), Ec = f2;
const {
  isAssignmentPattern: h2,
  isIdentifier: Zs
} = p2;
function d2(e) {
  var t;
  this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(e.name);
}
function m2() {
  this.tokenChar(63);
}
function y2(e) {
  this.token("..."), this.print(e.argument, e);
}
function T2(e) {
  const t = e.properties;
  if (this.tokenChar(123), t.length) {
    const r = this.enterForStatementInit(!1);
    this.space(), this.printList(t, e, {
      indent: !0,
      statement: !0
    }), this.space(), r();
  }
  this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
}
function g2(e) {
  this.printJoin(e.decorators, e), this._methodHead(e), this.space(), this.print(e.body, e);
}
function b2(e) {
  if (this.printJoin(e.decorators, e), e.computed)
    this.tokenChar(91), this.print(e.key, e), this.tokenChar(93);
  else {
    if (h2(e.value) && Zs(e.key) && e.key.name === e.value.left.name) {
      this.print(e.value, e);
      return;
    }
    if (this.print(e.key, e), e.shorthand && Zs(e.key) && Zs(e.value) && e.key.name === e.value.name)
      return;
  }
  this.tokenChar(58), this.space(), this.print(e.value, e);
}
function S2(e) {
  const t = e.elements, r = t.length;
  this.tokenChar(91);
  const i = this.enterForStatementInit(!1);
  for (let s = 0; s < t.length; s++) {
    const n = t[s];
    n ? (s > 0 && this.space(), this.print(n, e), s < r - 1 && this.tokenChar(44)) : this.tokenChar(44);
  }
  i(), this.tokenChar(93);
}
function E2(e) {
  const t = e.properties;
  let r, i;
  if (this.format.recordAndTupleSyntaxType === "bar")
    r = "{|", i = "|}";
  else {
    if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
      throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
    r = "#{", i = "}";
  }
  this.token(r), t.length && (this.space(), this.printList(t, e, {
    indent: !0,
    statement: !0
  }), this.space()), this.token(i);
}
function P2(e) {
  const t = e.elements, r = t.length;
  let i, s;
  if (this.format.recordAndTupleSyntaxType === "bar")
    i = "[|", s = "|]";
  else if (this.format.recordAndTupleSyntaxType === "hash")
    i = "#[", s = "]";
  else
    throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
  this.token(i);
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    a && (n > 0 && this.space(), this.print(a, e), n < r - 1 && this.tokenChar(44));
  }
  this.token(s);
}
function x2(e) {
  this.word(`/${e.pattern}/${e.flags}`);
}
function v2(e) {
  this.word(e.value ? "true" : "false");
}
function A2() {
  this.word("null");
}
function C2(e) {
  const t = this.getPossibleRaw(e), r = this.format.jsescOption, i = e.value, s = i + "";
  r.numbers ? this.number(Ec(i, r), i) : t == null ? this.number(s, i) : this.format.minified ? this.number(t.length < s.length ? t : s, i) : this.number(t, i);
}
function I2(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.token(t);
    return;
  }
  const r = Ec(e.value, this.format.jsescOption);
  this.token(r);
}
function w2(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.word(t);
    return;
  }
  this.word(e.value + "n");
}
function O2(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.word(t);
    return;
  }
  this.word(e.value + "m");
}
const fl = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
function N2() {
  const {
    topicToken: e
  } = this.format;
  if (fl.has(e))
    this.token(e);
  else {
    const t = JSON.stringify(e), r = Array.from(fl, (i) => JSON.stringify(i));
    throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${t} received instead).`);
  }
}
function _2(e) {
  this.print(e.expression, e);
}
function k2(e) {
  this.print(e.callee, e);
}
function D2() {
  this.tokenChar(35);
}
var Pc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.AnyTypeAnnotation = a, e.ArrayTypeAnnotation = o, e.BooleanLiteralTypeAnnotation = u, e.BooleanTypeAnnotation = l, e.DeclareClass = f, e.DeclareExportAllDeclaration = te, e.DeclareExportDeclaration = ce, e.DeclareFunction = p, e.DeclareInterface = b, e.DeclareModule = A, e.DeclareModuleExports = I, e.DeclareOpaqueType = j, e.DeclareTypeAlias = _, e.DeclareVariable = G, e.DeclaredPredicate = y, e.EmptyTypeAnnotation = Ee, e.EnumBooleanBody = re, e.EnumBooleanMember = F, e.EnumDeclaration = ae, e.EnumDefaultedMember = L, e.EnumNumberBody = W, e.EnumNumberMember = B, e.EnumStringBody = Q, e.EnumStringMember = N, e.EnumSymbolBody = U, e.ExistsTypeAnnotation = R, e.FunctionTypeAnnotation = V, e.FunctionTypeParam = $, e.IndexedAccessType = it, e.InferredPredicate = h, e.InterfaceDeclaration = Ue, e.GenericTypeAnnotation = e.ClassImplements = e.InterfaceExtends = H, e.InterfaceTypeAnnotation = pe, e.IntersectionTypeAnnotation = Se, e.MixedTypeAnnotation = Ce, e.NullLiteralTypeAnnotation = c, e.NullableTypeAnnotation = Ne, Object.defineProperty(e, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return i.NumericLiteral;
    }
  }), e.NumberTypeAnnotation = _e, e.ObjectTypeAnnotation = d, e.ObjectTypeCallProperty = O, e.ObjectTypeIndexer = M, e.ObjectTypeInternalSlot = x, e.ObjectTypeProperty = Z, e.ObjectTypeSpreadProperty = ee, e.OpaqueType = J, e.OptionalIndexedAccessType = dt, e.QualifiedTypeIdentifier = ge, Object.defineProperty(e, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return i.StringLiteral;
    }
  }), e.StringTypeAnnotation = qe, e.SymbolTypeAnnotation = xe, e.ThisTypeAnnotation = tt, e.TupleTypeAnnotation = Pe, e.TypeAlias = ve, e.TypeAnnotation = Re, e.TypeCastExpression = rt, e.TypeParameter = He, e.TypeParameterDeclaration = e.TypeParameterInstantiation = lt, e.TypeofTypeAnnotation = Be, e.UnionTypeAnnotation = X, e.Variance = Ve, e.VoidTypeAnnotation = We, e._interfaceish = se, e._variance = oe;
  var t = Ae(), r = ut, i = Je;
  const {
    isDeclareExportDeclaration: s,
    isStatement: n
  } = t;
  function a() {
    this.word("any");
  }
  function o(v) {
    this.print(v.elementType, v, !0), this.tokenChar(91), this.tokenChar(93);
  }
  function l() {
    this.word("boolean");
  }
  function u(v) {
    this.word(v.value ? "true" : "false");
  }
  function c() {
    this.word("null");
  }
  function f(v, he) {
    s(he) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(v);
  }
  function p(v, he) {
    s(he) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(v.id, v), this.print(v.id.typeAnnotation.typeAnnotation, v), v.predicate && (this.space(), this.print(v.predicate, v)), this.semicolon();
  }
  function h() {
    this.tokenChar(37), this.word("checks");
  }
  function y(v) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(v.value, v), this.tokenChar(41);
  }
  function b(v) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(v);
  }
  function A(v) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(v.id, v), this.space(), this.print(v.body, v);
  }
  function I(v) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(v.typeAnnotation, v);
  }
  function _(v) {
    this.word("declare"), this.space(), this.TypeAlias(v);
  }
  function j(v, he) {
    s(he) || (this.word("declare"), this.space()), this.OpaqueType(v);
  }
  function G(v, he) {
    s(he) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(v.id, v), this.print(v.id.typeAnnotation, v), this.semicolon();
  }
  function ce(v) {
    this.word("declare"), this.space(), this.word("export"), this.space(), v.default && (this.word("default"), this.space()), D.call(this, v);
  }
  function te(v) {
    this.word("declare"), this.space(), r.ExportAllDeclaration.call(this, v);
  }
  function ae(v) {
    const {
      id: he,
      body: Fe
    } = v;
    this.word("enum"), this.space(), this.print(he, v), this.print(Fe, v);
  }
  function q(v, he, Fe) {
    Fe && (v.space(), v.word("of"), v.space(), v.word(he)), v.space();
  }
  function Y(v, he) {
    const {
      members: Fe
    } = he;
    v.token("{"), v.indent(), v.newline();
    for (const bt of Fe)
      v.print(bt, he), v.newline();
    he.hasUnknownMembers && (v.token("..."), v.newline()), v.dedent(), v.token("}");
  }
  function re(v) {
    const {
      explicitType: he
    } = v;
    q(this, "boolean", he), Y(this, v);
  }
  function W(v) {
    const {
      explicitType: he
    } = v;
    q(this, "number", he), Y(this, v);
  }
  function Q(v) {
    const {
      explicitType: he
    } = v;
    q(this, "string", he), Y(this, v);
  }
  function U(v) {
    q(this, "symbol", !0), Y(this, v);
  }
  function L(v) {
    const {
      id: he
    } = v;
    this.print(he, v), this.tokenChar(44);
  }
  function k(v, he) {
    const {
      id: Fe,
      init: bt
    } = he;
    v.print(Fe, he), v.space(), v.token("="), v.space(), v.print(bt, he), v.token(",");
  }
  function F(v) {
    k(this, v);
  }
  function B(v) {
    k(this, v);
  }
  function N(v) {
    k(this, v);
  }
  function D(v) {
    if (v.declaration) {
      const he = v.declaration;
      this.print(he, v), n(he) || this.semicolon();
    } else
      this.tokenChar(123), v.specifiers.length && (this.space(), this.printList(v.specifiers, v), this.space()), this.tokenChar(125), v.source && (this.space(), this.word("from"), this.space(), this.print(v.source, v)), this.semicolon();
  }
  function R() {
    this.tokenChar(42);
  }
  function V(v, he) {
    this.print(v.typeParameters, v), this.tokenChar(40), v.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(v.this.typeAnnotation, v), (v.params.length || v.rest) && (this.tokenChar(44), this.space())), this.printList(v.params, v), v.rest && (v.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(v.rest, v)), this.tokenChar(41);
    const Fe = he == null ? void 0 : he.type;
    Fe != null && (Fe === "ObjectTypeCallProperty" || Fe === "ObjectTypeInternalSlot" || Fe === "DeclareFunction" || Fe === "ObjectTypeProperty" && he.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(v.returnType, v);
  }
  function $(v) {
    this.print(v.name, v), v.optional && this.tokenChar(63), v.name && (this.tokenChar(58), this.space()), this.print(v.typeAnnotation, v);
  }
  function H(v) {
    this.print(v.id, v), this.print(v.typeParameters, v, !0);
  }
  function se(v) {
    var he;
    if (this.print(v.id, v), this.print(v.typeParameters, v), (he = v.extends) != null && he.length && (this.space(), this.word("extends"), this.space(), this.printList(v.extends, v)), v.type === "DeclareClass") {
      var Fe, bt;
      (Fe = v.mixins) != null && Fe.length && (this.space(), this.word("mixins"), this.space(), this.printList(v.mixins, v)), (bt = v.implements) != null && bt.length && (this.space(), this.word("implements"), this.space(), this.printList(v.implements, v));
    }
    this.space(), this.print(v.body, v);
  }
  function oe(v) {
    var he;
    const Fe = (he = v.variance) == null ? void 0 : he.kind;
    Fe != null && (Fe === "plus" ? this.tokenChar(43) : Fe === "minus" && this.tokenChar(45));
  }
  function Ue(v) {
    this.word("interface"), this.space(), this._interfaceish(v);
  }
  function fe() {
    this.space(), this.tokenChar(38), this.space();
  }
  function pe(v) {
    var he;
    this.word("interface"), (he = v.extends) != null && he.length && (this.space(), this.word("extends"), this.space(), this.printList(v.extends, v)), this.space(), this.print(v.body, v);
  }
  function Se(v) {
    this.printJoin(v.types, v, {
      separator: fe
    });
  }
  function Ce() {
    this.word("mixed");
  }
  function Ee() {
    this.word("empty");
  }
  function Ne(v) {
    this.tokenChar(63), this.print(v.typeAnnotation, v);
  }
  function _e() {
    this.word("number");
  }
  function qe() {
    this.word("string");
  }
  function tt() {
    this.word("this");
  }
  function Pe(v) {
    this.tokenChar(91), this.printList(v.types, v), this.tokenChar(93);
  }
  function Be(v) {
    this.word("typeof"), this.space(), this.print(v.argument, v);
  }
  function ve(v) {
    this.word("type"), this.space(), this.print(v.id, v), this.print(v.typeParameters, v), this.space(), this.tokenChar(61), this.space(), this.print(v.right, v), this.semicolon();
  }
  function Re(v) {
    this.tokenChar(58), this.space(), v.optional && this.tokenChar(63), this.print(v.typeAnnotation, v);
  }
  function lt(v) {
    this.tokenChar(60), this.printList(v.params, v, {}), this.tokenChar(62);
  }
  function He(v) {
    this._variance(v), this.word(v.name), v.bound && this.print(v.bound, v), v.default && (this.space(), this.tokenChar(61), this.space(), this.print(v.default, v));
  }
  function J(v) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(v.id, v), this.print(v.typeParameters, v), v.supertype && (this.tokenChar(58), this.space(), this.print(v.supertype, v)), v.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(v.impltype, v)), this.semicolon();
  }
  function d(v) {
    v.exact ? this.token("{|") : this.tokenChar(123);
    const he = [...v.properties, ...v.callProperties || [], ...v.indexers || [], ...v.internalSlots || []];
    he.length && (this.newline(), this.space(), this.printJoin(he, v, {
      addNewlines(Fe) {
        if (Fe && !he[0]) return 1;
      },
      indent: !0,
      statement: !0,
      iterator: () => {
        (he.length !== 1 || v.inexact) && (this.tokenChar(44), this.space());
      }
    }), this.space()), v.inexact && (this.indent(), this.token("..."), he.length && this.newline(), this.dedent()), v.exact ? this.token("|}") : this.tokenChar(125);
  }
  function x(v) {
    v.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(v.id, v), this.tokenChar(93), this.tokenChar(93), v.optional && this.tokenChar(63), v.method || (this.tokenChar(58), this.space()), this.print(v.value, v);
  }
  function O(v) {
    v.static && (this.word("static"), this.space()), this.print(v.value, v);
  }
  function M(v) {
    v.static && (this.word("static"), this.space()), this._variance(v), this.tokenChar(91), v.id && (this.print(v.id, v), this.tokenChar(58), this.space()), this.print(v.key, v), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(v.value, v);
  }
  function Z(v) {
    v.proto && (this.word("proto"), this.space()), v.static && (this.word("static"), this.space()), (v.kind === "get" || v.kind === "set") && (this.word(v.kind), this.space()), this._variance(v), this.print(v.key, v), v.optional && this.tokenChar(63), v.method || (this.tokenChar(58), this.space()), this.print(v.value, v);
  }
  function ee(v) {
    this.token("..."), this.print(v.argument, v);
  }
  function ge(v) {
    this.print(v.qualification, v), this.tokenChar(46), this.print(v.id, v);
  }
  function xe() {
    this.word("symbol");
  }
  function ye() {
    this.space(), this.tokenChar(124), this.space();
  }
  function X(v) {
    this.printJoin(v.types, v, {
      separator: ye
    });
  }
  function rt(v) {
    this.tokenChar(40), this.print(v.expression, v), this.print(v.typeAnnotation, v), this.tokenChar(41);
  }
  function Ve(v) {
    v.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  function We() {
    this.word("void");
  }
  function it(v) {
    this.print(v.objectType, v, !0), this.tokenChar(91), this.print(v.indexType, v), this.tokenChar(93);
  }
  function dt(v) {
    this.print(v.objectType, v), v.optional && this.token("?."), this.tokenChar(91), this.print(v.indexType, v), this.tokenChar(93);
  }
})(Pc);
var qt = {};
Object.defineProperty(qt, "__esModule", {
  value: !0
});
qt.BlockStatement = B2;
qt.Directive = F2;
qt.DirectiveLiteral = U2;
qt.File = L2;
qt.InterpreterDirective = $2;
qt.Placeholder = V2;
qt.Program = M2;
function L2(e) {
  e.program && this.print(e.program.interpreter, e), this.print(e.program, e);
}
function M2(e) {
  var t;
  this.noIndentInnerCommentsHere(), this.printInnerComments();
  const r = (t = e.directives) == null ? void 0 : t.length;
  if (r) {
    var i;
    const s = e.body.length ? 2 : 1;
    this.printSequence(e.directives, e, {
      trailingCommentsLineOffset: s
    }), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(s);
  }
  this.printSequence(e.body, e);
}
function B2(e) {
  var t;
  this.tokenChar(123);
  const r = (t = e.directives) == null ? void 0 : t.length;
  if (r) {
    var i;
    const n = e.body.length ? 2 : 1;
    this.printSequence(e.directives, e, {
      indent: !0,
      trailingCommentsLineOffset: n
    }), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(n);
  }
  const s = this.enterForStatementInit(!1);
  this.printSequence(e.body, e, {
    indent: !0
  }), s(), this.rightBrace(e);
}
function F2(e) {
  this.print(e.value, e), this.semicolon();
}
const j2 = /(?:^|[^\\])(?:\\\\)*'/, R2 = /(?:^|[^\\])(?:\\\\)*"/;
function U2(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.token(t);
    return;
  }
  const {
    value: r
  } = e;
  if (!R2.test(r))
    this.token(`"${r}"`);
  else if (!j2.test(r))
    this.token(`'${r}'`);
  else
    throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
}
function $2(e) {
  this.token(`#!${e.value}`), this.newline(1, !0);
}
function V2(e) {
  this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
}
var ot = {};
Object.defineProperty(ot, "__esModule", {
  value: !0
});
ot.JSXAttribute = K2;
ot.JSXClosingElement = e_;
ot.JSXClosingFragment = s_;
ot.JSXElement = z2;
ot.JSXEmptyExpression = t_;
ot.JSXExpressionContainer = Y2;
ot.JSXFragment = r_;
ot.JSXIdentifier = q2;
ot.JSXMemberExpression = J2;
ot.JSXNamespacedName = W2;
ot.JSXOpeningElement = Z2;
ot.JSXOpeningFragment = i_;
ot.JSXSpreadAttribute = X2;
ot.JSXSpreadChild = H2;
ot.JSXText = G2;
function K2(e) {
  this.print(e.name, e), e.value && (this.tokenChar(61), this.print(e.value, e));
}
function q2(e) {
  this.word(e.name);
}
function W2(e) {
  this.print(e.namespace, e), this.tokenChar(58), this.print(e.name, e);
}
function J2(e) {
  this.print(e.object, e), this.tokenChar(46), this.print(e.property, e);
}
function X2(e) {
  this.tokenChar(123), this.token("..."), this.print(e.argument, e), this.tokenChar(125);
}
function Y2(e) {
  this.tokenChar(123), this.print(e.expression, e), this.tokenChar(125);
}
function H2(e) {
  this.tokenChar(123), this.token("..."), this.print(e.expression, e), this.tokenChar(125);
}
function G2(e) {
  const t = this.getPossibleRaw(e);
  t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
}
function z2(e) {
  const t = e.openingElement;
  if (this.print(t, e), !t.selfClosing) {
    this.indent();
    for (const r of e.children)
      this.print(r, e);
    this.dedent(), this.print(e.closingElement, e);
  }
}
function Q2() {
  this.space();
}
function Z2(e) {
  this.tokenChar(60), this.print(e.name, e), this.print(e.typeParameters, e), e.attributes.length > 0 && (this.space(), this.printJoin(e.attributes, e, {
    separator: Q2
  })), e.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
}
function e_(e) {
  this.token("</"), this.print(e.name, e), this.tokenChar(62);
}
function t_() {
  this.printInnerComments();
}
function r_(e) {
  this.print(e.openingFragment, e), this.indent();
  for (const t of e.children)
    this.print(t, e);
  this.dedent(), this.print(e.closingFragment, e);
}
function i_() {
  this.tokenChar(60), this.tokenChar(62);
}
function s_() {
  this.token("</"), this.tokenChar(62);
}
var ne = {};
Object.defineProperty(ne, "__esModule", {
  value: !0
});
ne.TSAnyKeyword = g_;
ne.TSArrayType = U_;
ne.TSSatisfiesExpression = ne.TSAsExpression = sk;
ne.TSBigIntKeyword = b_;
ne.TSBooleanKeyword = x_;
ne.TSCallSignatureDeclaration = p_;
ne.TSConditionalType = X_;
ne.TSConstructSignatureDeclaration = h_;
ne.TSConstructorType = D_;
ne.TSDeclareFunction = u_;
ne.TSDeclareMethod = c_;
ne.TSEnumDeclaration = ok;
ne.TSEnumMember = lk;
ne.TSExportAssignment = mk;
ne.TSExpressionWithTypeArguments = ek;
ne.TSExternalModuleReference = hk;
ne.TSFunctionType = k_;
ne.TSImportEqualsDeclaration = pk;
ne.TSImportType = fk;
ne.TSIndexSignature = T_;
ne.TSIndexedAccessType = z_;
ne.TSInferType = Y_;
ne.TSInstantiationExpression = ak;
ne.TSInterfaceBody = rk;
ne.TSInterfaceDeclaration = tk;
ne.TSIntersectionType = J_;
ne.TSIntrinsicKeyword = N_;
ne.TSLiteralType = Z_;
ne.TSMappedType = Q_;
ne.TSMethodSignature = y_;
ne.TSModuleBlock = ck;
ne.TSModuleDeclaration = uk;
ne.TSNamedTupleMember = q_;
ne.TSNamespaceExportDeclaration = yk;
ne.TSNeverKeyword = O_;
ne.TSNonNullExpression = dk;
ne.TSNullKeyword = w_;
ne.TSNumberKeyword = E_;
ne.TSObjectKeyword = P_;
ne.TSOptionalType = V_;
ne.TSParameterProperty = l_;
ne.TSParenthesizedType = H_;
ne.TSPropertySignature = d_;
ne.TSQualifiedName = f_;
ne.TSRestType = K_;
ne.TSStringKeyword = v_;
ne.TSSymbolKeyword = A_;
ne.TSThisType = __;
ne.TSTupleType = $_;
ne.TSTypeAliasDeclaration = ik;
ne.TSTypeAnnotation = n_;
ne.TSTypeAssertion = nk;
ne.TSTypeLiteral = j_;
ne.TSTypeOperator = G_;
ne.TSTypeParameter = o_;
ne.TSTypeParameterDeclaration = ne.TSTypeParameterInstantiation = a_;
ne.TSTypePredicate = B_;
ne.TSTypeQuery = F_;
ne.TSTypeReference = M_;
ne.TSUndefinedKeyword = I_;
ne.TSUnionType = W_;
ne.TSUnknownKeyword = S_;
ne.TSVoidKeyword = C_;
ne.tsPrintClassMemberModifiers = gk;
ne.tsPrintFunctionOrConstructorType = L_;
ne.tsPrintPropertyOrMethodName = m_;
ne.tsPrintSignatureDeclarationBase = Tk;
ne.tsPrintTypeLiteralOrInterfaceBody = R_;
function n_(e) {
  this.tokenChar(58), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
}
function a_(e, t) {
  this.tokenChar(60), this.printList(e.params, e, {}), t.type === "ArrowFunctionExpression" && e.params.length === 1 && this.tokenChar(44), this.tokenChar(62);
}
function o_(e) {
  e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.word(e.name), e.constraint && (this.space(), this.word("extends"), this.space(), this.print(e.constraint, e)), e.default && (this.space(), this.tokenChar(61), this.space(), this.print(e.default, e));
}
function l_(e) {
  e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
}
function u_(e, t) {
  e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.tokenChar(59);
}
function c_(e) {
  this._classMethodHead(e), this.tokenChar(59);
}
function f_(e) {
  this.print(e.left, e), this.tokenChar(46), this.print(e.right, e);
}
function p_(e) {
  this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function h_(e) {
  this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function d_(e) {
  const {
    readonly: t
  } = e;
  t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation, e), this.tokenChar(59);
}
function m_(e) {
  e.computed && this.tokenChar(91), this.print(e.key, e), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
}
function y_(e) {
  const {
    kind: t
  } = e;
  (t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function T_(e) {
  const {
    readonly: t,
    static: r
  } = e;
  r && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters, e), this.tokenChar(93), this.print(e.typeAnnotation, e), this.tokenChar(59);
}
function g_() {
  this.word("any");
}
function b_() {
  this.word("bigint");
}
function S_() {
  this.word("unknown");
}
function E_() {
  this.word("number");
}
function P_() {
  this.word("object");
}
function x_() {
  this.word("boolean");
}
function v_() {
  this.word("string");
}
function A_() {
  this.word("symbol");
}
function C_() {
  this.word("void");
}
function I_() {
  this.word("undefined");
}
function w_() {
  this.word("null");
}
function O_() {
  this.word("never");
}
function N_() {
  this.word("intrinsic");
}
function __() {
  this.word("this");
}
function k_(e) {
  this.tsPrintFunctionOrConstructorType(e);
}
function D_(e) {
  e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
}
function L_(e) {
  const {
    typeParameters: t
  } = e, r = e.parameters;
  this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41), this.space(), this.token("=>"), this.space();
  const i = e.typeAnnotation;
  this.print(i.typeAnnotation, e);
}
function M_(e) {
  this.print(e.typeName, e, !0), this.print(e.typeParameters, e, !0);
}
function B_(e) {
  e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(e.typeAnnotation.typeAnnotation));
}
function F_(e) {
  this.word("typeof"), this.space(), this.print(e.exprName), e.typeParameters && this.print(e.typeParameters, e);
}
function j_(e) {
  this.tsPrintTypeLiteralOrInterfaceBody(e.members, e);
}
function R_(e, t) {
  Pa(this, e, t);
}
function Pa(e, t, r) {
  if (e.token("{"), t.length) {
    e.indent(), e.newline();
    for (const i of t)
      e.print(i, r), e.newline();
    e.dedent();
  }
  e.rightBrace(r);
}
function U_(e) {
  this.print(e.elementType, e, !0), this.token("[]");
}
function $_(e) {
  this.tokenChar(91), this.printList(e.elementTypes, e), this.tokenChar(93);
}
function V_(e) {
  this.print(e.typeAnnotation, e), this.tokenChar(63);
}
function K_(e) {
  this.token("..."), this.print(e.typeAnnotation, e);
}
function q_(e) {
  this.print(e.label, e), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType, e);
}
function W_(e) {
  xc(this, e, "|");
}
function J_(e) {
  xc(this, e, "&");
}
function xc(e, t, r) {
  e.printJoin(t.types, t, {
    separator() {
      this.space(), this.token(r), this.space();
    }
  });
}
function X_(e) {
  this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
}
function Y_(e) {
  this.token("infer"), this.space(), this.print(e.typeParameter);
}
function H_(e) {
  this.tokenChar(40), this.print(e.typeAnnotation, e), this.tokenChar(41);
}
function G_(e) {
  this.word(e.operator), this.space(), this.print(e.typeAnnotation, e);
}
function z_(e) {
  this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
}
function Q_(e) {
  const {
    nameType: t,
    optional: r,
    readonly: i,
    typeParameter: s,
    typeAnnotation: n
  } = e;
  this.tokenChar(123), this.space(), i && (pl(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(s.name), this.space(), this.word("in"), this.space(), this.print(s.constraint, s), t && (this.space(), this.word("as"), this.space(), this.print(t, e)), this.tokenChar(93), r && (pl(this, r), this.tokenChar(63)), n && (this.tokenChar(58), this.space(), this.print(n, e)), this.space(), this.tokenChar(125);
}
function pl(e, t) {
  t !== !0 && e.token(t);
}
function Z_(e) {
  this.print(e.literal, e);
}
function ek(e) {
  this.print(e.expression, e), this.print(e.typeParameters, e);
}
function tk(e) {
  const {
    declare: t,
    id: r,
    typeParameters: i,
    extends: s,
    body: n
  } = e;
  t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r, e), this.print(i, e), s != null && s.length && (this.space(), this.word("extends"), this.space(), this.printList(s, e)), this.space(), this.print(n, e);
}
function rk(e) {
  this.tsPrintTypeLiteralOrInterfaceBody(e.body, e);
}
function ik(e) {
  const {
    declare: t,
    id: r,
    typeParameters: i,
    typeAnnotation: s
  } = e;
  t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r, e), this.print(i, e), this.space(), this.tokenChar(61), this.space(), this.print(s, e), this.tokenChar(59);
}
function sk(e) {
  var t;
  const {
    type: r,
    expression: i,
    typeAnnotation: s
  } = e, n = !!((t = i.trailingComments) != null && t.length);
  this.print(i, e, !0, void 0, n), this.space(), this.word(r === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(s, e);
}
function nk(e) {
  const {
    typeAnnotation: t,
    expression: r
  } = e;
  this.tokenChar(60), this.print(t, e), this.tokenChar(62), this.space(), this.print(r, e);
}
function ak(e) {
  this.print(e.expression, e), this.print(e.typeParameters, e);
}
function ok(e) {
  const {
    declare: t,
    const: r,
    id: i,
    members: s
  } = e;
  t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i, e), this.space(), Pa(this, s, e);
}
function lk(e) {
  const {
    id: t,
    initializer: r
  } = e;
  this.print(t, e), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, e)), this.tokenChar(44);
}
function uk(e) {
  const {
    declare: t,
    id: r
  } = e;
  if (t && (this.word("declare"), this.space()), e.global || (this.word(r.type === "Identifier" ? "namespace" : "module"), this.space()), this.print(r, e), !e.body) {
    this.tokenChar(59);
    return;
  }
  let i = e.body;
  for (; i.type === "TSModuleDeclaration"; )
    this.tokenChar(46), this.print(i.id, i), i = i.body;
  this.space(), this.print(i, e);
}
function ck(e) {
  Pa(this, e.body, e);
}
function fk(e) {
  const {
    argument: t,
    qualifier: r,
    typeParameters: i
  } = e;
  this.word("import"), this.tokenChar(40), this.print(t, e), this.tokenChar(41), r && (this.tokenChar(46), this.print(r, e)), i && this.print(i, e);
}
function pk(e) {
  const {
    isExport: t,
    id: r,
    moduleReference: i
  } = e;
  t && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r, e), this.space(), this.tokenChar(61), this.space(), this.print(i, e), this.tokenChar(59);
}
function hk(e) {
  this.token("require("), this.print(e.expression, e), this.tokenChar(41);
}
function dk(e) {
  this.print(e.expression, e), this.tokenChar(33);
}
function mk(e) {
  this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression, e), this.tokenChar(59);
}
function yk(e) {
  this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id, e);
}
function Tk(e) {
  const {
    typeParameters: t
  } = e, r = e.parameters;
  this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41);
  const i = e.typeAnnotation;
  this.print(i, e);
}
function gk(e) {
  const t = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
  t && e.declare && (this.word("declare"), this.space()), e.accessibility && (this.word(e.accessibility), this.space()), e.static && (this.word("static"), this.space()), e.override && (this.word("override"), this.space()), e.abstract && (this.word("abstract"), this.space()), t && e.readonly && (this.word("readonly"), this.space());
}
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = ci;
  Object.keys(t).forEach(function(p) {
    p === "default" || p === "__esModule" || p in e && e[p] === t[p] || Object.defineProperty(e, p, {
      enumerable: !0,
      get: function() {
        return t[p];
      }
    });
  });
  var r = je;
  Object.keys(r).forEach(function(p) {
    p === "default" || p === "__esModule" || p in e && e[p] === r[p] || Object.defineProperty(e, p, {
      enumerable: !0,
      get: function() {
        return r[p];
      }
    });
  });
  var i = ze;
  Object.keys(i).forEach(function(p) {
    p === "default" || p === "__esModule" || p in e && e[p] === i[p] || Object.defineProperty(e, p, {
      enumerable: !0,
      get: function() {
        return i[p];
      }
    });
  });
  var s = Et;
  Object.keys(s).forEach(function(p) {
    p === "default" || p === "__esModule" || p in e && e[p] === s[p] || Object.defineProperty(e, p, {
      enumerable: !0,
      get: function() {
        return s[p];
      }
    });
  });
  var n = Ct;
  Object.keys(n).forEach(function(p) {
    p === "default" || p === "__esModule" || p in e && e[p] === n[p] || Object.defineProperty(e, p, {
      enumerable: !0,
      get: function() {
        return n[p];
      }
    });
  });
  var a = ut;
  Object.keys(a).forEach(function(p) {
    p === "default" || p === "__esModule" || p in e && e[p] === a[p] || Object.defineProperty(e, p, {
      enumerable: !0,
      get: function() {
        return a[p];
      }
    });
  });
  var o = Je;
  Object.keys(o).forEach(function(p) {
    p === "default" || p === "__esModule" || p in e && e[p] === o[p] || Object.defineProperty(e, p, {
      enumerable: !0,
      get: function() {
        return o[p];
      }
    });
  });
  var l = Pc;
  Object.keys(l).forEach(function(p) {
    p === "default" || p === "__esModule" || p in e && e[p] === l[p] || Object.defineProperty(e, p, {
      enumerable: !0,
      get: function() {
        return l[p];
      }
    });
  });
  var u = qt;
  Object.keys(u).forEach(function(p) {
    p === "default" || p === "__esModule" || p in e && e[p] === u[p] || Object.defineProperty(e, p, {
      enumerable: !0,
      get: function() {
        return u[p];
      }
    });
  });
  var c = ot;
  Object.keys(c).forEach(function(p) {
    p === "default" || p === "__esModule" || p in e && e[p] === c[p] || Object.defineProperty(e, p, {
      enumerable: !0,
      get: function() {
        return c[p];
      }
    });
  });
  var f = ne;
  Object.keys(f).forEach(function(p) {
    p === "default" || p === "__esModule" || p in e && e[p] === f[p] || Object.defineProperty(e, p, {
      enumerable: !0,
      get: function() {
        return f[p];
      }
    });
  });
})(hc);
Object.defineProperty(Cs, "__esModule", {
  value: !0
});
Cs.default = void 0;
var bk = Is, Sk = vr, Ek = Ae(), Pk = hc;
const {
  isFunction: xk,
  isStatement: vk,
  isClassBody: Ak,
  isTSInterfaceBody: Ck,
  isTSEnumDeclaration: Ik
} = Ek, wk = /e/i, Ok = /\.0+$/, hl = /[\n\r\u2028\u2029]/, Nk = /[\n\r\u2028\u2029]|\*\//, {
  needsParens: _k
} = Sk;
class xa {
  constructor(t, r) {
    this.inForStatementInit = !1, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState = null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = t, this._indentRepeat = t.indent.style.length, this._inputMap = r == null ? void 0 : r._inputMap, this._buf = new bk.default(r, t.indent.style[0]);
  }
  enterForStatementInit(t) {
    const r = this.inForStatementInit;
    return r === t ? () => {
    } : (this.inForStatementInit = t, () => {
      this.inForStatementInit = r;
    });
  }
  generate(t) {
    return this.print(t), this._maybeAddAuxComment(), this._buf.get();
  }
  indent() {
    this.format.compact || this.format.concise || this._indent++;
  }
  dedent() {
    this.format.compact || this.format.concise || this._indent--;
  }
  semicolon(t = !1) {
    this._maybeAddAuxComment(), t ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
  }
  rightBrace(t) {
    this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  rightParens(t) {
    this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
  }
  space(t = !1) {
    if (!this.format.compact) {
      if (t)
        this._space();
      else if (this._buf.hasContent()) {
        const r = this.getLastChar();
        r !== 32 && r !== 10 && this._space();
      }
    }
  }
  word(t, r = !1) {
    this._maybePrintInnerComments(), (this._endsWithWord || t.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator = r;
  }
  number(t, r) {
    function i(s) {
      if (s.length > 2 && s.charCodeAt(0) === 48) {
        const n = s.charCodeAt(1);
        return n === 98 || n === 111 || n === 120;
      }
      return !1;
    }
    this.word(t), this._endsWithInteger = Number.isInteger(r) && !i(t) && !wk.test(t) && !Ok.test(t) && t.charCodeAt(t.length - 1) !== 46;
  }
  token(t, r = !1) {
    this._maybePrintInnerComments();
    const i = this.getLastChar(), s = t.charCodeAt(0);
    (i === 33 && (t === "--" || s === 61) || s === 43 && i === 43 || s === 45 && i === 45 || s === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(t, r), this._noLineTerminator = !1;
  }
  tokenChar(t) {
    this._maybePrintInnerComments();
    const r = this.getLastChar();
    (t === 43 && r === 43 || t === 45 && r === 45 || t === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(t), this._noLineTerminator = !1;
  }
  newline(t = 1, r) {
    if (!(t <= 0)) {
      if (!r) {
        if (this.format.retainLines || this.format.compact) return;
        if (this.format.concise) {
          this.space();
          return;
        }
      }
      t > 2 && (t = 2), t -= this._buf.getNewlineCount();
      for (let i = 0; i < t; i++)
        this._newline();
    }
  }
  endsWith(t) {
    return this.getLastChar() === t;
  }
  getLastChar() {
    return this._buf.getLastChar();
  }
  endsWithCharAndNewline() {
    return this._buf.endsWithCharAndNewline();
  }
  removeTrailingNewline() {
    this._buf.removeTrailingNewline();
  }
  exactSource(t, r) {
    if (!t) {
      r();
      return;
    }
    this._catchUp("start", t), this._buf.exactSource(t, r);
  }
  source(t, r) {
    r && (this._catchUp(t, r), this._buf.source(t, r));
  }
  sourceWithOffset(t, r, i) {
    r && (this._catchUp(t, r), this._buf.sourceWithOffset(t, r, i));
  }
  sourceIdentifierName(t, r) {
    if (!this._buf._canMarkIdName) return;
    const i = this._buf._sourcePosition;
    i.identifierNamePos = r, i.identifierName = t;
  }
  _space() {
    this._queue(32);
  }
  _newline() {
    this._queue(10);
  }
  _append(t, r) {
    this._maybeAddParen(t), this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, r), this._endsWithWord = !1, this._endsWithInteger = !1;
  }
  _appendChar(t) {
    this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1;
  }
  _queue(t) {
    this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
  }
  _maybeIndent(t) {
    this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
  }
  _shouldIndent(t) {
    if (this._indent && t !== 10 && this.endsWith(10))
      return !0;
  }
  _maybeAddParenChar(t) {
    const r = this._parenPushNewlineState;
    if (r && t !== 32) {
      if (t !== 10) {
        this._parenPushNewlineState = null;
        return;
      }
      this.tokenChar(40), this.indent(), r.printed = !0;
    }
  }
  _maybeAddParen(t) {
    const r = this._parenPushNewlineState;
    if (!r) return;
    const i = t.length;
    let s;
    for (s = 0; s < i && t.charCodeAt(s) === 32; s++) ;
    if (s === i)
      return;
    const n = t.charCodeAt(s);
    if (n !== 10) {
      if (n !== 47 || s + 1 === i) {
        this._parenPushNewlineState = null;
        return;
      }
      const a = t.charCodeAt(s + 1);
      if (a === 42)
        return;
      if (a !== 47) {
        this._parenPushNewlineState = null;
        return;
      }
    }
    this.tokenChar(40), this.indent(), r.printed = !0;
  }
  catchUp(t) {
    if (!this.format.retainLines) return;
    const r = t - this._buf.getCurrentLine();
    for (let i = 0; i < r; i++)
      this._newline();
  }
  _catchUp(t, r) {
    var i;
    if (!this.format.retainLines) return;
    const s = r == null || (i = r[t]) == null ? void 0 : i.line;
    if (s != null) {
      const n = s - this._buf.getCurrentLine();
      for (let a = 0; a < n; a++)
        this._newline();
    }
  }
  _getIndent() {
    return this._indentRepeat * this._indent;
  }
  printTerminatorless(t, r, i) {
    if (i)
      this._noLineTerminator = !0, this.print(t, r);
    else {
      const s = {
        printed: !1
      };
      this._parenPushNewlineState = s, this.print(t, r), s.printed && (this.dedent(), this.newline(), this.tokenChar(41));
    }
  }
  print(t, r, i, s, n) {
    var a, o;
    if (!t) return;
    this._endsWithInnerRaw = !1;
    const l = t.type, u = this.format, c = u.concise;
    t._compact && (u.concise = !0);
    const f = this[l];
    if (f === void 0)
      throw new ReferenceError(`unknown node of type ${JSON.stringify(l)} with constructor ${JSON.stringify(t.constructor.name)}`);
    this._printStack.push(t);
    const p = this._insideAux;
    this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !p);
    const h = (a = t.extra) == null ? void 0 : a.parenthesized;
    let y = n || h && u.retainFunctionParens && l === "FunctionExpression" || _k(t, r, this._printStack, this.inForStatementInit);
    if (!y && h && (o = t.leadingComments) != null && o.length && t.leadingComments[0].type === "CommentBlock")
      switch (r == null ? void 0 : r.type) {
        case "ExpressionStatement":
        case "VariableDeclarator":
        case "AssignmentExpression":
        case "ReturnStatement":
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          if (r.callee !== t) break;
        default:
          y = !0;
      }
    let b;
    y && (this.tokenChar(40), this._endsWithInnerRaw = !1, b = this.enterForStatementInit(!1)), this._lastCommentLine = 0, this._printLeadingComments(t, r);
    const A = l === "Program" || l === "File" ? null : t.loc;
    this.exactSource(A, f.bind(this, t, r)), y ? (this._printTrailingComments(t, r), this.tokenChar(41), this._noLineTerminator = i, b()) : i && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(t, r)) : this._printTrailingComments(t, r, s), this._printStack.pop(), u.concise = c, this._insideAux = p, this._endsWithInnerRaw = !1;
  }
  _maybeAddAuxComment(t) {
    t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
  }
  _printAuxBeforeComment() {
    if (this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = !0;
    const t = this.format.auxiliaryCommentBefore;
    t && this._printComment({
      type: "CommentBlock",
      value: t
    }, 0);
  }
  _printAuxAfterComment() {
    if (!this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = !1;
    const t = this.format.auxiliaryCommentAfter;
    t && this._printComment({
      type: "CommentBlock",
      value: t
    }, 0);
  }
  getPossibleRaw(t) {
    const r = t.extra;
    if ((r == null ? void 0 : r.raw) != null && r.rawValue != null && t.value === r.rawValue)
      return r.raw;
  }
  printJoin(t, r, i = {}) {
    if (!(t != null && t.length)) return;
    let {
      indent: s
    } = i;
    if (s == null && this.format.retainLines) {
      var n;
      const f = (n = t[0].loc) == null ? void 0 : n.start.line;
      f != null && f !== this._buf.getCurrentLine() && (s = !0);
    }
    s && this.indent();
    const a = {
      addNewlines: i.addNewlines,
      nextNodeStartLine: 0
    }, o = i.separator ? i.separator.bind(this) : null, l = t.length;
    for (let f = 0; f < l; f++) {
      const p = t[f];
      if (p && (i.statement && this._printNewline(f === 0, a), this.print(p, r, void 0, i.trailingCommentsLineOffset || 0), i.iterator == null || i.iterator(p, f), f < l - 1 && (o == null || o()), i.statement)) {
        var u;
        if ((u = p.trailingComments) != null && u.length || (this._lastCommentLine = 0), f + 1 === l)
          this.newline(1);
        else {
          var c;
          const h = t[f + 1];
          a.nextNodeStartLine = ((c = h.loc) == null ? void 0 : c.start.line) || 0, this._printNewline(!0, a);
        }
      }
    }
    s && this.dedent();
  }
  printAndIndentOnComments(t, r) {
    const i = t.leadingComments && t.leadingComments.length > 0;
    i && this.indent(), this.print(t, r), i && this.dedent();
  }
  printBlock(t) {
    const r = t.body;
    r.type !== "EmptyStatement" && this.space(), this.print(r, t);
  }
  _printTrailingComments(t, r, i) {
    const {
      innerComments: s,
      trailingComments: n
    } = t;
    s != null && s.length && this._printComments(2, s, t, r, i), n != null && n.length && this._printComments(2, n, t, r, i);
  }
  _printLeadingComments(t, r) {
    const i = t.leadingComments;
    i != null && i.length && this._printComments(0, i, t, r);
  }
  _maybePrintInnerComments() {
    this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
  }
  printInnerComments() {
    const t = this._printStack[this._printStack.length - 1], r = t.innerComments;
    if (!(r != null && r.length)) return;
    const i = this.endsWith(32), s = this._indentInnerComments, n = this._printedComments.size;
    s && this.indent(), this._printComments(1, r, t), i && n !== this._printedComments.size && this.space(), s && this.dedent();
  }
  noIndentInnerCommentsHere() {
    this._indentInnerComments = !1;
  }
  printSequence(t, r, i = {}) {
    var s;
    i.statement = !0, (s = i.indent) != null || (i.indent = !1), this.printJoin(t, r, i);
  }
  printList(t, r, i = {}) {
    i.separator == null && (i.separator = kk), this.printJoin(t, r, i);
  }
  _printNewline(t, r) {
    const i = this.format;
    if (i.retainLines || i.compact) return;
    if (i.concise) {
      this.space();
      return;
    }
    if (!t)
      return;
    const s = r.nextNodeStartLine, n = this._lastCommentLine;
    if (s > 0 && n > 0) {
      const a = s - n;
      if (a >= 0) {
        this.newline(a || 1);
        return;
      }
    }
    this._buf.hasContent() && this.newline(1);
  }
  _shouldPrintComment(t) {
    return t.ignore || this._printedComments.has(t) ? 0 : this._noLineTerminator && Nk.test(t.value) ? 2 : (this._printedComments.add(t), this.format.shouldPrintComment(t.value) ? 1 : 0);
  }
  _printComment(t, r) {
    const i = this._noLineTerminator, s = t.type === "CommentBlock", n = s && r !== 1 && !this._noLineTerminator;
    n && this._buf.hasContent() && r !== 2 && this.newline(1);
    const a = this.getLastChar();
    a !== 91 && a !== 123 && this.space();
    let o;
    if (s) {
      const {
        _parenPushNewlineState: u
      } = this;
      if ((u == null ? void 0 : u.printed) === !1 && hl.test(t.value) && (this.tokenChar(40), this.indent(), u.printed = !0), o = `/*${t.value}*/`, this.format.indent.adjustMultilineComment) {
        var l;
        const c = (l = t.loc) == null ? void 0 : l.start.column;
        if (c) {
          const f = new RegExp("\\n\\s{1," + c + "}", "g");
          o = o.replace(f, `
`);
        }
        if (this.format.concise)
          o = o.replace(/\n(?!$)/g, `
`);
        else {
          let f = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
          (this._shouldIndent(47) || this.format.retainLines) && (f += this._getIndent()), o = o.replace(/\n(?!$)/g, `
${" ".repeat(f)}`);
        }
      }
    } else i ? o = `/*${t.value}*/` : o = `//${t.value}`;
    this.endsWith(47) && this._space(), this.source("start", t.loc), this._append(o, s), !s && !i && this.newline(1, !0), n && r !== 3 && this.newline(1);
  }
  _printComments(t, r, i, s, n = 0) {
    const a = i.loc, o = r.length;
    let l = !!a;
    const u = l ? a.start.line : 0, c = l ? a.end.line : 0;
    let f = 0, p = 0;
    const h = this._noLineTerminator ? function() {
    } : this.newline.bind(this);
    for (let y = 0; y < o; y++) {
      const b = r[y], A = this._shouldPrintComment(b);
      if (A === 2) {
        l = !1;
        break;
      }
      if (l && b.loc && A === 1) {
        const I = b.loc.start.line, _ = b.loc.end.line;
        if (t === 0) {
          let j = 0;
          y === 0 ? this._buf.hasContent() && (b.type === "CommentLine" || I !== _) && (j = p = 1) : j = I - f, f = _, h(j), this._printComment(b, 1), y + 1 === o && (h(Math.max(u - f, p)), f = u);
        } else if (t === 1) {
          const j = I - (y === 0 ? u : f);
          f = _, h(j), this._printComment(b, 1), y + 1 === o && (h(Math.min(1, c - f)), f = c);
        } else {
          const j = I - (y === 0 ? c - n : f);
          f = _, h(j), this._printComment(b, 1);
        }
      } else {
        if (l = !1, A !== 1)
          continue;
        if (o === 1) {
          const I = b.loc ? b.loc.start.line === b.loc.end.line : !hl.test(b.value), _ = I && !vk(i) && !Ak(s) && !Ck(s) && !Ik(s);
          t === 0 ? this._printComment(b, _ && i.type !== "ObjectExpression" || I && xk(s, {
            body: i
          }) ? 1 : 0) : _ && t === 2 ? this._printComment(b, 1) : this._printComment(b, 0);
        } else t === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterfaceBody" ? this._printComment(b, y === 0 ? 2 : y === o - 1 ? 3 : 0) : this._printComment(b, 0);
      }
    }
    t === 2 && l && f && (this._lastCommentLine = f);
  }
}
Object.assign(xa.prototype, Pk);
xa.prototype.Noop = function() {
};
Cs.default = xa;
function kk() {
  this.tokenChar(44), this.space();
}
Object.defineProperty(vs, "__esModule", {
  value: !0
});
var Dk = vs.default = Lk, vc = As, Ac = Cs;
function Cc(e, t) {
  const r = {
    auxiliaryCommentBefore: t.auxiliaryCommentBefore,
    auxiliaryCommentAfter: t.auxiliaryCommentAfter,
    shouldPrintComment: t.shouldPrintComment,
    retainLines: t.retainLines,
    retainFunctionParens: t.retainFunctionParens,
    comments: t.comments == null || t.comments,
    compact: t.compact,
    minified: t.minified,
    concise: t.concise,
    indent: {
      adjustMultilineComment: !0,
      style: "  "
    },
    jsescOption: Object.assign({
      quotes: "double",
      wrap: !0,
      minimal: !1
    }, t.jsescOption),
    topicToken: t.topicToken,
    importAttributesKeyword: t.importAttributesKeyword
  };
  {
    var i;
    r.decoratorsBeforeExport = t.decoratorsBeforeExport, r.jsescOption.json = t.jsonCompatibleStrings, r.recordAndTupleSyntaxType = (i = t.recordAndTupleSyntaxType) != null ? i : "hash";
  }
  r.minified ? (r.compact = !0, r.shouldPrintComment = r.shouldPrintComment || (() => r.comments)) : r.shouldPrintComment = r.shouldPrintComment || ((o) => r.comments || o.includes("@license") || o.includes("@preserve")), r.compact === "auto" && (r.compact = typeof e == "string" && e.length > 5e5, r.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds the max of 500KB.`)), r.compact && (r.indent.adjustMultilineComment = !1);
  const {
    auxiliaryCommentBefore: s,
    auxiliaryCommentAfter: n,
    shouldPrintComment: a
  } = r;
  return s && !a(s) && (r.auxiliaryCommentBefore = void 0), n && !a(n) && (r.auxiliaryCommentAfter = void 0), r;
}
vs.CodeGenerator = class {
  constructor(t, r = {}, i) {
    this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = t, this._format = Cc(i, r), this._map = r.sourceMaps ? new vc.default(r, i) : null;
  }
  generate() {
    return new Ac.default(this._format, this._map).generate(this._ast);
  }
};
function Lk(e, t = {}, r) {
  const i = Cc(r, t), s = t.sourceMaps ? new vc.default(t, r) : null;
  return new Ac.default(i, s).generate(e);
}
var Pt = {};
Object.defineProperty(Pt, "__esModule", {
  value: !0
});
Pt.find = jk;
Pt.findParent = Fk;
Pt.getAncestry = Kk;
Pt.getDeepestCommonAncestorFrom = Vk;
Pt.getEarliestCommonAncestorFrom = $k;
Pt.getFunctionParent = Rk;
Pt.getStatementParent = Uk;
Pt.inType = Jk;
Pt.isAncestor = qk;
Pt.isDescendant = Wk;
var Mk = Ae();
const {
  VISITOR_KEYS: Bk
} = Mk;
function Fk(e) {
  let t = this;
  for (; t = t.parentPath; )
    if (e(t)) return t;
  return null;
}
function jk(e) {
  let t = this;
  do
    if (e(t)) return t;
  while (t = t.parentPath);
  return null;
}
function Rk() {
  return this.findParent((e) => e.isFunction());
}
function Uk() {
  let e = this;
  do {
    if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
      break;
    e = e.parentPath;
  } while (e);
  if (e && (e.isProgram() || e.isFile()))
    throw new Error("File/Program node, we can't possibly find a statement parent to this");
  return e;
}
function $k(e) {
  return this.getDeepestCommonAncestorFrom(e, function(t, r, i) {
    let s;
    const n = Bk[t.type];
    for (const a of i) {
      const o = a[r + 1];
      if (!s) {
        s = o;
        continue;
      }
      if (o.listKey && s.listKey === o.listKey && o.key < s.key) {
        s = o;
        continue;
      }
      const l = n.indexOf(s.parentKey), u = n.indexOf(o.parentKey);
      l > u && (s = o);
    }
    return s;
  });
}
function Vk(e, t) {
  if (!e.length)
    return this;
  if (e.length === 1)
    return e[0];
  let r = 1 / 0, i, s;
  const n = e.map((o) => {
    const l = [];
    do
      l.unshift(o);
    while ((o = o.parentPath) && o !== this);
    return l.length < r && (r = l.length), l;
  }), a = n[0];
  e: for (let o = 0; o < r; o++) {
    const l = a[o];
    for (const u of n)
      if (u[o] !== l)
        break e;
    i = o, s = l;
  }
  if (s)
    return t ? t(s, i, n) : s;
  throw new Error("Couldn't find intersection");
}
function Kk() {
  let e = this;
  const t = [];
  do
    t.push(e);
  while (e = e.parentPath);
  return t;
}
function qk(e) {
  return e.isDescendant(this);
}
function Wk(e) {
  return !!this.findParent((t) => t === e);
}
function Jk(...e) {
  let t = this;
  for (; t; ) {
    for (const r of e)
      if (t.node.type === r) return !0;
    t = t.parentPath;
  }
  return !1;
}
var Zt = {}, Ic = {}, va = {}, _s = {};
Object.defineProperty(_s, "__esModule", {
  value: !0
});
_s.createUnionType = zk;
var Xk = Ae();
const {
  createFlowUnionType: dl,
  createTSUnionType: ml,
  createUnionTypeAnnotation: Yk,
  isFlowType: Hk,
  isTSType: Gk
} = Xk;
function zk(e) {
  {
    if (e.every((t) => Hk(t)))
      return dl ? dl(e) : Yk(e);
    if (e.every((t) => Gk(t)) && ml)
      return ml(e);
  }
}
Object.defineProperty(va, "__esModule", {
  value: !0
});
va.default = rD;
var Qk = Ae(), wc = _s;
const {
  BOOLEAN_NUMBER_BINARY_OPERATORS: Zk,
  createTypeAnnotationBasedOnTypeof: eD,
  numberTypeAnnotation: Oc,
  voidTypeAnnotation: tD
} = Qk;
function rD(e) {
  if (!this.isReferenced()) return;
  const t = this.scope.getBinding(e.name);
  if (t)
    return t.identifier.typeAnnotation ? t.identifier.typeAnnotation : iD(t, this, e.name);
  if (e.name === "undefined")
    return tD();
  if (e.name === "NaN" || e.name === "Infinity")
    return Oc();
  e.name;
}
function iD(e, t, r) {
  const i = [], s = [];
  let n = yl(e, t, s);
  const a = Nc(e, t, r);
  if (a) {
    const o = yl(e, a.ifStatement);
    n = n.filter((l) => !o.includes(l)), i.push(a.typeAnnotation);
  }
  if (n.length) {
    n.push(...s);
    for (const o of n)
      i.push(o.getTypeAnnotation());
  }
  if (i.length)
    return (0, wc.createUnionType)(i);
}
function yl(e, t, r) {
  const i = e.constantViolations.slice();
  return i.unshift(e.path), i.filter((s) => {
    s = s.resolve();
    const n = s._guessExecutionStatusRelativeTo(t);
    return r && n === "unknown" && r.push(s), n === "before";
  });
}
function sD(e, t) {
  const r = t.node.operator, i = t.get("right").resolve(), s = t.get("left").resolve();
  let n;
  if (s.isIdentifier({
    name: e
  }) ? n = i : i.isIdentifier({
    name: e
  }) && (n = s), n)
    return r === "===" ? n.getTypeAnnotation() : Zk.includes(r) ? Oc() : void 0;
  if (r !== "===" && r !== "==") return;
  let a, o;
  if (s.isUnaryExpression({
    operator: "typeof"
  }) ? (a = s, o = i) : i.isUnaryExpression({
    operator: "typeof"
  }) && (a = i, o = s), !a || !a.get("argument").isIdentifier({
    name: e
  }) || (o = o.resolve(), !o.isLiteral())) return;
  const l = o.node.value;
  if (typeof l == "string")
    return eD(l);
}
function nD(e, t, r) {
  let i;
  for (; i = t.parentPath; ) {
    if (i.isIfStatement() || i.isConditionalExpression())
      return t.key === "test" ? void 0 : i;
    if (i.isFunction() && i.parentPath.scope.getBinding(r) !== e)
      return;
    t = i;
  }
}
function Nc(e, t, r) {
  const i = nD(e, t, r);
  if (!i) return;
  const n = [i.get("test")], a = [];
  for (let o = 0; o < n.length; o++) {
    const l = n[o];
    if (l.isLogicalExpression())
      l.node.operator === "&&" && (n.push(l.get("left")), n.push(l.get("right")));
    else if (l.isBinaryExpression()) {
      const u = sD(r, l);
      u && a.push(u);
    }
  }
  return a.length ? {
    typeAnnotation: (0, wc.createUnionType)(a),
    ifStatement: i
  } : Nc(e, i, r);
}
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.ArrayExpression = Ue, e.AssignmentExpression = N, e.BinaryExpression = U, e.BooleanLiteral = $, e.CallExpression = _e, e.ConditionalExpression = k, e.ClassDeclaration = e.ClassExpression = e.FunctionDeclaration = e.ArrowFunctionExpression = e.FunctionExpression = pe, Object.defineProperty(e, "Identifier", {
    enumerable: !0,
    get: function() {
      return r.default;
    }
  }), e.LogicalExpression = L, e.NewExpression = re, e.NullLiteral = H, e.NumericLiteral = V, e.ObjectExpression = oe, e.ParenthesizedExpression = B, e.RegExpLiteral = se, e.RestElement = fe, e.SequenceExpression = F, e.StringLiteral = R, e.TSAsExpression = q, e.TSNonNullExpression = Y, e.TaggedTemplateExpression = qe, e.TemplateLiteral = W, e.TypeCastExpression = ae, e.UnaryExpression = Q, e.UpdateExpression = D, e.VariableDeclarator = te;
  var t = Ae(), r = va, i = _s;
  const {
    BOOLEAN_BINARY_OPERATORS: s,
    BOOLEAN_UNARY_OPERATORS: n,
    NUMBER_BINARY_OPERATORS: a,
    NUMBER_UNARY_OPERATORS: o,
    STRING_UNARY_OPERATORS: l,
    anyTypeAnnotation: u,
    arrayTypeAnnotation: c,
    booleanTypeAnnotation: f,
    buildMatchMemberExpression: p,
    genericTypeAnnotation: h,
    identifier: y,
    nullLiteralTypeAnnotation: b,
    numberTypeAnnotation: A,
    stringTypeAnnotation: I,
    tupleTypeAnnotation: _,
    unionTypeAnnotation: j,
    voidTypeAnnotation: G,
    isIdentifier: ce
  } = t;
  function te() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  function ae(Pe) {
    return Pe.typeAnnotation;
  }
  ae.validParent = !0;
  function q(Pe) {
    return Pe.typeAnnotation;
  }
  q.validParent = !0;
  function Y() {
    return this.get("expression").getTypeAnnotation();
  }
  function re(Pe) {
    if (Pe.callee.type === "Identifier")
      return h(Pe.callee);
  }
  function W() {
    return I();
  }
  function Q(Pe) {
    const Be = Pe.operator;
    if (Be === "void")
      return G();
    if (o.includes(Be))
      return A();
    if (l.includes(Be))
      return I();
    if (n.includes(Be))
      return f();
  }
  function U(Pe) {
    const Be = Pe.operator;
    if (a.includes(Be))
      return A();
    if (s.includes(Be))
      return f();
    if (Be === "+") {
      const ve = this.get("right"), Re = this.get("left");
      return Re.isBaseType("number") && ve.isBaseType("number") ? A() : Re.isBaseType("string") || ve.isBaseType("string") ? I() : j([I(), A()]);
    }
  }
  function L() {
    const Pe = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, i.createUnionType)(Pe);
  }
  function k() {
    const Pe = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, i.createUnionType)(Pe);
  }
  function F() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  function B() {
    return this.get("expression").getTypeAnnotation();
  }
  function N() {
    return this.get("right").getTypeAnnotation();
  }
  function D(Pe) {
    const Be = Pe.operator;
    if (Be === "++" || Be === "--")
      return A();
  }
  function R() {
    return I();
  }
  function V() {
    return A();
  }
  function $() {
    return f();
  }
  function H() {
    return b();
  }
  function se() {
    return h(y("RegExp"));
  }
  function oe() {
    return h(y("Object"));
  }
  function Ue() {
    return h(y("Array"));
  }
  function fe() {
    return Ue();
  }
  fe.validParent = !0;
  function pe() {
    return h(y("Function"));
  }
  const Se = p("Array.from"), Ce = p("Object.keys"), Ee = p("Object.values"), Ne = p("Object.entries");
  function _e() {
    const {
      callee: Pe
    } = this.node;
    return Ce(Pe) ? c(I()) : Se(Pe) || Ee(Pe) || ce(Pe, {
      name: "Array"
    }) ? c(u()) : Ne(Pe) ? c(_([I(), u()])) : tt(this.get("callee"));
  }
  function qe() {
    return tt(this.get("tag"));
  }
  function tt(Pe) {
    if (Pe = Pe.resolve(), Pe.isFunction()) {
      const {
        node: Be
      } = Pe;
      if (Be.async)
        return Be.generator ? h(y("AsyncIterator")) : h(y("Promise"));
      if (Be.generator)
        return h(y("Iterator"));
      if (Pe.node.returnType)
        return Pe.node.returnType;
    }
  }
})(Ic);
Object.defineProperty(Zt, "__esModule", {
  value: !0
});
Zt._getTypeAnnotation = kc;
Zt.baseTypeStrictlyMatches = ID;
Zt.couldBeBaseType = CD;
Zt.getTypeAnnotation = vD;
Zt.isBaseType = AD;
Zt.isGenericType = wD;
var Tl = Ic, aD = Ae();
const {
  anyTypeAnnotation: _c,
  isAnyTypeAnnotation: ts,
  isArrayTypeAnnotation: oD,
  isBooleanTypeAnnotation: lD,
  isEmptyTypeAnnotation: uD,
  isFlowBaseAnnotation: cD,
  isGenericTypeAnnotation: fD,
  isIdentifier: gl,
  isMixedTypeAnnotation: pD,
  isNumberTypeAnnotation: hD,
  isStringTypeAnnotation: dD,
  isTSArrayType: mD,
  isTSTypeAnnotation: yD,
  isTSTypeReference: TD,
  isTupleTypeAnnotation: gD,
  isTypeAnnotation: bD,
  isUnionTypeAnnotation: SD,
  isVoidTypeAnnotation: ED,
  stringTypeAnnotation: PD,
  voidTypeAnnotation: xD
} = aD;
function vD() {
  let e = this.getData("typeAnnotation");
  return e != null || (e = kc.call(this) || _c(), (bD(e) || yD(e)) && (e = e.typeAnnotation), this.setData("typeAnnotation", e)), e;
}
const en = /* @__PURE__ */ new WeakSet();
function kc() {
  const e = this.node;
  if (!e)
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
      const r = this.parentPath.parentPath, i = r.parentPath;
      return r.key === "left" && i.isForInStatement() ? PD() : r.key === "left" && i.isForOfStatement() ? _c() : xD();
    } else
      return;
  if (e.typeAnnotation)
    return e.typeAnnotation;
  if (!en.has(e)) {
    en.add(e);
    try {
      var t;
      let r = Tl[e.type];
      if (r)
        return r.call(this, e);
      if (r = Tl[this.parentPath.type], (t = r) != null && t.validParent)
        return this.parentPath.getTypeAnnotation();
    } finally {
      en.delete(e);
    }
  }
}
function AD(e, t) {
  return _n(e, this.getTypeAnnotation(), t);
}
function _n(e, t, r) {
  if (e === "string")
    return dD(t);
  if (e === "number")
    return hD(t);
  if (e === "boolean")
    return lD(t);
  if (e === "any")
    return ts(t);
  if (e === "mixed")
    return pD(t);
  if (e === "empty")
    return uD(t);
  if (e === "void")
    return ED(t);
  if (r)
    return !1;
  throw new Error(`Unknown base type ${e}`);
}
function CD(e) {
  const t = this.getTypeAnnotation();
  if (ts(t)) return !0;
  if (SD(t)) {
    for (const r of t.types)
      if (ts(r) || _n(e, r, !0))
        return !0;
    return !1;
  } else
    return _n(e, t, !0);
}
function ID(e) {
  const t = this.getTypeAnnotation(), r = e.getTypeAnnotation();
  return !ts(t) && cD(t) ? r.type === t.type : !1;
}
function wD(e) {
  const t = this.getTypeAnnotation();
  return e === "Array" && (mD(t) || oD(t) || gD(t)) ? !0 : fD(t) && gl(t.id, {
    name: e
  }) || TD(t) && gl(t.typeName, {
    name: e
  });
}
var Dt = {}, pi = {}, hi = {}, ks = {};
Object.defineProperty(ks, "__esModule", {
  value: !0
});
ks.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
ks.matchToToken = function(e) {
  var t = { type: "invalid", value: e[0], closed: void 0 };
  return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) : e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "whitespace"), t;
};
var Aa = { exports: {} }, Xe = String, Dc = function() {
  return { isColorSupported: !1, reset: Xe, bold: Xe, dim: Xe, italic: Xe, underline: Xe, inverse: Xe, hidden: Xe, strikethrough: Xe, black: Xe, red: Xe, green: Xe, yellow: Xe, blue: Xe, magenta: Xe, cyan: Xe, white: Xe, gray: Xe, bgBlack: Xe, bgRed: Xe, bgGreen: Xe, bgYellow: Xe, bgBlue: Xe, bgMagenta: Xe, bgCyan: Xe, bgWhite: Xe };
};
Aa.exports = Dc();
Aa.exports.createColors = Dc;
var Lc = Aa.exports, tn = { exports: {} }, rn, bl;
function OD() {
  if (bl) return rn;
  bl = 1;
  var e = /[|\\{}()[\]^$+*?.]/g;
  return rn = function(t) {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    return t.replace(e, "\\$&");
  }, rn;
}
var Xi = { exports: {} }, sn = { exports: {} }, nn, Sl;
function ND() {
  return Sl || (Sl = 1, nn = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), nn;
}
var El;
function Mc() {
  if (El) return sn.exports;
  El = 1;
  var e = ND(), t = {};
  for (var r in e)
    e.hasOwnProperty(r) && (t[e[r]] = r);
  var i = sn.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (var s in i)
    if (i.hasOwnProperty(s)) {
      if (!("channels" in i[s]))
        throw new Error("missing channels property: " + s);
      if (!("labels" in i[s]))
        throw new Error("missing channel labels property: " + s);
      if (i[s].labels.length !== i[s].channels)
        throw new Error("channel and label counts mismatch: " + s);
      var n = i[s].channels, a = i[s].labels;
      delete i[s].channels, delete i[s].labels, Object.defineProperty(i[s], "channels", { value: n }), Object.defineProperty(i[s], "labels", { value: a });
    }
  i.rgb.hsl = function(l) {
    var u = l[0] / 255, c = l[1] / 255, f = l[2] / 255, p = Math.min(u, c, f), h = Math.max(u, c, f), y = h - p, b, A, I;
    return h === p ? b = 0 : u === h ? b = (c - f) / y : c === h ? b = 2 + (f - u) / y : f === h && (b = 4 + (u - c) / y), b = Math.min(b * 60, 360), b < 0 && (b += 360), I = (p + h) / 2, h === p ? A = 0 : I <= 0.5 ? A = y / (h + p) : A = y / (2 - h - p), [b, A * 100, I * 100];
  }, i.rgb.hsv = function(l) {
    var u, c, f, p, h, y = l[0] / 255, b = l[1] / 255, A = l[2] / 255, I = Math.max(y, b, A), _ = I - Math.min(y, b, A), j = function(G) {
      return (I - G) / 6 / _ + 1 / 2;
    };
    return _ === 0 ? p = h = 0 : (h = _ / I, u = j(y), c = j(b), f = j(A), y === I ? p = f - c : b === I ? p = 1 / 3 + u - f : A === I && (p = 2 / 3 + c - u), p < 0 ? p += 1 : p > 1 && (p -= 1)), [
      p * 360,
      h * 100,
      I * 100
    ];
  }, i.rgb.hwb = function(l) {
    var u = l[0], c = l[1], f = l[2], p = i.rgb.hsl(l)[0], h = 1 / 255 * Math.min(u, Math.min(c, f));
    return f = 1 - 1 / 255 * Math.max(u, Math.max(c, f)), [p, h * 100, f * 100];
  }, i.rgb.cmyk = function(l) {
    var u = l[0] / 255, c = l[1] / 255, f = l[2] / 255, p, h, y, b;
    return b = Math.min(1 - u, 1 - c, 1 - f), p = (1 - u - b) / (1 - b) || 0, h = (1 - c - b) / (1 - b) || 0, y = (1 - f - b) / (1 - b) || 0, [p * 100, h * 100, y * 100, b * 100];
  };
  function o(l, u) {
    return Math.pow(l[0] - u[0], 2) + Math.pow(l[1] - u[1], 2) + Math.pow(l[2] - u[2], 2);
  }
  return i.rgb.keyword = function(l) {
    var u = t[l];
    if (u)
      return u;
    var c = 1 / 0, f;
    for (var p in e)
      if (e.hasOwnProperty(p)) {
        var h = e[p], y = o(l, h);
        y < c && (c = y, f = p);
      }
    return f;
  }, i.keyword.rgb = function(l) {
    return e[l];
  }, i.rgb.xyz = function(l) {
    var u = l[0] / 255, c = l[1] / 255, f = l[2] / 255;
    u = u > 0.04045 ? Math.pow((u + 0.055) / 1.055, 2.4) : u / 12.92, c = c > 0.04045 ? Math.pow((c + 0.055) / 1.055, 2.4) : c / 12.92, f = f > 0.04045 ? Math.pow((f + 0.055) / 1.055, 2.4) : f / 12.92;
    var p = u * 0.4124 + c * 0.3576 + f * 0.1805, h = u * 0.2126 + c * 0.7152 + f * 0.0722, y = u * 0.0193 + c * 0.1192 + f * 0.9505;
    return [p * 100, h * 100, y * 100];
  }, i.rgb.lab = function(l) {
    var u = i.rgb.xyz(l), c = u[0], f = u[1], p = u[2], h, y, b;
    return c /= 95.047, f /= 100, p /= 108.883, c = c > 8856e-6 ? Math.pow(c, 1 / 3) : 7.787 * c + 16 / 116, f = f > 8856e-6 ? Math.pow(f, 1 / 3) : 7.787 * f + 16 / 116, p = p > 8856e-6 ? Math.pow(p, 1 / 3) : 7.787 * p + 16 / 116, h = 116 * f - 16, y = 500 * (c - f), b = 200 * (f - p), [h, y, b];
  }, i.hsl.rgb = function(l) {
    var u = l[0] / 360, c = l[1] / 100, f = l[2] / 100, p, h, y, b, A;
    if (c === 0)
      return A = f * 255, [A, A, A];
    f < 0.5 ? h = f * (1 + c) : h = f + c - f * c, p = 2 * f - h, b = [0, 0, 0];
    for (var I = 0; I < 3; I++)
      y = u + 1 / 3 * -(I - 1), y < 0 && y++, y > 1 && y--, 6 * y < 1 ? A = p + (h - p) * 6 * y : 2 * y < 1 ? A = h : 3 * y < 2 ? A = p + (h - p) * (2 / 3 - y) * 6 : A = p, b[I] = A * 255;
    return b;
  }, i.hsl.hsv = function(l) {
    var u = l[0], c = l[1] / 100, f = l[2] / 100, p = c, h = Math.max(f, 0.01), y, b;
    return f *= 2, c *= f <= 1 ? f : 2 - f, p *= h <= 1 ? h : 2 - h, b = (f + c) / 2, y = f === 0 ? 2 * p / (h + p) : 2 * c / (f + c), [u, y * 100, b * 100];
  }, i.hsv.rgb = function(l) {
    var u = l[0] / 60, c = l[1] / 100, f = l[2] / 100, p = Math.floor(u) % 6, h = u - Math.floor(u), y = 255 * f * (1 - c), b = 255 * f * (1 - c * h), A = 255 * f * (1 - c * (1 - h));
    switch (f *= 255, p) {
      case 0:
        return [f, A, y];
      case 1:
        return [b, f, y];
      case 2:
        return [y, f, A];
      case 3:
        return [y, b, f];
      case 4:
        return [A, y, f];
      case 5:
        return [f, y, b];
    }
  }, i.hsv.hsl = function(l) {
    var u = l[0], c = l[1] / 100, f = l[2] / 100, p = Math.max(f, 0.01), h, y, b;
    return b = (2 - c) * f, h = (2 - c) * p, y = c * p, y /= h <= 1 ? h : 2 - h, y = y || 0, b /= 2, [u, y * 100, b * 100];
  }, i.hwb.rgb = function(l) {
    var u = l[0] / 360, c = l[1] / 100, f = l[2] / 100, p = c + f, h, y, b, A;
    p > 1 && (c /= p, f /= p), h = Math.floor(6 * u), y = 1 - f, b = 6 * u - h, h & 1 && (b = 1 - b), A = c + b * (y - c);
    var I, _, j;
    switch (h) {
      default:
      case 6:
      case 0:
        I = y, _ = A, j = c;
        break;
      case 1:
        I = A, _ = y, j = c;
        break;
      case 2:
        I = c, _ = y, j = A;
        break;
      case 3:
        I = c, _ = A, j = y;
        break;
      case 4:
        I = A, _ = c, j = y;
        break;
      case 5:
        I = y, _ = c, j = A;
        break;
    }
    return [I * 255, _ * 255, j * 255];
  }, i.cmyk.rgb = function(l) {
    var u = l[0] / 100, c = l[1] / 100, f = l[2] / 100, p = l[3] / 100, h, y, b;
    return h = 1 - Math.min(1, u * (1 - p) + p), y = 1 - Math.min(1, c * (1 - p) + p), b = 1 - Math.min(1, f * (1 - p) + p), [h * 255, y * 255, b * 255];
  }, i.xyz.rgb = function(l) {
    var u = l[0] / 100, c = l[1] / 100, f = l[2] / 100, p, h, y;
    return p = u * 3.2406 + c * -1.5372 + f * -0.4986, h = u * -0.9689 + c * 1.8758 + f * 0.0415, y = u * 0.0557 + c * -0.204 + f * 1.057, p = p > 31308e-7 ? 1.055 * Math.pow(p, 1 / 2.4) - 0.055 : p * 12.92, h = h > 31308e-7 ? 1.055 * Math.pow(h, 1 / 2.4) - 0.055 : h * 12.92, y = y > 31308e-7 ? 1.055 * Math.pow(y, 1 / 2.4) - 0.055 : y * 12.92, p = Math.min(Math.max(0, p), 1), h = Math.min(Math.max(0, h), 1), y = Math.min(Math.max(0, y), 1), [p * 255, h * 255, y * 255];
  }, i.xyz.lab = function(l) {
    var u = l[0], c = l[1], f = l[2], p, h, y;
    return u /= 95.047, c /= 100, f /= 108.883, u = u > 8856e-6 ? Math.pow(u, 1 / 3) : 7.787 * u + 16 / 116, c = c > 8856e-6 ? Math.pow(c, 1 / 3) : 7.787 * c + 16 / 116, f = f > 8856e-6 ? Math.pow(f, 1 / 3) : 7.787 * f + 16 / 116, p = 116 * c - 16, h = 500 * (u - c), y = 200 * (c - f), [p, h, y];
  }, i.lab.xyz = function(l) {
    var u = l[0], c = l[1], f = l[2], p, h, y;
    h = (u + 16) / 116, p = c / 500 + h, y = h - f / 200;
    var b = Math.pow(h, 3), A = Math.pow(p, 3), I = Math.pow(y, 3);
    return h = b > 8856e-6 ? b : (h - 16 / 116) / 7.787, p = A > 8856e-6 ? A : (p - 16 / 116) / 7.787, y = I > 8856e-6 ? I : (y - 16 / 116) / 7.787, p *= 95.047, h *= 100, y *= 108.883, [p, h, y];
  }, i.lab.lch = function(l) {
    var u = l[0], c = l[1], f = l[2], p, h, y;
    return p = Math.atan2(f, c), h = p * 360 / 2 / Math.PI, h < 0 && (h += 360), y = Math.sqrt(c * c + f * f), [u, y, h];
  }, i.lch.lab = function(l) {
    var u = l[0], c = l[1], f = l[2], p, h, y;
    return y = f / 360 * 2 * Math.PI, p = c * Math.cos(y), h = c * Math.sin(y), [u, p, h];
  }, i.rgb.ansi16 = function(l) {
    var u = l[0], c = l[1], f = l[2], p = 1 in arguments ? arguments[1] : i.rgb.hsv(l)[2];
    if (p = Math.round(p / 50), p === 0)
      return 30;
    var h = 30 + (Math.round(f / 255) << 2 | Math.round(c / 255) << 1 | Math.round(u / 255));
    return p === 2 && (h += 60), h;
  }, i.hsv.ansi16 = function(l) {
    return i.rgb.ansi16(i.hsv.rgb(l), l[2]);
  }, i.rgb.ansi256 = function(l) {
    var u = l[0], c = l[1], f = l[2];
    if (u === c && c === f)
      return u < 8 ? 16 : u > 248 ? 231 : Math.round((u - 8) / 247 * 24) + 232;
    var p = 16 + 36 * Math.round(u / 255 * 5) + 6 * Math.round(c / 255 * 5) + Math.round(f / 255 * 5);
    return p;
  }, i.ansi16.rgb = function(l) {
    var u = l % 10;
    if (u === 0 || u === 7)
      return l > 50 && (u += 3.5), u = u / 10.5 * 255, [u, u, u];
    var c = (~~(l > 50) + 1) * 0.5, f = (u & 1) * c * 255, p = (u >> 1 & 1) * c * 255, h = (u >> 2 & 1) * c * 255;
    return [f, p, h];
  }, i.ansi256.rgb = function(l) {
    if (l >= 232) {
      var u = (l - 232) * 10 + 8;
      return [u, u, u];
    }
    l -= 16;
    var c, f = Math.floor(l / 36) / 5 * 255, p = Math.floor((c = l % 36) / 6) / 5 * 255, h = c % 6 / 5 * 255;
    return [f, p, h];
  }, i.rgb.hex = function(l) {
    var u = ((Math.round(l[0]) & 255) << 16) + ((Math.round(l[1]) & 255) << 8) + (Math.round(l[2]) & 255), c = u.toString(16).toUpperCase();
    return "000000".substring(c.length) + c;
  }, i.hex.rgb = function(l) {
    var u = l.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!u)
      return [0, 0, 0];
    var c = u[0];
    u[0].length === 3 && (c = c.split("").map(function(b) {
      return b + b;
    }).join(""));
    var f = parseInt(c, 16), p = f >> 16 & 255, h = f >> 8 & 255, y = f & 255;
    return [p, h, y];
  }, i.rgb.hcg = function(l) {
    var u = l[0] / 255, c = l[1] / 255, f = l[2] / 255, p = Math.max(Math.max(u, c), f), h = Math.min(Math.min(u, c), f), y = p - h, b, A;
    return y < 1 ? b = h / (1 - y) : b = 0, y <= 0 ? A = 0 : p === u ? A = (c - f) / y % 6 : p === c ? A = 2 + (f - u) / y : A = 4 + (u - c) / y + 4, A /= 6, A %= 1, [A * 360, y * 100, b * 100];
  }, i.hsl.hcg = function(l) {
    var u = l[1] / 100, c = l[2] / 100, f = 1, p = 0;
    return c < 0.5 ? f = 2 * u * c : f = 2 * u * (1 - c), f < 1 && (p = (c - 0.5 * f) / (1 - f)), [l[0], f * 100, p * 100];
  }, i.hsv.hcg = function(l) {
    var u = l[1] / 100, c = l[2] / 100, f = u * c, p = 0;
    return f < 1 && (p = (c - f) / (1 - f)), [l[0], f * 100, p * 100];
  }, i.hcg.rgb = function(l) {
    var u = l[0] / 360, c = l[1] / 100, f = l[2] / 100;
    if (c === 0)
      return [f * 255, f * 255, f * 255];
    var p = [0, 0, 0], h = u % 1 * 6, y = h % 1, b = 1 - y, A = 0;
    switch (Math.floor(h)) {
      case 0:
        p[0] = 1, p[1] = y, p[2] = 0;
        break;
      case 1:
        p[0] = b, p[1] = 1, p[2] = 0;
        break;
      case 2:
        p[0] = 0, p[1] = 1, p[2] = y;
        break;
      case 3:
        p[0] = 0, p[1] = b, p[2] = 1;
        break;
      case 4:
        p[0] = y, p[1] = 0, p[2] = 1;
        break;
      default:
        p[0] = 1, p[1] = 0, p[2] = b;
    }
    return A = (1 - c) * f, [
      (c * p[0] + A) * 255,
      (c * p[1] + A) * 255,
      (c * p[2] + A) * 255
    ];
  }, i.hcg.hsv = function(l) {
    var u = l[1] / 100, c = l[2] / 100, f = u + c * (1 - u), p = 0;
    return f > 0 && (p = u / f), [l[0], p * 100, f * 100];
  }, i.hcg.hsl = function(l) {
    var u = l[1] / 100, c = l[2] / 100, f = c * (1 - u) + 0.5 * u, p = 0;
    return f > 0 && f < 0.5 ? p = u / (2 * f) : f >= 0.5 && f < 1 && (p = u / (2 * (1 - f))), [l[0], p * 100, f * 100];
  }, i.hcg.hwb = function(l) {
    var u = l[1] / 100, c = l[2] / 100, f = u + c * (1 - u);
    return [l[0], (f - u) * 100, (1 - f) * 100];
  }, i.hwb.hcg = function(l) {
    var u = l[1] / 100, c = l[2] / 100, f = 1 - c, p = f - u, h = 0;
    return p < 1 && (h = (f - p) / (1 - p)), [l[0], p * 100, h * 100];
  }, i.apple.rgb = function(l) {
    return [l[0] / 65535 * 255, l[1] / 65535 * 255, l[2] / 65535 * 255];
  }, i.rgb.apple = function(l) {
    return [l[0] / 255 * 65535, l[1] / 255 * 65535, l[2] / 255 * 65535];
  }, i.gray.rgb = function(l) {
    return [l[0] / 100 * 255, l[0] / 100 * 255, l[0] / 100 * 255];
  }, i.gray.hsl = i.gray.hsv = function(l) {
    return [0, 0, l[0]];
  }, i.gray.hwb = function(l) {
    return [0, 100, l[0]];
  }, i.gray.cmyk = function(l) {
    return [0, 0, 0, l[0]];
  }, i.gray.lab = function(l) {
    return [l[0], 0, 0];
  }, i.gray.hex = function(l) {
    var u = Math.round(l[0] / 100 * 255) & 255, c = (u << 16) + (u << 8) + u, f = c.toString(16).toUpperCase();
    return "000000".substring(f.length) + f;
  }, i.rgb.gray = function(l) {
    var u = (l[0] + l[1] + l[2]) / 3;
    return [u / 255 * 100];
  }, sn.exports;
}
var an, Pl;
function _D() {
  if (Pl) return an;
  Pl = 1;
  var e = Mc();
  function t() {
    for (var n = {}, a = Object.keys(e), o = a.length, l = 0; l < o; l++)
      n[a[l]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return n;
  }
  function r(n) {
    var a = t(), o = [n];
    for (a[n].distance = 0; o.length; )
      for (var l = o.pop(), u = Object.keys(e[l]), c = u.length, f = 0; f < c; f++) {
        var p = u[f], h = a[p];
        h.distance === -1 && (h.distance = a[l].distance + 1, h.parent = l, o.unshift(p));
      }
    return a;
  }
  function i(n, a) {
    return function(o) {
      return a(n(o));
    };
  }
  function s(n, a) {
    for (var o = [a[n].parent, n], l = e[a[n].parent][n], u = a[n].parent; a[u].parent; )
      o.unshift(a[u].parent), l = i(e[a[u].parent][u], l), u = a[u].parent;
    return l.conversion = o, l;
  }
  return an = function(n) {
    for (var a = r(n), o = {}, l = Object.keys(a), u = l.length, c = 0; c < u; c++) {
      var f = l[c], p = a[f];
      p.parent !== null && (o[f] = s(f, a));
    }
    return o;
  }, an;
}
var on, xl;
function kD() {
  if (xl) return on;
  xl = 1;
  var e = Mc(), t = _D(), r = {}, i = Object.keys(e);
  function s(a) {
    var o = function(l) {
      return l == null ? l : (arguments.length > 1 && (l = Array.prototype.slice.call(arguments)), a(l));
    };
    return "conversion" in a && (o.conversion = a.conversion), o;
  }
  function n(a) {
    var o = function(l) {
      if (l == null)
        return l;
      arguments.length > 1 && (l = Array.prototype.slice.call(arguments));
      var u = a(l);
      if (typeof u == "object")
        for (var c = u.length, f = 0; f < c; f++)
          u[f] = Math.round(u[f]);
      return u;
    };
    return "conversion" in a && (o.conversion = a.conversion), o;
  }
  return i.forEach(function(a) {
    r[a] = {}, Object.defineProperty(r[a], "channels", { value: e[a].channels }), Object.defineProperty(r[a], "labels", { value: e[a].labels });
    var o = t(a), l = Object.keys(o);
    l.forEach(function(u) {
      var c = o[u];
      r[a][u] = n(c), r[a][u].raw = s(c);
    });
  }), on = r, on;
}
Xi.exports;
var vl;
function DD() {
  return vl || (vl = 1, function(e) {
    const t = kD(), r = (a, o) => function() {
      return `\x1B[${a.apply(t, arguments) + o}m`;
    }, i = (a, o) => function() {
      const l = a.apply(t, arguments);
      return `\x1B[${38 + o};5;${l}m`;
    }, s = (a, o) => function() {
      const l = a.apply(t, arguments);
      return `\x1B[${38 + o};2;${l[0]};${l[1]};${l[2]}m`;
    };
    function n() {
      const a = /* @__PURE__ */ new Map(), o = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      o.color.grey = o.color.gray;
      for (const c of Object.keys(o)) {
        const f = o[c];
        for (const p of Object.keys(f)) {
          const h = f[p];
          o[p] = {
            open: `\x1B[${h[0]}m`,
            close: `\x1B[${h[1]}m`
          }, f[p] = o[p], a.set(h[0], h[1]);
        }
        Object.defineProperty(o, c, {
          value: f,
          enumerable: !1
        }), Object.defineProperty(o, "codes", {
          value: a,
          enumerable: !1
        });
      }
      const l = (c) => c, u = (c, f, p) => [c, f, p];
      o.color.close = "\x1B[39m", o.bgColor.close = "\x1B[49m", o.color.ansi = {
        ansi: r(l, 0)
      }, o.color.ansi256 = {
        ansi256: i(l, 0)
      }, o.color.ansi16m = {
        rgb: s(u, 0)
      }, o.bgColor.ansi = {
        ansi: r(l, 10)
      }, o.bgColor.ansi256 = {
        ansi256: i(l, 10)
      }, o.bgColor.ansi16m = {
        rgb: s(u, 10)
      };
      for (let c of Object.keys(t)) {
        if (typeof t[c] != "object")
          continue;
        const f = t[c];
        c === "ansi16" && (c = "ansi"), "ansi16" in f && (o.color.ansi[c] = r(f.ansi16, 0), o.bgColor.ansi[c] = r(f.ansi16, 10)), "ansi256" in f && (o.color.ansi256[c] = i(f.ansi256, 0), o.bgColor.ansi256[c] = i(f.ansi256, 10)), "rgb" in f && (o.color.ansi16m[c] = s(f.rgb, 0), o.bgColor.ansi16m[c] = s(f.rgb, 10));
      }
      return o;
    }
    Object.defineProperty(e, "exports", {
      enumerable: !0,
      get: n
    });
  }(Xi)), Xi.exports;
}
var ln, Al;
function LD() {
  return Al || (Al = 1, ln = {
    stdout: !1,
    stderr: !1
  }), ln;
}
var un, Cl;
function MD() {
  if (Cl) return un;
  Cl = 1;
  const e = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, t = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, r = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, i = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, s = /* @__PURE__ */ new Map([
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function n(u) {
    return u[0] === "u" && u.length === 5 || u[0] === "x" && u.length === 3 ? String.fromCharCode(parseInt(u.slice(1), 16)) : s.get(u) || u;
  }
  function a(u, c) {
    const f = [], p = c.trim().split(/\s*,\s*/g);
    let h;
    for (const y of p)
      if (!isNaN(y))
        f.push(Number(y));
      else if (h = y.match(r))
        f.push(h[2].replace(i, (b, A, I) => A ? n(A) : I));
      else
        throw new Error(`Invalid Chalk template style argument: ${y} (in style '${u}')`);
    return f;
  }
  function o(u) {
    t.lastIndex = 0;
    const c = [];
    let f;
    for (; (f = t.exec(u)) !== null; ) {
      const p = f[1];
      if (f[2]) {
        const h = a(p, f[2]);
        c.push([p].concat(h));
      } else
        c.push([p]);
    }
    return c;
  }
  function l(u, c) {
    const f = {};
    for (const h of c)
      for (const y of h.styles)
        f[y[0]] = h.inverse ? null : y.slice(1);
    let p = u;
    for (const h of Object.keys(f))
      if (Array.isArray(f[h])) {
        if (!(h in p))
          throw new Error(`Unknown Chalk style: ${h}`);
        f[h].length > 0 ? p = p[h].apply(p, f[h]) : p = p[h];
      }
    return p;
  }
  return un = (u, c) => {
    const f = [], p = [];
    let h = [];
    if (c.replace(e, (y, b, A, I, _, j) => {
      if (b)
        h.push(n(b));
      else if (I) {
        const G = h.join("");
        h = [], p.push(f.length === 0 ? G : l(u, f)(G)), f.push({ inverse: A, styles: o(I) });
      } else if (_) {
        if (f.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        p.push(l(u, f)(h.join(""))), h = [], f.pop();
      } else
        h.push(j);
    }), p.push(h.join("")), f.length > 0) {
      const y = `Chalk template literal is missing ${f.length} closing bracket${f.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(y);
    }
    return p.join("");
  }, un;
}
var Il;
function BD() {
  return Il || (Il = 1, function(e) {
    const t = OD(), r = DD(), i = LD().stdout, s = MD(), n = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm"), a = ["ansi", "ansi", "ansi256", "ansi16m"], o = /* @__PURE__ */ new Set(["gray"]), l = /* @__PURE__ */ Object.create(null);
    function u(b, A) {
      A = A || {};
      const I = i ? i.level : 0;
      b.level = A.level === void 0 ? I : A.level, b.enabled = "enabled" in A ? A.enabled : b.level > 0;
    }
    function c(b) {
      if (!this || !(this instanceof c) || this.template) {
        const A = {};
        return u(A, b), A.template = function() {
          const I = [].slice.call(arguments);
          return y.apply(null, [A.template].concat(I));
        }, Object.setPrototypeOf(A, c.prototype), Object.setPrototypeOf(A.template, A), A.template.constructor = c, A.template;
      }
      u(this, b);
    }
    n && (r.blue.open = "\x1B[94m");
    for (const b of Object.keys(r))
      r[b].closeRe = new RegExp(t(r[b].close), "g"), l[b] = {
        get() {
          const A = r[b];
          return p.call(this, this._styles ? this._styles.concat(A) : [A], this._empty, b);
        }
      };
    l.visible = {
      get() {
        return p.call(this, this._styles || [], !0, "visible");
      }
    }, r.color.closeRe = new RegExp(t(r.color.close), "g");
    for (const b of Object.keys(r.color.ansi))
      o.has(b) || (l[b] = {
        get() {
          const A = this.level;
          return function() {
            const _ = {
              open: r.color[a[A]][b].apply(null, arguments),
              close: r.color.close,
              closeRe: r.color.closeRe
            };
            return p.call(this, this._styles ? this._styles.concat(_) : [_], this._empty, b);
          };
        }
      });
    r.bgColor.closeRe = new RegExp(t(r.bgColor.close), "g");
    for (const b of Object.keys(r.bgColor.ansi)) {
      if (o.has(b))
        continue;
      const A = "bg" + b[0].toUpperCase() + b.slice(1);
      l[A] = {
        get() {
          const I = this.level;
          return function() {
            const j = {
              open: r.bgColor[a[I]][b].apply(null, arguments),
              close: r.bgColor.close,
              closeRe: r.bgColor.closeRe
            };
            return p.call(this, this._styles ? this._styles.concat(j) : [j], this._empty, b);
          };
        }
      };
    }
    const f = Object.defineProperties(() => {
    }, l);
    function p(b, A, I) {
      const _ = function() {
        return h.apply(_, arguments);
      };
      _._styles = b, _._empty = A;
      const j = this;
      return Object.defineProperty(_, "level", {
        enumerable: !0,
        get() {
          return j.level;
        },
        set(G) {
          j.level = G;
        }
      }), Object.defineProperty(_, "enabled", {
        enumerable: !0,
        get() {
          return j.enabled;
        },
        set(G) {
          j.enabled = G;
        }
      }), _.hasGrey = this.hasGrey || I === "gray" || I === "grey", _.__proto__ = f, _;
    }
    function h() {
      const b = arguments, A = b.length;
      let I = String(arguments[0]);
      if (A === 0)
        return "";
      if (A > 1)
        for (let j = 1; j < A; j++)
          I += " " + b[j];
      if (!this.enabled || this.level <= 0 || !I)
        return this._empty ? "" : I;
      const _ = r.dim.open;
      n && this.hasGrey && (r.dim.open = "");
      for (const j of this._styles.slice().reverse())
        I = j.open + I.replace(j.closeRe, j.open) + j.close, I = I.replace(/\r?\n/g, `${j.close}$&${j.open}`);
      return r.dim.open = _, I;
    }
    function y(b, A) {
      if (!Array.isArray(A))
        return [].slice.call(arguments, 1).join(" ");
      const I = [].slice.call(arguments, 2), _ = [A.raw[0]];
      for (let j = 1; j < A.length; j++)
        _.push(String(I[j - 1]).replace(/[{}\\]/g, "\\$&")), _.push(String(A.raw[j]));
      return s(b, _.join(""));
    }
    Object.defineProperties(c.prototype, l), e.exports = c(), e.exports.supportsColor = i, e.exports.default = e.exports;
  }(tn)), tn.exports;
}
Object.defineProperty(hi, "__esModule", {
  value: !0
});
hi.default = qD;
hi.shouldHighlight = Rc;
var wl = ks, Ol = ii, kn = FD(Lc, !0);
function Bc(e) {
  if (typeof WeakMap != "function") return null;
  var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (Bc = function(i) {
    return i ? r : t;
  })(e);
}
function FD(e, t) {
  if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
  var r = Bc(t);
  if (r && r.has(e)) return r.get(e);
  var i = { __proto__: null }, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var n in e) if (n !== "default" && {}.hasOwnProperty.call(e, n)) {
    var a = s ? Object.getOwnPropertyDescriptor(e, n) : null;
    a && (a.get || a.set) ? Object.defineProperty(i, n, a) : i[n] = e[n];
  }
  return i.default = e, r && r.set(e, i), i;
}
const Fc = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, kn.createColors)(!1) : kn.default, Nl = (e, t) => (r) => e(t(r)), jD = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
function RD(e) {
  return {
    keyword: e.cyan,
    capitalized: e.yellow,
    jsxIdentifier: e.yellow,
    punctuator: e.yellow,
    number: e.magenta,
    string: e.green,
    regex: e.magenta,
    comment: e.gray,
    invalid: Nl(Nl(e.white, e.bgRed), e.bold)
  };
}
const UD = /\r\n|[\n\r\u2028\u2029]/, $D = /^[()[\]{}]$/;
let jc;
{
  const e = /^[a-z][\w-]*$/i, t = function(r, i, s) {
    if (r.type === "name") {
      if ((0, Ol.isKeyword)(r.value) || (0, Ol.isStrictReservedWord)(r.value, !0) || jD.has(r.value))
        return "keyword";
      if (e.test(r.value) && (s[i - 1] === "<" || s.slice(i - 2, i) === "</"))
        return "jsxIdentifier";
      if (r.value[0] !== r.value[0].toLowerCase())
        return "capitalized";
    }
    return r.type === "punctuator" && $D.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punctuator" : r.type;
  };
  jc = function* (r) {
    let i;
    for (; i = wl.default.exec(r); ) {
      const s = wl.matchToToken(i);
      yield {
        type: t(s, i.index, r),
        value: s.value
      };
    }
  };
}
function VD(e, t) {
  let r = "";
  for (const {
    type: i,
    value: s
  } of jc(t)) {
    const n = e[i];
    n ? r += s.split(UD).map((a) => n(a)).join(`
`) : r += s;
  }
  return r;
}
function Rc(e) {
  return Fc.isColorSupported || e.forceColor;
}
let cn;
function KD(e) {
  if (e) {
    var t;
    return (t = cn) != null || (cn = (0, kn.createColors)(!0)), cn;
  }
  return Fc;
}
function qD(e, t = {}) {
  if (e !== "" && Rc(t)) {
    const r = RD(KD(t.forceColor));
    return VD(r, e);
  } else
    return e;
}
{
  let e, t;
  hi.getChalk = ({
    forceColor: r
  }) => {
    var i;
    if ((i = e) != null || (e = BD()), r) {
      var s;
      return (s = t) != null || (t = new e.constructor({
        enabled: !0,
        level: 1
      })), t;
    }
    return e;
  };
}
Object.defineProperty(pi, "__esModule", {
  value: !0
});
pi.codeFrameColumns = $c;
pi.default = GD;
var _l = hi, Dn = WD(Lc, !0);
function Uc(e) {
  if (typeof WeakMap != "function") return null;
  var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (Uc = function(i) {
    return i ? r : t;
  })(e);
}
function WD(e, t) {
  if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
  var r = Uc(t);
  if (r && r.has(e)) return r.get(e);
  var i = { __proto__: null }, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var n in e) if (n !== "default" && {}.hasOwnProperty.call(e, n)) {
    var a = s ? Object.getOwnPropertyDescriptor(e, n) : null;
    a && (a.get || a.set) ? Object.defineProperty(i, n, a) : i[n] = e[n];
  }
  return i.default = e, r && r.set(e, i), i;
}
const JD = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Dn.createColors)(!1) : Dn.default, kl = (e, t) => (r) => e(t(r));
let fn;
function XD(e) {
  if (e) {
    var t;
    return (t = fn) != null || (fn = (0, Dn.createColors)(!0)), fn;
  }
  return JD;
}
let Dl = !1;
function YD(e) {
  return {
    gutter: e.gray,
    marker: kl(e.red, e.bold),
    message: kl(e.red, e.bold)
  };
}
const Ll = /\r\n|[\n\r\u2028\u2029]/;
function HD(e, t, r) {
  const i = Object.assign({
    column: 0,
    line: -1
  }, e.start), s = Object.assign({}, i, e.end), {
    linesAbove: n = 2,
    linesBelow: a = 3
  } = r || {}, o = i.line, l = i.column, u = s.line, c = s.column;
  let f = Math.max(o - (n + 1), 0), p = Math.min(t.length, u + a);
  o === -1 && (f = 0), u === -1 && (p = t.length);
  const h = u - o, y = {};
  if (h)
    for (let b = 0; b <= h; b++) {
      const A = b + o;
      if (!l)
        y[A] = !0;
      else if (b === 0) {
        const I = t[A - 1].length;
        y[A] = [l, I - l + 1];
      } else if (b === h)
        y[A] = [0, c];
      else {
        const I = t[A - b].length;
        y[A] = [0, I];
      }
    }
  else
    l === c ? l ? y[o] = [l, 0] : y[o] = !0 : y[o] = [l, c - l];
  return {
    start: f,
    end: p,
    markerLines: y
  };
}
function $c(e, t, r = {}) {
  const i = (r.highlightCode || r.forceColor) && (0, _l.shouldHighlight)(r), s = XD(r.forceColor), n = YD(s), a = (b, A) => i ? b(A) : A, o = e.split(Ll), {
    start: l,
    end: u,
    markerLines: c
  } = HD(t, o, r), f = t.start && typeof t.start.column == "number", p = String(u).length;
  let y = (i ? (0, _l.default)(e, r) : e).split(Ll, u).slice(l, u).map((b, A) => {
    const I = l + 1 + A, j = ` ${` ${I}`.slice(-p)} |`, G = c[I], ce = !c[I + 1];
    if (G) {
      let te = "";
      if (Array.isArray(G)) {
        const ae = b.slice(0, Math.max(G[0] - 1, 0)).replace(/[^\t]/g, " "), q = G[1] || 1;
        te = [`
 `, a(n.gutter, j.replace(/\d/g, " ")), " ", ae, a(n.marker, "^").repeat(q)].join(""), ce && r.message && (te += " " + a(n.message, r.message));
      }
      return [a(n.marker, ">"), a(n.gutter, j), b.length > 0 ? ` ${b}` : "", te].join("");
    } else
      return ` ${a(n.gutter, j)}${b.length > 0 ? ` ${b}` : ""}`;
  }).join(`
`);
  return r.message && !f && (y = `${" ".repeat(p + 1)}${r.message}
${y}`), i ? s.reset(y) : y;
}
function GD(e, t, r, i = {}) {
  if (!Dl) {
    Dl = !0;
    const n = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
    if (process.emitWarning)
      process.emitWarning(n, "DeprecationWarning");
    else {
      const a = new Error(n);
      a.name = "DeprecationWarning", console.warn(new Error(n));
    }
  }
  return r = Math.max(r, 0), $c(e, {
    start: {
      column: r,
      line: t
    }
  }, i);
}
var gt = {}, Ds = {};
Object.defineProperty(Ds, "__esModule", {
  value: !0
});
Ds.default = void 0;
var Vc = Ae(), zD = Vc;
const {
  react: QD
} = Vc, {
  cloneNode: ZD,
  jsxExpressionContainer: eL,
  variableDeclaration: tL,
  variableDeclarator: rL
} = zD, iL = {
  ReferencedIdentifier(e, t) {
    if (e.isJSXIdentifier() && QD.isCompatTag(e.node.name) && !e.parentPath.isJSXMemberExpression())
      return;
    if (e.node.name === "this") {
      let i = e.scope;
      do
        if (i.path.isFunction() && !i.path.isArrowFunctionExpression())
          break;
      while (i = i.parent);
      i && t.breakOnScopePaths.push(i.path);
    }
    const r = e.scope.getBinding(e.node.name);
    if (r) {
      for (const i of r.constantViolations)
        if (i.scope !== r.path.scope) {
          t.mutableBinding = !0, e.stop();
          return;
        }
      r === t.scope.getBinding(e.node.name) && (t.bindings[e.node.name] = r);
    }
  }
};
class sL {
  constructor(t, r) {
    this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], this.scope = r, this.path = t, this.attachAfter = !1;
  }
  isCompatibleScope(t) {
    for (const r of Object.keys(this.bindings)) {
      const i = this.bindings[r];
      if (!t.bindingIdentifierEquals(r, i.identifier))
        return !1;
    }
    return !0;
  }
  getCompatibleScopes() {
    let t = this.path.scope;
    do {
      if (this.isCompatibleScope(t))
        this.scopes.push(t);
      else
        break;
      if (this.breakOnScopePaths.includes(t.path))
        break;
    } while (t = t.parent);
  }
  getAttachmentPath() {
    let t = this._getAttachmentPath();
    if (!t) return;
    let r = t.scope;
    if (r.path === t && (r = t.scope.parent), r.path.isProgram() || r.path.isFunction())
      for (const i of Object.keys(this.bindings)) {
        if (!r.hasOwnBinding(i)) continue;
        const s = this.bindings[i];
        if (s.kind === "param" || s.path.parentKey === "params")
          continue;
        if (this.getAttachmentParentForPath(s.path).key >= t.key) {
          this.attachAfter = !0, t = s.path;
          for (const a of s.constantViolations)
            this.getAttachmentParentForPath(a).key > t.key && (t = a);
        }
      }
    return t;
  }
  _getAttachmentPath() {
    const r = this.scopes.pop();
    if (r) {
      if (r.path.isFunction())
        if (this.hasOwnParamBindings(r)) {
          if (this.scope === r) return;
          const i = r.path.get("body").get("body");
          for (let s = 0; s < i.length; s++)
            if (!i[s].node._blockHoist)
              return i[s];
        } else
          return this.getNextScopeAttachmentParent();
      else if (r.path.isProgram())
        return this.getNextScopeAttachmentParent();
    }
  }
  getNextScopeAttachmentParent() {
    const t = this.scopes.pop();
    if (t) return this.getAttachmentParentForPath(t.path);
  }
  getAttachmentParentForPath(t) {
    do
      if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
        return t;
    while (t = t.parentPath);
  }
  hasOwnParamBindings(t) {
    for (const r of Object.keys(this.bindings)) {
      if (!t.hasOwnBinding(r)) continue;
      const i = this.bindings[r];
      if (i.kind === "param" && i.constant) return !0;
    }
    return !1;
  }
  run() {
    if (this.path.traverse(iL, this), this.mutableBinding) return;
    this.getCompatibleScopes();
    const t = this.getAttachmentPath();
    if (!t || t.getFunctionParent() === this.path.getFunctionParent()) return;
    let r = t.scope.generateUidIdentifier("ref");
    const i = rL(r, this.path.node), s = this.attachAfter ? "insertAfter" : "insertBefore", [n] = t[s]([t.isVariableDeclarator() ? i : tL("var", [i])]), a = this.path.parentPath;
    return a.isJSXElement() && this.path.container === a.node.children && (r = eL(r)), this.path.replaceWith(ZD(r)), t.isVariableDeclarator() ? n.get("init") : n.get("declarations.0.init");
  }
}
Ds.default = sL;
var Ge = {}, Lt = {}, Ls = {};
Object.defineProperty(Ls, "__esModule", {
  value: !0
});
Ls.hooks = void 0;
Ls.hooks = [function(e, t) {
  if (e.key === "test" && (t.isWhile() || t.isSwitchCase()) || e.key === "declaration" && t.isExportDeclaration() || e.key === "body" && t.isLabeledStatement() || e.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e.key === "expression" && t.isExpressionStatement())
    return t.remove(), !0;
}, function(e, t) {
  if (t.isSequenceExpression() && t.node.expressions.length === 1)
    return t.replaceWith(t.node.expressions[0]), !0;
}, function(e, t) {
  if (t.isBinary())
    return e.key === "left" ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
}, function(e, t) {
  if (t.isIfStatement() && e.key === "consequent" || e.key === "body" && (t.isLoop() || t.isArrowFunctionExpression()))
    return e.replaceWith({
      type: "BlockStatement",
      body: []
    }), !0;
}];
var Ml;
function Ca() {
  if (Ml) return Lt;
  Ml = 1, Object.defineProperty(Lt, "__esModule", {
    value: !0
  }), Lt._assertUnremoved = f, Lt._callRemovalHooks = l, Lt._markRemoved = c, Lt._remove = u, Lt._removeFromScope = o, Lt.remove = a;
  var e = Ls, t = nt, r = pf(), i = mr(), s = Ae();
  const {
    getBindingIdentifiers: n
  } = s;
  function a() {
    var p;
    if (f.call(this), this.resync(), (p = this.opts) != null && p.noScope || o.call(this), l.call(this)) {
      c.call(this);
      return;
    }
    this.shareCommentsWithSiblings(), u.call(this), c.call(this);
  }
  function o() {
    const p = n(this.node, !1, !1, !0);
    Object.keys(p).forEach((h) => this.scope.removeBinding(h));
  }
  function l() {
    if (this.parentPath) {
      for (const p of e.hooks)
        if (p(this, this.parentPath)) return !0;
    }
  }
  function u() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : r._replaceWith.call(this, null);
  }
  function c() {
    this._traverseFlags |= i.SHOULD_SKIP | i.REMOVED, this.parent && (0, t.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
  }
  function f() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  return Lt;
}
var Bl;
function Kc() {
  if (Bl) return Ge;
  Bl = 1, Object.defineProperty(Ge, "__esModule", {
    value: !0
  }), Ge._call = s, Ge._getQueueContexts = ae, Ge._resyncKey = b, Ge._resyncList = A, Ge._resyncParent = y, Ge._resyncRemoved = I, Ge.call = i, Ge.isBlacklisted = Ge.isDenylisted = n, Ge.popContext = _, Ge.pushContext = j, Ge.requeue = te, Ge.resync = h, Ge.setContext = p, Ge.setKey = ce, Ge.setScope = f, Ge.setup = G, Ge.skip = l, Ge.skipKey = u, Ge.stop = c, Ge.visit = o;
  var e = Ha(), t = mr(), r = Ca();
  function i(q) {
    const Y = this.opts;
    if (this.debug(q), this.node && s.call(this, Y[q]))
      return !0;
    if (this.node) {
      var re;
      return s.call(this, (re = Y[this.node.type]) == null ? void 0 : re[q]);
    }
    return !1;
  }
  function s(q) {
    if (!q) return !1;
    for (const Y of q) {
      if (!Y) continue;
      const re = this.node;
      if (!re) return !0;
      const W = Y.call(this.state, this, this.state);
      if (W && typeof W == "object" && typeof W.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (W)
        throw new Error(`Unexpected return value from visitor method ${Y}`);
      if (this.node !== re || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  function n() {
    var q;
    const Y = (q = this.opts.denylist) != null ? q : this.opts.blacklist;
    return Y && Y.indexOf(this.node.type) > -1;
  }
  function a(q, Y) {
    q.context !== Y && (q.context = Y, q.state = Y.state, q.opts = Y.opts);
  }
  function o() {
    var q, Y;
    if (!this.node || this.isDenylisted() || (q = (Y = this.opts).shouldSkip) != null && q.call(Y, this))
      return !1;
    const re = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (a(this, re), this.debug("Recursing into..."), this.shouldStop = (0, e.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), a(this, re), this.call("exit"), this.shouldStop);
  }
  function l() {
    this.shouldSkip = !0;
  }
  function u(q) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[q] = !0;
  }
  function c() {
    this._traverseFlags |= t.SHOULD_SKIP | t.SHOULD_STOP;
  }
  function f() {
    var q, Y;
    if ((q = this.opts) != null && q.noScope) return;
    let re = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && re.isMethod() || this.key === "discriminant" && re.isSwitchStatement()) && (re = re.parentPath);
    let W;
    for (; re && !W; ) {
      var Q;
      if ((Q = re.opts) != null && Q.noScope) return;
      W = re.scope, re = re.parentPath;
    }
    this.scope = this.getScope(W), (Y = this.scope) == null || Y.init();
  }
  function p(q) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, q && (this.context = q, this.state = q.state, this.opts = q.opts), this.setScope(), this;
  }
  function h() {
    this.removed || (y.call(this), A.call(this), b.call(this));
  }
  function y() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  function b() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let q = 0; q < this.container.length; q++)
          if (this.container[q] === this.node) {
            this.setKey(q);
            return;
          }
      } else
        for (const q of Object.keys(this.container))
          if (this.container[q] === this.node) {
            this.setKey(q);
            return;
          }
      this.key = null;
    }
  }
  function A() {
    if (!this.parent || !this.inList) return;
    const q = this.parent[this.listKey];
    this.container !== q && (this.container = q || null);
  }
  function I() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && r._markRemoved.call(this);
  }
  function _() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  function j(q) {
    this.contexts.push(q), this.setContext(q);
  }
  function G(q, Y, re, W) {
    this.listKey = re, this.container = Y, this.parentPath = q || this.parentPath, this.setKey(W);
  }
  function ce(q) {
    var Y;
    this.key = q, this.node = this.container[this.key], this.type = (Y = this.node) == null ? void 0 : Y.type;
  }
  function te(q = this) {
    if (q.removed) return;
    const Y = this.contexts;
    for (const re of Y)
      re.maybeQueue(q);
  }
  function ae() {
    let q = this, Y = this.contexts;
    for (; !Y.length && (q = q.parentPath, !!q); )
      Y = q.contexts;
    return Y;
  }
  return Ge;
}
var Fl;
function qc() {
  if (Fl) return gt;
  Fl = 1, Object.defineProperty(gt, "__esModule", {
    value: !0
  }), gt._containerInsert = te, gt._containerInsertAfter = q, gt._containerInsertBefore = ae, gt._verifyNodeList = L, gt.hoist = B, gt.insertAfter = Q, gt.insertBefore = ce, gt.pushContainer = F, gt.unshiftContainer = k, gt.updateSiblingKeys = U;
  var e = nt, t = Ds, r = mr(), i = Kc(), s = Ca(), n = Ae();
  const {
    arrowFunctionExpression: a,
    assertExpression: o,
    assignmentExpression: l,
    blockStatement: u,
    callExpression: c,
    cloneNode: f,
    expressionStatement: p,
    isAssignmentExpression: h,
    isCallExpression: y,
    isExportNamedDeclaration: b,
    isExpression: A,
    isIdentifier: I,
    isSequenceExpression: _,
    isSuper: j,
    thisExpression: G
  } = n;
  function ce(N) {
    s._assertUnremoved.call(this);
    const D = L.call(this, N), {
      parentPath: R,
      parent: V
    } = this;
    if (R.isExpressionStatement() || R.isLabeledStatement() || b(V) || R.isExportDefaultDeclaration() && this.isDeclaration())
      return R.insertBefore(D);
    if (this.isNodeType("Expression") && !this.isJSXElement() || R.isForStatement() && this.key === "init")
      return this.node && D.push(this.node), this.replaceExpressionWithStatements(D);
    if (Array.isArray(this.container))
      return ae.call(this, D);
    if (this.isStatementOrBlock()) {
      const $ = this.node, H = $ && (!this.isExpressionStatement() || $.expression != null);
      return this.replaceWith(u(H ? [$] : [])), this.unshiftContainer("body", D);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  function te(N, D) {
    this.updateSiblingKeys(N, D.length);
    const R = [];
    this.container.splice(N, 0, ...D);
    for (let H = 0; H < D.length; H++) {
      var V;
      const se = N + H, oe = this.getSibling(se);
      R.push(oe), (V = this.context) != null && V.queue && oe.pushContext(this.context);
    }
    const $ = i._getQueueContexts.call(this);
    for (const H of R) {
      H.setScope(), H.debug("Inserted.");
      for (const se of $)
        se.maybeQueue(H, !0);
    }
    return R;
  }
  function ae(N) {
    return te.call(this, this.key, N);
  }
  function q(N) {
    return te.call(this, this.key + 1, N);
  }
  const Y = (N) => N[N.length - 1];
  function re(N) {
    return _(N.parent) && (Y(N.parent.expressions) !== N.node || re(N.parentPath));
  }
  function W(N, D) {
    if (!h(N) || !I(N.left))
      return !1;
    const R = D.getBlockParent();
    return R.hasOwnBinding(N.left.name) && R.getOwnBinding(N.left.name).constantViolations.length <= 1;
  }
  function Q(N) {
    if (s._assertUnremoved.call(this), this.isSequenceExpression())
      return Y(this.get("expressions")).insertAfter(N);
    const D = L.call(this, N), {
      parentPath: R,
      parent: V
    } = this;
    if (R.isExpressionStatement() || R.isLabeledStatement() || b(V) || R.isExportDefaultDeclaration() && this.isDeclaration())
      return R.insertAfter(D.map(($) => A($) ? p($) : $));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !R.isJSXElement() || R.isForStatement() && this.key === "init") {
      const $ = this;
      if ($.node) {
        const H = $.node;
        let {
          scope: se
        } = this;
        if (se.path.isPattern())
          return o(H), $.replaceWith(c(a([], H), [])), $.get("callee.body").insertAfter(D), [$];
        if (re($))
          D.unshift(H);
        else if (y(H) && j(H.callee))
          D.unshift(H), D.push(G());
        else if (W(H, se))
          D.unshift(H), D.push(f(H.left));
        else if (se.isPure(H, !0))
          D.push(H);
        else {
          R.isMethod({
            computed: !0,
            key: H
          }) && (se = se.parent);
          const oe = se.generateDeclaredUidIdentifier();
          D.unshift(p(l("=", f(oe), H))), D.push(p(f(oe)));
        }
      }
      return this.replaceExpressionWithStatements(D);
    } else {
      if (Array.isArray(this.container))
        return q.call(this, D);
      if (this.isStatementOrBlock()) {
        const $ = this.node, H = $ && (!this.isExpressionStatement() || $.expression != null);
        return this.replaceWith(u(H ? [$] : [])), this.pushContainer("body", D);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  function U(N, D) {
    if (!this.parent) return;
    const R = (0, e.getCachedPaths)(this.hub, this.parent) || [];
    for (const [, V] of R)
      typeof V.key == "number" && V.key >= N && (V.key += D);
  }
  function L(N) {
    if (!N)
      return [];
    Array.isArray(N) || (N = [N]);
    for (let D = 0; D < N.length; D++) {
      const R = N[D];
      let V;
      if (R ? typeof R != "object" ? V = "contains a non-object node" : R.type ? R instanceof r.default && (V = "has a NodePath when it expected a raw object") : V = "without a type" : V = "has falsy node", V) {
        const $ = Array.isArray(R) ? "array" : typeof R;
        throw new Error(`Node list ${V} with the index of ${D} and type of ${$}`);
      }
    }
    return N;
  }
  function k(N, D) {
    s._assertUnremoved.call(this), D = L.call(this, D);
    const R = r.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[N],
      listKey: N,
      key: 0
    }).setContext(this.context);
    return ae.call(R, D);
  }
  function F(N, D) {
    s._assertUnremoved.call(this);
    const R = L.call(this, D), V = this.node[N];
    return r.default.get({
      parentPath: this,
      parent: this.node,
      container: V,
      listKey: N,
      key: V.length
    }).setContext(this.context).replaceWithMultiple(R);
  }
  function B(N = this.scope) {
    return new t.default(this, N).run();
  }
  return gt;
}
var Ar = {};
Object.defineProperty(Ar, "__esModule", {
  value: !0
});
function Wc(e, t) {
  if (e == null) return {};
  var r = {}, i = Object.keys(e), s, n;
  for (n = 0; n < i.length; n++)
    s = i[n], !(t.indexOf(s) >= 0) && (r[s] = e[s]);
  return r;
}
class Gt {
  constructor(t, r, i) {
    this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = i;
  }
}
class rs {
  constructor(t, r) {
    this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
  }
}
function ht(e, t) {
  const {
    line: r,
    column: i,
    index: s
  } = e;
  return new Gt(r, i + t, s + t);
}
const jl = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
var nL = {
  ImportMetaOutsideModule: {
    message: `import.meta may appear only with 'sourceType: "module"'`,
    code: jl
  },
  ImportOutsideModule: {
    message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
    code: jl
  }
};
const Rl = {
  ArrayPattern: "array destructuring pattern",
  AssignmentExpression: "assignment expression",
  AssignmentPattern: "assignment expression",
  ArrowFunctionExpression: "arrow function expression",
  ConditionalExpression: "conditional expression",
  CatchClause: "catch clause",
  ForOfStatement: "for-of statement",
  ForInStatement: "for-in statement",
  ForStatement: "for-loop",
  FormalParameters: "function parameter list",
  Identifier: "identifier",
  ImportSpecifier: "import specifier",
  ImportDefaultSpecifier: "import default specifier",
  ImportNamespaceSpecifier: "import namespace specifier",
  ObjectPattern: "object destructuring pattern",
  ParenthesizedExpression: "parenthesized expression",
  RestElement: "rest element",
  UpdateExpression: {
    true: "prefix operation",
    false: "postfix operation"
  },
  VariableDeclarator: "variable declaration",
  YieldExpression: "yield expression"
}, Yi = (e) => e.type === "UpdateExpression" ? Rl.UpdateExpression[`${e.prefix}`] : Rl[e.type];
var aL = {
  AccessorIsGenerator: ({
    kind: e
  }) => `A ${e}ter cannot be a generator.`,
  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
  AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
  BadGetterArity: "A 'get' accessor must not have any formal parameters.",
  BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
  BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
  ConstructorClassField: "Classes may not have a field named 'constructor'.",
  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
  ConstructorIsAccessor: "Class constructor may not be an accessor.",
  ConstructorIsAsync: "Constructor can't be an async function.",
  ConstructorIsGenerator: "Constructor can't be a generator.",
  DeclarationMissingInitializer: ({
    kind: e
  }) => `Missing initializer in ${e} declaration.`,
  DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
  DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
  DecoratorStaticBlock: "Decorators can't be used with a static block.",
  DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
  DeletePrivateField: "Deleting a private field is not allowed.",
  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
  DuplicateConstructor: "Duplicate constructor in the same class.",
  DuplicateDefaultExport: "Only one default export allowed per module.",
  DuplicateExport: ({
    exportName: e
  }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`,
  DuplicateProto: "Redefinition of __proto__ property.",
  DuplicateRegExpFlags: "Duplicate regular expression flag.",
  DynamicImportPhaseRequiresImportExpressions: ({
    phase: e
  }) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`,
  ElementAfterRest: "Rest element must be last element.",
  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
  ExportBindingIsString: ({
    localName: e,
    exportName: t
  }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`,
  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
  ForInOfLoopInitializer: ({
    type: e
  }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
  ForInUsing: "For-in loop may not start with 'using' declaration.",
  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
  IllegalBreakContinue: ({
    type: e
  }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`,
  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
  IllegalReturn: "'return' outside of function.",
  ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
  ImportBindingIsString: ({
    importName: e
  }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`,
  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
  ImportCallArity: ({
    maxArgumentCount: e
  }) => `\`import()\` requires exactly ${e === 1 ? "one argument" : "one or two arguments"}.`,
  ImportCallNotNewExpression: "Cannot use new with import(...).",
  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
  ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
  ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
  ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
  IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
  InvalidCodePoint: "Code point out of bounds.",
  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
  InvalidDecimal: "Invalid decimal.",
  InvalidDigit: ({
    radix: e
  }) => `Expected number in radix ${e}.`,
  InvalidEscapeSequence: "Bad character escape sequence.",
  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
  InvalidEscapedReservedWord: ({
    reservedWord: e
  }) => `Escape sequence in keyword ${e}.`,
  InvalidIdentifier: ({
    identifierName: e
  }) => `Invalid identifier ${e}.`,
  InvalidLhs: ({
    ancestor: e
  }) => `Invalid left-hand side in ${Yi(e)}.`,
  InvalidLhsBinding: ({
    ancestor: e
  }) => `Binding invalid left-hand side in ${Yi(e)}.`,
  InvalidLhsOptionalChaining: ({
    ancestor: e
  }) => `Invalid optional chaining in the left-hand side of ${Yi(e)}.`,
  InvalidNumber: "Invalid number.",
  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
  InvalidOrUnexpectedToken: ({
    unexpected: e
  }) => `Unexpected character '${e}'.`,
  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
  InvalidPrivateFieldResolution: ({
    identifierName: e
  }) => `Private name #${e} is not defined.`,
  InvalidPropertyBindingPattern: "Binding member expression.",
  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
  LabelRedeclaration: ({
    labelName: e
  }) => `Label '${e}' is already declared.`,
  LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
  MalformedRegExpFlags: "Invalid regular expression flag.",
  MissingClassName: "A class name is required.",
  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
  MissingSemicolon: "Missing semicolon.",
  MissingPlugin: ({
    missingPlugin: e
  }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
  MissingOneOfPlugins: ({
    missingPlugin: e
  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
  ModuleAttributesWithDuplicateKeys: ({
    key: e
  }) => `Duplicate key "${e}" is not allowed in module attributes.`,
  ModuleExportNameHasLoneSurrogate: ({
    surrogateCharCode: e
  }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`,
  ModuleExportUndefined: ({
    localName: e
  }) => `Export '${e}' is not defined.`,
  MultipleDefaultsInSwitch: "Multiple default clauses.",
  NewlineAfterThrow: "Illegal newline after throw.",
  NoCatchOrFinally: "Missing catch or finally clause.",
  NumberIdentifier: "Identifier directly after number.",
  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
  ParamDupe: "Argument name clash.",
  PatternHasAccessor: "Object pattern can't contain getter or setter.",
  PatternHasMethod: "Object pattern can't contain methods.",
  PrivateInExpectedIn: ({
    identifierName: e
  }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`,
  PrivateNameRedeclaration: ({
    identifierName: e
  }) => `Duplicate private name #${e}.`,
  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
  RestTrailingComma: "Unexpected trailing comma after rest element.",
  SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
  SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
  SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
  StaticPrototype: "Classes may not have static property named prototype.",
  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
  SuperPrivateField: "Private fields can't be accessed on super.",
  TrailingDecorator: "Decorators must be attached to a class element.",
  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
  UnexpectedKeyword: ({
    keyword: e
  }) => `Unexpected keyword '${e}'.`,
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
  UnexpectedPrivateField: "Unexpected private name.",
  UnexpectedReservedWord: ({
    reservedWord: e
  }) => `Unexpected reserved word '${e}'.`,
  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
  UnexpectedToken: ({
    expected: e,
    unexpected: t
  }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`,
  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
  UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
  UnsupportedBind: "Binding should be performed on object property.",
  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
  UnsupportedMetaProperty: ({
    target: e,
    onlyValidPropertyName: t
  }) => `The only valid meta property for ${e} is ${e}.${t}.`,
  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
  UnterminatedComment: "Unterminated comment.",
  UnterminatedRegExp: "Unterminated regular expression.",
  UnterminatedString: "Unterminated string constant.",
  UnterminatedTemplate: "Unterminated template.",
  UsingDeclarationExport: "Using declaration cannot be exported.",
  UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
  VarRedeclaration: ({
    identifierName: e
  }) => `Identifier '${e}' has already been declared.`,
  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
  YieldInParameter: "Yield expression is not allowed in formal parameters.",
  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
}, oL = {
  StrictDelete: "Deleting local variable in strict mode.",
  StrictEvalArguments: ({
    referenceName: e
  }) => `Assigning to '${e}' in strict mode.`,
  StrictEvalArgumentsBinding: ({
    bindingName: e
  }) => `Binding '${e}' in strict mode.`,
  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
  StrictWith: "'with' in strict mode."
};
const lL = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
var uL = {
  PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
  PipeTopicUnconfiguredToken: ({
    token: e
  }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`,
  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
  PipeUnparenthesizedBody: ({
    type: e
  }) => `Hack-style pipe body cannot be an unparenthesized ${Yi({
    type: e
  })}; please wrap it in parentheses.`,
  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
};
const cL = ["toMessage"], fL = ["message"];
function Ul(e, t, r) {
  Object.defineProperty(e, t, {
    enumerable: !1,
    configurable: !0,
    value: r
  });
}
function pL(e) {
  let {
    toMessage: t
  } = e, r = Wc(e, cL);
  return function i(s, n) {
    const a = new SyntaxError();
    return Object.assign(a, r, {
      loc: s,
      pos: s.index
    }), "missingPlugin" in n && Object.assign(a, {
      missingPlugin: n.missingPlugin
    }), Ul(a, "clone", function(l = {}) {
      var u;
      const {
        line: c,
        column: f,
        index: p
      } = (u = l.loc) != null ? u : s;
      return i(new Gt(c, f, p), Object.assign({}, n, l.details));
    }), Ul(a, "details", n), Object.defineProperty(a, "message", {
      configurable: !0,
      get() {
        const o = `${t(n)} (${s.line}:${s.column})`;
        return this.message = o, o;
      },
      set(o) {
        Object.defineProperty(this, "message", {
          value: o,
          writable: !0
        });
      }
    }), a;
  };
}
function Ut(e, t) {
  if (Array.isArray(e))
    return (i) => Ut(i, e[0]);
  const r = {};
  for (const i of Object.keys(e)) {
    const s = e[i], n = typeof s == "string" ? {
      message: () => s
    } : typeof s == "function" ? {
      message: s
    } : s, {
      message: a
    } = n, o = Wc(n, fL), l = typeof a == "string" ? () => a : a;
    r[i] = pL(Object.assign({
      code: "BABEL_PARSER_SYNTAX_ERROR",
      reasonCode: i,
      toMessage: l
    }, t ? {
      syntaxPlugin: t
    } : {}, o));
  }
  return r;
}
const w = Object.assign({}, Ut(nL), Ut(aL), Ut(oL), Ut`pipelineOperator`(uL)), {
  defineProperty: hL
} = Object, $l = (e, t) => {
  e && hL(e, t, {
    enumerable: !1,
    value: e[t]
  });
};
function Fr(e) {
  return $l(e.loc.start, "index"), $l(e.loc.end, "index"), e;
}
var dL = (e) => class extends e {
  parse() {
    const r = Fr(super.parse());
    return this.options.tokens && (r.tokens = r.tokens.map(Fr)), r;
  }
  parseRegExpLiteral({
    pattern: r,
    flags: i
  }) {
    let s = null;
    try {
      s = new RegExp(r, i);
    } catch {
    }
    const n = this.estreeParseLiteral(s);
    return n.regex = {
      pattern: r,
      flags: i
    }, n;
  }
  parseBigIntLiteral(r) {
    let i;
    try {
      i = BigInt(r);
    } catch {
      i = null;
    }
    const s = this.estreeParseLiteral(i);
    return s.bigint = String(s.value || r), s;
  }
  parseDecimalLiteral(r) {
    const s = this.estreeParseLiteral(null);
    return s.decimal = String(s.value || r), s;
  }
  estreeParseLiteral(r) {
    return this.parseLiteral(r, "Literal");
  }
  parseStringLiteral(r) {
    return this.estreeParseLiteral(r);
  }
  parseNumericLiteral(r) {
    return this.estreeParseLiteral(r);
  }
  parseNullLiteral() {
    return this.estreeParseLiteral(null);
  }
  parseBooleanLiteral(r) {
    return this.estreeParseLiteral(r);
  }
  directiveToStmt(r) {
    const i = r.value;
    delete r.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
    const s = r;
    return s.type = "ExpressionStatement", s.expression = i, s.directive = i.extra.rawValue, delete i.extra, s;
  }
  initFunction(r, i) {
    super.initFunction(r, i), r.expression = !1;
  }
  checkDeclaration(r) {
    r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
  }
  getObjectOrClassMethodParams(r) {
    return r.value.params;
  }
  isValidDirective(r) {
    var i;
    return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((i = r.expression.extra) != null && i.parenthesized);
  }
  parseBlockBody(r, i, s, n, a) {
    super.parseBlockBody(r, i, s, n, a);
    const o = r.directives.map((l) => this.directiveToStmt(l));
    r.body = o.concat(r.body), delete r.directives;
  }
  pushClassMethod(r, i, s, n, a, o) {
    this.parseMethod(i, s, n, a, o, "ClassMethod", !0), i.typeParameters && (i.value.typeParameters = i.typeParameters, delete i.typeParameters), r.body.push(i);
  }
  parsePrivateName() {
    const r = super.parsePrivateName();
    return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
  }
  convertPrivateNameToPrivateIdentifier(r) {
    const i = super.getPrivateNameSV(r);
    return r = r, delete r.id, r.name = i, r.type = "PrivateIdentifier", r;
  }
  isPrivateName(r) {
    return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
  }
  getPrivateNameSV(r) {
    return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
  }
  parseLiteral(r, i) {
    const s = super.parseLiteral(r, i);
    return s.raw = s.extra.raw, delete s.extra, s;
  }
  parseFunctionBody(r, i, s = !1) {
    super.parseFunctionBody(r, i, s), r.expression = r.body.type !== "BlockStatement";
  }
  parseMethod(r, i, s, n, a, o, l = !1) {
    let u = this.startNode();
    return u.kind = r.kind, u = super.parseMethod(u, i, s, n, a, o, l), u.type = "FunctionExpression", delete u.kind, r.value = u, o === "ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
  }
  nameIsConstructor(r) {
    return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
  }
  parseClassProperty(...r) {
    const i = super.parseClassProperty(...r);
    return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
  }
  parseClassPrivateProperty(...r) {
    const i = super.parseClassPrivateProperty(...r);
    return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
  }
  parseObjectMethod(r, i, s, n, a) {
    const o = super.parseObjectMethod(r, i, s, n, a);
    return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = !1), o;
  }
  parseObjectProperty(r, i, s, n) {
    const a = super.parseObjectProperty(r, i, s, n);
    return a && (a.kind = "init", a.type = "Property"), a;
  }
  isValidLVal(r, i, s) {
    return r === "Property" ? "value" : super.isValidLVal(r, i, s);
  }
  isAssignable(r, i) {
    return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, i) : super.isAssignable(r, i);
  }
  toAssignable(r, i = !1) {
    if (r != null && this.isObjectProperty(r)) {
      const {
        key: s,
        value: n
      } = r;
      this.isPrivateName(s) && this.classScope.usePrivateName(this.getPrivateNameSV(s), s.loc.start), this.toAssignable(n, i);
    } else
      super.toAssignable(r, i);
  }
  toAssignableObjectExpressionProp(r, i, s) {
    r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(w.PatternHasAccessor, r.key) : r.type === "Property" && r.method ? this.raise(w.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, i, s);
  }
  finishCallExpression(r, i) {
    const s = super.finishCallExpression(r, i);
    if (s.callee.type === "Import") {
      if (s.type = "ImportExpression", s.source = s.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
        var n, a;
        s.options = (n = s.arguments[1]) != null ? n : null, s.attributes = (a = s.arguments[1]) != null ? a : null;
      }
      delete s.arguments, delete s.callee;
    }
    return s;
  }
  toReferencedArguments(r) {
    r.type !== "ImportExpression" && super.toReferencedArguments(r);
  }
  parseExport(r, i) {
    const s = this.state.lastTokStartLoc, n = super.parseExport(r, i);
    switch (n.type) {
      case "ExportAllDeclaration":
        n.exported = null;
        break;
      case "ExportNamedDeclaration":
        n.specifiers.length === 1 && n.specifiers[0].type === "ExportNamespaceSpecifier" && (n.type = "ExportAllDeclaration", n.exported = n.specifiers[0].exported, delete n.specifiers);
      case "ExportDefaultDeclaration":
        {
          var a;
          const {
            declaration: o
          } = n;
          (o == null ? void 0 : o.type) === "ClassDeclaration" && ((a = o.decorators) == null ? void 0 : a.length) > 0 && o.start === n.start && this.resetStartLocation(n, s);
        }
        break;
    }
    return n;
  }
  parseSubscript(r, i, s, n) {
    const a = super.parseSubscript(r, i, s, n);
    if (n.optionalChainMember) {
      if ((a.type === "OptionalMemberExpression" || a.type === "OptionalCallExpression") && (a.type = a.type.substring(8)), n.stop) {
        const o = this.startNodeAtNode(a);
        return o.expression = a, this.finishNode(o, "ChainExpression");
      }
    } else (a.type === "MemberExpression" || a.type === "CallExpression") && (a.optional = !1);
    return a;
  }
  isOptionalMemberExpression(r) {
    return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
  }
  hasPropertyAsPrivateName(r) {
    return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
  }
  isObjectProperty(r) {
    return r.type === "Property" && r.kind === "init" && !r.method;
  }
  isObjectMethod(r) {
    return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
  }
  finishNodeAt(r, i, s) {
    return Fr(super.finishNodeAt(r, i, s));
  }
  resetStartLocation(r, i) {
    super.resetStartLocation(r, i), Fr(r);
  }
  resetEndLocation(r, i = this.state.lastTokEndLoc) {
    super.resetEndLocation(r, i), Fr(r);
  }
};
class Wr {
  constructor(t, r) {
    this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
  }
}
const $e = {
  brace: new Wr("{"),
  j_oTag: new Wr("<tag"),
  j_cTag: new Wr("</tag"),
  j_expr: new Wr("<tag>...</tag>", !0)
};
$e.template = new Wr("`", !0);
const we = !0, ie = !0, pn = !0, jr = !0, Jt = !0, mL = !0;
class Jc {
  constructor(t, r = {}) {
    this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.updateContext = null;
  }
}
const Ia = /* @__PURE__ */ new Map();
function De(e, t = {}) {
  t.keyword = e;
  const r = de(e, t);
  return Ia.set(e, r), r;
}
function ft(e, t) {
  return de(e, {
    beforeExpr: we,
    binop: t
  });
}
let Hr = -1;
const Ft = [], wa = [], Oa = [], Na = [], _a = [], ka = [];
function de(e, t = {}) {
  var r, i, s, n;
  return ++Hr, wa.push(e), Oa.push((r = t.binop) != null ? r : -1), Na.push((i = t.beforeExpr) != null ? i : !1), _a.push((s = t.startsExpr) != null ? s : !1), ka.push((n = t.prefix) != null ? n : !1), Ft.push(new Jc(e, t)), Hr;
}
function Ie(e, t = {}) {
  var r, i, s, n;
  return ++Hr, Ia.set(e, Hr), wa.push(e), Oa.push((r = t.binop) != null ? r : -1), Na.push((i = t.beforeExpr) != null ? i : !1), _a.push((s = t.startsExpr) != null ? s : !1), ka.push((n = t.prefix) != null ? n : !1), Ft.push(new Jc("name", t)), Hr;
}
const yL = {
  bracketL: de("[", {
    beforeExpr: we,
    startsExpr: ie
  }),
  bracketHashL: de("#[", {
    beforeExpr: we,
    startsExpr: ie
  }),
  bracketBarL: de("[|", {
    beforeExpr: we,
    startsExpr: ie
  }),
  bracketR: de("]"),
  bracketBarR: de("|]"),
  braceL: de("{", {
    beforeExpr: we,
    startsExpr: ie
  }),
  braceBarL: de("{|", {
    beforeExpr: we,
    startsExpr: ie
  }),
  braceHashL: de("#{", {
    beforeExpr: we,
    startsExpr: ie
  }),
  braceR: de("}"),
  braceBarR: de("|}"),
  parenL: de("(", {
    beforeExpr: we,
    startsExpr: ie
  }),
  parenR: de(")"),
  comma: de(",", {
    beforeExpr: we
  }),
  semi: de(";", {
    beforeExpr: we
  }),
  colon: de(":", {
    beforeExpr: we
  }),
  doubleColon: de("::", {
    beforeExpr: we
  }),
  dot: de("."),
  question: de("?", {
    beforeExpr: we
  }),
  questionDot: de("?."),
  arrow: de("=>", {
    beforeExpr: we
  }),
  template: de("template"),
  ellipsis: de("...", {
    beforeExpr: we
  }),
  backQuote: de("`", {
    startsExpr: ie
  }),
  dollarBraceL: de("${", {
    beforeExpr: we,
    startsExpr: ie
  }),
  templateTail: de("...`", {
    startsExpr: ie
  }),
  templateNonTail: de("...${", {
    beforeExpr: we,
    startsExpr: ie
  }),
  at: de("@"),
  hash: de("#", {
    startsExpr: ie
  }),
  interpreterDirective: de("#!..."),
  eq: de("=", {
    beforeExpr: we,
    isAssign: jr
  }),
  assign: de("_=", {
    beforeExpr: we,
    isAssign: jr
  }),
  slashAssign: de("_=", {
    beforeExpr: we,
    isAssign: jr
  }),
  xorAssign: de("_=", {
    beforeExpr: we,
    isAssign: jr
  }),
  moduloAssign: de("_=", {
    beforeExpr: we,
    isAssign: jr
  }),
  incDec: de("++/--", {
    prefix: Jt,
    postfix: mL,
    startsExpr: ie
  }),
  bang: de("!", {
    beforeExpr: we,
    prefix: Jt,
    startsExpr: ie
  }),
  tilde: de("~", {
    beforeExpr: we,
    prefix: Jt,
    startsExpr: ie
  }),
  doubleCaret: de("^^", {
    startsExpr: ie
  }),
  doubleAt: de("@@", {
    startsExpr: ie
  }),
  pipeline: ft("|>", 0),
  nullishCoalescing: ft("??", 1),
  logicalOR: ft("||", 1),
  logicalAND: ft("&&", 2),
  bitwiseOR: ft("|", 3),
  bitwiseXOR: ft("^", 4),
  bitwiseAND: ft("&", 5),
  equality: ft("==/!=/===/!==", 6),
  lt: ft("</>/<=/>=", 7),
  gt: ft("</>/<=/>=", 7),
  relational: ft("</>/<=/>=", 7),
  bitShift: ft("<</>>/>>>", 8),
  bitShiftL: ft("<</>>/>>>", 8),
  bitShiftR: ft("<</>>/>>>", 8),
  plusMin: de("+/-", {
    beforeExpr: we,
    binop: 9,
    prefix: Jt,
    startsExpr: ie
  }),
  modulo: de("%", {
    binop: 10,
    startsExpr: ie
  }),
  star: de("*", {
    binop: 10
  }),
  slash: ft("/", 10),
  exponent: de("**", {
    beforeExpr: we,
    binop: 11,
    rightAssociative: !0
  }),
  _in: De("in", {
    beforeExpr: we,
    binop: 7
  }),
  _instanceof: De("instanceof", {
    beforeExpr: we,
    binop: 7
  }),
  _break: De("break"),
  _case: De("case", {
    beforeExpr: we
  }),
  _catch: De("catch"),
  _continue: De("continue"),
  _debugger: De("debugger"),
  _default: De("default", {
    beforeExpr: we
  }),
  _else: De("else", {
    beforeExpr: we
  }),
  _finally: De("finally"),
  _function: De("function", {
    startsExpr: ie
  }),
  _if: De("if"),
  _return: De("return", {
    beforeExpr: we
  }),
  _switch: De("switch"),
  _throw: De("throw", {
    beforeExpr: we,
    prefix: Jt,
    startsExpr: ie
  }),
  _try: De("try"),
  _var: De("var"),
  _const: De("const"),
  _with: De("with"),
  _new: De("new", {
    beforeExpr: we,
    startsExpr: ie
  }),
  _this: De("this", {
    startsExpr: ie
  }),
  _super: De("super", {
    startsExpr: ie
  }),
  _class: De("class", {
    startsExpr: ie
  }),
  _extends: De("extends", {
    beforeExpr: we
  }),
  _export: De("export"),
  _import: De("import", {
    startsExpr: ie
  }),
  _null: De("null", {
    startsExpr: ie
  }),
  _true: De("true", {
    startsExpr: ie
  }),
  _false: De("false", {
    startsExpr: ie
  }),
  _typeof: De("typeof", {
    beforeExpr: we,
    prefix: Jt,
    startsExpr: ie
  }),
  _void: De("void", {
    beforeExpr: we,
    prefix: Jt,
    startsExpr: ie
  }),
  _delete: De("delete", {
    beforeExpr: we,
    prefix: Jt,
    startsExpr: ie
  }),
  _do: De("do", {
    isLoop: pn,
    beforeExpr: we
  }),
  _for: De("for", {
    isLoop: pn
  }),
  _while: De("while", {
    isLoop: pn
  }),
  _as: Ie("as", {
    startsExpr: ie
  }),
  _assert: Ie("assert", {
    startsExpr: ie
  }),
  _async: Ie("async", {
    startsExpr: ie
  }),
  _await: Ie("await", {
    startsExpr: ie
  }),
  _defer: Ie("defer", {
    startsExpr: ie
  }),
  _from: Ie("from", {
    startsExpr: ie
  }),
  _get: Ie("get", {
    startsExpr: ie
  }),
  _let: Ie("let", {
    startsExpr: ie
  }),
  _meta: Ie("meta", {
    startsExpr: ie
  }),
  _of: Ie("of", {
    startsExpr: ie
  }),
  _sent: Ie("sent", {
    startsExpr: ie
  }),
  _set: Ie("set", {
    startsExpr: ie
  }),
  _source: Ie("source", {
    startsExpr: ie
  }),
  _static: Ie("static", {
    startsExpr: ie
  }),
  _using: Ie("using", {
    startsExpr: ie
  }),
  _yield: Ie("yield", {
    startsExpr: ie
  }),
  _asserts: Ie("asserts", {
    startsExpr: ie
  }),
  _checks: Ie("checks", {
    startsExpr: ie
  }),
  _exports: Ie("exports", {
    startsExpr: ie
  }),
  _global: Ie("global", {
    startsExpr: ie
  }),
  _implements: Ie("implements", {
    startsExpr: ie
  }),
  _intrinsic: Ie("intrinsic", {
    startsExpr: ie
  }),
  _infer: Ie("infer", {
    startsExpr: ie
  }),
  _is: Ie("is", {
    startsExpr: ie
  }),
  _mixins: Ie("mixins", {
    startsExpr: ie
  }),
  _proto: Ie("proto", {
    startsExpr: ie
  }),
  _require: Ie("require", {
    startsExpr: ie
  }),
  _satisfies: Ie("satisfies", {
    startsExpr: ie
  }),
  _keyof: Ie("keyof", {
    startsExpr: ie
  }),
  _readonly: Ie("readonly", {
    startsExpr: ie
  }),
  _unique: Ie("unique", {
    startsExpr: ie
  }),
  _abstract: Ie("abstract", {
    startsExpr: ie
  }),
  _declare: Ie("declare", {
    startsExpr: ie
  }),
  _enum: Ie("enum", {
    startsExpr: ie
  }),
  _module: Ie("module", {
    startsExpr: ie
  }),
  _namespace: Ie("namespace", {
    startsExpr: ie
  }),
  _interface: Ie("interface", {
    startsExpr: ie
  }),
  _type: Ie("type", {
    startsExpr: ie
  }),
  _opaque: Ie("opaque", {
    startsExpr: ie
  }),
  name: de("name", {
    startsExpr: ie
  }),
  string: de("string", {
    startsExpr: ie
  }),
  num: de("num", {
    startsExpr: ie
  }),
  bigint: de("bigint", {
    startsExpr: ie
  }),
  decimal: de("decimal", {
    startsExpr: ie
  }),
  regexp: de("regexp", {
    startsExpr: ie
  }),
  privateName: de("#name", {
    startsExpr: ie
  }),
  eof: de("eof"),
  jsxName: de("jsxName"),
  jsxText: de("jsxText", {
    beforeExpr: !0
  }),
  jsxTagStart: de("jsxTagStart", {
    startsExpr: !0
  }),
  jsxTagEnd: de("jsxTagEnd"),
  placeholder: de("%%", {
    startsExpr: !0
  })
};
function Le(e) {
  return e >= 93 && e <= 132;
}
function TL(e) {
  return e <= 92;
}
function At(e) {
  return e >= 58 && e <= 132;
}
function Xc(e) {
  return e >= 58 && e <= 136;
}
function gL(e) {
  return Na[e];
}
function Ln(e) {
  return _a[e];
}
function bL(e) {
  return e >= 29 && e <= 33;
}
function Vl(e) {
  return e >= 129 && e <= 131;
}
function SL(e) {
  return e >= 90 && e <= 92;
}
function Da(e) {
  return e >= 58 && e <= 92;
}
function EL(e) {
  return e >= 39 && e <= 59;
}
function PL(e) {
  return e === 34;
}
function xL(e) {
  return ka[e];
}
function vL(e) {
  return e >= 121 && e <= 123;
}
function AL(e) {
  return e >= 124 && e <= 130;
}
function zt(e) {
  return wa[e];
}
function Hi(e) {
  return Oa[e];
}
function CL(e) {
  return e === 57;
}
function is(e) {
  return e >= 24 && e <= 25;
}
function Mt(e) {
  return Ft[e];
}
Ft[8].updateContext = (e) => {
  e.pop();
}, Ft[5].updateContext = Ft[7].updateContext = Ft[23].updateContext = (e) => {
  e.push($e.brace);
}, Ft[22].updateContext = (e) => {
  e[e.length - 1] === $e.template ? e.pop() : e.push($e.template);
}, Ft[142].updateContext = (e) => {
  e.push($e.j_expr, $e.j_oTag);
};
let La = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", Yc = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
const IL = new RegExp("[" + La + "]"), wL = new RegExp("[" + La + Yc + "]");
La = Yc = null;
const Hc = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], OL = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function Mn(e, t) {
  let r = 65536;
  for (let i = 0, s = t.length; i < s; i += 2) {
    if (r += t[i], r > e) return !1;
    if (r += t[i + 1], r >= e) return !0;
  }
  return !1;
}
function Rt(e) {
  return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && IL.test(String.fromCharCode(e)) : Mn(e, Hc);
}
function Sr(e) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && wL.test(String.fromCharCode(e)) : Mn(e, Hc) || Mn(e, OL);
}
const Ma = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
}, NL = new Set(Ma.keyword), _L = new Set(Ma.strict), kL = new Set(Ma.strictBind);
function Gc(e, t) {
  return t && e === "await" || e === "enum";
}
function zc(e, t) {
  return Gc(e, t) || _L.has(e);
}
function Qc(e) {
  return kL.has(e);
}
function Zc(e, t) {
  return zc(e, t) || Qc(e);
}
function DL(e) {
  return NL.has(e);
}
function LL(e, t, r) {
  return e === 64 && t === 64 && Rt(r);
}
const ML = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
function BL(e) {
  return ML.has(e);
}
class Ba {
  constructor(t) {
    this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
  }
}
class Fa {
  constructor(t, r) {
    this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = r;
  }
  get inTopLevel() {
    return (this.currentScope().flags & 1) > 0;
  }
  get inFunction() {
    return (this.currentVarScopeFlags() & 2) > 0;
  }
  get allowSuper() {
    return (this.currentThisScopeFlags() & 16) > 0;
  }
  get allowDirectSuper() {
    return (this.currentThisScopeFlags() & 32) > 0;
  }
  get inClass() {
    return (this.currentThisScopeFlags() & 64) > 0;
  }
  get inClassAndNotInNonArrowFunction() {
    const t = this.currentThisScopeFlags();
    return (t & 64) > 0 && (t & 2) === 0;
  }
  get inStaticBlock() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      const {
        flags: r
      } = this.scopeStack[t];
      if (r & 128)
        return !0;
      if (r & 451)
        return !1;
    }
  }
  get inNonArrowFunction() {
    return (this.currentThisScopeFlags() & 2) > 0;
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }
  createScope(t) {
    return new Ba(t);
  }
  enter(t) {
    this.scopeStack.push(this.createScope(t));
  }
  exit() {
    return this.scopeStack.pop().flags;
  }
  treatFunctionsAsVarInScope(t) {
    return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
  }
  declareName(t, r, i) {
    let s = this.currentScope();
    if (r & 8 || r & 16) {
      this.checkRedeclarationInScope(s, t, r, i);
      let n = s.names.get(t) || 0;
      r & 16 ? n = n | 4 : (s.firstLexicalName || (s.firstLexicalName = t), n = n | 2), s.names.set(t, n), r & 8 && this.maybeExportDefined(s, t);
    } else if (r & 4)
      for (let n = this.scopeStack.length - 1; n >= 0 && (s = this.scopeStack[n], this.checkRedeclarationInScope(s, t, r, i), s.names.set(t, (s.names.get(t) || 0) | 1), this.maybeExportDefined(s, t), !(s.flags & 387)); --n)
        ;
    this.parser.inModule && s.flags & 1 && this.undefinedExports.delete(t);
  }
  maybeExportDefined(t, r) {
    this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(r);
  }
  checkRedeclarationInScope(t, r, i, s) {
    this.isRedeclaredInScope(t, r, i) && this.parser.raise(w.VarRedeclaration, s, {
      identifierName: r
    });
  }
  isRedeclaredInScope(t, r, i) {
    if (!(i & 1)) return !1;
    if (i & 8)
      return t.names.has(r);
    const s = t.names.get(r);
    return i & 16 ? (s & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (s & 1) > 0 : (s & 2) > 0 && !(t.flags & 8 && t.firstLexicalName === r) || !this.treatFunctionsAsVarInScope(t) && (s & 4) > 0;
  }
  checkLocalExport(t) {
    const {
      name: r
    } = t;
    this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, t.loc.start);
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }
  currentVarScopeFlags() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      const {
        flags: r
      } = this.scopeStack[t];
      if (r & 387)
        return r;
    }
  }
  currentThisScopeFlags() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      const {
        flags: r
      } = this.scopeStack[t];
      if (r & 451 && !(r & 4))
        return r;
    }
  }
}
class FL extends Ba {
  constructor(...t) {
    super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
  }
}
class jL extends Fa {
  createScope(t) {
    return new FL(t);
  }
  declareName(t, r, i) {
    const s = this.currentScope();
    if (r & 2048) {
      this.checkRedeclarationInScope(s, t, r, i), this.maybeExportDefined(s, t), s.declareFunctions.add(t);
      return;
    }
    super.declareName(t, r, i);
  }
  isRedeclaredInScope(t, r, i) {
    if (super.isRedeclaredInScope(t, r, i)) return !0;
    if (i & 2048 && !t.declareFunctions.has(r)) {
      const s = t.names.get(r);
      return (s & 4) > 0 || (s & 2) > 0;
    }
    return !1;
  }
  checkLocalExport(t) {
    this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
  }
}
class RL {
  constructor() {
    this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
  }
  hasPlugin(t) {
    if (typeof t == "string")
      return this.plugins.has(t);
    {
      const [r, i] = t;
      if (!this.hasPlugin(r))
        return !1;
      const s = this.plugins.get(r);
      for (const n of Object.keys(i))
        if ((s == null ? void 0 : s[n]) !== i[n])
          return !1;
      return !0;
    }
  }
  getPluginOption(t, r) {
    var i;
    return (i = this.plugins.get(t)) == null ? void 0 : i[r];
  }
}
function ef(e, t) {
  e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
}
function UL(e, t) {
  e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
}
function zr(e, t) {
  e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
}
function Rr(e, t, r) {
  let i = null, s = t.length;
  for (; i === null && s > 0; )
    i = t[--s];
  i === null || i.start > r.start ? zr(e, r.comments) : ef(i, r.comments);
}
class $L extends RL {
  addComment(t) {
    this.filename && (t.loc.filename = this.filename);
    const {
      commentsLen: r
    } = this.state;
    this.comments.length !== r && (this.comments.length = r), this.comments.push(t), this.state.commentsLen++;
  }
  processComment(t) {
    const {
      commentStack: r
    } = this.state, i = r.length;
    if (i === 0) return;
    let s = i - 1;
    const n = r[s];
    n.start === t.end && (n.leadingNode = t, s--);
    const {
      start: a
    } = t;
    for (; s >= 0; s--) {
      const o = r[s], l = o.end;
      if (l > a)
        o.containingNode = t, this.finalizeComment(o), r.splice(s, 1);
      else {
        l === a && (o.trailingNode = t);
        break;
      }
    }
  }
  finalizeComment(t) {
    const {
      comments: r
    } = t;
    if (t.leadingNode !== null || t.trailingNode !== null)
      t.leadingNode !== null && ef(t.leadingNode, r), t.trailingNode !== null && UL(t.trailingNode, r);
    else {
      const {
        containingNode: i,
        start: s
      } = t;
      if (this.input.charCodeAt(s - 1) === 44)
        switch (i.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            Rr(i, i.properties, t);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            Rr(i, i.arguments, t);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            Rr(i, i.params, t);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            Rr(i, i.elements, t);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            Rr(i, i.specifiers, t);
            break;
          default:
            zr(i, r);
        }
      else
        zr(i, r);
    }
  }
  finalizeRemainingComments() {
    const {
      commentStack: t
    } = this.state;
    for (let r = t.length - 1; r >= 0; r--)
      this.finalizeComment(t[r]);
    this.state.commentStack = [];
  }
  resetPreviousNodeTrailingComments(t) {
    const {
      commentStack: r
    } = this.state, {
      length: i
    } = r;
    if (i === 0) return;
    const s = r[i - 1];
    s.leadingNode === t && (s.leadingNode = null);
  }
  resetPreviousIdentifierLeadingComments(t) {
    const {
      commentStack: r
    } = this.state, {
      length: i
    } = r;
    i !== 0 && (r[i - 1].trailingNode === t ? r[i - 1].trailingNode = null : i >= 2 && r[i - 2].trailingNode === t && (r[i - 2].trailingNode = null));
  }
  takeSurroundingComments(t, r, i) {
    const {
      commentStack: s
    } = this.state, n = s.length;
    if (n === 0) return;
    let a = n - 1;
    for (; a >= 0; a--) {
      const o = s[a], l = o.end;
      if (o.start === i)
        o.leadingNode = t;
      else if (l === r)
        o.trailingNode = t;
      else if (l < r)
        break;
    }
  }
}
const tf = /\r\n?|[\n\u2028\u2029]/, Ki = new RegExp(tf.source, "g");
function Gr(e) {
  switch (e) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return !0;
    default:
      return !1;
  }
}
const hn = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Gi = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Kl = new RegExp("(?=(" + Gi.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function VL(e) {
  switch (e) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return !0;
    default:
      return !1;
  }
}
class ja {
  constructor() {
    this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [$e.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
  }
  get strict() {
    return (this.flags & 1) > 0;
  }
  set strict(t) {
    t ? this.flags |= 1 : this.flags &= -2;
  }
  init({
    strictMode: t,
    sourceType: r,
    startLine: i,
    startColumn: s
  }) {
    this.strict = t === !1 ? !1 : t === !0 ? !0 : r === "module", this.curLine = i, this.lineStart = -s, this.startLoc = this.endLoc = new Gt(i, s, 0);
  }
  get maybeInArrowParameters() {
    return (this.flags & 2) > 0;
  }
  set maybeInArrowParameters(t) {
    t ? this.flags |= 2 : this.flags &= -3;
  }
  get inType() {
    return (this.flags & 4) > 0;
  }
  set inType(t) {
    t ? this.flags |= 4 : this.flags &= -5;
  }
  get noAnonFunctionType() {
    return (this.flags & 8) > 0;
  }
  set noAnonFunctionType(t) {
    t ? this.flags |= 8 : this.flags &= -9;
  }
  get hasFlowComment() {
    return (this.flags & 16) > 0;
  }
  set hasFlowComment(t) {
    t ? this.flags |= 16 : this.flags &= -17;
  }
  get isAmbientContext() {
    return (this.flags & 32) > 0;
  }
  set isAmbientContext(t) {
    t ? this.flags |= 32 : this.flags &= -33;
  }
  get inAbstractClass() {
    return (this.flags & 64) > 0;
  }
  set inAbstractClass(t) {
    t ? this.flags |= 64 : this.flags &= -65;
  }
  get inDisallowConditionalTypesContext() {
    return (this.flags & 128) > 0;
  }
  set inDisallowConditionalTypesContext(t) {
    t ? this.flags |= 128 : this.flags &= -129;
  }
  get soloAwait() {
    return (this.flags & 256) > 0;
  }
  set soloAwait(t) {
    t ? this.flags |= 256 : this.flags &= -257;
  }
  get inFSharpPipelineDirectBody() {
    return (this.flags & 512) > 0;
  }
  set inFSharpPipelineDirectBody(t) {
    t ? this.flags |= 512 : this.flags &= -513;
  }
  get canStartJSXElement() {
    return (this.flags & 1024) > 0;
  }
  set canStartJSXElement(t) {
    t ? this.flags |= 1024 : this.flags &= -1025;
  }
  get containsEsc() {
    return (this.flags & 2048) > 0;
  }
  set containsEsc(t) {
    t ? this.flags |= 2048 : this.flags &= -2049;
  }
  curPosition() {
    return new Gt(this.curLine, this.pos - this.lineStart, this.pos);
  }
  clone() {
    const t = new ja();
    return t.flags = this.flags, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc, t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen, t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
  }
}
var KL = function(t) {
  return t >= 48 && t <= 57;
};
const ql = {
  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
}, qi = {
  bin: (e) => e === 48 || e === 49,
  oct: (e) => e >= 48 && e <= 55,
  dec: (e) => e >= 48 && e <= 57,
  hex: (e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102
};
function Wl(e, t, r, i, s, n) {
  const a = r, o = i, l = s;
  let u = "", c = null, f = r;
  const {
    length: p
  } = t;
  for (; ; ) {
    if (r >= p) {
      n.unterminated(a, o, l), u += t.slice(f, r);
      break;
    }
    const h = t.charCodeAt(r);
    if (qL(e, h, t, r)) {
      u += t.slice(f, r);
      break;
    }
    if (h === 92) {
      u += t.slice(f, r);
      const y = WL(t, r, i, s, e === "template", n);
      y.ch === null && !c ? c = {
        pos: r,
        lineStart: i,
        curLine: s
      } : u += y.ch, {
        pos: r,
        lineStart: i,
        curLine: s
      } = y, f = r;
    } else h === 8232 || h === 8233 ? (++r, ++s, i = r) : h === 10 || h === 13 ? e === "template" ? (u += t.slice(f, r) + `
`, ++r, h === 13 && t.charCodeAt(r) === 10 && ++r, ++s, f = i = r) : n.unterminated(a, o, l) : ++r;
  }
  return {
    pos: r,
    str: u,
    firstInvalidLoc: c,
    lineStart: i,
    curLine: s,
    containsInvalid: !!c
  };
}
function qL(e, t, r, i) {
  return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
}
function WL(e, t, r, i, s, n) {
  const a = !s;
  t++;
  const o = (u) => ({
    pos: t,
    ch: u,
    lineStart: r,
    curLine: i
  }), l = e.charCodeAt(t++);
  switch (l) {
    case 110:
      return o(`
`);
    case 114:
      return o("\r");
    case 120: {
      let u;
      return {
        code: u,
        pos: t
      } = Bn(e, t, r, i, 2, !1, a, n), o(u === null ? null : String.fromCharCode(u));
    }
    case 117: {
      let u;
      return {
        code: u,
        pos: t
      } = sf(e, t, r, i, a, n), o(u === null ? null : String.fromCodePoint(u));
    }
    case 116:
      return o("	");
    case 98:
      return o("\b");
    case 118:
      return o("\v");
    case 102:
      return o("\f");
    case 13:
      e.charCodeAt(t) === 10 && ++t;
    case 10:
      r = t, ++i;
    case 8232:
    case 8233:
      return o("");
    case 56:
    case 57:
      if (s)
        return o(null);
      n.strictNumericEscape(t - 1, r, i);
    default:
      if (l >= 48 && l <= 55) {
        const u = t - 1;
        let f = /^[0-7]+/.exec(e.slice(u, t + 2))[0], p = parseInt(f, 8);
        p > 255 && (f = f.slice(0, -1), p = parseInt(f, 8)), t += f.length - 1;
        const h = e.charCodeAt(t);
        if (f !== "0" || h === 56 || h === 57) {
          if (s)
            return o(null);
          n.strictNumericEscape(u, r, i);
        }
        return o(String.fromCharCode(p));
      }
      return o(String.fromCharCode(l));
  }
}
function Bn(e, t, r, i, s, n, a, o) {
  const l = t;
  let u;
  return {
    n: u,
    pos: t
  } = rf(e, t, r, i, 16, s, n, !1, o, !a), u === null && (a ? o.invalidEscapeSequence(l, r, i) : t = l - 1), {
    code: u,
    pos: t
  };
}
function rf(e, t, r, i, s, n, a, o, l, u) {
  const c = t, f = s === 16 ? ql.hex : ql.decBinOct, p = s === 16 ? qi.hex : s === 10 ? qi.dec : s === 8 ? qi.oct : qi.bin;
  let h = !1, y = 0;
  for (let b = 0, A = n ?? 1 / 0; b < A; ++b) {
    const I = e.charCodeAt(t);
    let _;
    if (I === 95 && o !== "bail") {
      const j = e.charCodeAt(t - 1), G = e.charCodeAt(t + 1);
      if (o) {
        if (Number.isNaN(G) || !p(G) || f.has(j) || f.has(G)) {
          if (u) return {
            n: null,
            pos: t
          };
          l.unexpectedNumericSeparator(t, r, i);
        }
      } else {
        if (u) return {
          n: null,
          pos: t
        };
        l.numericSeparatorInEscapeSequence(t, r, i);
      }
      ++t;
      continue;
    }
    if (I >= 97 ? _ = I - 97 + 10 : I >= 65 ? _ = I - 65 + 10 : KL(I) ? _ = I - 48 : _ = 1 / 0, _ >= s) {
      if (_ <= 9 && u)
        return {
          n: null,
          pos: t
        };
      if (_ <= 9 && l.invalidDigit(t, r, i, s))
        _ = 0;
      else if (a)
        _ = 0, h = !0;
      else
        break;
    }
    ++t, y = y * s + _;
  }
  return t === c || n != null && t - c !== n || h ? {
    n: null,
    pos: t
  } : {
    n: y,
    pos: t
  };
}
function sf(e, t, r, i, s, n) {
  const a = e.charCodeAt(t);
  let o;
  if (a === 123) {
    if (++t, {
      code: o,
      pos: t
    } = Bn(e, t, r, i, e.indexOf("}", t) - t, !0, s, n), ++t, o !== null && o > 1114111)
      if (s)
        n.invalidCodePoint(t, r, i);
      else
        return {
          code: null,
          pos: t
        };
  } else
    ({
      code: o,
      pos: t
    } = Bn(e, t, r, i, 4, !1, s, n));
  return {
    code: o,
    pos: t
  };
}
function Ur(e, t, r) {
  return new Gt(r, e - t, e);
}
const JL = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
class Yt {
  constructor(t) {
    this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new rs(t.startLoc, t.endLoc);
  }
}
class XL extends $L {
  constructor(t, r) {
    super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
      invalidDigit: (i, s, n, a) => this.options.errorRecovery ? (this.raise(w.InvalidDigit, Ur(i, s, n), {
        radix: a
      }), !0) : !1,
      numericSeparatorInEscapeSequence: this.errorBuilder(w.NumericSeparatorInEscapeSequence),
      unexpectedNumericSeparator: this.errorBuilder(w.UnexpectedNumericSeparator)
    }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
      invalidEscapeSequence: this.errorBuilder(w.InvalidEscapeSequence),
      invalidCodePoint: this.errorBuilder(w.InvalidCodePoint)
    }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: (i, s, n) => {
        this.recordStrictModeErrors(w.StrictNumericEscape, Ur(i, s, n));
      },
      unterminated: (i, s, n) => {
        throw this.raise(w.UnterminatedString, Ur(i - 1, s, n));
      }
    }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: this.errorBuilder(w.StrictNumericEscape),
      unterminated: (i, s, n) => {
        throw this.raise(w.UnterminatedTemplate, Ur(i, s, n));
      }
    }), this.state = new ja(), this.state.init(t), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
  }
  pushToken(t) {
    this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
  }
  next() {
    this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Yt(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
  }
  eat(t) {
    return this.match(t) ? (this.next(), !0) : !1;
  }
  match(t) {
    return this.state.type === t;
  }
  createLookaheadState(t) {
    return {
      pos: t.pos,
      value: null,
      type: t.type,
      start: t.start,
      end: t.end,
      context: [this.curContext()],
      inType: t.inType,
      startLoc: t.startLoc,
      lastTokEndLoc: t.lastTokEndLoc,
      curLine: t.curLine,
      lineStart: t.lineStart,
      curPosition: t.curPosition
    };
  }
  lookahead() {
    const t = this.state;
    this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
    const r = this.state;
    return this.state = t, r;
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos);
  }
  nextTokenStartSince(t) {
    return hn.lastIndex = t, hn.test(this.input) ? hn.lastIndex : t;
  }
  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart());
  }
  nextTokenInLineStart() {
    return this.nextTokenInLineStartSince(this.state.pos);
  }
  nextTokenInLineStartSince(t) {
    return Gi.lastIndex = t, Gi.test(this.input) ? Gi.lastIndex : t;
  }
  lookaheadInLineCharCode() {
    return this.input.charCodeAt(this.nextTokenInLineStart());
  }
  codePointAtPos(t) {
    let r = this.input.charCodeAt(t);
    if ((r & 64512) === 55296 && ++t < this.input.length) {
      const i = this.input.charCodeAt(t);
      (i & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (i & 1023));
    }
    return r;
  }
  setStrict(t) {
    this.state.strict = t, t && (this.state.strictErrors.forEach(([r, i]) => this.raise(r, i)), this.state.strictErrors.clear());
  }
  curContext() {
    return this.state.context[this.state.context.length - 1];
  }
  nextToken() {
    if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
      this.finishToken(139);
      return;
    }
    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
  }
  skipBlockComment(t) {
    let r;
    this.isLookahead || (r = this.state.curPosition());
    const i = this.state.pos, s = this.input.indexOf(t, i + 2);
    if (s === -1)
      throw this.raise(w.UnterminatedComment, this.state.curPosition());
    for (this.state.pos = s + t.length, Ki.lastIndex = i + 2; Ki.test(this.input) && Ki.lastIndex <= s; )
      ++this.state.curLine, this.state.lineStart = Ki.lastIndex;
    if (this.isLookahead) return;
    const n = {
      type: "CommentBlock",
      value: this.input.slice(i + 2, s),
      start: i,
      end: s + t.length,
      loc: new rs(r, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(n), n;
  }
  skipLineComment(t) {
    const r = this.state.pos;
    let i;
    this.isLookahead || (i = this.state.curPosition());
    let s = this.input.charCodeAt(this.state.pos += t);
    if (this.state.pos < this.length)
      for (; !Gr(s) && ++this.state.pos < this.length; )
        s = this.input.charCodeAt(this.state.pos);
    if (this.isLookahead) return;
    const n = this.state.pos, o = {
      type: "CommentLine",
      value: this.input.slice(r + t, n),
      start: r,
      end: n,
      loc: new rs(i, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(o), o;
  }
  skipSpace() {
    const t = this.state.pos, r = [];
    e: for (; this.state.pos < this.length; ) {
      const i = this.input.charCodeAt(this.state.pos);
      switch (i) {
        case 32:
        case 160:
        case 9:
          ++this.state.pos;
          break;
        case 13:
          this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
          break;
        case 47:
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42: {
              const s = this.skipBlockComment("*/");
              s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
              break;
            }
            case 47: {
              const s = this.skipLineComment(2);
              s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
              break;
            }
            default:
              break e;
          }
          break;
        default:
          if (VL(i))
            ++this.state.pos;
          else if (i === 45 && !this.inModule && this.options.annexB) {
            const s = this.state.pos;
            if (this.input.charCodeAt(s + 1) === 45 && this.input.charCodeAt(s + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
              const n = this.skipLineComment(3);
              n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
            } else
              break e;
          } else if (i === 60 && !this.inModule && this.options.annexB) {
            const s = this.state.pos;
            if (this.input.charCodeAt(s + 1) === 33 && this.input.charCodeAt(s + 2) === 45 && this.input.charCodeAt(s + 3) === 45) {
              const n = this.skipLineComment(4);
              n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
            } else
              break e;
          } else
            break e;
      }
    }
    if (r.length > 0) {
      const i = this.state.pos, s = {
        start: t,
        end: i,
        comments: r,
        leadingNode: null,
        trailingNode: null,
        containingNode: null
      };
      this.state.commentStack.push(s);
    }
  }
  finishToken(t, r) {
    this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
    const i = this.state.type;
    this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(i);
  }
  replaceToken(t) {
    this.state.type = t, this.updateContext();
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter())
      return;
    const t = this.state.pos + 1, r = this.codePointAtPos(t);
    if (r >= 48 && r <= 57)
      throw this.raise(w.UnexpectedDigitAfterHash, this.state.curPosition());
    if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
      if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
        throw this.raise(r === 123 ? w.RecordExpressionHashIncorrectStartSyntaxType : w.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
      this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
    } else Rt(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
  }
  readToken_dot() {
    const t = this.input.charCodeAt(this.state.pos + 1);
    if (t >= 48 && t <= 57) {
      this.readNumber(!0);
      return;
    }
    t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
  }
  readToken_slash() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2) return !1;
    let t = this.input.charCodeAt(this.state.pos + 1);
    if (t !== 33) return !1;
    const r = this.state.pos;
    for (this.state.pos += 1; !Gr(t) && ++this.state.pos < this.length; )
      t = this.input.charCodeAt(this.state.pos);
    const i = this.input.slice(r + 2, this.state.pos);
    return this.finishToken(28, i), !0;
  }
  readToken_mult_modulo(t) {
    let r = t === 42 ? 55 : 54, i = 1, s = this.input.charCodeAt(this.state.pos + 1);
    t === 42 && s === 42 && (i++, s = this.input.charCodeAt(this.state.pos + 2), r = 57), s === 61 && !this.state.inType && (i++, r = t === 37 ? 33 : 30), this.finishOp(r, i);
  }
  readToken_pipe_amp(t) {
    const r = this.input.charCodeAt(this.state.pos + 1);
    if (r === t) {
      this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
      return;
    }
    if (t === 124) {
      if (r === 62) {
        this.finishOp(39, 2);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && r === 125) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(w.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
        this.state.pos += 2, this.finishToken(9);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && r === 93) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(w.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
        this.state.pos += 2, this.finishToken(4);
        return;
      }
    }
    if (r === 61) {
      this.finishOp(30, 2);
      return;
    }
    this.finishOp(t === 124 ? 43 : 45, 1);
  }
  readToken_caret() {
    const t = this.input.charCodeAt(this.state.pos + 1);
    t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "^^"
    }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
  }
  readToken_atSign() {
    this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "@@"
    }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
  }
  readToken_plus_min(t) {
    const r = this.input.charCodeAt(this.state.pos + 1);
    if (r === t) {
      this.finishOp(34, 2);
      return;
    }
    r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
  }
  readToken_lt() {
    const {
      pos: t
    } = this.state, r = this.input.charCodeAt(t + 1);
    if (r === 60) {
      if (this.input.charCodeAt(t + 2) === 61) {
        this.finishOp(30, 3);
        return;
      }
      this.finishOp(51, 2);
      return;
    }
    if (r === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(47, 1);
  }
  readToken_gt() {
    const {
      pos: t
    } = this.state, r = this.input.charCodeAt(t + 1);
    if (r === 62) {
      const i = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(t + i) === 61) {
        this.finishOp(30, i + 1);
        return;
      }
      this.finishOp(52, i);
      return;
    }
    if (r === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(48, 1);
  }
  readToken_eq_excl(t) {
    const r = this.input.charCodeAt(this.state.pos + 1);
    if (r === 61) {
      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
      return;
    }
    if (t === 61 && r === 62) {
      this.state.pos += 2, this.finishToken(19);
      return;
    }
    this.finishOp(t === 61 ? 29 : 35, 1);
  }
  readToken_question() {
    const t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
    t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
  }
  getTokenFromCode(t) {
    switch (t) {
      case 46:
        this.readToken_dot();
        return;
      case 40:
        ++this.state.pos, this.finishToken(10);
        return;
      case 41:
        ++this.state.pos, this.finishToken(11);
        return;
      case 59:
        ++this.state.pos, this.finishToken(13);
        return;
      case 44:
        ++this.state.pos, this.finishToken(12);
        return;
      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(w.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(2);
        } else
          ++this.state.pos, this.finishToken(0);
        return;
      case 93:
        ++this.state.pos, this.finishToken(3);
        return;
      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(w.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(6);
        } else
          ++this.state.pos, this.finishToken(5);
        return;
      case 125:
        ++this.state.pos, this.finishToken(8);
        return;
      case 58:
        this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
        return;
      case 63:
        this.readToken_question();
        return;
      case 96:
        this.readTemplateToken();
        return;
      case 48: {
        const r = this.input.charCodeAt(this.state.pos + 1);
        if (r === 120 || r === 88) {
          this.readRadixNumber(16);
          return;
        }
        if (r === 111 || r === 79) {
          this.readRadixNumber(8);
          return;
        }
        if (r === 98 || r === 66) {
          this.readRadixNumber(2);
          return;
        }
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(!1);
        return;
      case 34:
      case 39:
        this.readString(t);
        return;
      case 47:
        this.readToken_slash();
        return;
      case 37:
      case 42:
        this.readToken_mult_modulo(t);
        return;
      case 124:
      case 38:
        this.readToken_pipe_amp(t);
        return;
      case 94:
        this.readToken_caret();
        return;
      case 43:
      case 45:
        this.readToken_plus_min(t);
        return;
      case 60:
        this.readToken_lt();
        return;
      case 62:
        this.readToken_gt();
        return;
      case 61:
      case 33:
        this.readToken_eq_excl(t);
        return;
      case 126:
        this.finishOp(36, 1);
        return;
      case 64:
        this.readToken_atSign();
        return;
      case 35:
        this.readToken_numberSign();
        return;
      case 92:
        this.readWord();
        return;
      default:
        if (Rt(t)) {
          this.readWord(t);
          return;
        }
    }
    throw this.raise(w.InvalidOrUnexpectedToken, this.state.curPosition(), {
      unexpected: String.fromCodePoint(t)
    });
  }
  finishOp(t, r) {
    const i = this.input.slice(this.state.pos, this.state.pos + r);
    this.state.pos += r, this.finishToken(t, i);
  }
  readRegexp() {
    const t = this.state.startLoc, r = this.state.start + 1;
    let i, s, {
      pos: n
    } = this.state;
    for (; ; ++n) {
      if (n >= this.length)
        throw this.raise(w.UnterminatedRegExp, ht(t, 1));
      const u = this.input.charCodeAt(n);
      if (Gr(u))
        throw this.raise(w.UnterminatedRegExp, ht(t, 1));
      if (i)
        i = !1;
      else {
        if (u === 91)
          s = !0;
        else if (u === 93 && s)
          s = !1;
        else if (u === 47 && !s)
          break;
        i = u === 92;
      }
    }
    const a = this.input.slice(r, n);
    ++n;
    let o = "";
    const l = () => ht(t, n + 2 - r);
    for (; n < this.length; ) {
      const u = this.codePointAtPos(n), c = String.fromCharCode(u);
      if (JL.has(u))
        u === 118 ? o.includes("u") && this.raise(w.IncompatibleRegExpUVFlags, l()) : u === 117 && o.includes("v") && this.raise(w.IncompatibleRegExpUVFlags, l()), o.includes(c) && this.raise(w.DuplicateRegExpFlags, l());
      else if (Sr(u) || u === 92)
        this.raise(w.MalformedRegExpFlags, l());
      else
        break;
      ++n, o += c;
    }
    this.state.pos = n, this.finishToken(137, {
      pattern: a,
      flags: o
    });
  }
  readInt(t, r, i = !1, s = !0) {
    const {
      n,
      pos: a
    } = rf(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, i, s, this.errorHandlers_readInt, !1);
    return this.state.pos = a, n;
  }
  readRadixNumber(t) {
    const r = this.state.curPosition();
    let i = !1;
    this.state.pos += 2;
    const s = this.readInt(t);
    s == null && this.raise(w.InvalidDigit, ht(r, 2), {
      radix: t
    });
    const n = this.input.charCodeAt(this.state.pos);
    if (n === 110)
      ++this.state.pos, i = !0;
    else if (n === 109)
      throw this.raise(w.InvalidDecimal, r);
    if (Rt(this.codePointAtPos(this.state.pos)))
      throw this.raise(w.NumberIdentifier, this.state.curPosition());
    if (i) {
      const a = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(135, a);
      return;
    }
    this.finishToken(134, s);
  }
  readNumber(t) {
    const r = this.state.pos, i = this.state.curPosition();
    let s = !1, n = !1, a = !1, o = !1, l = !1;
    !t && this.readInt(10) === null && this.raise(w.InvalidNumber, this.state.curPosition());
    const u = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
    if (u) {
      const h = this.input.slice(r, this.state.pos);
      if (this.recordStrictModeErrors(w.StrictOctalLiteral, i), !this.state.strict) {
        const y = h.indexOf("_");
        y > 0 && this.raise(w.ZeroDigitNumericSeparator, ht(i, y));
      }
      l = u && !/[89]/.test(h);
    }
    let c = this.input.charCodeAt(this.state.pos);
    if (c === 46 && !l && (++this.state.pos, this.readInt(10), s = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) && !l && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(w.InvalidOrMissingExponent, i), s = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((s || u) && this.raise(w.InvalidBigIntLiteral, i), ++this.state.pos, n = !0), c === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (o || u) && this.raise(w.InvalidDecimal, i), ++this.state.pos, a = !0), Rt(this.codePointAtPos(this.state.pos)))
      throw this.raise(w.NumberIdentifier, this.state.curPosition());
    const f = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
    if (n) {
      this.finishToken(135, f);
      return;
    }
    if (a) {
      this.finishToken(136, f);
      return;
    }
    const p = l ? parseInt(f, 8) : parseFloat(f);
    this.finishToken(134, p);
  }
  readCodePoint(t) {
    const {
      code: r,
      pos: i
    } = sf(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
    return this.state.pos = i, r;
  }
  readString(t) {
    const {
      str: r,
      pos: i,
      curLine: s,
      lineStart: n
    } = Wl(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
    this.state.pos = i + 1, this.state.lineStart = n, this.state.curLine = s, this.finishToken(133, r);
  }
  readTemplateContinuation() {
    this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
  }
  readTemplateToken() {
    const t = this.input[this.state.pos], {
      str: r,
      firstInvalidLoc: i,
      pos: s,
      curLine: n,
      lineStart: a
    } = Wl("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
    this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = n, i && (this.state.firstInvalidTemplateEscapePos = new Gt(i.curLine, i.pos - i.lineStart, i.pos)), this.input.codePointAt(s) === 96 ? this.finishToken(24, i ? null : t + r + "`") : (this.state.pos++, this.finishToken(25, i ? null : t + r + "${"));
  }
  recordStrictModeErrors(t, r) {
    const i = r.index;
    this.state.strict && !this.state.strictErrors.has(i) ? this.raise(t, r) : this.state.strictErrors.set(i, [t, r]);
  }
  readWord1(t) {
    this.state.containsEsc = !1;
    let r = "";
    const i = this.state.pos;
    let s = this.state.pos;
    for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
      const n = this.codePointAtPos(this.state.pos);
      if (Sr(n))
        this.state.pos += n <= 65535 ? 1 : 2;
      else if (n === 92) {
        this.state.containsEsc = !0, r += this.input.slice(s, this.state.pos);
        const a = this.state.curPosition(), o = this.state.pos === i ? Rt : Sr;
        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(w.MissingUnicodeEscape, this.state.curPosition()), s = this.state.pos - 1;
          continue;
        }
        ++this.state.pos;
        const l = this.readCodePoint(!0);
        l !== null && (o(l) || this.raise(w.EscapedCharNotAnIdentifier, a), r += String.fromCodePoint(l)), s = this.state.pos;
      } else
        break;
    }
    return r + this.input.slice(s, this.state.pos);
  }
  readWord(t) {
    const r = this.readWord1(t), i = Ia.get(r);
    i !== void 0 ? this.finishToken(i, zt(i)) : this.finishToken(132, r);
  }
  checkKeywordEscapes() {
    const {
      type: t
    } = this.state;
    Da(t) && this.state.containsEsc && this.raise(w.InvalidEscapedReservedWord, this.state.startLoc, {
      reservedWord: zt(t)
    });
  }
  raise(t, r, i = {}) {
    const s = r instanceof Gt ? r : r.loc.start, n = t(s, i);
    if (!this.options.errorRecovery) throw n;
    return this.isLookahead || this.state.errors.push(n), n;
  }
  raiseOverwrite(t, r, i = {}) {
    const s = r instanceof Gt ? r : r.loc.start, n = s.index, a = this.state.errors;
    for (let o = a.length - 1; o >= 0; o--) {
      const l = a[o];
      if (l.loc.index === n)
        return a[o] = t(s, i);
      if (l.loc.index < n) break;
    }
    return this.raise(t, r, i);
  }
  updateContext(t) {
  }
  unexpected(t, r) {
    throw this.raise(w.UnexpectedToken, t ?? this.state.startLoc, {
      expected: r ? zt(r) : null
    });
  }
  expectPlugin(t, r) {
    if (this.hasPlugin(t))
      return !0;
    throw this.raise(w.MissingPlugin, r ?? this.state.startLoc, {
      missingPlugin: [t]
    });
  }
  expectOnePlugin(t) {
    if (!t.some((r) => this.hasPlugin(r)))
      throw this.raise(w.MissingOneOfPlugins, this.state.startLoc, {
        missingPlugin: t
      });
  }
  errorBuilder(t) {
    return (r, i, s) => {
      this.raise(t, Ur(r, i, s));
    };
  }
}
class YL {
  constructor() {
    this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
  }
}
class HL {
  constructor(t) {
    this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  enter() {
    this.stack.push(new YL());
  }
  exit() {
    const t = this.stack.pop(), r = this.current();
    for (const [i, s] of Array.from(t.undefinedPrivateNames))
      r ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, s) : this.parser.raise(w.InvalidPrivateFieldResolution, s, {
        identifierName: i
      });
  }
  declarePrivateName(t, r, i) {
    const {
      privateNames: s,
      loneAccessors: n,
      undefinedPrivateNames: a
    } = this.current();
    let o = s.has(t);
    if (r & 3) {
      const l = o && n.get(t);
      if (l) {
        const u = l & 4, c = r & 4, f = l & 3, p = r & 3;
        o = f === p || u !== c, o || n.delete(t);
      } else o || n.set(t, r);
    }
    o && this.parser.raise(w.PrivateNameRedeclaration, i, {
      identifierName: t
    }), s.add(t), a.delete(t);
  }
  usePrivateName(t, r) {
    let i;
    for (i of this.stack)
      if (i.privateNames.has(t)) return;
    i ? i.undefinedPrivateNames.set(t, r) : this.parser.raise(w.InvalidPrivateFieldResolution, r, {
      identifierName: t
    });
  }
}
class Ms {
  constructor(t = 0) {
    this.type = t;
  }
  canBeArrowParameterDeclaration() {
    return this.type === 2 || this.type === 1;
  }
  isCertainlyParameterDeclaration() {
    return this.type === 3;
  }
}
class nf extends Ms {
  constructor(t) {
    super(t), this.declarationErrors = /* @__PURE__ */ new Map();
  }
  recordDeclarationError(t, r) {
    const i = r.index;
    this.declarationErrors.set(i, [t, r]);
  }
  clearDeclarationError(t) {
    this.declarationErrors.delete(t);
  }
  iterateErrors(t) {
    this.declarationErrors.forEach(t);
  }
}
class GL {
  constructor(t) {
    this.parser = void 0, this.stack = [new Ms()], this.parser = t;
  }
  enter(t) {
    this.stack.push(t);
  }
  exit() {
    this.stack.pop();
  }
  recordParameterInitializerError(t, r) {
    const i = r.loc.start, {
      stack: s
    } = this;
    let n = s.length - 1, a = s[n];
    for (; !a.isCertainlyParameterDeclaration(); ) {
      if (a.canBeArrowParameterDeclaration())
        a.recordDeclarationError(t, i);
      else
        return;
      a = s[--n];
    }
    this.parser.raise(t, i);
  }
  recordArrowParameterBindingError(t, r) {
    const {
      stack: i
    } = this, s = i[i.length - 1], n = r.loc.start;
    if (s.isCertainlyParameterDeclaration())
      this.parser.raise(t, n);
    else if (s.canBeArrowParameterDeclaration())
      s.recordDeclarationError(t, n);
    else
      return;
  }
  recordAsyncArrowParametersError(t) {
    const {
      stack: r
    } = this;
    let i = r.length - 1, s = r[i];
    for (; s.canBeArrowParameterDeclaration(); )
      s.type === 2 && s.recordDeclarationError(w.AwaitBindingIdentifier, t), s = r[--i];
  }
  validateAsPattern() {
    const {
      stack: t
    } = this, r = t[t.length - 1];
    r.canBeArrowParameterDeclaration() && r.iterateErrors(([i, s]) => {
      this.parser.raise(i, s);
      let n = t.length - 2, a = t[n];
      for (; a.canBeArrowParameterDeclaration(); )
        a.clearDeclarationError(s.index), a = t[--n];
    });
  }
}
function zL() {
  return new Ms(3);
}
function QL() {
  return new nf(1);
}
function ZL() {
  return new nf(2);
}
function af() {
  return new Ms();
}
class eM {
  constructor() {
    this.stacks = [];
  }
  enter(t) {
    this.stacks.push(t);
  }
  exit() {
    this.stacks.pop();
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1];
  }
  get hasAwait() {
    return (this.currentFlags() & 2) > 0;
  }
  get hasYield() {
    return (this.currentFlags() & 1) > 0;
  }
  get hasReturn() {
    return (this.currentFlags() & 4) > 0;
  }
  get hasIn() {
    return (this.currentFlags() & 8) > 0;
  }
}
function zi(e, t) {
  return (e ? 2 : 0) | (t ? 1 : 0);
}
class tM extends XL {
  addExtra(t, r, i, s = !0) {
    if (!t) return;
    const n = t.extra = t.extra || {};
    s ? n[r] = i : Object.defineProperty(n, r, {
      enumerable: s,
      value: i
    });
  }
  isContextual(t) {
    return this.state.type === t && !this.state.containsEsc;
  }
  isUnparsedContextual(t, r) {
    const i = t + r.length;
    if (this.input.slice(t, i) === r) {
      const s = this.input.charCodeAt(i);
      return !(Sr(s) || (s & 64512) === 55296);
    }
    return !1;
  }
  isLookaheadContextual(t) {
    const r = this.nextTokenStart();
    return this.isUnparsedContextual(r, t);
  }
  eatContextual(t) {
    return this.isContextual(t) ? (this.next(), !0) : !1;
  }
  expectContextual(t, r) {
    if (!this.eatContextual(t)) {
      if (r != null)
        throw this.raise(r, this.state.startLoc);
      this.unexpected(null, t);
    }
  }
  canInsertSemicolon() {
    return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
  }
  hasPrecedingLineBreak() {
    return tf.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
  }
  hasFollowingLineBreak() {
    return Kl.lastIndex = this.state.end, Kl.test(this.input);
  }
  isLineTerminator() {
    return this.eat(13) || this.canInsertSemicolon();
  }
  semicolon(t = !0) {
    (t ? this.isLineTerminator() : this.eat(13)) || this.raise(w.MissingSemicolon, this.state.lastTokEndLoc);
  }
  expect(t, r) {
    this.eat(t) || this.unexpected(r, t);
  }
  tryParse(t, r = this.state.clone()) {
    const i = {
      node: null
    };
    try {
      const s = t((n = null) => {
        throw i.node = n, i;
      });
      if (this.state.errors.length > r.errors.length) {
        const n = this.state;
        return this.state = r, this.state.tokensLength = n.tokensLength, {
          node: s,
          error: n.errors[r.errors.length],
          thrown: !1,
          aborted: !1,
          failState: n
        };
      }
      return {
        node: s,
        error: null,
        thrown: !1,
        aborted: !1,
        failState: null
      };
    } catch (s) {
      const n = this.state;
      if (this.state = r, s instanceof SyntaxError)
        return {
          node: null,
          error: s,
          thrown: !0,
          aborted: !1,
          failState: n
        };
      if (s === i)
        return {
          node: i.node,
          error: null,
          thrown: !1,
          aborted: !0,
          failState: n
        };
      throw s;
    }
  }
  checkExpressionErrors(t, r) {
    if (!t) return !1;
    const {
      shorthandAssignLoc: i,
      doubleProtoLoc: s,
      privateKeyLoc: n,
      optionalParametersLoc: a
    } = t, o = !!i || !!s || !!a || !!n;
    if (!r)
      return o;
    i != null && this.raise(w.InvalidCoverInitializedName, i), s != null && this.raise(w.DuplicateProto, s), n != null && this.raise(w.UnexpectedPrivateField, n), a != null && this.unexpected(a);
  }
  isLiteralPropertyName() {
    return Xc(this.state.type);
  }
  isPrivateName(t) {
    return t.type === "PrivateName";
  }
  getPrivateNameSV(t) {
    return t.id.name;
  }
  hasPropertyAsPrivateName(t) {
    return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
  }
  isObjectProperty(t) {
    return t.type === "ObjectProperty";
  }
  isObjectMethod(t) {
    return t.type === "ObjectMethod";
  }
  initializeScopes(t = this.options.sourceType === "module") {
    const r = this.state.labels;
    this.state.labels = [];
    const i = this.exportedIdentifiers;
    this.exportedIdentifiers = /* @__PURE__ */ new Set();
    const s = this.inModule;
    this.inModule = t;
    const n = this.scope, a = this.getScopeHandler();
    this.scope = new a(this, t);
    const o = this.prodParam;
    this.prodParam = new eM();
    const l = this.classScope;
    this.classScope = new HL(this);
    const u = this.expressionScope;
    return this.expressionScope = new GL(this), () => {
      this.state.labels = r, this.exportedIdentifiers = i, this.inModule = s, this.scope = n, this.prodParam = o, this.classScope = l, this.expressionScope = u;
    };
  }
  enterInitialScopes() {
    let t = 0;
    this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);
  }
  checkDestructuringPrivate(t) {
    const {
      privateKeyLoc: r
    } = t;
    r !== null && this.expectPlugin("destructuringPrivate", r);
  }
}
class Qi {
  constructor() {
    this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
  }
}
class ss {
  constructor(t, r, i) {
    this.type = "", this.start = r, this.end = 0, this.loc = new rs(i), t != null && t.options.ranges && (this.range = [r, 0]), t != null && t.filename && (this.loc.filename = t.filename);
  }
}
const Ra = ss.prototype;
Ra.__clone = function() {
  const e = new ss(void 0, this.start, this.loc.start), t = Object.keys(this);
  for (let r = 0, i = t.length; r < i; r++) {
    const s = t[r];
    s !== "leadingComments" && s !== "trailingComments" && s !== "innerComments" && (e[s] = this[s]);
  }
  return e;
};
function rM(e) {
  return $t(e);
}
function $t(e) {
  const {
    type: t,
    start: r,
    end: i,
    loc: s,
    range: n,
    extra: a,
    name: o
  } = e, l = Object.create(Ra);
  return l.type = t, l.start = r, l.end = i, l.loc = s, l.range = n, l.extra = a, l.name = o, t === "Placeholder" && (l.expectedNode = e.expectedNode), l;
}
function iM(e) {
  const {
    type: t,
    start: r,
    end: i,
    loc: s,
    range: n,
    extra: a
  } = e;
  if (t === "Placeholder")
    return rM(e);
  const o = Object.create(Ra);
  return o.type = t, o.start = r, o.end = i, o.loc = s, o.range = n, e.raw !== void 0 ? o.raw = e.raw : o.extra = a, o.value = e.value, o;
}
class sM extends tM {
  startNode() {
    const t = this.state.startLoc;
    return new ss(this, t.index, t);
  }
  startNodeAt(t) {
    return new ss(this, t.index, t);
  }
  startNodeAtNode(t) {
    return this.startNodeAt(t.loc.start);
  }
  finishNode(t, r) {
    return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
  }
  finishNodeAt(t, r, i) {
    return t.type = r, t.end = i.index, t.loc.end = i, this.options.ranges && (t.range[1] = i.index), this.options.attachComment && this.processComment(t), t;
  }
  resetStartLocation(t, r) {
    t.start = r.index, t.loc.start = r, this.options.ranges && (t.range[0] = r.index);
  }
  resetEndLocation(t, r = this.state.lastTokEndLoc) {
    t.end = r.index, t.loc.end = r, this.options.ranges && (t.range[1] = r.index);
  }
  resetStartLocationFromNode(t, r) {
    this.resetStartLocation(t, r.loc.start);
  }
}
const nM = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), me = Ut`flow`({
  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
  AssignReservedType: ({
    reservedType: e
  }) => `Cannot overwrite reserved type ${e}.`,
  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
  EnumBooleanMemberNotInitialized: ({
    memberName: e,
    enumName: t
  }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`,
  EnumDuplicateMemberName: ({
    memberName: e,
    enumName: t
  }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`,
  EnumInconsistentMemberValues: ({
    enumName: e
  }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
  EnumInvalidExplicitType: ({
    invalidEnumType: e,
    enumName: t
  }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`,
  EnumInvalidExplicitTypeUnknownSupplied: ({
    enumName: e
  }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`,
  EnumInvalidMemberInitializerPrimaryType: ({
    enumName: e,
    memberName: t,
    explicitType: r
  }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`,
  EnumInvalidMemberInitializerSymbolType: ({
    enumName: e,
    memberName: t
  }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`,
  EnumInvalidMemberInitializerUnknownType: ({
    enumName: e,
    memberName: t
  }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`,
  EnumInvalidMemberName: ({
    enumName: e,
    memberName: t,
    suggestion: r
  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`,
  EnumNumberMemberNotInitialized: ({
    enumName: e,
    memberName: t
  }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`,
  EnumStringMemberInconsistentlyInitialized: ({
    enumName: e
  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`,
  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
  InexactVariance: "Explicit inexact syntax cannot have variance.",
  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
  PatternIsOptional: Object.assign({
    message: "A binding pattern parameter cannot be optional in an implementation signature."
  }, {
    reasonCode: "OptionalBindingPattern"
  }),
  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
  SpreadVariance: "Spread properties cannot have variance.",
  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
  ThisParamNoDefault: "The `this` parameter may not have a default value.",
  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
  UnexpectedReservedType: ({
    reservedType: e
  }) => `Unexpected reserved type ${e}.`,
  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
  UnsupportedDeclareExportKind: ({
    unsupportedExportKind: e,
    suggestion: t
  }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`,
  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
  UnterminatedFlowComment: "Unterminated flow-comment."
});
function aM(e) {
  return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "TypeAlias" && e.declaration.type !== "InterfaceDeclaration");
}
function Jl(e) {
  return e.importKind === "type" || e.importKind === "typeof";
}
const oM = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface"
};
function lM(e, t) {
  const r = [], i = [];
  for (let s = 0; s < e.length; s++)
    (t(e[s], s, e) ? r : i).push(e[s]);
  return [r, i];
}
const uM = /\*?\s*@((?:no)?flow)\b/;
var cM = (e) => class extends e {
  constructor(...r) {
    super(...r), this.flowPragma = void 0;
  }
  getScopeHandler() {
    return jL;
  }
  shouldParseTypes() {
    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
  }
  shouldParseEnums() {
    return !!this.getPluginOption("flow", "enums");
  }
  finishToken(r, i) {
    r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, i);
  }
  addComment(r) {
    if (this.flowPragma === void 0) {
      const i = uM.exec(r.value);
      if (i) if (i[1] === "flow")
        this.flowPragma = "flow";
      else if (i[1] === "noflow")
        this.flowPragma = "noflow";
      else
        throw new Error("Unexpected flow pragma");
    }
    super.addComment(r);
  }
  flowParseTypeInitialiser(r) {
    const i = this.state.inType;
    this.state.inType = !0, this.expect(r || 14);
    const s = this.flowParseType();
    return this.state.inType = i, s;
  }
  flowParsePredicate() {
    const r = this.startNode(), i = this.state.startLoc;
    return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > i.index + 1 && this.raise(me.UnexpectedSpaceBetweenModuloChecks, i), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "InferredPredicate");
  }
  flowParseTypeAndPredicateInitialiser() {
    const r = this.state.inType;
    this.state.inType = !0, this.expect(14);
    let i = null, s = null;
    return this.match(54) ? (this.state.inType = r, s = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = r, this.match(54) && (s = this.flowParsePredicate())), [i, s];
  }
  flowParseDeclareClass(r) {
    return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
  }
  flowParseDeclareFunction(r) {
    this.next();
    const i = r.id = this.parseIdentifier(), s = this.startNode(), n = this.startNode();
    this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, this.expect(10);
    const a = this.flowParseFunctionTypeParams();
    return s.params = a.params, s.rest = a.rest, s.this = a._this, this.expect(11), [s.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), n.typeAnnotation = this.finishNode(s, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(n, "TypeAnnotation"), this.resetEndLocation(i), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
  }
  flowParseDeclare(r, i) {
    if (this.match(80))
      return this.flowParseDeclareClass(r);
    if (this.match(68))
      return this.flowParseDeclareFunction(r);
    if (this.match(74))
      return this.flowParseDeclareVariable(r);
    if (this.eatContextual(127))
      return this.match(16) ? this.flowParseDeclareModuleExports(r) : (i && this.raise(me.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(r));
    if (this.isContextual(130))
      return this.flowParseDeclareTypeAlias(r);
    if (this.isContextual(131))
      return this.flowParseDeclareOpaqueType(r);
    if (this.isContextual(129))
      return this.flowParseDeclareInterface(r);
    if (this.match(82))
      return this.flowParseDeclareExportDeclaration(r, i);
    this.unexpected();
  }
  flowParseDeclareVariable(r) {
    return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(), this.finishNode(r, "DeclareVariable");
  }
  flowParseDeclareModule(r) {
    this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
    const i = r.body = this.startNode(), s = i.body = [];
    for (this.expect(5); !this.match(8); ) {
      let o = this.startNode();
      this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(me.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(o)) : (this.expectContextual(125, me.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, !0)), s.push(o);
    }
    this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
    let n = null, a = !1;
    return s.forEach((o) => {
      aM(o) ? (n === "CommonJS" && this.raise(me.AmbiguousDeclareModuleKind, o), n = "ES") : o.type === "DeclareModuleExports" && (a && this.raise(me.DuplicateDeclareModuleExports, o), n === "ES" && this.raise(me.AmbiguousDeclareModuleKind, o), n = "CommonJS", a = !0);
    }), r.kind = n || "CommonJS", this.finishNode(r, "DeclareModule");
  }
  flowParseDeclareExportDeclaration(r, i) {
    if (this.expect(82), this.eat(65))
      return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(), this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
    if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
      const s = this.state.value;
      throw this.raise(me.UnsupportedDeclareExportKind, this.state.startLoc, {
        unsupportedExportKind: s,
        suggestion: oM[s]
      });
    }
    if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
      return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
    if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
      return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.exportKind), r.type = "Declare" + r.type, r;
    this.unexpected();
  }
  flowParseDeclareModuleExports(r) {
    return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r, "DeclareModuleExports");
  }
  flowParseDeclareTypeAlias(r) {
    this.next();
    const i = this.flowParseTypeAlias(r);
    return i.type = "DeclareTypeAlias", i;
  }
  flowParseDeclareOpaqueType(r) {
    this.next();
    const i = this.flowParseOpaqueType(r, !0);
    return i.type = "DeclareOpaqueType", i;
  }
  flowParseDeclareInterface(r) {
    return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
  }
  flowParseInterfaceish(r, i) {
    if (r.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(r.id.name, i ? 17 : 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
      do
        r.extends.push(this.flowParseInterfaceExtends());
      while (!i && this.eat(12));
    if (i) {
      if (r.implements = [], r.mixins = [], this.eatContextual(117))
        do
          r.mixins.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      if (this.eatContextual(113))
        do
          r.implements.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
    }
    r.body = this.flowParseObjectType({
      allowStatic: i,
      allowExact: !1,
      allowSpread: !1,
      allowProto: i,
      allowInexact: !1
    });
  }
  flowParseInterfaceExtends() {
    const r = this.startNode();
    return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
  }
  flowParseInterface(r) {
    return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
  }
  checkNotUnderscore(r) {
    r === "_" && this.raise(me.UnexpectedReservedUnderscore, this.state.startLoc);
  }
  checkReservedType(r, i, s) {
    nM.has(r) && this.raise(s ? me.AssignReservedType : me.UnexpectedReservedType, i, {
      reservedType: r
    });
  }
  flowParseRestrictedIdentifier(r, i) {
    return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(r);
  }
  flowParseTypeAlias(r) {
    return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(r, "TypeAlias");
  }
  flowParseOpaqueType(r, i) {
    return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, i || (r.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(r, "OpaqueType");
  }
  flowParseTypeParameter(r = !1) {
    const i = this.state.startLoc, s = this.startNode(), n = this.flowParseVariance(), a = this.flowParseTypeAnnotatableIdentifier();
    return s.name = a.name, s.variance = n, s.bound = a.typeAnnotation, this.match(29) ? (this.eat(29), s.default = this.flowParseType()) : r && this.raise(me.MissingTypeParamDefault, i), this.finishNode(s, "TypeParameter");
  }
  flowParseTypeParameterDeclaration() {
    const r = this.state.inType, i = this.startNode();
    i.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
    let s = !1;
    do {
      const n = this.flowParseTypeParameter(s);
      i.params.push(n), n.default && (s = !0), this.match(48) || this.expect(12);
    } while (!this.match(48));
    return this.expect(48), this.state.inType = r, this.finishNode(i, "TypeParameterDeclaration");
  }
  flowParseTypeParameterInstantiation() {
    const r = this.startNode(), i = this.state.inType;
    r.params = [], this.state.inType = !0, this.expect(47);
    const s = this.state.noAnonFunctionType;
    for (this.state.noAnonFunctionType = !1; !this.match(48); )
      r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
    return this.state.noAnonFunctionType = s, this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
  }
  flowParseTypeParameterInstantiationCallOrNew() {
    const r = this.startNode(), i = this.state.inType;
    for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
      r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
    return this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
  }
  flowParseInterfaceType() {
    const r = this.startNode();
    if (this.expectContextual(129), r.extends = [], this.eat(81))
      do
        r.extends.push(this.flowParseInterfaceExtends());
      while (this.eat(12));
    return r.body = this.flowParseObjectType({
      allowStatic: !1,
      allowExact: !1,
      allowSpread: !1,
      allowProto: !1,
      allowInexact: !1
    }), this.finishNode(r, "InterfaceTypeAnnotation");
  }
  flowParseObjectPropertyKey() {
    return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
  }
  flowParseObjectTypeIndexer(r, i, s) {
    return r.static = i, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) : (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = s, this.finishNode(r, "ObjectTypeIndexer");
  }
  flowParseObjectTypeInternalSlot(r, i) {
    return r.static = i, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method = !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
  }
  flowParseObjectTypeMethodish(r) {
    for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
      r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
    return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(), this.finishNode(r, "FunctionTypeAnnotation");
  }
  flowParseObjectTypeCallProperty(r, i) {
    const s = this.startNode();
    return r.static = i, r.value = this.flowParseObjectTypeMethodish(s), this.finishNode(r, "ObjectTypeCallProperty");
  }
  flowParseObjectType({
    allowStatic: r,
    allowExact: i,
    allowSpread: s,
    allowProto: n,
    allowInexact: a
  }) {
    const o = this.state.inType;
    this.state.inType = !0;
    const l = this.startNode();
    l.callProperties = [], l.properties = [], l.indexers = [], l.internalSlots = [];
    let u, c, f = !1;
    for (i && this.match(6) ? (this.expect(6), u = 9, c = !0) : (this.expect(5), u = 8, c = !1), l.exact = c; !this.match(u); ) {
      let h = !1, y = null, b = null;
      const A = this.startNode();
      if (n && this.isContextual(118)) {
        const _ = this.lookahead();
        _.type !== 14 && _.type !== 17 && (this.next(), y = this.state.startLoc, r = !1);
      }
      if (r && this.isContextual(106)) {
        const _ = this.lookahead();
        _.type !== 14 && _.type !== 17 && (this.next(), h = !0);
      }
      const I = this.flowParseVariance();
      if (this.eat(0))
        y != null && this.unexpected(y), this.eat(0) ? (I && this.unexpected(I.loc.start), l.internalSlots.push(this.flowParseObjectTypeInternalSlot(A, h))) : l.indexers.push(this.flowParseObjectTypeIndexer(A, h, I));
      else if (this.match(10) || this.match(47))
        y != null && this.unexpected(y), I && this.unexpected(I.loc.start), l.callProperties.push(this.flowParseObjectTypeCallProperty(A, h));
      else {
        let _ = "init";
        if (this.isContextual(99) || this.isContextual(104)) {
          const G = this.lookahead();
          Xc(G.type) && (_ = this.state.value, this.next());
        }
        const j = this.flowParseObjectTypeProperty(A, h, y, I, _, s, a ?? !c);
        j === null ? (f = !0, b = this.state.lastTokStartLoc) : l.properties.push(j);
      }
      this.flowObjectTypeSemicolon(), b && !this.match(8) && !this.match(9) && this.raise(me.UnexpectedExplicitInexactInObject, b);
    }
    this.expect(u), s && (l.inexact = f);
    const p = this.finishNode(l, "ObjectTypeAnnotation");
    return this.state.inType = o, p;
  }
  flowParseObjectTypeProperty(r, i, s, n, a, o, l) {
    if (this.eat(21))
      return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? l || this.raise(me.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(me.InexactInsideNonObject, this.state.lastTokStartLoc), n && this.raise(me.InexactVariance, n), null) : (o || this.raise(me.UnexpectedSpreadType, this.state.lastTokStartLoc), s != null && this.unexpected(s), n && this.raise(me.SpreadVariance, n), r.argument = this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
    {
      r.key = this.flowParseObjectPropertyKey(), r.static = i, r.proto = s != null, r.kind = a;
      let u = !1;
      return this.match(47) || this.match(10) ? (r.method = !0, s != null && this.unexpected(s), n && this.unexpected(n.loc.start), r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (a === "get" || a === "set") && this.flowCheckGetterSetterParams(r), !o && r.key.name === "constructor" && r.value.this && this.raise(me.ThisParamBannedInConstructor, r.value.this)) : (a !== "init" && this.unexpected(), r.method = !1, this.eat(17) && (u = !0), r.value = this.flowParseTypeInitialiser(), r.variance = n), r.optional = u, this.finishNode(r, "ObjectTypeProperty");
    }
  }
  flowCheckGetterSetterParams(r) {
    const i = r.kind === "get" ? 0 : 1, s = r.value.params.length + (r.value.rest ? 1 : 0);
    r.value.this && this.raise(r.kind === "get" ? me.GetterMayNotHaveThisParam : me.SetterMayNotHaveThisParam, r.value.this), s !== i && this.raise(r.kind === "get" ? w.BadGetterArity : w.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(w.BadSetterRestParameter, r);
  }
  flowObjectTypeSemicolon() {
    !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
  }
  flowParseQualifiedTypeIdentifier(r, i) {
    var s;
    (s = r) != null || (r = this.state.startLoc);
    let n = i || this.flowParseRestrictedIdentifier(!0);
    for (; this.eat(16); ) {
      const a = this.startNodeAt(r);
      a.qualification = n, a.id = this.flowParseRestrictedIdentifier(!0), n = this.finishNode(a, "QualifiedTypeIdentifier");
    }
    return n;
  }
  flowParseGenericType(r, i) {
    const s = this.startNodeAt(r);
    return s.typeParameters = null, s.id = this.flowParseQualifiedTypeIdentifier(r, i), this.match(47) && (s.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(s, "GenericTypeAnnotation");
  }
  flowParseTypeofType() {
    const r = this.startNode();
    return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
  }
  flowParseTupleType() {
    const r = this.startNode();
    for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(3)); )
      this.expect(12);
    return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
  }
  flowParseFunctionTypeParam(r) {
    let i = null, s = !1, n = null;
    const a = this.startNode(), o = this.lookahead(), l = this.state.type === 78;
    return o.type === 14 || o.type === 17 ? (l && !r && this.raise(me.ThisParamMustBeFirst, a), i = this.parseIdentifier(l), this.eat(17) && (s = !0, l && this.raise(me.ThisParamMayNotBeOptional, a)), n = this.flowParseTypeInitialiser()) : n = this.flowParseType(), a.name = i, a.optional = s, a.typeAnnotation = n, this.finishNode(a, "FunctionTypeParam");
  }
  reinterpretTypeAsFunctionTypeParam(r) {
    const i = this.startNodeAt(r.loc.start);
    return i.name = null, i.optional = !1, i.typeAnnotation = r, this.finishNode(i, "FunctionTypeParam");
  }
  flowParseFunctionTypeParams(r = []) {
    let i = null, s = null;
    for (this.match(78) && (s = this.flowParseFunctionTypeParam(!0), s.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
      r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
    return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
      params: r,
      rest: i,
      _this: s
    };
  }
  flowIdentToTypeAnnotation(r, i, s) {
    switch (s.name) {
      case "any":
        return this.finishNode(i, "AnyTypeAnnotation");
      case "bool":
      case "boolean":
        return this.finishNode(i, "BooleanTypeAnnotation");
      case "mixed":
        return this.finishNode(i, "MixedTypeAnnotation");
      case "empty":
        return this.finishNode(i, "EmptyTypeAnnotation");
      case "number":
        return this.finishNode(i, "NumberTypeAnnotation");
      case "string":
        return this.finishNode(i, "StringTypeAnnotation");
      case "symbol":
        return this.finishNode(i, "SymbolTypeAnnotation");
      default:
        return this.checkNotUnderscore(s.name), this.flowParseGenericType(r, s);
    }
  }
  flowParsePrimaryType() {
    const r = this.state.startLoc, i = this.startNode();
    let s, n, a = !1;
    const o = this.state.noAnonFunctionType;
    switch (this.state.type) {
      case 5:
        return this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !1,
          allowSpread: !0,
          allowProto: !1,
          allowInexact: !0
        });
      case 6:
        return this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !0,
          allowSpread: !0,
          allowProto: !1,
          allowInexact: !1
        });
      case 0:
        return this.state.noAnonFunctionType = !1, n = this.flowParseTupleType(), this.state.noAnonFunctionType = o, n;
      case 47: {
        const l = this.startNode();
        return l.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), s = this.flowParseFunctionTypeParams(), l.params = s.params, l.rest = s.rest, l.this = s._this, this.expect(11), this.expect(19), l.returnType = this.flowParseType(), this.finishNode(l, "FunctionTypeAnnotation");
      }
      case 10: {
        const l = this.startNode();
        if (this.next(), !this.match(11) && !this.match(21))
          if (Le(this.state.type) || this.match(78)) {
            const u = this.lookahead().type;
            a = u !== 17 && u !== 14;
          } else
            a = !0;
        if (a) {
          if (this.state.noAnonFunctionType = !1, n = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
            return this.expect(11), n;
          this.eat(12);
        }
        return n ? s = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(n)]) : s = this.flowParseFunctionTypeParams(), l.params = s.params, l.rest = s.rest, l.this = s._this, this.expect(11), this.expect(19), l.returnType = this.flowParseType(), l.typeParameters = null, this.finishNode(l, "FunctionTypeAnnotation");
      }
      case 133:
        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
      case 85:
      case 86:
        return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
      case 53:
        if (this.state.value === "-") {
          if (this.next(), this.match(134))
            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
          if (this.match(135))
            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
          throw this.raise(me.UnexpectedSubtractionOperand, this.state.startLoc);
        }
        this.unexpected();
        return;
      case 134:
        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
      case 135:
        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
      case 88:
        return this.next(), this.finishNode(i, "VoidTypeAnnotation");
      case 84:
        return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
      case 78:
        return this.next(), this.finishNode(i, "ThisTypeAnnotation");
      case 55:
        return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
      case 87:
        return this.flowParseTypeofType();
      default:
        if (Da(this.state.type)) {
          const l = zt(this.state.type);
          return this.next(), super.createIdentifier(i, l);
        } else if (Le(this.state.type))
          return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, i, this.parseIdentifier());
    }
    this.unexpected();
  }
  flowParsePostfixType() {
    const r = this.state.startLoc;
    let i = this.flowParsePrimaryType(), s = !1;
    for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
      const n = this.startNodeAt(r), a = this.eat(18);
      s = s || a, this.expect(0), !a && this.match(3) ? (n.elementType = i, this.next(), i = this.finishNode(n, "ArrayTypeAnnotation")) : (n.objectType = i, n.indexType = this.flowParseType(), this.expect(3), s ? (n.optional = a, i = this.finishNode(n, "OptionalIndexedAccessType")) : i = this.finishNode(n, "IndexedAccessType"));
    }
    return i;
  }
  flowParsePrefixType() {
    const r = this.startNode();
    return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
  }
  flowParseAnonFunctionWithoutParens() {
    const r = this.flowParsePrefixType();
    if (!this.state.noAnonFunctionType && this.eat(19)) {
      const i = this.startNodeAt(r.loc.start);
      return i.params = [this.reinterpretTypeAsFunctionTypeParam(r)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
    }
    return r;
  }
  flowParseIntersectionType() {
    const r = this.startNode();
    this.eat(45);
    const i = this.flowParseAnonFunctionWithoutParens();
    for (r.types = [i]; this.eat(45); )
      r.types.push(this.flowParseAnonFunctionWithoutParens());
    return r.types.length === 1 ? i : this.finishNode(r, "IntersectionTypeAnnotation");
  }
  flowParseUnionType() {
    const r = this.startNode();
    this.eat(43);
    const i = this.flowParseIntersectionType();
    for (r.types = [i]; this.eat(43); )
      r.types.push(this.flowParseIntersectionType());
    return r.types.length === 1 ? i : this.finishNode(r, "UnionTypeAnnotation");
  }
  flowParseType() {
    const r = this.state.inType;
    this.state.inType = !0;
    const i = this.flowParseUnionType();
    return this.state.inType = r, i;
  }
  flowParseTypeOrImplicitInstantiation() {
    if (this.state.type === 132 && this.state.value === "_") {
      const r = this.state.startLoc, i = this.parseIdentifier();
      return this.flowParseGenericType(r, i);
    } else
      return this.flowParseType();
  }
  flowParseTypeAnnotation() {
    const r = this.startNode();
    return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
  }
  flowParseTypeAnnotatableIdentifier(r) {
    const i = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
    return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
  }
  typeCastToParameter(r) {
    return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
  }
  flowParseVariance() {
    let r = null;
    return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(r, "Variance")) : r;
  }
  parseFunctionBody(r, i, s = !1) {
    if (i) {
      this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, s));
      return;
    }
    super.parseFunctionBody(r, !1, s);
  }
  parseFunctionBodyAndFinish(r, i, s = !1) {
    if (this.match(14)) {
      const n = this.startNode();
      [n.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = n.typeAnnotation ? this.finishNode(n, "TypeAnnotation") : null;
    }
    return super.parseFunctionBodyAndFinish(r, i, s);
  }
  parseStatementLike(r) {
    if (this.state.strict && this.isContextual(129)) {
      const s = this.lookahead();
      if (At(s.type)) {
        const n = this.startNode();
        return this.next(), this.flowParseInterface(n);
      }
    } else if (this.shouldParseEnums() && this.isContextual(126)) {
      const s = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(s);
    }
    const i = super.parseStatementLike(r);
    return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
  }
  parseExpressionStatement(r, i, s) {
    if (i.type === "Identifier") {
      if (i.name === "declare") {
        if (this.match(80) || Le(this.state.type) || this.match(68) || this.match(74) || this.match(82))
          return this.flowParseDeclare(r);
      } else if (Le(this.state.type)) {
        if (i.name === "interface")
          return this.flowParseInterface(r);
        if (i.name === "type")
          return this.flowParseTypeAlias(r);
        if (i.name === "opaque")
          return this.flowParseOpaqueType(r, !1);
      }
    }
    return super.parseExpressionStatement(r, i, s);
  }
  shouldParseExportDeclaration() {
    const {
      type: r
    } = this.state;
    return Vl(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
  }
  isExportDefaultSpecifier() {
    const {
      type: r
    } = this.state;
    return Vl(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
  }
  parseExportDefaultExpression() {
    if (this.shouldParseEnums() && this.isContextual(126)) {
      const r = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(r);
    }
    return super.parseExportDefaultExpression();
  }
  parseConditional(r, i, s) {
    if (!this.match(17)) return r;
    if (this.state.maybeInArrowParameters) {
      const p = this.lookaheadCharCode();
      if (p === 44 || p === 61 || p === 58 || p === 41)
        return this.setOptionalParametersError(s), r;
    }
    this.expect(17);
    const n = this.state.clone(), a = this.state.noArrowAt, o = this.startNodeAt(i);
    let {
      consequent: l,
      failed: u
    } = this.tryParseConditionalConsequent(), [c, f] = this.getArrowLikeExpressions(l);
    if (u || f.length > 0) {
      const p = [...a];
      if (f.length > 0) {
        this.state = n, this.state.noArrowAt = p;
        for (let h = 0; h < f.length; h++)
          p.push(f[h].start);
        ({
          consequent: l,
          failed: u
        } = this.tryParseConditionalConsequent()), [c, f] = this.getArrowLikeExpressions(l);
      }
      u && c.length > 1 && this.raise(me.AmbiguousConditionalArrow, n.startLoc), u && c.length === 1 && (this.state = n, p.push(c[0].start), this.state.noArrowAt = p, {
        consequent: l,
        failed: u
      } = this.tryParseConditionalConsequent());
    }
    return this.getArrowLikeExpressions(l, !0), this.state.noArrowAt = a, this.expect(14), o.test = r, o.consequent = l, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
  }
  tryParseConditionalConsequent() {
    this.state.noArrowParamsConversionAt.push(this.state.start);
    const r = this.parseMaybeAssignAllowIn(), i = !this.match(14);
    return this.state.noArrowParamsConversionAt.pop(), {
      consequent: r,
      failed: i
    };
  }
  getArrowLikeExpressions(r, i) {
    const s = [r], n = [];
    for (; s.length !== 0; ) {
      const a = s.pop();
      a.type === "ArrowFunctionExpression" && a.body.type !== "BlockStatement" ? (a.typeParameters || !a.returnType ? this.finishArrowValidation(a) : n.push(a), s.push(a.body)) : a.type === "ConditionalExpression" && (s.push(a.consequent), s.push(a.alternate));
    }
    return i ? (n.forEach((a) => this.finishArrowValidation(a)), [n, []]) : lM(n, (a) => a.params.every((o) => this.isAssignable(o, !0)));
  }
  finishArrowValidation(r) {
    var i;
    this.toAssignableList(r.params, (i = r.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1, !0), this.scope.exit();
  }
  forwardNoArrowParamsConversionAt(r, i) {
    let s;
    return this.state.noArrowParamsConversionAt.includes(r.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), s = i(), this.state.noArrowParamsConversionAt.pop()) : s = i(), s;
  }
  parseParenItem(r, i) {
    const s = super.parseParenItem(r, i);
    if (this.eat(17) && (s.optional = !0, this.resetEndLocation(r)), this.match(14)) {
      const n = this.startNodeAt(i);
      return n.expression = s, n.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(n, "TypeCastExpression");
    }
    return s;
  }
  assertModuleNodeAllowed(r) {
    r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind === "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
  }
  parseExportDeclaration(r) {
    if (this.isContextual(130)) {
      r.exportKind = "type";
      const i = this.startNode();
      return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(i);
    } else if (this.isContextual(131)) {
      r.exportKind = "type";
      const i = this.startNode();
      return this.next(), this.flowParseOpaqueType(i, !1);
    } else if (this.isContextual(129)) {
      r.exportKind = "type";
      const i = this.startNode();
      return this.next(), this.flowParseInterface(i);
    } else if (this.shouldParseEnums() && this.isContextual(126)) {
      r.exportKind = "value";
      const i = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(i);
    } else
      return super.parseExportDeclaration(r);
  }
  eatExportStar(r) {
    return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.next(), !0) : !1;
  }
  maybeParseExportNamespaceSpecifier(r) {
    const {
      startLoc: i
    } = this.state, s = super.maybeParseExportNamespaceSpecifier(r);
    return s && r.exportKind === "type" && this.unexpected(i), s;
  }
  parseClassId(r, i, s) {
    super.parseClassId(r, i, s), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
  }
  parseClassMember(r, i, s) {
    const {
      startLoc: n
    } = this.state;
    if (this.isContextual(125)) {
      if (super.parseClassMemberFromModifier(r, i))
        return;
      i.declare = !0;
    }
    super.parseClassMember(r, i, s), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "PropertyDefinition" ? this.raise(me.DeclareClassElement, n) : i.value && this.raise(me.DeclareClassFieldInitializer, i.value));
  }
  isIterator(r) {
    return r === "iterator" || r === "asyncIterator";
  }
  readIterator() {
    const r = super.readWord1(), i = "@@" + r;
    (!this.isIterator(r) || !this.state.inType) && this.raise(w.InvalidIdentifier, this.state.curPosition(), {
      identifierName: i
    }), this.finishToken(132, i);
  }
  getTokenFromCode(r) {
    const i = this.input.charCodeAt(this.state.pos + 1);
    r === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.state.inType && r === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : LL(r, i, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
  }
  isAssignable(r, i) {
    return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, i) : super.isAssignable(r, i);
  }
  toAssignable(r, i = !1) {
    !i && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.toAssignable(r, i);
  }
  toAssignableList(r, i, s) {
    for (let n = 0; n < r.length; n++) {
      const a = r[n];
      (a == null ? void 0 : a.type) === "TypeCastExpression" && (r[n] = this.typeCastToParameter(a));
    }
    super.toAssignableList(r, i, s);
  }
  toReferencedList(r, i) {
    for (let n = 0; n < r.length; n++) {
      var s;
      const a = r[n];
      a && a.type === "TypeCastExpression" && !((s = a.extra) != null && s.parenthesized) && (r.length > 1 || !i) && this.raise(me.TypeCastInPattern, a.typeAnnotation);
    }
    return r;
  }
  parseArrayLike(r, i, s, n) {
    const a = super.parseArrayLike(r, i, s, n);
    return i && !this.state.maybeInArrowParameters && this.toReferencedList(a.elements), a;
  }
  isValidLVal(r, i, s) {
    return r === "TypeCastExpression" || super.isValidLVal(r, i, s);
  }
  parseClassProperty(r) {
    return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
  }
  parseClassPrivateProperty(r) {
    return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(14) || super.isClassProperty();
  }
  isNonstaticConstructor(r) {
    return !this.match(14) && super.isNonstaticConstructor(r);
  }
  pushClassMethod(r, i, s, n, a, o) {
    if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(r, i, s, n, a, o), i.params && a) {
      const l = i.params;
      l.length > 0 && this.isThisParam(l[0]) && this.raise(me.ThisParamBannedInConstructor, i);
    } else if (i.type === "MethodDefinition" && a && i.value.params) {
      const l = i.value.params;
      l.length > 0 && this.isThisParam(l[0]) && this.raise(me.ThisParamBannedInConstructor, i);
    }
  }
  pushClassPrivateMethod(r, i, s, n) {
    i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(r, i, s, n);
  }
  parseClassSuper(r) {
    if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
      this.next();
      const i = r.implements = [];
      do {
        const s = this.startNode();
        s.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? s.typeParameters = this.flowParseTypeParameterInstantiation() : s.typeParameters = null, i.push(this.finishNode(s, "ClassImplements"));
      } while (this.eat(12));
    }
  }
  checkGetterSetterParams(r) {
    super.checkGetterSetterParams(r);
    const i = this.getObjectOrClassMethodParams(r);
    if (i.length > 0) {
      const s = i[0];
      this.isThisParam(s) && r.kind === "get" ? this.raise(me.GetterMayNotHaveThisParam, s) : this.isThisParam(s) && this.raise(me.SetterMayNotHaveThisParam, s);
    }
  }
  parsePropertyNamePrefixOperator(r) {
    r.variance = this.flowParseVariance();
  }
  parseObjPropValue(r, i, s, n, a, o, l) {
    r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
    let u;
    this.match(47) && !o && (u = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
    const c = super.parseObjPropValue(r, i, s, n, a, o, l);
    return u && ((c.value || c).typeParameters = u), c;
  }
  parseAssignableListItemTypes(r) {
    return this.eat(17) && (r.type !== "Identifier" && this.raise(me.PatternIsOptional, r), this.isThisParam(r) && this.raise(me.ThisParamMayNotBeOptional, r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(me.ThisParamAnnotationRequired, r), this.match(29) && this.isThisParam(r) && this.raise(me.ThisParamNoDefault, r), this.resetEndLocation(r), r;
  }
  parseMaybeDefault(r, i) {
    const s = super.parseMaybeDefault(r, i);
    return s.type === "AssignmentPattern" && s.typeAnnotation && s.right.start < s.typeAnnotation.start && this.raise(me.TypeBeforeInitializer, s.typeAnnotation), s;
  }
  checkImportReflection(r) {
    super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(me.ImportReflectionHasImportType, r.specifiers[0].loc.start);
  }
  parseImportSpecifierLocal(r, i, s) {
    i.local = Jl(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(i, s));
  }
  isPotentialImportPhase(r) {
    if (super.isPotentialImportPhase(r)) return !0;
    if (this.isContextual(130)) {
      if (!r) return !0;
      const i = this.lookaheadCharCode();
      return i === 123 || i === 42;
    }
    return !r && this.isContextual(87);
  }
  applyImportPhase(r, i, s, n) {
    if (super.applyImportPhase(r, i, s, n), i) {
      if (!s && this.match(65))
        return;
      r.exportKind = s === "type" ? s : "value";
    } else
      s === "type" && this.match(55) && this.unexpected(), r.importKind = s === "type" || s === "typeof" ? s : "value";
  }
  parseImportSpecifier(r, i, s, n, a) {
    const o = r.imported;
    let l = null;
    o.type === "Identifier" && (o.name === "type" ? l = "type" : o.name === "typeof" && (l = "typeof"));
    let u = !1;
    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
      const f = this.parseIdentifier(!0);
      l !== null && !At(this.state.type) ? (r.imported = f, r.importKind = l, r.local = $t(f)) : (r.imported = o, r.importKind = null, r.local = this.parseIdentifier());
    } else {
      if (l !== null && At(this.state.type))
        r.imported = this.parseIdentifier(!0), r.importKind = l;
      else {
        if (i)
          throw this.raise(w.ImportBindingIsString, r, {
            importName: o.value
          });
        r.imported = o, r.importKind = null;
      }
      this.eatContextual(93) ? r.local = this.parseIdentifier() : (u = !0, r.local = $t(r.imported));
    }
    const c = Jl(r);
    return s && c && this.raise(me.ImportTypeShorthandOnlyInPureImport, r), (s || c) && this.checkReservedType(r.local.name, r.local.loc.start, !0), u && !s && !c && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 78:
        return this.parseIdentifier(!0);
      default:
        return super.parseBindingAtom();
    }
  }
  parseFunctionParams(r, i) {
    const s = r.kind;
    s !== "get" && s !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(r, i);
  }
  parseVarId(r, i) {
    super.parseVarId(r, i), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
  }
  parseAsyncArrowFromCallExpression(r, i) {
    if (this.match(14)) {
      const s = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = s;
    }
    return super.parseAsyncArrowFromCallExpression(r, i);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  parseMaybeAssign(r, i) {
    var s;
    let n = null, a;
    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
      if (n = this.state.clone(), a = this.tryParse(() => super.parseMaybeAssign(r, i), n), !a.error) return a.node;
      const {
        context: u
      } = this.state, c = u[u.length - 1];
      (c === $e.j_oTag || c === $e.j_expr) && u.pop();
    }
    if ((s = a) != null && s.error || this.match(47)) {
      var o, l;
      n = n || this.state.clone();
      let u;
      const c = this.tryParse((p) => {
        var h;
        u = this.flowParseTypeParameterDeclaration();
        const y = this.forwardNoArrowParamsConversionAt(u, () => {
          const A = super.parseMaybeAssign(r, i);
          return this.resetStartLocationFromNode(A, u), A;
        });
        (h = y.extra) != null && h.parenthesized && p();
        const b = this.maybeUnwrapTypeCastExpression(y);
        return b.type !== "ArrowFunctionExpression" && p(), b.typeParameters = u, this.resetStartLocationFromNode(b, u), y;
      }, n);
      let f = null;
      if (c.node && this.maybeUnwrapTypeCastExpression(c.node).type === "ArrowFunctionExpression") {
        if (!c.error && !c.aborted)
          return c.node.async && this.raise(me.UnexpectedTypeParameterBeforeAsyncArrowFunction, u), c.node;
        f = c.node;
      }
      if ((o = a) != null && o.node)
        return this.state = a.failState, a.node;
      if (f)
        return this.state = c.failState, f;
      throw (l = a) != null && l.thrown ? a.error : c.thrown ? c.error : this.raise(me.UnexpectedTokenAfterTypeParameter, u);
    }
    return super.parseMaybeAssign(r, i);
  }
  parseArrow(r) {
    if (this.match(14)) {
      const i = this.tryParse(() => {
        const s = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0;
        const n = this.startNode();
        return [n.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = s, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), n;
      });
      if (i.thrown) return null;
      i.error && (this.state = i.failState), r.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
    }
    return super.parseArrow(r);
  }
  shouldParseArrow(r) {
    return this.match(14) || super.shouldParseArrow(r);
  }
  setArrowFunctionParameters(r, i) {
    this.state.noArrowParamsConversionAt.includes(r.start) ? r.params = i : super.setArrowFunctionParameters(r, i);
  }
  checkParams(r, i, s, n = !0) {
    if (!(s && this.state.noArrowParamsConversionAt.includes(r.start))) {
      for (let a = 0; a < r.params.length; a++)
        this.isThisParam(r.params[a]) && a > 0 && this.raise(me.ThisParamMustBeFirst, r.params[a]);
      super.checkParams(r, i, s, n);
    }
  }
  parseParenAndDistinguishExpression(r) {
    return super.parseParenAndDistinguishExpression(r && !this.state.noArrowAt.includes(this.state.start));
  }
  parseSubscripts(r, i, s) {
    if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.includes(i.index)) {
      this.next();
      const n = this.startNodeAt(i);
      n.callee = r, n.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(n, "CallExpression");
    } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
      const n = this.state.clone(), a = this.tryParse((l) => this.parseAsyncArrowWithTypeParameters(i) || l(), n);
      if (!a.error && !a.aborted) return a.node;
      const o = this.tryParse(() => super.parseSubscripts(r, i, s), n);
      if (o.node && !o.error) return o.node;
      if (a.node)
        return this.state = a.failState, a.node;
      if (o.node)
        return this.state = o.failState, o.node;
      throw a.error || o.error;
    }
    return super.parseSubscripts(r, i, s);
  }
  parseSubscript(r, i, s, n) {
    if (this.match(18) && this.isLookaheadToken_lt()) {
      if (n.optionalChainMember = !0, s)
        return n.stop = !0, r;
      this.next();
      const a = this.startNodeAt(i);
      return a.callee = r, a.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), a.arguments = this.parseCallExpressionArguments(11, !1), a.optional = !0, this.finishCallExpression(a, !0);
    } else if (!s && this.shouldParseTypes() && this.match(47)) {
      const a = this.startNodeAt(i);
      a.callee = r;
      const o = this.tryParse(() => (a.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), a.arguments = super.parseCallExpressionArguments(11, !1), n.optionalChainMember && (a.optional = !1), this.finishCallExpression(a, n.optionalChainMember)));
      if (o.node)
        return o.error && (this.state = o.failState), o.node;
    }
    return super.parseSubscript(r, i, s, n);
  }
  parseNewCallee(r) {
    super.parseNewCallee(r);
    let i = null;
    this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments = i;
  }
  parseAsyncArrowWithTypeParameters(r) {
    const i = this.startNodeAt(r);
    if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
      return super.parseArrowExpression(i, void 0, !0);
  }
  readToken_mult_modulo(r) {
    const i = this.input.charCodeAt(this.state.pos + 1);
    if (r === 42 && i === 47 && this.state.hasFlowComment) {
      this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
      return;
    }
    super.readToken_mult_modulo(r);
  }
  readToken_pipe_amp(r) {
    const i = this.input.charCodeAt(this.state.pos + 1);
    if (r === 124 && i === 125) {
      this.finishOp(9, 2);
      return;
    }
    super.readToken_pipe_amp(r);
  }
  parseTopLevel(r, i) {
    const s = super.parseTopLevel(r, i);
    return this.state.hasFlowComment && this.raise(me.UnterminatedFlowComment, this.state.curPosition()), s;
  }
  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
      if (this.state.hasFlowComment)
        throw this.raise(me.NestedFlowComment, this.state.startLoc);
      this.hasFlowCommentCompletion();
      const r = this.skipFlowComment();
      r && (this.state.pos += r, this.state.hasFlowComment = !0);
      return;
    }
    return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
  }
  skipFlowComment() {
    const {
      pos: r
    } = this.state;
    let i = 2;
    for (; [32, 9].includes(this.input.charCodeAt(r + i)); )
      i++;
    const s = this.input.charCodeAt(i + r), n = this.input.charCodeAt(i + r + 1);
    return s === 58 && n === 58 ? i + 2 : this.input.slice(i + r, i + r + 12) === "flow-include" ? i + 12 : s === 58 && n !== 58 ? i : !1;
  }
  hasFlowCommentCompletion() {
    if (this.input.indexOf("*/", this.state.pos) === -1)
      throw this.raise(w.UnterminatedComment, this.state.curPosition());
  }
  flowEnumErrorBooleanMemberNotInitialized(r, {
    enumName: i,
    memberName: s
  }) {
    this.raise(me.EnumBooleanMemberNotInitialized, r, {
      memberName: s,
      enumName: i
    });
  }
  flowEnumErrorInvalidMemberInitializer(r, i) {
    return this.raise(i.explicitType ? i.explicitType === "symbol" ? me.EnumInvalidMemberInitializerSymbolType : me.EnumInvalidMemberInitializerPrimaryType : me.EnumInvalidMemberInitializerUnknownType, r, i);
  }
  flowEnumErrorNumberMemberNotInitialized(r, i) {
    this.raise(me.EnumNumberMemberNotInitialized, r, i);
  }
  flowEnumErrorStringMemberInconsistentlyInitialized(r, i) {
    this.raise(me.EnumStringMemberInconsistentlyInitialized, r, i);
  }
  flowEnumMemberInit() {
    const r = this.state.startLoc, i = () => this.match(12) || this.match(8);
    switch (this.state.type) {
      case 134: {
        const s = this.parseNumericLiteral(this.state.value);
        return i() ? {
          type: "number",
          loc: s.loc.start,
          value: s
        } : {
          type: "invalid",
          loc: r
        };
      }
      case 133: {
        const s = this.parseStringLiteral(this.state.value);
        return i() ? {
          type: "string",
          loc: s.loc.start,
          value: s
        } : {
          type: "invalid",
          loc: r
        };
      }
      case 85:
      case 86: {
        const s = this.parseBooleanLiteral(this.match(85));
        return i() ? {
          type: "boolean",
          loc: s.loc.start,
          value: s
        } : {
          type: "invalid",
          loc: r
        };
      }
      default:
        return {
          type: "invalid",
          loc: r
        };
    }
  }
  flowEnumMemberRaw() {
    const r = this.state.startLoc, i = this.parseIdentifier(!0), s = this.eat(29) ? this.flowEnumMemberInit() : {
      type: "none",
      loc: r
    };
    return {
      id: i,
      init: s
    };
  }
  flowEnumCheckExplicitTypeMismatch(r, i, s) {
    const {
      explicitType: n
    } = i;
    n !== null && n !== s && this.flowEnumErrorInvalidMemberInitializer(r, i);
  }
  flowEnumMembers({
    enumName: r,
    explicitType: i
  }) {
    const s = /* @__PURE__ */ new Set(), n = {
      booleanMembers: [],
      numberMembers: [],
      stringMembers: [],
      defaultedMembers: []
    };
    let a = !1;
    for (; !this.match(8); ) {
      if (this.eat(21)) {
        a = !0;
        break;
      }
      const o = this.startNode(), {
        id: l,
        init: u
      } = this.flowEnumMemberRaw(), c = l.name;
      if (c === "")
        continue;
      /^[a-z]/.test(c) && this.raise(me.EnumInvalidMemberName, l, {
        memberName: c,
        suggestion: c[0].toUpperCase() + c.slice(1),
        enumName: r
      }), s.has(c) && this.raise(me.EnumDuplicateMemberName, l, {
        memberName: c,
        enumName: r
      }), s.add(c);
      const f = {
        enumName: r,
        explicitType: i,
        memberName: c
      };
      switch (o.id = l, u.type) {
        case "boolean": {
          this.flowEnumCheckExplicitTypeMismatch(u.loc, f, "boolean"), o.init = u.value, n.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
          break;
        }
        case "number": {
          this.flowEnumCheckExplicitTypeMismatch(u.loc, f, "number"), o.init = u.value, n.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
          break;
        }
        case "string": {
          this.flowEnumCheckExplicitTypeMismatch(u.loc, f, "string"), o.init = u.value, n.stringMembers.push(this.finishNode(o, "EnumStringMember"));
          break;
        }
        case "invalid":
          throw this.flowEnumErrorInvalidMemberInitializer(u.loc, f);
        case "none":
          switch (i) {
            case "boolean":
              this.flowEnumErrorBooleanMemberNotInitialized(u.loc, f);
              break;
            case "number":
              this.flowEnumErrorNumberMemberNotInitialized(u.loc, f);
              break;
            default:
              n.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
          }
      }
      this.match(8) || this.expect(12);
    }
    return {
      members: n,
      hasUnknownMembers: a
    };
  }
  flowEnumStringMembers(r, i, {
    enumName: s
  }) {
    if (r.length === 0)
      return i;
    if (i.length === 0)
      return r;
    if (i.length > r.length) {
      for (const n of r)
        this.flowEnumErrorStringMemberInconsistentlyInitialized(n, {
          enumName: s
        });
      return i;
    } else {
      for (const n of i)
        this.flowEnumErrorStringMemberInconsistentlyInitialized(n, {
          enumName: s
        });
      return r;
    }
  }
  flowEnumParseExplicitType({
    enumName: r
  }) {
    if (!this.eatContextual(102)) return null;
    if (!Le(this.state.type))
      throw this.raise(me.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
        enumName: r
      });
    const {
      value: i
    } = this.state;
    return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(me.EnumInvalidExplicitType, this.state.startLoc, {
      enumName: r,
      invalidEnumType: i
    }), i;
  }
  flowEnumBody(r, i) {
    const s = i.name, n = i.loc.start, a = this.flowEnumParseExplicitType({
      enumName: s
    });
    this.expect(5);
    const {
      members: o,
      hasUnknownMembers: l
    } = this.flowEnumMembers({
      enumName: s,
      explicitType: a
    });
    switch (r.hasUnknownMembers = l, a) {
      case "boolean":
        return r.explicitType = !0, r.members = o.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
      case "number":
        return r.explicitType = !0, r.members = o.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
      case "string":
        return r.explicitType = !0, r.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {
          enumName: s
        }), this.expect(8), this.finishNode(r, "EnumStringBody");
      case "symbol":
        return r.members = o.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
      default: {
        const u = () => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody"));
        r.explicitType = !1;
        const c = o.booleanMembers.length, f = o.numberMembers.length, p = o.stringMembers.length, h = o.defaultedMembers.length;
        if (!c && !f && !p && !h)
          return u();
        if (!c && !f)
          return r.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {
            enumName: s
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        if (!f && !p && c >= h) {
          for (const y of o.defaultedMembers)
            this.flowEnumErrorBooleanMemberNotInitialized(y.loc.start, {
              enumName: s,
              memberName: y.id.name
            });
          return r.members = o.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        } else if (!c && !p && f >= h) {
          for (const y of o.defaultedMembers)
            this.flowEnumErrorNumberMemberNotInitialized(y.loc.start, {
              enumName: s,
              memberName: y.id.name
            });
          return r.members = o.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        } else
          return this.raise(me.EnumInconsistentMemberValues, n, {
            enumName: s
          }), u();
      }
    }
  }
  flowParseEnumDeclaration(r) {
    const i = this.parseIdentifier();
    return r.id = i, r.body = this.flowEnumBody(this.startNode(), i), this.finishNode(r, "EnumDeclaration");
  }
  isLookaheadToken_lt() {
    const r = this.nextTokenStart();
    if (this.input.charCodeAt(r) === 60) {
      const i = this.input.charCodeAt(r + 1);
      return i !== 60 && i !== 61;
    }
    return !1;
  }
  maybeUnwrapTypeCastExpression(r) {
    return r.type === "TypeCastExpression" ? r.expression : r;
  }
};
const fM = {
  __proto__: null,
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  fnof: "",
  circ: "",
  tilde: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  bull: "",
  hellip: "",
  permil: "",
  prime: "",
  Prime: "",
  lsaquo: "",
  rsaquo: "",
  oline: "",
  frasl: "",
  euro: "",
  image: "",
  weierp: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: ""
}, rr = Ut`jsx`({
  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
  MissingClosingTagElement: ({
    openingTagName: e
  }) => `Expected corresponding JSX closing tag for <${e}>.`,
  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
  UnexpectedToken: ({
    unexpected: e,
    HTMLEntity: t
  }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`,
  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
  UnterminatedJsxContent: "Unterminated JSX contents.",
  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
});
function Xt(e) {
  return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
}
function br(e) {
  if (e.type === "JSXIdentifier")
    return e.name;
  if (e.type === "JSXNamespacedName")
    return e.namespace.name + ":" + e.name.name;
  if (e.type === "JSXMemberExpression")
    return br(e.object) + "." + br(e.property);
  throw new Error("Node had unexpected type: " + e.type);
}
var pM = (e) => class extends e {
  jsxReadToken() {
    let r = "", i = this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(rr.UnterminatedJsxContent, this.state.startLoc);
      const s = this.input.charCodeAt(this.state.pos);
      switch (s) {
        case 60:
        case 123:
          if (this.state.pos === this.state.start) {
            s === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(s);
            return;
          }
          r += this.input.slice(i, this.state.pos), this.finishToken(141, r);
          return;
        case 38:
          r += this.input.slice(i, this.state.pos), r += this.jsxReadEntity(), i = this.state.pos;
          break;
        case 62:
        case 125:
        default:
          Gr(s) ? (r += this.input.slice(i, this.state.pos), r += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
      }
    }
  }
  jsxReadNewLine(r) {
    const i = this.input.charCodeAt(this.state.pos);
    let s;
    return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s = r ? `
` : `\r
`) : s = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, s;
  }
  jsxReadString(r) {
    let i = "", s = ++this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(w.UnterminatedString, this.state.startLoc);
      const n = this.input.charCodeAt(this.state.pos);
      if (n === r) break;
      n === 38 ? (i += this.input.slice(s, this.state.pos), i += this.jsxReadEntity(), s = this.state.pos) : Gr(n) ? (i += this.input.slice(s, this.state.pos), i += this.jsxReadNewLine(!1), s = this.state.pos) : ++this.state.pos;
    }
    i += this.input.slice(s, this.state.pos++), this.finishToken(133, i);
  }
  jsxReadEntity() {
    const r = ++this.state.pos;
    if (this.codePointAtPos(this.state.pos) === 35) {
      ++this.state.pos;
      let i = 10;
      this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
      const s = this.readInt(i, void 0, !1, "bail");
      if (s !== null && this.codePointAtPos(this.state.pos) === 59)
        return ++this.state.pos, String.fromCodePoint(s);
    } else {
      let i = 0, s = !1;
      for (; i++ < 10 && this.state.pos < this.length && !(s = this.codePointAtPos(this.state.pos) === 59); )
        ++this.state.pos;
      if (s) {
        const n = this.input.slice(r, this.state.pos), a = fM[n];
        if (++this.state.pos, a)
          return a;
      }
    }
    return this.state.pos = r, "&";
  }
  jsxReadWord() {
    let r;
    const i = this.state.pos;
    do
      r = this.input.charCodeAt(++this.state.pos);
    while (Sr(r) || r === 45);
    this.finishToken(140, this.input.slice(i, this.state.pos));
  }
  jsxParseIdentifier() {
    const r = this.startNode();
    return this.match(140) ? r.name = this.state.value : Da(this.state.type) ? r.name = zt(this.state.type) : this.unexpected(), this.next(), this.finishNode(r, "JSXIdentifier");
  }
  jsxParseNamespacedName() {
    const r = this.state.startLoc, i = this.jsxParseIdentifier();
    if (!this.eat(14)) return i;
    const s = this.startNodeAt(r);
    return s.namespace = i, s.name = this.jsxParseIdentifier(), this.finishNode(s, "JSXNamespacedName");
  }
  jsxParseElementName() {
    const r = this.state.startLoc;
    let i = this.jsxParseNamespacedName();
    if (i.type === "JSXNamespacedName")
      return i;
    for (; this.eat(16); ) {
      const s = this.startNodeAt(r);
      s.object = i, s.property = this.jsxParseIdentifier(), i = this.finishNode(s, "JSXMemberExpression");
    }
    return i;
  }
  jsxParseAttributeValue() {
    let r;
    switch (this.state.type) {
      case 5:
        return r = this.startNode(), this.setContext($e.brace), this.next(), r = this.jsxParseExpressionContainer(r, $e.j_oTag), r.expression.type === "JSXEmptyExpression" && this.raise(rr.AttributeIsEmpty, r), r;
      case 142:
      case 133:
        return this.parseExprAtom();
      default:
        throw this.raise(rr.UnsupportedJsxValue, this.state.startLoc);
    }
  }
  jsxParseEmptyExpression() {
    const r = this.startNodeAt(this.state.lastTokEndLoc);
    return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
  }
  jsxParseSpreadChild(r) {
    return this.next(), r.expression = this.parseExpression(), this.setContext($e.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadChild");
  }
  jsxParseExpressionContainer(r, i) {
    if (this.match(8))
      r.expression = this.jsxParseEmptyExpression();
    else {
      const s = this.parseExpression();
      r.expression = s;
    }
    return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
  }
  jsxParseAttribute() {
    const r = this.startNode();
    return this.match(5) ? (this.setContext($e.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext($e.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(), r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
  }
  jsxParseOpeningElementAt(r) {
    const i = this.startNodeAt(r);
    return this.eat(143) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(i));
  }
  jsxParseOpeningElementAfterName(r) {
    const i = [];
    for (; !this.match(56) && !this.match(143); )
      i.push(this.jsxParseAttribute());
    return r.attributes = i, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
  }
  jsxParseClosingElementAt(r) {
    const i = this.startNodeAt(r);
    return this.eat(143) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(143), this.finishNode(i, "JSXClosingElement"));
  }
  jsxParseElementAt(r) {
    const i = this.startNodeAt(r), s = [], n = this.jsxParseOpeningElementAt(r);
    let a = null;
    if (!n.selfClosing) {
      e: for (; ; )
        switch (this.state.type) {
          case 142:
            if (r = this.state.startLoc, this.next(), this.eat(56)) {
              a = this.jsxParseClosingElementAt(r);
              break e;
            }
            s.push(this.jsxParseElementAt(r));
            break;
          case 141:
            s.push(this.parseLiteral(this.state.value, "JSXText"));
            break;
          case 5: {
            const o = this.startNode();
            this.setContext($e.brace), this.next(), this.match(21) ? s.push(this.jsxParseSpreadChild(o)) : s.push(this.jsxParseExpressionContainer(o, $e.j_expr));
            break;
          }
          default:
            this.unexpected();
        }
      Xt(n) && !Xt(a) && a !== null ? this.raise(rr.MissingClosingTagFragment, a) : !Xt(n) && Xt(a) ? this.raise(rr.MissingClosingTagElement, a, {
        openingTagName: br(n.name)
      }) : !Xt(n) && !Xt(a) && br(a.name) !== br(n.name) && this.raise(rr.MissingClosingTagElement, a, {
        openingTagName: br(n.name)
      });
    }
    if (Xt(n) ? (i.openingFragment = n, i.closingFragment = a) : (i.openingElement = n, i.closingElement = a), i.children = s, this.match(47))
      throw this.raise(rr.UnwrappedAdjacentJSXElements, this.state.startLoc);
    return Xt(n) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
  }
  jsxParseElement() {
    const r = this.state.startLoc;
    return this.next(), this.jsxParseElementAt(r);
  }
  setContext(r) {
    const {
      context: i
    } = this.state;
    i[i.length - 1] = r;
  }
  parseExprAtom(r) {
    return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(r);
  }
  skipSpace() {
    this.curContext().preserveSpace || super.skipSpace();
  }
  getTokenFromCode(r) {
    const i = this.curContext();
    if (i === $e.j_expr) {
      this.jsxReadToken();
      return;
    }
    if (i === $e.j_oTag || i === $e.j_cTag) {
      if (Rt(r)) {
        this.jsxReadWord();
        return;
      }
      if (r === 62) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      if ((r === 34 || r === 39) && i === $e.j_oTag) {
        this.jsxReadString(r);
        return;
      }
    }
    if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
      ++this.state.pos, this.finishToken(142);
      return;
    }
    super.getTokenFromCode(r);
  }
  updateContext(r) {
    const {
      context: i,
      type: s
    } = this.state;
    if (s === 56 && r === 142)
      i.splice(-2, 2, $e.j_cTag), this.state.canStartJSXElement = !1;
    else if (s === 142)
      i.push($e.j_oTag);
    else if (s === 143) {
      const n = i[i.length - 1];
      n === $e.j_oTag && r === 56 || n === $e.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === $e.j_expr) : (this.setContext($e.j_expr), this.state.canStartJSXElement = !0);
    } else
      this.state.canStartJSXElement = gL(s);
  }
};
class hM extends Ba {
  constructor(...t) {
    super(...t), this.tsNames = /* @__PURE__ */ new Map();
  }
}
class dM extends Fa {
  constructor(...t) {
    super(...t), this.importsStack = [];
  }
  createScope(t) {
    return this.importsStack.push(/* @__PURE__ */ new Set()), new hM(t);
  }
  enter(t) {
    t === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
  }
  exit() {
    const t = super.exit();
    return t === 256 && this.importsStack.pop(), t;
  }
  hasImport(t, r) {
    const i = this.importsStack.length;
    if (this.importsStack[i - 1].has(t))
      return !0;
    if (!r && i > 1) {
      for (let s = 0; s < i - 1; s++)
        if (this.importsStack[s].has(t)) return !0;
    }
    return !1;
  }
  declareName(t, r, i) {
    if (r & 4096) {
      this.hasImport(t, !0) && this.parser.raise(w.VarRedeclaration, i, {
        identifierName: t
      }), this.importsStack[this.importsStack.length - 1].add(t);
      return;
    }
    const s = this.currentScope();
    let n = s.tsNames.get(t) || 0;
    if (r & 1024) {
      this.maybeExportDefined(s, t), s.tsNames.set(t, n | 16);
      return;
    }
    super.declareName(t, r, i), r & 2 && (r & 1 || (this.checkRedeclarationInScope(s, t, r, i), this.maybeExportDefined(s, t)), n = n | 1), r & 256 && (n = n | 2), r & 512 && (n = n | 4), r & 128 && (n = n | 8), n && s.tsNames.set(t, n);
  }
  isRedeclaredInScope(t, r, i) {
    const s = t.tsNames.get(r);
    if ((s & 2) > 0) {
      if (i & 256) {
        const n = !!(i & 512), a = (s & 4) > 0;
        return n !== a;
      }
      return !0;
    }
    return i & 128 && (s & 8) > 0 ? t.names.get(r) & 2 ? !!(i & 1) : !1 : i & 2 && (s & 1) > 0 ? !0 : super.isRedeclaredInScope(t, r, i);
  }
  checkLocalExport(t) {
    const {
      name: r
    } = t;
    if (this.hasImport(r)) return;
    const i = this.scopeStack.length;
    for (let s = i - 1; s >= 0; s--) {
      const a = this.scopeStack[s].tsNames.get(r);
      if ((a & 1) > 0 || (a & 16) > 0)
        return;
    }
    super.checkLocalExport(t);
  }
}
const mM = (e, t) => hasOwnProperty.call(e, t) && e[t], of = (e) => e.type === "ParenthesizedExpression" ? of(e.expression) : e;
class yM extends sM {
  toAssignable(t, r = !1) {
    var i, s;
    let n;
    switch ((t.type === "ParenthesizedExpression" || (i = t.extra) != null && i.parenthesized) && (n = of(t), r ? n.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(w.InvalidParenthesizedAssignment, t) : n.type !== "MemberExpression" && !this.isOptionalMemberExpression(n) && this.raise(w.InvalidParenthesizedAssignment, t) : this.raise(w.InvalidParenthesizedAssignment, t)), t.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        t.type = "ObjectPattern";
        for (let o = 0, l = t.properties.length, u = l - 1; o < l; o++) {
          var a;
          const c = t.properties[o], f = o === u;
          this.toAssignableObjectExpressionProp(c, f, r), f && c.type === "RestElement" && (a = t.extra) != null && a.trailingCommaLoc && this.raise(w.RestTrailingComma, t.extra.trailingCommaLoc);
        }
        break;
      case "ObjectProperty": {
        const {
          key: o,
          value: l
        } = t;
        this.isPrivateName(o) && this.classScope.usePrivateName(this.getPrivateNameSV(o), o.loc.start), this.toAssignable(l, r);
        break;
      }
      case "SpreadElement":
        throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
      case "ArrayExpression":
        t.type = "ArrayPattern", this.toAssignableList(t.elements, (s = t.extra) == null ? void 0 : s.trailingCommaLoc, r);
        break;
      case "AssignmentExpression":
        t.operator !== "=" && this.raise(w.MissingEqInAssignment, t.left.loc.end), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, r);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(n, r);
        break;
    }
  }
  toAssignableObjectExpressionProp(t, r, i) {
    if (t.type === "ObjectMethod")
      this.raise(t.kind === "get" || t.kind === "set" ? w.PatternHasAccessor : w.PatternHasMethod, t.key);
    else if (t.type === "SpreadElement") {
      t.type = "RestElement";
      const s = t.argument;
      this.checkToRestConversion(s, !1), this.toAssignable(s, i), r || this.raise(w.RestTrailingComma, t);
    } else
      this.toAssignable(t, i);
  }
  toAssignableList(t, r, i) {
    const s = t.length - 1;
    for (let n = 0; n <= s; n++) {
      const a = t[n];
      if (a) {
        if (a.type === "SpreadElement") {
          a.type = "RestElement";
          const o = a.argument;
          this.checkToRestConversion(o, !0), this.toAssignable(o, i);
        } else
          this.toAssignable(a, i);
        a.type === "RestElement" && (n < s ? this.raise(w.RestTrailingComma, a) : r && this.raise(w.RestTrailingComma, r));
      }
    }
  }
  isAssignable(t, r) {
    switch (t.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        return !0;
      case "ObjectExpression": {
        const i = t.properties.length - 1;
        return t.properties.every((s, n) => s.type !== "ObjectMethod" && (n === i || s.type !== "SpreadElement") && this.isAssignable(s));
      }
      case "ObjectProperty":
        return this.isAssignable(t.value);
      case "SpreadElement":
        return this.isAssignable(t.argument);
      case "ArrayExpression":
        return t.elements.every((i) => i === null || this.isAssignable(i));
      case "AssignmentExpression":
        return t.operator === "=";
      case "ParenthesizedExpression":
        return this.isAssignable(t.expression);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return !r;
      default:
        return !1;
    }
  }
  toReferencedList(t, r) {
    return t;
  }
  toReferencedListDeep(t, r) {
    this.toReferencedList(t, r);
    for (const i of t)
      (i == null ? void 0 : i.type) === "ArrayExpression" && this.toReferencedListDeep(i.elements);
  }
  parseSpread(t) {
    const r = this.startNode();
    return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
  }
  parseRestBinding() {
    const t = this.startNode();
    return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 0: {
        const t = this.startNode();
        return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
      }
      case 5:
        return this.parseObjectLike(8, !0);
    }
    return this.parseIdentifier();
  }
  parseBindingList(t, r, i) {
    const s = i & 1, n = [];
    let a = !0;
    for (; !this.eat(t); )
      if (a ? a = !1 : this.expect(12), s && this.match(12))
        n.push(null);
      else {
        if (this.eat(t))
          break;
        if (this.match(21)) {
          if (n.push(this.parseAssignableListItemTypes(this.parseRestBinding(), i)), !this.checkCommaAfterRest(r)) {
            this.expect(t);
            break;
          }
        } else {
          const o = [];
          for (this.match(26) && this.hasPlugin("decorators") && this.raise(w.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
            o.push(this.parseDecorator());
          n.push(this.parseAssignableListItem(i, o));
        }
      }
    return n;
  }
  parseBindingRestProperty(t) {
    return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
  }
  parseBindingProperty() {
    const {
      type: t,
      startLoc: r
    } = this.state;
    if (t === 21)
      return this.parseBindingRestProperty(this.startNode());
    const i = this.startNode();
    return t === 138 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), i.key = this.parsePrivateName()) : this.parsePropertyName(i), i.method = !1, this.parseObjPropValue(i, r, !1, !1, !0, !1);
  }
  parseAssignableListItem(t, r) {
    const i = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(i, t);
    const s = this.parseMaybeDefault(i.loc.start, i);
    return r.length && (i.decorators = r), s;
  }
  parseAssignableListItemTypes(t, r) {
    return t;
  }
  parseMaybeDefault(t, r) {
    var i, s;
    if ((i = t) != null || (t = this.state.startLoc), r = (s = r) != null ? s : this.parseBindingAtom(), !this.eat(29)) return r;
    const n = this.startNodeAt(t);
    return n.left = r, n.right = this.parseMaybeAssignAllowIn(), this.finishNode(n, "AssignmentPattern");
  }
  isValidLVal(t, r, i) {
    return mM({
      AssignmentPattern: "left",
      RestElement: "argument",
      ObjectProperty: "value",
      ParenthesizedExpression: "expression",
      ArrayPattern: "elements",
      ObjectPattern: "properties"
    }, t);
  }
  isOptionalMemberExpression(t) {
    return t.type === "OptionalMemberExpression";
  }
  checkLVal(t, {
    in: r,
    binding: i = 64,
    checkClashes: s = !1,
    strictModeChanged: n = !1,
    hasParenthesizedAncestor: a = !1
  }) {
    var o;
    const l = t.type;
    if (this.isObjectMethod(t)) return;
    const u = this.isOptionalMemberExpression(t);
    if (u || l === "MemberExpression") {
      u && (this.expectPlugin("optionalChainingAssign", t.loc.start), r.type !== "AssignmentExpression" && this.raise(w.InvalidLhsOptionalChaining, t, {
        ancestor: r
      })), i !== 64 && this.raise(w.InvalidPropertyBindingPattern, t);
      return;
    }
    if (l === "Identifier") {
      this.checkIdentifier(t, i, n);
      const {
        name: y
      } = t;
      s && (s.has(y) ? this.raise(w.ParamDupe, t) : s.add(y));
      return;
    }
    const c = this.isValidLVal(l, !(a || (o = t.extra) != null && o.parenthesized) && r.type === "AssignmentExpression", i);
    if (c === !0) return;
    if (c === !1) {
      const y = i === 64 ? w.InvalidLhs : w.InvalidLhsBinding;
      this.raise(y, t, {
        ancestor: r
      });
      return;
    }
    const [f, p] = Array.isArray(c) ? c : [c, l === "ParenthesizedExpression"], h = l === "ArrayPattern" || l === "ObjectPattern" ? {
      type: l
    } : r;
    for (const y of [].concat(t[f]))
      y && this.checkLVal(y, {
        in: h,
        binding: i,
        checkClashes: s,
        strictModeChanged: n,
        hasParenthesizedAncestor: p
      });
  }
  checkIdentifier(t, r, i = !1) {
    this.state.strict && (i ? Zc(t.name, this.inModule) : Qc(t.name)) && (r === 64 ? this.raise(w.StrictEvalArguments, t, {
      referenceName: t.name
    }) : this.raise(w.StrictEvalArgumentsBinding, t, {
      bindingName: t.name
    })), r & 8192 && t.name === "let" && this.raise(w.LetInLexicalBinding, t), r & 64 || this.declareNameFromIdentifier(t, r);
  }
  declareNameFromIdentifier(t, r) {
    this.scope.declareName(t.name, r, t.loc.start);
  }
  checkToRestConversion(t, r) {
    switch (t.type) {
      case "ParenthesizedExpression":
        this.checkToRestConversion(t.expression, r);
        break;
      case "Identifier":
      case "MemberExpression":
        break;
      case "ArrayExpression":
      case "ObjectExpression":
        if (r) break;
      default:
        this.raise(w.InvalidRestAssignmentPattern, t);
    }
  }
  checkCommaAfterRest(t) {
    return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? w.RestTrailingComma : w.ElementAfterRest, this.state.startLoc), !0) : !1;
  }
}
const TM = (e, t) => hasOwnProperty.call(e, t) && e[t];
function gM(e) {
  if (e == null)
    throw new Error(`Unexpected ${e} value.`);
  return e;
}
function Xl(e) {
  if (!e)
    throw new Error("Assert fail");
}
const le = Ut`typescript`({
  AbstractMethodHasImplementation: ({
    methodName: e
  }) => `Method '${e}' cannot have an implementation because it is marked abstract.`,
  AbstractPropertyHasInitializer: ({
    propertyName: e
  }) => `Property '${e}' cannot have an initializer because it is marked abstract.`,
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: ({
    kind: e
  }) => `'declare' is not allowed in ${e}ters.`,
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: ({
    modifier: e
  }) => "Accessibility modifier already seen.",
  DuplicateModifier: ({
    modifier: e
  }) => `Duplicate modifier: '${e}'.`,
  EmptyHeritageClauseType: ({
    token: e
  }) => `'${e}' list cannot be empty.`,
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
  IncompatibleModifiers: ({
    modifiers: e
  }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`,
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: ({
    modifier: e
  }) => `Index signatures cannot have an accessibility modifier ('${e}').`,
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: ({
    modifier: e
  }) => `'${e}' modifier cannot appear on a type member.`,
  InvalidModifierOnTypeParameter: ({
    modifier: e
  }) => `'${e}' modifier cannot appear on a type parameter.`,
  InvalidModifierOnTypeParameterPositions: ({
    modifier: e
  }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`,
  InvalidModifiersOrder: ({
    orderedModifiers: e
  }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`,
  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: ({
    modifier: e
  }) => `Private elements cannot have an accessibility modifier ('${e}').`,
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: ({
    typeParameterName: e
  }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`,
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: ({
    type: e
  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`
});
function bM(e) {
  switch (e) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "bigint":
      return "TSBigIntKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return;
  }
}
function Yl(e) {
  return e === "private" || e === "public" || e === "protected";
}
function SM(e) {
  return e === "in" || e === "out";
}
var EM = (e) => class extends e {
  constructor(...r) {
    super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out"],
      disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: le.InvalidModifierOnTypeParameter
    }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["const"],
      disallowedModifiers: ["in", "out"],
      errorTemplate: le.InvalidModifierOnTypeParameterPositions
    }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out", "const"],
      disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: le.InvalidModifierOnTypeParameter
    });
  }
  getScopeHandler() {
    return dM;
  }
  tsIsIdentifier() {
    return Le(this.state.type);
  }
  tsTokenCanFollowModifier() {
    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
  }
  tsNextTokenCanFollowModifier() {
    return this.next(), this.tsTokenCanFollowModifier();
  }
  tsParseModifier(r, i) {
    if (!Le(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
      return;
    const s = this.state.value;
    if (r.includes(s)) {
      if (i && this.tsIsStartOfStaticBlocks())
        return;
      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
        return s;
    }
  }
  tsParseModifiers({
    allowedModifiers: r,
    disallowedModifiers: i,
    stopOnStartOfClassStaticBlock: s,
    errorTemplate: n = le.InvalidModifierOnTypeMember
  }, a) {
    const o = (u, c, f, p) => {
      c === f && a[p] && this.raise(le.InvalidModifiersOrder, u, {
        orderedModifiers: [f, p]
      });
    }, l = (u, c, f, p) => {
      (a[f] && c === p || a[p] && c === f) && this.raise(le.IncompatibleModifiers, u, {
        modifiers: [f, p]
      });
    };
    for (; ; ) {
      const {
        startLoc: u
      } = this.state, c = this.tsParseModifier(r.concat(i ?? []), s);
      if (!c) break;
      Yl(c) ? a.accessibility ? this.raise(le.DuplicateAccessibilityModifier, u, {
        modifier: c
      }) : (o(u, c, c, "override"), o(u, c, c, "static"), o(u, c, c, "readonly"), a.accessibility = c) : SM(c) ? (a[c] && this.raise(le.DuplicateModifier, u, {
        modifier: c
      }), a[c] = !0, o(u, c, "in", "out")) : (hasOwnProperty.call(a, c) ? this.raise(le.DuplicateModifier, u, {
        modifier: c
      }) : (o(u, c, "static", "readonly"), o(u, c, "static", "override"), o(u, c, "override", "readonly"), o(u, c, "abstract", "override"), l(u, c, "declare", "override"), l(u, c, "static", "abstract")), a[c] = !0), i != null && i.includes(c) && this.raise(n, u, {
        modifier: c
      });
    }
  }
  tsIsListTerminator(r) {
    switch (r) {
      case "EnumMembers":
      case "TypeMembers":
        return this.match(8);
      case "HeritageClauseElement":
        return this.match(5);
      case "TupleElementTypes":
        return this.match(3);
      case "TypeParametersOrArguments":
        return this.match(48);
    }
  }
  tsParseList(r, i) {
    const s = [];
    for (; !this.tsIsListTerminator(r); )
      s.push(i());
    return s;
  }
  tsParseDelimitedList(r, i, s) {
    return gM(this.tsParseDelimitedListWorker(r, i, !0, s));
  }
  tsParseDelimitedListWorker(r, i, s, n) {
    const a = [];
    let o = -1;
    for (; !this.tsIsListTerminator(r); ) {
      o = -1;
      const l = i();
      if (l == null)
        return;
      if (a.push(l), this.eat(12)) {
        o = this.state.lastTokStartLoc.index;
        continue;
      }
      if (this.tsIsListTerminator(r))
        break;
      s && this.expect(12);
      return;
    }
    return n && (n.value = o), a;
  }
  tsParseBracketedList(r, i, s, n, a) {
    n || (s ? this.expect(0) : this.expect(47));
    const o = this.tsParseDelimitedList(r, i, a);
    return s ? this.expect(3) : this.expect(48), o;
  }
  tsParseImportType() {
    const r = this.startNode();
    return this.expect(83), this.expect(10), this.match(133) || this.raise(le.UnsupportedImportTypeArgument, this.state.startLoc), r.argument = super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSImportType");
  }
  tsParseEntityName(r = !0) {
    let i = this.parseIdentifier(r);
    for (; this.eat(16); ) {
      const s = this.startNodeAtNode(i);
      s.left = i, s.right = this.parseIdentifier(r), i = this.finishNode(s, "TSQualifiedName");
    }
    return i;
  }
  tsParseTypeReference() {
    const r = this.startNode();
    return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeReference");
  }
  tsParseThisTypePredicate(r) {
    this.next();
    const i = this.startNodeAtNode(r);
    return i.parameterName = r, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
  }
  tsParseThisTypeNode() {
    const r = this.startNode();
    return this.next(), this.finishNode(r, "TSThisType");
  }
  tsParseTypeQuery() {
    const r = this.startNode();
    return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
  }
  tsParseTypeParameter(r) {
    const i = this.startNode();
    return r(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(29), this.finishNode(i, "TSTypeParameter");
  }
  tsTryParseTypeParameters(r) {
    if (this.match(47))
      return this.tsParseTypeParameters(r);
  }
  tsParseTypeParameters(r) {
    const i = this.startNode();
    this.match(47) || this.match(142) ? this.next() : this.unexpected();
    const s = {
      value: -1
    };
    return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, s), i.params.length === 0 && this.raise(le.EmptyTypeParameters, i), s.value !== -1 && this.addExtra(i, "trailingComma", s.value), this.finishNode(i, "TSTypeParameterDeclaration");
  }
  tsFillSignature(r, i) {
    const s = r === 19, n = "parameters", a = "typeAnnotation";
    i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[n] = this.tsParseBindingListForSignature(), s ? i[a] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (i[a] = this.tsParseTypeOrTypePredicateAnnotation(r));
  }
  tsParseBindingListForSignature() {
    const r = super.parseBindingList(11, 41, 2);
    for (const i of r) {
      const {
        type: s
      } = i;
      (s === "AssignmentPattern" || s === "TSParameterProperty") && this.raise(le.UnsupportedSignatureParameterKind, i, {
        type: s
      });
    }
    return r;
  }
  tsParseTypeMemberSemicolon() {
    !this.eat(12) && !this.isLineTerminator() && this.expect(13);
  }
  tsParseSignatureMember(r, i) {
    return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, r);
  }
  tsIsUnambiguouslyIndexSignature() {
    return this.next(), Le(this.state.type) ? (this.next(), this.match(14)) : !1;
  }
  tsTryParseIndexSignature(r) {
    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
      return;
    this.expect(0);
    const i = this.parseIdentifier();
    i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), r.parameters = [i];
    const s = this.tsTryParseTypeAnnotation();
    return s && (r.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
  }
  tsParsePropertyOrMethodSignature(r, i) {
    this.eat(17) && (r.optional = !0);
    const s = r;
    if (this.match(10) || this.match(47)) {
      i && this.raise(le.ReadonlyForMethodSignature, r);
      const n = s;
      n.kind && this.match(47) && this.raise(le.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, n), this.tsParseTypeMemberSemicolon();
      const a = "parameters", o = "typeAnnotation";
      if (n.kind === "get")
        n[a].length > 0 && (this.raise(w.BadGetterArity, this.state.curPosition()), this.isThisParam(n[a][0]) && this.raise(le.AccesorCannotDeclareThisParameter, this.state.curPosition()));
      else if (n.kind === "set") {
        if (n[a].length !== 1)
          this.raise(w.BadSetterArity, this.state.curPosition());
        else {
          const l = n[a][0];
          this.isThisParam(l) && this.raise(le.AccesorCannotDeclareThisParameter, this.state.curPosition()), l.type === "Identifier" && l.optional && this.raise(le.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), l.type === "RestElement" && this.raise(le.SetAccesorCannotHaveRestParameter, this.state.curPosition());
        }
        n[o] && this.raise(le.SetAccesorCannotHaveReturnType, n[o]);
      } else
        n.kind = "method";
      return this.finishNode(n, "TSMethodSignature");
    } else {
      const n = s;
      i && (n.readonly = !0);
      const a = this.tsTryParseTypeAnnotation();
      return a && (n.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(n, "TSPropertySignature");
    }
  }
  tsParseTypeMember() {
    const r = this.startNode();
    if (this.match(10) || this.match(47))
      return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
    if (this.match(77)) {
      const s = this.startNode();
      return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.createIdentifier(s, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
    }
    this.tsParseModifiers({
      allowedModifiers: ["readonly"],
      disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
    }, r);
    const i = this.tsTryParseIndexSignature(r);
    return i || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") && this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
  }
  tsParseTypeLiteral() {
    const r = this.startNode();
    return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
  }
  tsParseObjectTypeMembers() {
    this.expect(5);
    const r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    return this.expect(8), r;
  }
  tsIsStartOfMappedType() {
    return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
  }
  tsParseMappedTypeParameter() {
    const r = this.startNode();
    return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
  }
  tsParseMappedType() {
    const r = this.startNode();
    return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
  }
  tsParseTupleType() {
    const r = this.startNode();
    r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
    let i = !1;
    return r.elementTypes.forEach((s) => {
      const {
        type: n
      } = s;
      i && n !== "TSRestType" && n !== "TSOptionalType" && !(n === "TSNamedTupleMember" && s.optional) && this.raise(le.OptionalTypeBeforeRequired, s), i || (i = n === "TSNamedTupleMember" && s.optional || n === "TSOptionalType");
    }), this.finishNode(r, "TSTupleType");
  }
  tsParseTupleElementType() {
    const {
      startLoc: r
    } = this.state, i = this.eat(21);
    let s, n, a, o;
    const u = At(this.state.type) ? this.lookaheadCharCode() : null;
    if (u === 58)
      s = !0, a = !1, n = this.parseIdentifier(!0), this.expect(14), o = this.tsParseType();
    else if (u === 63) {
      a = !0;
      const c = this.state.startLoc, f = this.state.value, p = this.tsParseNonArrayType();
      this.lookaheadCharCode() === 58 ? (s = !0, n = this.createIdentifier(this.startNodeAt(c), f), this.expect(17), this.expect(14), o = this.tsParseType()) : (s = !1, o = p, this.expect(17));
    } else
      o = this.tsParseType(), a = this.eat(17), s = this.eat(14);
    if (s) {
      let c;
      n ? (c = this.startNodeAtNode(n), c.optional = a, c.label = n, c.elementType = o, this.eat(17) && (c.optional = !0, this.raise(le.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (c = this.startNodeAtNode(o), c.optional = a, this.raise(le.InvalidTupleMemberLabel, o), c.label = o, c.elementType = this.tsParseType()), o = this.finishNode(c, "TSNamedTupleMember");
    } else if (a) {
      const c = this.startNodeAtNode(o);
      c.typeAnnotation = o, o = this.finishNode(c, "TSOptionalType");
    }
    if (i) {
      const c = this.startNodeAt(r);
      c.typeAnnotation = o, o = this.finishNode(c, "TSRestType");
    }
    return o;
  }
  tsParseParenthesizedType() {
    const r = this.startNode();
    return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
  }
  tsParseFunctionOrConstructorType(r, i) {
    const s = this.startNode();
    return r === "TSConstructorType" && (s.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, s)), this.finishNode(s, r);
  }
  tsParseLiteralTypeNode() {
    const r = this.startNode();
    switch (this.state.type) {
      case 134:
      case 135:
      case 133:
      case 85:
      case 86:
        r.literal = super.parseExprAtom();
        break;
      default:
        this.unexpected();
    }
    return this.finishNode(r, "TSLiteralType");
  }
  tsParseTemplateLiteralType() {
    const r = this.startNode();
    return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
  }
  parseTemplateSubstitution() {
    return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
  }
  tsParseThisTypeOrThisTypePredicate() {
    const r = this.tsParseThisTypeNode();
    return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
  }
  tsParseNonArrayType() {
    switch (this.state.type) {
      case 133:
      case 134:
      case 135:
      case 85:
      case 86:
        return this.tsParseLiteralTypeNode();
      case 53:
        if (this.state.value === "-") {
          const r = this.startNode(), i = this.lookahead();
          return i.type !== 134 && i.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralType");
        }
        break;
      case 78:
        return this.tsParseThisTypeOrThisTypePredicate();
      case 87:
        return this.tsParseTypeQuery();
      case 83:
        return this.tsParseImportType();
      case 5:
        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
      case 0:
        return this.tsParseTupleType();
      case 10:
        return this.tsParseParenthesizedType();
      case 25:
      case 24:
        return this.tsParseTemplateLiteralType();
      default: {
        const {
          type: r
        } = this.state;
        if (Le(r) || r === 88 || r === 84) {
          const i = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : bM(this.state.value);
          if (i !== void 0 && this.lookaheadCharCode() !== 46) {
            const s = this.startNode();
            return this.next(), this.finishNode(s, i);
          }
          return this.tsParseTypeReference();
        }
      }
    }
    this.unexpected();
  }
  tsParseArrayTypeOrHigher() {
    let r = this.tsParseNonArrayType();
    for (; !this.hasPrecedingLineBreak() && this.eat(0); )
      if (this.match(3)) {
        const i = this.startNodeAtNode(r);
        i.elementType = r, this.expect(3), r = this.finishNode(i, "TSArrayType");
      } else {
        const i = this.startNodeAtNode(r);
        i.objectType = r, i.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(i, "TSIndexedAccessType");
      }
    return r;
  }
  tsParseTypeOperator() {
    const r = this.startNode(), i = this.state.value;
    return this.next(), r.operator = i, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(r), this.finishNode(r, "TSTypeOperator");
  }
  tsCheckTypeAnnotationForReadOnly(r) {
    switch (r.typeAnnotation.type) {
      case "TSTupleType":
      case "TSArrayType":
        return;
      default:
        this.raise(le.UnexpectedReadonly, r);
    }
  }
  tsParseInferType() {
    const r = this.startNode();
    this.expectContextual(115);
    const i = this.startNode();
    return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter = this.finishNode(i, "TSTypeParameter"), this.finishNode(r, "TSInferType");
  }
  tsParseConstraintForInferType() {
    if (this.eat(81)) {
      const r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
      if (this.state.inDisallowConditionalTypesContext || !this.match(17))
        return r;
    }
  }
  tsParseTypeOperatorOrHigher() {
    return vL(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
  }
  tsParseUnionOrIntersectionType(r, i, s) {
    const n = this.startNode(), a = this.eat(s), o = [];
    do
      o.push(i());
    while (this.eat(s));
    return o.length === 1 && !a ? o[0] : (n.types = o, this.finishNode(n, r));
  }
  tsParseIntersectionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
  }
  tsParseUnionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
  }
  tsIsStartOfFunctionType() {
    return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }
  tsSkipParameterStart() {
    if (Le(this.state.type) || this.match(78))
      return this.next(), !0;
    if (this.match(5)) {
      const {
        errors: r
      } = this.state, i = r.length;
      try {
        return this.parseObjectLike(8, !0), r.length === i;
      } catch {
        return !1;
      }
    }
    if (this.match(0)) {
      this.next();
      const {
        errors: r
      } = this.state, i = r.length;
      try {
        return super.parseBindingList(3, 93, 1), r.length === i;
      } catch {
        return !1;
      }
    }
    return !1;
  }
  tsIsUnambiguouslyStartOfFunctionType() {
    return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
  }
  tsParseTypeOrTypePredicateAnnotation(r) {
    return this.tsInType(() => {
      const i = this.startNode();
      this.expect(r);
      const s = this.startNode(), n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
      if (n && this.match(78)) {
        let l = this.tsParseThisTypeOrThisTypePredicate();
        return l.type === "TSThisType" ? (s.parameterName = l, s.asserts = !0, s.typeAnnotation = null, l = this.finishNode(s, "TSTypePredicate")) : (this.resetStartLocationFromNode(l, s), l.asserts = !0), i.typeAnnotation = l, this.finishNode(i, "TSTypeAnnotation");
      }
      const a = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
      if (!a)
        return n ? (s.parameterName = this.parseIdentifier(), s.asserts = n, s.typeAnnotation = null, i.typeAnnotation = this.finishNode(s, "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
      const o = this.tsParseTypeAnnotation(!1);
      return s.parameterName = a, s.typeAnnotation = o, s.asserts = n, i.typeAnnotation = this.finishNode(s, "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation");
    });
  }
  tsTryParseTypeOrTypePredicateAnnotation() {
    if (this.match(14))
      return this.tsParseTypeOrTypePredicateAnnotation(14);
  }
  tsTryParseTypeAnnotation() {
    if (this.match(14))
      return this.tsParseTypeAnnotation();
  }
  tsTryParseType() {
    return this.tsEatThenParseType(14);
  }
  tsParseTypePredicatePrefix() {
    const r = this.parseIdentifier();
    if (this.isContextual(116) && !this.hasPrecedingLineBreak())
      return this.next(), r;
  }
  tsParseTypePredicateAsserts() {
    if (this.state.type !== 109)
      return !1;
    const r = this.state.containsEsc;
    return this.next(), !Le(this.state.type) && !this.match(78) ? !1 : (r && this.raise(w.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
      reservedWord: "asserts"
    }), !0);
  }
  tsParseTypeAnnotation(r = !0, i = this.startNode()) {
    return this.tsInType(() => {
      r && this.expect(14), i.typeAnnotation = this.tsParseType();
    }), this.finishNode(i, "TSTypeAnnotation");
  }
  tsParseType() {
    Xl(this.state.inType);
    const r = this.tsParseNonConditionalType();
    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
      return r;
    const i = this.startNodeAtNode(r);
    return i.checkType = r, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(i, "TSConditionalType");
  }
  isAbstractConstructorSignature() {
    return this.isContextual(124) && this.lookahead().type === 77;
  }
  tsParseNonConditionalType() {
    return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
  }
  tsParseTypeAssertion() {
    this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(le.ReservedTypeAssertion, this.state.startLoc);
    const r = this.startNode();
    return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
  }
  tsParseHeritageClause(r) {
    const i = this.state.startLoc, s = this.tsParseDelimitedList("HeritageClauseElement", () => {
      const n = this.startNode();
      return n.expression = this.tsParseEntityName(), this.match(47) && (n.typeParameters = this.tsParseTypeArguments()), this.finishNode(n, "TSExpressionWithTypeArguments");
    });
    return s.length || this.raise(le.EmptyHeritageClauseType, i, {
      token: r
    }), s;
  }
  tsParseInterfaceDeclaration(r, i = {}) {
    if (this.hasFollowingLineBreak()) return null;
    this.expectContextual(129), i.declare && (r.declare = !0), Le(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 130)) : (r.id = null, this.raise(le.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
    const s = this.startNode();
    return s.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(s, "TSInterfaceBody"), this.finishNode(r, "TSInterfaceDeclaration");
  }
  tsParseTypeAliasDeclaration(r) {
    return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
      if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
        const i = this.startNode();
        return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
      }
      return this.tsParseType();
    }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
  }
  tsInNoContext(r) {
    const i = this.state.context;
    this.state.context = [i[0]];
    try {
      return r();
    } finally {
      this.state.context = i;
    }
  }
  tsInType(r) {
    const i = this.state.inType;
    this.state.inType = !0;
    try {
      return r();
    } finally {
      this.state.inType = i;
    }
  }
  tsInDisallowConditionalTypesContext(r) {
    const i = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = !0;
    try {
      return r();
    } finally {
      this.state.inDisallowConditionalTypesContext = i;
    }
  }
  tsInAllowConditionalTypesContext(r) {
    const i = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = !1;
    try {
      return r();
    } finally {
      this.state.inDisallowConditionalTypesContext = i;
    }
  }
  tsEatThenParseType(r) {
    if (this.match(r))
      return this.tsNextThenParseType();
  }
  tsExpectThenParseType(r) {
    return this.tsInType(() => (this.expect(r), this.tsParseType()));
  }
  tsNextThenParseType() {
    return this.tsInType(() => (this.next(), this.tsParseType()));
  }
  tsParseEnumMember() {
    const r = this.startNode();
    return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
  }
  tsParseEnumDeclaration(r, i = {}) {
    return i.const && (r.const = !0), i.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(r, "TSEnumDeclaration");
  }
  tsParseModuleBlock() {
    const r = this.startNode();
    return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(r, "TSModuleBlock");
  }
  tsParseModuleOrNamespaceDeclaration(r, i = !1) {
    if (r.id = this.parseIdentifier(), i || this.checkIdentifier(r.id, 1024), this.eat(16)) {
      const s = this.startNode();
      this.tsParseModuleOrNamespaceDeclaration(s, !0), r.body = s;
    } else
      this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
    return this.finishNode(r, "TSModuleDeclaration");
  }
  tsParseAmbientExternalModuleDeclaration(r) {
    return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
  }
  tsParseImportEqualsDeclaration(r, i, s) {
    r.isExport = s || !1, r.id = i || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
    const n = this.tsParseModuleReference();
    return r.importKind === "type" && n.type !== "TSExternalModuleReference" && this.raise(le.ImportAliasHasImportType, n), r.moduleReference = n, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
  }
  tsIsExternalModuleReference() {
    return this.isContextual(119) && this.lookaheadCharCode() === 40;
  }
  tsParseModuleReference() {
    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
  }
  tsParseExternalModuleReference() {
    const r = this.startNode();
    return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
  }
  tsLookAhead(r) {
    const i = this.state.clone(), s = r();
    return this.state = i, s;
  }
  tsTryParseAndCatch(r) {
    const i = this.tryParse((s) => r() || s());
    if (!(i.aborted || !i.node))
      return i.error && (this.state = i.failState), i.node;
  }
  tsTryParse(r) {
    const i = this.state.clone(), s = r();
    if (s !== void 0 && s !== !1)
      return s;
    this.state = i;
  }
  tsTryParseDeclare(r) {
    if (this.isLineTerminator())
      return;
    let i = this.state.type, s;
    return this.isContextual(100) && (i = 74, s = "let"), this.tsInAmbientContext(() => {
      switch (i) {
        case 68:
          return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
        case 80:
          return r.declare = !0, this.parseClass(r, !0, !1);
        case 126:
          return this.tsParseEnumDeclaration(r, {
            declare: !0
          });
        case 112:
          return this.tsParseAmbientExternalModuleDeclaration(r);
        case 75:
        case 74:
          return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, s || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
            const: !0,
            declare: !0
          }));
        case 129: {
          const n = this.tsParseInterfaceDeclaration(r, {
            declare: !0
          });
          if (n) return n;
        }
        default:
          if (Le(i))
            return this.tsParseDeclaration(r, this.state.value, !0, null);
      }
    });
  }
  tsTryParseExportDeclaration() {
    return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
  }
  tsParseExpressionStatement(r, i, s) {
    switch (i.name) {
      case "declare": {
        const n = this.tsTryParseDeclare(r);
        return n && (n.declare = !0), n;
      }
      case "global":
        if (this.match(5)) {
          this.scope.enter(256), this.prodParam.enter(0);
          const n = r;
          return n.global = !0, n.id = i, n.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(n, "TSModuleDeclaration");
        }
        break;
      default:
        return this.tsParseDeclaration(r, i.name, !1, s);
    }
  }
  tsParseDeclaration(r, i, s, n) {
    switch (i) {
      case "abstract":
        if (this.tsCheckLineTerminator(s) && (this.match(80) || Le(this.state.type)))
          return this.tsParseAbstractDeclaration(r, n);
        break;
      case "module":
        if (this.tsCheckLineTerminator(s)) {
          if (this.match(133))
            return this.tsParseAmbientExternalModuleDeclaration(r);
          if (Le(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
        }
        break;
      case "namespace":
        if (this.tsCheckLineTerminator(s) && Le(this.state.type))
          return this.tsParseModuleOrNamespaceDeclaration(r);
        break;
      case "type":
        if (this.tsCheckLineTerminator(s) && Le(this.state.type))
          return this.tsParseTypeAliasDeclaration(r);
        break;
    }
  }
  tsCheckLineTerminator(r) {
    return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
  }
  tsTryParseGenericAsyncArrowFunction(r) {
    if (!this.match(47)) return;
    const i = this.state.maybeInArrowParameters;
    this.state.maybeInArrowParameters = !0;
    const s = this.tsTryParseAndCatch(() => {
      const n = this.startNodeAt(r);
      return n.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(n), n.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), n;
    });
    if (this.state.maybeInArrowParameters = i, !!s)
      return super.parseArrowExpression(s, null, !0);
  }
  tsParseTypeArgumentsInExpression() {
    if (this.reScan_lt() === 47)
      return this.tsParseTypeArguments();
  }
  tsParseTypeArguments() {
    const r = this.startNode();
    return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(le.EmptyTypeArguments, r) : !this.state.inType && this.curContext() === $e.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
  }
  tsIsDeclarationStart() {
    return AL(this.state.type);
  }
  isExportDefaultSpecifier() {
    return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
  }
  parseAssignableListItem(r, i) {
    const s = this.state.startLoc, n = {};
    this.tsParseModifiers({
      allowedModifiers: ["public", "private", "protected", "override", "readonly"]
    }, n);
    const a = n.accessibility, o = n.override, l = n.readonly;
    !(r & 4) && (a || l || o) && this.raise(le.UnexpectedParameterModifier, s);
    const u = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(u, r);
    const c = this.parseMaybeDefault(u.loc.start, u);
    if (a || l || o) {
      const f = this.startNodeAt(s);
      return i.length && (f.decorators = i), a && (f.accessibility = a), l && (f.readonly = l), o && (f.override = o), c.type !== "Identifier" && c.type !== "AssignmentPattern" && this.raise(le.UnsupportedParameterPropertyKind, f), f.parameter = c, this.finishNode(f, "TSParameterProperty");
    }
    return i.length && (u.decorators = i), c;
  }
  isSimpleParameter(r) {
    return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
  }
  tsDisallowOptionalPattern(r) {
    for (const i of r.params)
      i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(le.PatternIsOptional, i);
  }
  setArrowFunctionParameters(r, i, s) {
    super.setArrowFunctionParameters(r, i, s), this.tsDisallowOptionalPattern(r);
  }
  parseFunctionBodyAndFinish(r, i, s = !1) {
    this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
    const n = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
    return n && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, n) : n === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(le.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, n, s) : (this.tsDisallowOptionalPattern(r), super.parseFunctionBodyAndFinish(r, i, s));
  }
  registerFunctionStatementId(r) {
    !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
  }
  tsCheckForInvalidTypeCasts(r) {
    r.forEach((i) => {
      (i == null ? void 0 : i.type) === "TSTypeCastExpression" && this.raise(le.UnexpectedTypeAnnotation, i.typeAnnotation);
    });
  }
  toReferencedList(r, i) {
    return this.tsCheckForInvalidTypeCasts(r), r;
  }
  parseArrayLike(r, i, s, n) {
    const a = super.parseArrayLike(r, i, s, n);
    return a.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(a.elements), a;
  }
  parseSubscript(r, i, s, n) {
    if (!this.hasPrecedingLineBreak() && this.match(35)) {
      this.state.canStartJSXElement = !1, this.next();
      const o = this.startNodeAt(i);
      return o.expression = r, this.finishNode(o, "TSNonNullExpression");
    }
    let a = !1;
    if (this.match(18) && this.lookaheadCharCode() === 60) {
      if (s)
        return n.stop = !0, r;
      n.optionalChainMember = a = !0, this.next();
    }
    if (this.match(47) || this.match(51)) {
      let o;
      const l = this.tsTryParseAndCatch(() => {
        if (!s && this.atPossibleAsyncArrow(r)) {
          const p = this.tsTryParseGenericAsyncArrowFunction(i);
          if (p)
            return p;
        }
        const u = this.tsParseTypeArgumentsInExpression();
        if (!u) return;
        if (a && !this.match(10)) {
          o = this.state.curPosition();
          return;
        }
        if (is(this.state.type)) {
          const p = super.parseTaggedTemplateExpression(r, i, n);
          return p.typeParameters = u, p;
        }
        if (!s && this.eat(10)) {
          const p = this.startNodeAt(i);
          return p.callee = r, p.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(p.arguments), p.typeParameters = u, n.optionalChainMember && (p.optional = a), this.finishCallExpression(p, n.optionalChainMember);
        }
        const c = this.state.type;
        if (c === 48 || c === 52 || c !== 10 && Ln(c) && !this.hasPrecedingLineBreak())
          return;
        const f = this.startNodeAt(i);
        return f.expression = r, f.typeParameters = u, this.finishNode(f, "TSInstantiationExpression");
      });
      if (o && this.unexpected(o, 10), l)
        return l.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(le.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), l;
    }
    return super.parseSubscript(r, i, s, n);
  }
  parseNewCallee(r) {
    var i;
    super.parseNewCallee(r);
    const {
      callee: s
    } = r;
    s.type === "TSInstantiationExpression" && !((i = s.extra) != null && i.parenthesized) && (r.typeParameters = s.typeParameters, r.callee = s.expression);
  }
  parseExprOp(r, i, s) {
    let n;
    if (Hi(58) > s && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n = this.isContextual(120)))) {
      const a = this.startNodeAt(i);
      return a.expression = r, a.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n && this.raise(w.UnexpectedKeyword, this.state.startLoc, {
        keyword: "const"
      }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(a, n ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(a, i, s);
    }
    return super.parseExprOp(r, i, s);
  }
  checkReservedWord(r, i, s, n) {
    this.state.isAmbientContext || super.checkReservedWord(r, i, s, n);
  }
  checkImportReflection(r) {
    super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(le.ImportReflectionHasImportType, r.specifiers[0].loc.start);
  }
  checkDuplicateExports() {
  }
  isPotentialImportPhase(r) {
    if (super.isPotentialImportPhase(r)) return !0;
    if (this.isContextual(130)) {
      const i = this.lookaheadCharCode();
      return r ? i === 123 || i === 42 : i !== 61;
    }
    return !r && this.isContextual(87);
  }
  applyImportPhase(r, i, s, n) {
    super.applyImportPhase(r, i, s, n), i ? r.exportKind = s === "type" ? "type" : "value" : r.importKind = s === "type" || s === "typeof" ? s : "value";
  }
  parseImport(r) {
    if (this.match(133))
      return r.importKind = "value", super.parseImport(r);
    let i;
    if (Le(this.state.type) && this.lookaheadCharCode() === 61)
      return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
    if (this.isContextual(130)) {
      const s = this.parseMaybeImportPhase(r, !1);
      if (this.lookaheadCharCode() === 61)
        return this.tsParseImportEqualsDeclaration(r, s);
      i = super.parseImportSpecifiersAndAfter(r, s);
    } else
      i = super.parseImport(r);
    return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(le.TypeImportCannotSpecifyDefaultAndNamed, i), i;
  }
  parseExport(r, i) {
    if (this.match(83)) {
      this.next();
      const s = r;
      let n = null;
      return this.isContextual(130) && this.isPotentialImportPhase(!1) ? n = this.parseMaybeImportPhase(s, !1) : s.importKind = "value", this.tsParseImportEqualsDeclaration(s, n, !0);
    } else if (this.eat(29)) {
      const s = r;
      return s.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(s, "TSExportAssignment");
    } else if (this.eatContextual(93)) {
      const s = r;
      return this.expectContextual(128), s.id = this.parseIdentifier(), this.semicolon(), this.finishNode(s, "TSNamespaceExportDeclaration");
    } else
      return super.parseExport(r, i);
  }
  isAbstractClass() {
    return this.isContextual(124) && this.lookahead().type === 80;
  }
  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      const r = this.startNode();
      return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
    }
    if (this.match(129)) {
      const r = this.tsParseInterfaceDeclaration(this.startNode());
      if (r) return r;
    }
    return super.parseExportDefaultExpression();
  }
  parseVarStatement(r, i, s = !1) {
    const {
      isAmbientContext: n
    } = this.state, a = super.parseVarStatement(r, i, s || n);
    if (!n) return a;
    for (const {
      id: o,
      init: l
    } of a.declarations)
      l && (i !== "const" || o.typeAnnotation ? this.raise(le.InitializerNotAllowedInAmbientContext, l) : xM(l, this.hasPlugin("estree")) || this.raise(le.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, l));
    return a;
  }
  parseStatementContent(r, i) {
    if (this.match(75) && this.isLookaheadContextual("enum")) {
      const s = this.startNode();
      return this.expect(75), this.tsParseEnumDeclaration(s, {
        const: !0
      });
    }
    if (this.isContextual(126))
      return this.tsParseEnumDeclaration(this.startNode());
    if (this.isContextual(129)) {
      const s = this.tsParseInterfaceDeclaration(this.startNode());
      if (s) return s;
    }
    return super.parseStatementContent(r, i);
  }
  parseAccessModifier() {
    return this.tsParseModifier(["public", "protected", "private"]);
  }
  tsHasSomeModifiers(r, i) {
    return i.some((s) => Yl(s) ? r.accessibility === s : !!r[s]);
  }
  tsIsStartOfStaticBlocks() {
    return this.isContextual(106) && this.lookaheadCharCode() === 123;
  }
  parseClassMember(r, i, s) {
    const n = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
    this.tsParseModifiers({
      allowedModifiers: n,
      disallowedModifiers: ["in", "out"],
      stopOnStartOfClassStaticBlock: !0,
      errorTemplate: le.InvalidModifierOnTypeParameterPositions
    }, i);
    const a = () => {
      this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, n) && this.raise(le.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(r, i)) : this.parseClassMemberWithIsStatic(r, i, s, !!i.static);
    };
    i.declare ? this.tsInAmbientContext(a) : a();
  }
  parseClassMemberWithIsStatic(r, i, s, n) {
    const a = this.tsTryParseIndexSignature(i);
    if (a) {
      r.body.push(a), i.abstract && this.raise(le.IndexSignatureHasAbstract, i), i.accessibility && this.raise(le.IndexSignatureHasAccessibility, i, {
        modifier: i.accessibility
      }), i.declare && this.raise(le.IndexSignatureHasDeclare, i), i.override && this.raise(le.IndexSignatureHasOverride, i);
      return;
    }
    !this.state.inAbstractClass && i.abstract && this.raise(le.NonAbstractClassHasAbstractMethod, i), i.override && (s.hadSuperClass || this.raise(le.OverrideNotInSubClass, i)), super.parseClassMemberWithIsStatic(r, i, s, n);
  }
  parsePostMemberNameModifiers(r) {
    this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(le.ClassMethodHasReadonly, r), r.declare && this.match(10) && this.raise(le.ClassMethodHasDeclare, r);
  }
  parseExpressionStatement(r, i, s) {
    return (i.type === "Identifier" ? this.tsParseExpressionStatement(r, i, s) : void 0) || super.parseExpressionStatement(r, i, s);
  }
  shouldParseExportDeclaration() {
    return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
  }
  parseConditional(r, i, s) {
    if (!this.state.maybeInArrowParameters || !this.match(17))
      return super.parseConditional(r, i, s);
    const n = this.tryParse(() => super.parseConditional(r, i));
    return n.node ? (n.error && (this.state = n.failState), n.node) : (n.error && super.setOptionalParametersError(s, n.error), r);
  }
  parseParenItem(r, i) {
    const s = super.parseParenItem(r, i);
    if (this.eat(17) && (s.optional = !0, this.resetEndLocation(r)), this.match(14)) {
      const n = this.startNodeAt(i);
      return n.expression = r, n.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(n, "TSTypeCastExpression");
    }
    return r;
  }
  parseExportDeclaration(r) {
    if (!this.state.isAmbientContext && this.isContextual(125))
      return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
    const i = this.state.startLoc, s = this.eatContextual(125);
    if (s && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
      throw this.raise(le.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
    const a = Le(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
    return a ? ((a.type === "TSInterfaceDeclaration" || a.type === "TSTypeAliasDeclaration" || s) && (r.exportKind = "type"), s && (this.resetStartLocation(a, i), a.declare = !0), a) : null;
  }
  parseClassId(r, i, s, n) {
    if ((!i || s) && this.isContextual(113))
      return;
    super.parseClassId(r, i, s, r.declare ? 1024 : 8331);
    const a = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
    a && (r.typeParameters = a);
  }
  parseClassPropertyAnnotation(r) {
    r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
    const i = this.tsTryParseTypeAnnotation();
    i && (r.typeAnnotation = i);
  }
  parseClassProperty(r) {
    if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.raise(le.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
      const {
        key: i
      } = r;
      this.raise(le.AbstractPropertyHasInitializer, this.state.startLoc, {
        propertyName: i.type === "Identifier" && !r.computed ? i.name : `[${this.input.slice(i.start, i.end)}]`
      });
    }
    return super.parseClassProperty(r);
  }
  parseClassPrivateProperty(r) {
    return r.abstract && this.raise(le.PrivateElementHasAbstract, r), r.accessibility && this.raise(le.PrivateElementHasAccessibility, r, {
      modifier: r.accessibility
    }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
  }
  parseClassAccessorProperty(r) {
    return this.parseClassPropertyAnnotation(r), r.optional && this.raise(le.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(r);
  }
  pushClassMethod(r, i, s, n, a, o) {
    const l = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    l && a && this.raise(le.ConstructorHasTypeParameters, l);
    const {
      declare: u = !1,
      kind: c
    } = i;
    u && (c === "get" || c === "set") && this.raise(le.DeclareAccessor, i, {
      kind: c
    }), l && (i.typeParameters = l), super.pushClassMethod(r, i, s, n, a, o);
  }
  pushClassPrivateMethod(r, i, s, n) {
    const a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    a && (i.typeParameters = a), super.pushClassPrivateMethod(r, i, s, n);
  }
  declareClassPrivateMethodInScope(r, i) {
    r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !hasOwnProperty.call(r.value, "body") || super.declareClassPrivateMethodInScope(r, i));
  }
  parseClassSuper(r) {
    super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
  }
  parseObjPropValue(r, i, s, n, a, o, l) {
    const u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    return u && (r.typeParameters = u), super.parseObjPropValue(r, i, s, n, a, o, l);
  }
  parseFunctionParams(r, i) {
    const s = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    s && (r.typeParameters = s), super.parseFunctionParams(r, i);
  }
  parseVarId(r, i) {
    super.parseVarId(r, i), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
    const s = this.tsTryParseTypeAnnotation();
    s && (r.id.typeAnnotation = s, this.resetEndLocation(r.id));
  }
  parseAsyncArrowFromCallExpression(r, i) {
    return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, i);
  }
  parseMaybeAssign(r, i) {
    var s, n, a, o, l;
    let u, c, f;
    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
      if (u = this.state.clone(), c = this.tryParse(() => super.parseMaybeAssign(r, i), u), !c.error) return c.node;
      const {
        context: y
      } = this.state, b = y[y.length - 1];
      (b === $e.j_oTag || b === $e.j_expr) && y.pop();
    }
    if (!((s = c) != null && s.error) && !this.match(47))
      return super.parseMaybeAssign(r, i);
    (!u || u === this.state) && (u = this.state.clone());
    let p;
    const h = this.tryParse((y) => {
      var b, A;
      p = this.tsParseTypeParameters(this.tsParseConstModifier);
      const I = super.parseMaybeAssign(r, i);
      return (I.type !== "ArrowFunctionExpression" || (b = I.extra) != null && b.parenthesized) && y(), ((A = p) == null ? void 0 : A.params.length) !== 0 && this.resetStartLocationFromNode(I, p), I.typeParameters = p, I;
    }, u);
    if (!h.error && !h.aborted)
      return p && this.reportReservedArrowTypeParam(p), h.node;
    if (!c && (Xl(!this.hasPlugin("jsx")), f = this.tryParse(() => super.parseMaybeAssign(r, i), u), !f.error))
      return f.node;
    if ((n = c) != null && n.node)
      return this.state = c.failState, c.node;
    if (h.node)
      return this.state = h.failState, p && this.reportReservedArrowTypeParam(p), h.node;
    if ((a = f) != null && a.node)
      return this.state = f.failState, f.node;
    throw ((o = c) == null ? void 0 : o.error) || h.error || ((l = f) == null ? void 0 : l.error);
  }
  reportReservedArrowTypeParam(r) {
    var i;
    r.params.length === 1 && !r.params[0].constraint && !((i = r.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(le.ReservedArrowTypeParam, r);
  }
  parseMaybeUnary(r, i) {
    return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, i);
  }
  parseArrow(r) {
    if (this.match(14)) {
      const i = this.tryParse((s) => {
        const n = this.tsParseTypeOrTypePredicateAnnotation(14);
        return (this.canInsertSemicolon() || !this.match(19)) && s(), n;
      });
      if (i.aborted) return;
      i.thrown || (i.error && (this.state = i.failState), r.returnType = i.node);
    }
    return super.parseArrow(r);
  }
  parseAssignableListItemTypes(r, i) {
    if (!(i & 2)) return r;
    this.eat(17) && (r.optional = !0);
    const s = this.tsTryParseTypeAnnotation();
    return s && (r.typeAnnotation = s), this.resetEndLocation(r), r;
  }
  isAssignable(r, i) {
    switch (r.type) {
      case "TSTypeCastExpression":
        return this.isAssignable(r.expression, i);
      case "TSParameterProperty":
        return !0;
      default:
        return super.isAssignable(r, i);
    }
  }
  toAssignable(r, i = !1) {
    switch (r.type) {
      case "ParenthesizedExpression":
        this.toAssignableParenthesizedExpression(r, i);
        break;
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        i ? this.expressionScope.recordArrowParameterBindingError(le.UnexpectedTypeCastInParameter, r) : this.raise(le.UnexpectedTypeCastInParameter, r), this.toAssignable(r.expression, i);
        break;
      case "AssignmentExpression":
        !i && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
      default:
        super.toAssignable(r, i);
    }
  }
  toAssignableParenthesizedExpression(r, i) {
    switch (r.expression.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
      case "ParenthesizedExpression":
        this.toAssignable(r.expression, i);
        break;
      default:
        super.toAssignable(r, i);
    }
  }
  checkToRestConversion(r, i) {
    switch (r.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        this.checkToRestConversion(r.expression, !1);
        break;
      default:
        super.checkToRestConversion(r, i);
    }
  }
  isValidLVal(r, i, s) {
    return TM({
      TSTypeCastExpression: !0,
      TSParameterProperty: "parameter",
      TSNonNullExpression: "expression",
      TSInstantiationExpression: "expression",
      TSAsExpression: (s !== 64 || !i) && ["expression", !0],
      TSSatisfiesExpression: (s !== 64 || !i) && ["expression", !0],
      TSTypeAssertion: (s !== 64 || !i) && ["expression", !0]
    }, r) || super.isValidLVal(r, i, s);
  }
  parseBindingAtom() {
    return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
  }
  parseMaybeDecoratorArguments(r) {
    if (this.match(47) || this.match(51)) {
      const i = this.tsParseTypeArgumentsInExpression();
      if (this.match(10)) {
        const s = super.parseMaybeDecoratorArguments(r);
        return s.typeParameters = i, s;
      }
      this.unexpected(null, 10);
    }
    return super.parseMaybeDecoratorArguments(r);
  }
  checkCommaAfterRest(r) {
    return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(r);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(35) || this.match(14) || super.isClassProperty();
  }
  parseMaybeDefault(r, i) {
    const s = super.parseMaybeDefault(r, i);
    return s.type === "AssignmentPattern" && s.typeAnnotation && s.right.start < s.typeAnnotation.start && this.raise(le.TypeAnnotationAfterAssign, s.typeAnnotation), s;
  }
  getTokenFromCode(r) {
    if (this.state.inType) {
      if (r === 62) {
        this.finishOp(48, 1);
        return;
      }
      if (r === 60) {
        this.finishOp(47, 1);
        return;
      }
    }
    super.getTokenFromCode(r);
  }
  reScan_lt_gt() {
    const {
      type: r
    } = this.state;
    r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
  }
  reScan_lt() {
    const {
      type: r
    } = this.state;
    return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
  }
  toAssignableList(r, i, s) {
    for (let n = 0; n < r.length; n++) {
      const a = r[n];
      (a == null ? void 0 : a.type) === "TSTypeCastExpression" && (r[n] = this.typeCastToParameter(a));
    }
    super.toAssignableList(r, i, s);
  }
  typeCastToParameter(r) {
    return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
  }
  shouldParseArrow(r) {
    return this.match(14) ? r.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(r);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  canHaveLeadingDecorator() {
    return super.canHaveLeadingDecorator() || this.isAbstractClass();
  }
  jsxParseOpeningElementAfterName(r) {
    if (this.match(47) || this.match(51)) {
      const i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
      i && (r.typeParameters = i);
    }
    return super.jsxParseOpeningElementAfterName(r);
  }
  getGetterSetterExpectedParamCount(r) {
    const i = super.getGetterSetterExpectedParamCount(r), n = this.getObjectOrClassMethodParams(r)[0];
    return n && this.isThisParam(n) ? i + 1 : i;
  }
  parseCatchClauseParam() {
    const r = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
    return i && (r.typeAnnotation = i, this.resetEndLocation(r)), r;
  }
  tsInAmbientContext(r) {
    const {
      isAmbientContext: i,
      strict: s
    } = this.state;
    this.state.isAmbientContext = !0, this.state.strict = !1;
    try {
      return r();
    } finally {
      this.state.isAmbientContext = i, this.state.strict = s;
    }
  }
  parseClass(r, i, s) {
    const n = this.state.inAbstractClass;
    this.state.inAbstractClass = !!r.abstract;
    try {
      return super.parseClass(r, i, s);
    } finally {
      this.state.inAbstractClass = n;
    }
  }
  tsParseAbstractDeclaration(r, i) {
    if (this.match(80))
      return r.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(r, !0, !1));
    if (this.isContextual(129)) {
      if (!this.hasFollowingLineBreak())
        return r.abstract = !0, this.raise(le.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
    } else
      this.unexpected(null, 80);
  }
  parseMethod(r, i, s, n, a, o, l) {
    const u = super.parseMethod(r, i, s, n, a, o, l);
    if (u.abstract && (this.hasPlugin("estree") ? !!u.value.body : !!u.body)) {
      const {
        key: f
      } = u;
      this.raise(le.AbstractMethodHasImplementation, u, {
        methodName: f.type === "Identifier" && !u.computed ? f.name : `[${this.input.slice(f.start, f.end)}]`
      });
    }
    return u;
  }
  tsParseTypeParameterName() {
    return this.parseIdentifier().name;
  }
  shouldParseAsAmbientContext() {
    return !!this.getPluginOption("typescript", "dts");
  }
  parse() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
  }
  getExpression() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
  }
  parseExportSpecifier(r, i, s, n) {
    return !i && n ? (this.parseTypeOnlyImportExportSpecifier(r, !1, s), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value", super.parseExportSpecifier(r, i, s, n));
  }
  parseImportSpecifier(r, i, s, n, a) {
    return !i && n ? (this.parseTypeOnlyImportExportSpecifier(r, !0, s), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value", super.parseImportSpecifier(r, i, s, n, s ? 4098 : 4096));
  }
  parseTypeOnlyImportExportSpecifier(r, i, s) {
    const n = i ? "imported" : "local", a = i ? "local" : "exported";
    let o = r[n], l, u = !1, c = !0;
    const f = o.loc.start;
    if (this.isContextual(93)) {
      const h = this.parseIdentifier();
      if (this.isContextual(93)) {
        const y = this.parseIdentifier();
        At(this.state.type) ? (u = !0, o = h, l = i ? this.parseIdentifier() : this.parseModuleExportName(), c = !1) : (l = y, c = !1);
      } else At(this.state.type) ? (c = !1, l = i ? this.parseIdentifier() : this.parseModuleExportName()) : (u = !0, o = h);
    } else At(this.state.type) && (u = !0, i ? (o = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, !0, !0)) : o = this.parseModuleExportName());
    u && s && this.raise(i ? le.TypeModifierIsUsedInTypeImports : le.TypeModifierIsUsedInTypeExports, f), r[n] = o, r[a] = l;
    const p = i ? "importKind" : "exportKind";
    r[p] = u ? "type" : "value", c && this.eatContextual(93) && (r[a] = i ? this.parseIdentifier() : this.parseModuleExportName()), r[a] || (r[a] = $t(r[n])), i && this.checkIdentifier(r[a], u ? 4098 : 4096);
  }
};
function PM(e) {
  if (e.type !== "MemberExpression") return !1;
  const {
    computed: t,
    property: r
  } = e;
  return t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : uf(e.object);
}
function xM(e, t) {
  var r;
  const {
    type: i
  } = e;
  if ((r = e.extra) != null && r.parenthesized)
    return !1;
  if (t) {
    if (i === "Literal") {
      const {
        value: s
      } = e;
      if (typeof s == "string" || typeof s == "boolean")
        return !0;
    }
  } else if (i === "StringLiteral" || i === "BooleanLiteral")
    return !0;
  return !!(lf(e, t) || vM(e, t) || i === "TemplateLiteral" && e.expressions.length === 0 || PM(e));
}
function lf(e, t) {
  return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLiteral";
}
function vM(e, t) {
  if (e.type === "UnaryExpression") {
    const {
      operator: r,
      argument: i
    } = e;
    if (r === "-" && lf(i, t))
      return !0;
  }
  return !1;
}
function uf(e) {
  return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : uf(e.object);
}
const Hl = Ut`placeholders`({
  ClassNameIsRequired: "A class name is required.",
  UnexpectedSpace: "Unexpected space in placeholder."
});
var AM = (e) => class extends e {
  parsePlaceholder(r) {
    if (this.match(144)) {
      const i = this.startNode();
      return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(i, r);
    }
  }
  finishPlaceholder(r, i) {
    let s = r;
    return (!s.expectedNode || !s.type) && (s = this.finishNode(s, "Placeholder")), s.expectedNode = i, s;
  }
  getTokenFromCode(r) {
    r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
  }
  parseExprAtom(r) {
    return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
  }
  parseIdentifier(r) {
    return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
  }
  checkReservedWord(r, i, s, n) {
    r !== void 0 && super.checkReservedWord(r, i, s, n);
  }
  parseBindingAtom() {
    return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
  }
  isValidLVal(r, i, s) {
    return r === "Placeholder" || super.isValidLVal(r, i, s);
  }
  toAssignable(r, i) {
    r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, i);
  }
  chStartsBindingIdentifier(r, i) {
    return !!(super.chStartsBindingIdentifier(r, i) || this.lookahead().type === 144);
  }
  verifyBreakContinue(r, i) {
    r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, i);
  }
  parseExpressionStatement(r, i) {
    var s;
    if (i.type !== "Placeholder" || (s = i.extra) != null && s.parenthesized)
      return super.parseExpressionStatement(r, i);
    if (this.match(14)) {
      const a = r;
      return a.label = this.finishPlaceholder(i, "Identifier"), this.next(), a.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(a, "LabeledStatement");
    }
    this.semicolon();
    const n = r;
    return n.name = i.name, this.finishPlaceholder(n, "Statement");
  }
  parseBlock(r, i, s) {
    return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, i, s);
  }
  parseFunctionId(r) {
    return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
  }
  parseClass(r, i, s) {
    const n = i ? "ClassDeclaration" : "ClassExpression";
    this.next();
    const a = this.state.strict, o = this.parsePlaceholder("Identifier");
    if (o)
      if (this.match(81) || this.match(144) || this.match(5))
        r.id = o;
      else {
        if (s || !i)
          return r.id = null, r.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(r, n);
        throw this.raise(Hl.ClassNameIsRequired, this.state.startLoc);
      }
    else
      this.parseClassId(r, i, s);
    return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, a), this.finishNode(r, n);
  }
  parseExport(r, i) {
    const s = this.parsePlaceholder("Identifier");
    if (!s) return super.parseExport(r, i);
    const n = r;
    if (!this.isContextual(98) && !this.match(12))
      return n.specifiers = [], n.source = null, n.declaration = this.finishPlaceholder(s, "Declaration"), this.finishNode(n, "ExportNamedDeclaration");
    this.expectPlugin("exportDefaultFrom");
    const a = this.startNode();
    return a.exported = s, n.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(n, i);
  }
  isExportDefaultSpecifier() {
    if (this.match(65)) {
      const r = this.nextTokenStart();
      if (this.isUnparsedContextual(r, "from") && this.input.startsWith(zt(144), this.nextTokenStartSince(r + 4)))
        return !0;
    }
    return super.isExportDefaultSpecifier();
  }
  maybeParseExportDefaultSpecifier(r, i) {
    var s;
    return (s = r.specifiers) != null && s.length ? !0 : super.maybeParseExportDefaultSpecifier(r, i);
  }
  checkExport(r) {
    const {
      specifiers: i
    } = r;
    i != null && i.length && (r.specifiers = i.filter((s) => s.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = i;
  }
  parseImport(r) {
    const i = this.parsePlaceholder("Identifier");
    if (!i) return super.parseImport(r);
    if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
      return r.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
    const s = this.startNodeAtNode(i);
    return s.local = i, r.specifiers.push(this.finishNode(s, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(r, "ImportDeclaration");
  }
  parseImportSource() {
    return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
  }
  assertNoSpace() {
    this.state.start > this.state.lastTokEndLoc.index && this.raise(Hl.UnexpectedSpace, this.state.lastTokEndLoc);
  }
}, CM = (e) => class extends e {
  parseV8Intrinsic() {
    if (this.match(54)) {
      const r = this.state.startLoc, i = this.startNode();
      if (this.next(), Le(this.state.type)) {
        const s = this.parseIdentifierName(), n = this.createIdentifier(i, s);
        if (n.type = "V8IntrinsicIdentifier", this.match(10))
          return n;
      }
      this.unexpected(r);
    }
  }
  parseExprAtom(r) {
    return this.parseV8Intrinsic() || super.parseExprAtom(r);
  }
};
function st(e, t) {
  const [r, i] = typeof t == "string" ? [t, {}] : t, s = Object.keys(i), n = s.length === 0;
  return e.some((a) => {
    if (typeof a == "string")
      return n && a === r;
    {
      const [o, l] = a;
      if (o !== r)
        return !1;
      for (const u of s)
        if (l[u] !== i[u])
          return !1;
      return !0;
    }
  });
}
function ir(e, t, r) {
  const i = e.find((s) => Array.isArray(s) ? s[0] === t : s === t);
  return i && Array.isArray(i) && i.length > 1 ? i[1][r] : null;
}
const Gl = ["minimal", "fsharp", "hack", "smart"], zl = ["^^", "@@", "^", "%", "#"];
function IM(e) {
  if (st(e, "decorators")) {
    if (st(e, "decorators-legacy"))
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    const t = ir(e, "decorators", "decoratorsBeforeExport");
    if (t != null && typeof t != "boolean")
      throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
    const r = ir(e, "decorators", "allowCallParenthesized");
    if (r != null && typeof r != "boolean")
      throw new Error("'allowCallParenthesized' must be a boolean.");
  }
  if (st(e, "flow") && st(e, "typescript"))
    throw new Error("Cannot combine flow and typescript plugins.");
  if (st(e, "placeholders") && st(e, "v8intrinsic"))
    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  if (st(e, "pipelineOperator")) {
    const t = ir(e, "pipelineOperator", "proposal");
    if (!Gl.includes(t)) {
      const s = Gl.map((n) => `"${n}"`).join(", ");
      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s}.`);
    }
    const r = ["recordAndTuple", {
      syntaxType: "hash"
    }], i = st(e, r);
    if (t === "hack") {
      if (st(e, "placeholders"))
        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
      if (st(e, "v8intrinsic"))
        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
      const s = ir(e, "pipelineOperator", "topicToken");
      if (!zl.includes(s)) {
        const n = zl.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${n}.`);
      }
      if (s === "#" && i)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(r)}\`.`);
    } else if (t === "smart" && i)
      throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(r)}\`.`);
  }
  if (st(e, "moduleAttributes")) {
    if (st(e, "importAssertions") || st(e, "importAttributes"))
      throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
    if (ir(e, "moduleAttributes", "version") !== "may-2020")
      throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
  }
  if (st(e, "importAssertions") && st(e, "importAttributes"))
    throw new Error("Cannot combine importAssertions and importAttributes plugins.");
  if (st(e, "recordAndTuple")) {
    const t = ir(e, "recordAndTuple", "syntaxType");
    if (t != null) {
      const r = ["hash", "bar"];
      if (!r.includes(t))
        throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + r.map((i) => `'${i}'`).join(", "));
    }
  }
  if (st(e, "asyncDoExpressions") && !st(e, "doExpressions")) {
    const t = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
    throw t.missingPlugins = "doExpressions", t;
  }
  if (st(e, "optionalChainingAssign") && ir(e, "optionalChainingAssign", "version") !== "2023-07")
    throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
}
const cf = {
  estree: dL,
  jsx: pM,
  flow: cM,
  typescript: EM,
  v8intrinsic: CM,
  placeholders: AM
}, wM = Object.keys(cf), dn = {
  sourceType: "script",
  sourceFilename: void 0,
  startColumn: 0,
  startLine: 1,
  allowAwaitOutsideFunction: !1,
  allowReturnOutsideFunction: !1,
  allowNewTargetOutsideFunction: !1,
  allowImportExportEverywhere: !1,
  allowSuperOutsideMethod: !1,
  allowUndeclaredExports: !1,
  plugins: [],
  strictMode: null,
  ranges: !1,
  tokens: !1,
  createImportExpressions: !1,
  createParenthesizedExpressions: !1,
  errorRecovery: !1,
  attachComment: !0,
  annexB: !0
};
function OM(e) {
  if (e == null)
    return Object.assign({}, dn);
  if (e.annexB != null && e.annexB !== !1)
    throw new Error("The `annexB` option can only be set to `false`.");
  const t = {};
  for (const i of Object.keys(dn)) {
    var r;
    t[i] = (r = e[i]) != null ? r : dn[i];
  }
  return t;
}
class NM extends yM {
  checkProto(t, r, i, s) {
    if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
      return;
    const n = t.key;
    if ((n.type === "Identifier" ? n.name : n.value) === "__proto__") {
      if (r) {
        this.raise(w.RecordNoProto, n);
        return;
      }
      i.used && (s ? s.doubleProtoLoc === null && (s.doubleProtoLoc = n.loc.start) : this.raise(w.DuplicateProto, n)), i.used = !0;
    }
  }
  shouldExitDescending(t, r) {
    return t.type === "ArrowFunctionExpression" && t.start === r;
  }
  getExpression() {
    this.enterInitialScopes(), this.nextToken();
    const t = this.parseExpression();
    return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
  }
  parseExpression(t, r) {
    return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
  }
  parseExpressionBase(t) {
    const r = this.state.startLoc, i = this.parseMaybeAssign(t);
    if (this.match(12)) {
      const s = this.startNodeAt(r);
      for (s.expressions = [i]; this.eat(12); )
        s.expressions.push(this.parseMaybeAssign(t));
      return this.toReferencedList(s.expressions), this.finishNode(s, "SequenceExpression");
    }
    return i;
  }
  parseMaybeAssignDisallowIn(t, r) {
    return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
  }
  parseMaybeAssignAllowIn(t, r) {
    return this.allowInAnd(() => this.parseMaybeAssign(t, r));
  }
  setOptionalParametersError(t, r) {
    var i;
    t.optionalParametersLoc = (i = r == null ? void 0 : r.loc) != null ? i : this.state.startLoc;
  }
  parseMaybeAssign(t, r) {
    const i = this.state.startLoc;
    if (this.isContextual(108) && this.prodParam.hasYield) {
      let o = this.parseYield();
      return r && (o = r.call(this, o, i)), o;
    }
    let s;
    t ? s = !1 : (t = new Qi(), s = !0);
    const {
      type: n
    } = this.state;
    (n === 10 || Le(n)) && (this.state.potentialArrowAt = this.state.start);
    let a = this.parseMaybeConditional(t);
    if (r && (a = r.call(this, a, i)), bL(this.state.type)) {
      const o = this.startNodeAt(i), l = this.state.value;
      if (o.operator = l, this.match(29)) {
        this.toAssignable(a, !0), o.left = a;
        const u = i.index;
        t.doubleProtoLoc != null && t.doubleProtoLoc.index >= u && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= u && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= u && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null);
      } else
        o.left = a;
      return this.next(), o.right = this.parseMaybeAssign(), this.checkLVal(a, {
        in: this.finishNode(o, "AssignmentExpression")
      }), o;
    } else s && this.checkExpressionErrors(t, !0);
    return a;
  }
  parseMaybeConditional(t) {
    const r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseExprOps(t);
    return this.shouldExitDescending(s, i) ? s : this.parseConditional(s, r, t);
  }
  parseConditional(t, r, i) {
    if (this.eat(17)) {
      const s = this.startNodeAt(r);
      return s.test = t, s.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), s.alternate = this.parseMaybeAssign(), this.finishNode(s, "ConditionalExpression");
    }
    return t;
  }
  parseMaybeUnaryOrPrivate(t) {
    return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t);
  }
  parseExprOps(t) {
    const r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseMaybeUnaryOrPrivate(t);
    return this.shouldExitDescending(s, i) ? s : this.parseExprOp(s, r, -1);
  }
  parseExprOp(t, r, i) {
    if (this.isPrivateName(t)) {
      const n = this.getPrivateNameSV(t);
      (i >= Hi(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(w.PrivateInExpectedIn, t, {
        identifierName: n
      }), this.classScope.usePrivateName(n, t.loc.start);
    }
    const s = this.state.type;
    if (EL(s) && (this.prodParam.hasIn || !this.match(58))) {
      let n = Hi(s);
      if (n > i) {
        if (s === 39) {
          if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
            return t;
          this.checkPipelineAtInfixOperator(t, r);
        }
        const a = this.startNodeAt(r);
        a.left = t, a.operator = this.state.value;
        const o = s === 41 || s === 42, l = s === 40;
        if (l && (n = Hi(42)), this.next(), s === 39 && this.hasPlugin(["pipelineOperator", {
          proposal: "minimal"
        }]) && this.state.type === 96 && this.prodParam.hasAwait)
          throw this.raise(w.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
        a.right = this.parseExprOpRightExpr(s, n);
        const u = this.finishNode(a, o || l ? "LogicalExpression" : "BinaryExpression"), c = this.state.type;
        if (l && (c === 41 || c === 42) || o && c === 40)
          throw this.raise(w.MixingCoalesceWithLogical, this.state.startLoc);
        return this.parseExprOp(u, r, i);
      }
    }
    return t;
  }
  parseExprOpRightExpr(t, r) {
    const i = this.state.startLoc;
    switch (t) {
      case 39:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => this.parseHackPipeBody());
          case "smart":
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(w.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), i);
            });
          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
        }
      default:
        return this.parseExprOpBaseRightExpr(t, r);
    }
  }
  parseExprOpBaseRightExpr(t, r) {
    const i = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, CL(t) ? r - 1 : r);
  }
  parseHackPipeBody() {
    var t;
    const {
      startLoc: r
    } = this.state, i = this.parseMaybeAssign();
    return lL.has(i.type) && !((t = i.extra) != null && t.parenthesized) && this.raise(w.PipeUnparenthesizedBody, r, {
      type: i.type
    }), this.topicReferenceWasUsedInCurrentContext() || this.raise(w.PipeTopicUnused, r), i;
  }
  checkExponentialAfterUnary(t) {
    this.match(57) && this.raise(w.UnexpectedTokenUnaryExponentiation, t.argument);
  }
  parseMaybeUnary(t, r) {
    const i = this.state.startLoc, s = this.isContextual(96);
    if (s && this.isAwaitAllowed()) {
      this.next();
      const l = this.parseAwait(i);
      return r || this.checkExponentialAfterUnary(l), l;
    }
    const n = this.match(34), a = this.startNode();
    if (xL(this.state.type)) {
      a.operator = this.state.value, a.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
      const l = this.match(89);
      if (this.next(), a.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && l) {
        const u = a.argument;
        u.type === "Identifier" ? this.raise(w.StrictDelete, a) : this.hasPropertyAsPrivateName(u) && this.raise(w.DeletePrivateField, a);
      }
      if (!n)
        return r || this.checkExponentialAfterUnary(a), this.finishNode(a, "UnaryExpression");
    }
    const o = this.parseUpdate(a, n, t);
    if (s) {
      const {
        type: l
      } = this.state;
      if ((this.hasPlugin("v8intrinsic") ? Ln(l) : Ln(l) && !this.match(54)) && !this.isAmbiguousAwait())
        return this.raiseOverwrite(w.AwaitNotInAsyncContext, i), this.parseAwait(i);
    }
    return o;
  }
  parseUpdate(t, r, i) {
    if (r) {
      const a = t;
      return this.checkLVal(a.argument, {
        in: this.finishNode(a, "UpdateExpression")
      }), t;
    }
    const s = this.state.startLoc;
    let n = this.parseExprSubscripts(i);
    if (this.checkExpressionErrors(i, !1)) return n;
    for (; PL(this.state.type) && !this.canInsertSemicolon(); ) {
      const a = this.startNodeAt(s);
      a.operator = this.state.value, a.prefix = !1, a.argument = n, this.next(), this.checkLVal(n, {
        in: n = this.finishNode(a, "UpdateExpression")
      });
    }
    return n;
  }
  parseExprSubscripts(t) {
    const r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseExprAtom(t);
    return this.shouldExitDescending(s, i) ? s : this.parseSubscripts(s, r);
  }
  parseSubscripts(t, r, i) {
    const s = {
      optionalChainMember: !1,
      maybeAsyncArrow: this.atPossibleAsyncArrow(t),
      stop: !1
    };
    do
      t = this.parseSubscript(t, r, i, s), s.maybeAsyncArrow = !1;
    while (!s.stop);
    return t;
  }
  parseSubscript(t, r, i, s) {
    const {
      type: n
    } = this.state;
    if (!i && n === 15)
      return this.parseBind(t, r, i, s);
    if (is(n))
      return this.parseTaggedTemplateExpression(t, r, s);
    let a = !1;
    if (n === 18) {
      if (i && (this.raise(w.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
        return s.stop = !0, t;
      s.optionalChainMember = a = !0, this.next();
    }
    if (!i && this.match(10))
      return this.parseCoverCallAndAsyncArrowHead(t, r, s, a);
    {
      const o = this.eat(0);
      return o || a || this.eat(16) ? this.parseMember(t, r, s, o, a) : (s.stop = !0, t);
    }
  }
  parseMember(t, r, i, s, n) {
    const a = this.startNodeAt(r);
    return a.object = t, a.computed = s, s ? (a.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (t.type === "Super" && this.raise(w.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), a.property = this.parsePrivateName()) : a.property = this.parseIdentifier(!0), i.optionalChainMember ? (a.optional = n, this.finishNode(a, "OptionalMemberExpression")) : this.finishNode(a, "MemberExpression");
  }
  parseBind(t, r, i, s) {
    const n = this.startNodeAt(r);
    return n.object = t, this.next(), n.callee = this.parseNoCallExpr(), s.stop = !0, this.parseSubscripts(this.finishNode(n, "BindExpression"), r, i);
  }
  parseCoverCallAndAsyncArrowHead(t, r, i, s) {
    const n = this.state.maybeInArrowParameters;
    let a = null;
    this.state.maybeInArrowParameters = !0, this.next();
    const o = this.startNodeAt(r);
    o.callee = t;
    const {
      maybeAsyncArrow: l,
      optionalChainMember: u
    } = i;
    l && (this.expressionScope.enter(ZL()), a = new Qi()), u && (o.optional = s), s ? o.arguments = this.parseCallExpressionArguments(11) : o.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", o, a);
    let c = this.finishCallExpression(o, u);
    return l && this.shouldParseAsyncArrow() && !s ? (i.stop = !0, this.checkDestructuringPrivate(a), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), c)) : (l && (this.checkExpressionErrors(a, !0), this.expressionScope.exit()), this.toReferencedArguments(c)), this.state.maybeInArrowParameters = n, c;
  }
  toReferencedArguments(t, r) {
    this.toReferencedListDeep(t.arguments, r);
  }
  parseTaggedTemplateExpression(t, r, i) {
    const s = this.startNodeAt(r);
    return s.tag = t, s.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(w.OptionalChainingNoTemplate, r), this.finishNode(s, "TaggedTemplateExpression");
  }
  atPossibleAsyncArrow(t) {
    return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && t.start === this.state.potentialArrowAt;
  }
  expectImportAttributesPlugin() {
    this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
  }
  finishCallExpression(t, r) {
    if (t.callee.type === "Import")
      if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t.arguments.length === 0 || t.arguments.length > 2)
        this.raise(w.ImportCallArity, t, {
          maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
        });
      else
        for (const i of t.arguments)
          i.type === "SpreadElement" && this.raise(w.ImportCallSpreadArgument, i);
    return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
  }
  parseCallExpressionArguments(t, r, i, s, n) {
    const a = [];
    let o = !0;
    const l = this.state.inFSharpPipelineDirectBody;
    for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t); ) {
      if (o)
        o = !1;
      else if (this.expect(12), this.match(t)) {
        r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(w.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), s && this.addTrailingCommaExtraToNode(s), this.next();
        break;
      }
      a.push(this.parseExprListItem(!1, n, i));
    }
    return this.state.inFSharpPipelineDirectBody = l, a;
  }
  shouldParseAsyncArrow() {
    return this.match(19) && !this.canInsertSemicolon();
  }
  parseAsyncArrowFromCallExpression(t, r) {
    var i;
    return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, !0, (i = r.extra) == null ? void 0 : i.trailingCommaLoc), r.innerComments && zr(t, r.innerComments), r.callee.trailingComments && zr(t, r.callee.trailingComments), t;
  }
  parseNoCallExpr() {
    const t = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), t, !0);
  }
  parseExprAtom(t) {
    let r, i = null;
    const {
      type: s
    } = this.state;
    switch (s) {
      case 79:
        return this.parseSuper();
      case 83:
        return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(w.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(r, "Import"));
      case 78:
        return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
      case 90:
        return this.parseDo(this.startNode(), !1);
      case 56:
      case 31:
        return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
      case 134:
        return this.parseNumericLiteral(this.state.value);
      case 135:
        return this.parseBigIntLiteral(this.state.value);
      case 136:
        return this.parseDecimalLiteral(this.state.value);
      case 133:
        return this.parseStringLiteral(this.state.value);
      case 84:
        return this.parseNullLiteral();
      case 85:
        return this.parseBooleanLiteral(!0);
      case 86:
        return this.parseBooleanLiteral(!1);
      case 10: {
        const n = this.state.potentialArrowAt === this.state.start;
        return this.parseParenAndDistinguishExpression(n);
      }
      case 2:
      case 1:
        return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
      case 0:
        return this.parseArrayLike(3, !0, !1, t);
      case 6:
      case 7:
        return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
      case 5:
        return this.parseObjectLike(8, !1, !1, t);
      case 68:
        return this.parseFunctionOrFunctionSent();
      case 26:
        i = this.parseDecorators();
      case 80:
        return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
      case 77:
        return this.parseNewOrNewTarget();
      case 25:
      case 24:
        return this.parseTemplate(!1);
      case 15: {
        r = this.startNode(), this.next(), r.object = null;
        const n = r.callee = this.parseNoCallExpr();
        if (n.type === "MemberExpression")
          return this.finishNode(r, "BindExpression");
        throw this.raise(w.UnsupportedBind, n);
      }
      case 138:
        return this.raise(w.PrivateInExpectedIn, this.state.startLoc, {
          identifierName: this.state.value
        }), this.parsePrivateName();
      case 33:
        return this.parseTopicReferenceThenEqualsSign(54, "%");
      case 32:
        return this.parseTopicReferenceThenEqualsSign(44, "^");
      case 37:
      case 38:
        return this.parseTopicReference("hack");
      case 44:
      case 54:
      case 27: {
        const n = this.getPluginOption("pipelineOperator", "proposal");
        if (n)
          return this.parseTopicReference(n);
        this.unexpected();
        break;
      }
      case 47: {
        const n = this.input.codePointAt(this.nextTokenStart());
        Rt(n) || n === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
        break;
      }
      default:
        if (Le(s)) {
          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
            return this.parseModuleExpression();
          const n = this.state.potentialArrowAt === this.state.start, a = this.state.containsEsc, o = this.parseIdentifier();
          if (!a && o.name === "async" && !this.canInsertSemicolon()) {
            const {
              type: l
            } = this.state;
            if (l === 68)
              return this.resetPreviousNodeTrailingComments(o), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o));
            if (Le(l))
              return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o)) : o;
            if (l === 90)
              return this.resetPreviousNodeTrailingComments(o), this.parseDo(this.startNodeAtNode(o), !0);
          }
          return n && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o), [o], !1)) : o;
        } else
          this.unexpected();
    }
  }
  parseTopicReferenceThenEqualsSign(t, r) {
    const i = this.getPluginOption("pipelineOperator", "proposal");
    if (i)
      return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = ht(this.state.endLoc, -1), this.parseTopicReference(i);
    this.unexpected();
  }
  parseTopicReference(t) {
    const r = this.startNode(), i = this.state.startLoc, s = this.state.type;
    return this.next(), this.finishTopicReference(r, i, t, s);
  }
  finishTopicReference(t, r, i, s) {
    if (this.testTopicReferenceConfiguration(i, r, s)) {
      const n = i === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
      return this.topicReferenceIsAllowedInCurrentContext() || this.raise(i === "smart" ? w.PrimaryTopicNotAllowed : w.PipeTopicUnbound, r), this.registerTopicReference(), this.finishNode(t, n);
    } else
      throw this.raise(w.PipeTopicUnconfiguredToken, r, {
        token: zt(s)
      });
  }
  testTopicReferenceConfiguration(t, r, i) {
    switch (t) {
      case "hack":
        return this.hasPlugin(["pipelineOperator", {
          topicToken: zt(i)
        }]);
      case "smart":
        return i === 27;
      default:
        throw this.raise(w.PipeTopicRequiresHackPipes, r);
    }
  }
  parseAsyncArrowUnaryFunction(t) {
    this.prodParam.enter(zi(!0, this.prodParam.hasYield));
    const r = [this.parseIdentifier()];
    return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(w.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(t, r, !0);
  }
  parseDo(t, r) {
    this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
    const i = this.state.labels;
    return this.state.labels = [], r ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = i, this.finishNode(t, "DoExpression");
  }
  parseSuper() {
    const t = this.startNode();
    return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(w.SuperNotAllowed, t) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(w.UnexpectedSuper, t), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(w.UnsupportedSuper, t), this.finishNode(t, "Super");
  }
  parsePrivateName() {
    const t = this.startNode(), r = this.startNodeAt(ht(this.state.startLoc, 1)), i = this.state.value;
    return this.next(), t.id = this.createIdentifier(r, i), this.finishNode(t, "PrivateName");
  }
  parseFunctionOrFunctionSent() {
    const t = this.startNode();
    if (this.next(), this.prodParam.hasYield && this.match(16)) {
      const r = this.createIdentifier(this.startNodeAtNode(t), "function");
      return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, r, "sent");
    }
    return this.parseFunction(t);
  }
  parseMetaProperty(t, r, i) {
    t.meta = r;
    const s = this.state.containsEsc;
    return t.property = this.parseIdentifier(!0), (t.property.name !== i || s) && this.raise(w.UnsupportedMetaProperty, t.property, {
      target: r.name,
      onlyValidPropertyName: i
    }), this.finishNode(t, "MetaProperty");
  }
  parseImportMetaProperty(t) {
    const r = this.createIdentifier(this.startNodeAtNode(t), "import");
    if (this.next(), this.isContextual(101))
      this.inModule || this.raise(w.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
    else if (this.isContextual(105) || this.isContextual(97)) {
      const i = this.isContextual(105);
      if (i || this.unexpected(), this.expectPlugin(i ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
        throw this.raise(w.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
          phase: this.state.value
        });
      return this.next(), t.phase = i ? "source" : "defer", this.parseImportCall(t);
    }
    return this.parseMetaProperty(t, r, "meta");
  }
  parseLiteralAtNode(t, r, i) {
    return this.addExtra(i, "rawValue", t), this.addExtra(i, "raw", this.input.slice(i.start, this.state.end)), i.value = t, this.next(), this.finishNode(i, r);
  }
  parseLiteral(t, r) {
    const i = this.startNode();
    return this.parseLiteralAtNode(t, r, i);
  }
  parseStringLiteral(t) {
    return this.parseLiteral(t, "StringLiteral");
  }
  parseNumericLiteral(t) {
    return this.parseLiteral(t, "NumericLiteral");
  }
  parseBigIntLiteral(t) {
    return this.parseLiteral(t, "BigIntLiteral");
  }
  parseDecimalLiteral(t) {
    return this.parseLiteral(t, "DecimalLiteral");
  }
  parseRegExpLiteral(t) {
    const r = this.startNode();
    return this.addExtra(r, "raw", this.input.slice(r.start, this.state.end)), r.pattern = t.pattern, r.flags = t.flags, this.next(), this.finishNode(r, "RegExpLiteral");
  }
  parseBooleanLiteral(t) {
    const r = this.startNode();
    return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
  }
  parseNullLiteral() {
    const t = this.startNode();
    return this.next(), this.finishNode(t, "NullLiteral");
  }
  parseParenAndDistinguishExpression(t) {
    const r = this.state.startLoc;
    let i;
    this.next(), this.expressionScope.enter(QL());
    const s = this.state.maybeInArrowParameters, n = this.state.inFSharpPipelineDirectBody;
    this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
    const a = this.state.startLoc, o = [], l = new Qi();
    let u = !0, c, f;
    for (; !this.match(11); ) {
      if (u)
        u = !1;
      else if (this.expect(12, l.optionalParametersLoc === null ? null : l.optionalParametersLoc), this.match(11)) {
        f = this.state.startLoc;
        break;
      }
      if (this.match(21)) {
        const y = this.state.startLoc;
        if (c = this.state.startLoc, o.push(this.parseParenItem(this.parseRestBinding(), y)), !this.checkCommaAfterRest(41))
          break;
      } else
        o.push(this.parseMaybeAssignAllowIn(l, this.parseParenItem));
    }
    const p = this.state.lastTokEndLoc;
    this.expect(11), this.state.maybeInArrowParameters = s, this.state.inFSharpPipelineDirectBody = n;
    let h = this.startNodeAt(r);
    return t && this.shouldParseArrow(o) && (h = this.parseArrow(h)) ? (this.checkDestructuringPrivate(l), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(h, o, !1), h) : (this.expressionScope.exit(), o.length || this.unexpected(this.state.lastTokStartLoc), f && this.unexpected(f), c && this.unexpected(c), this.checkExpressionErrors(l, !0), this.toReferencedListDeep(o, !0), o.length > 1 ? (i = this.startNodeAt(a), i.expressions = o, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i, p)) : i = o[0], this.wrapParenthesis(r, i));
  }
  wrapParenthesis(t, r) {
    if (!this.options.createParenthesizedExpressions)
      return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.state.lastTokEndLoc.index), r;
    const i = this.startNodeAt(t);
    return i.expression = r, this.finishNode(i, "ParenthesizedExpression");
  }
  shouldParseArrow(t) {
    return !this.canInsertSemicolon();
  }
  parseArrow(t) {
    if (this.eat(19))
      return t;
  }
  parseParenItem(t, r) {
    return t;
  }
  parseNewOrNewTarget() {
    const t = this.startNode();
    if (this.next(), this.match(16)) {
      const r = this.createIdentifier(this.startNodeAtNode(t), "new");
      this.next();
      const i = this.parseMetaProperty(t, r, "target");
      return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(w.UnexpectedNewTarget, i), i;
    }
    return this.parseNew(t);
  }
  parseNew(t) {
    if (this.parseNewCallee(t), this.eat(10)) {
      const r = this.parseExprList(11);
      this.toReferencedList(r), t.arguments = r;
    } else
      t.arguments = [];
    return this.finishNode(t, "NewExpression");
  }
  parseNewCallee(t) {
    const r = this.match(83), i = this.parseNoCallExpr();
    t.callee = i, r && (i.type === "Import" || i.type === "ImportExpression") && this.raise(w.ImportCallNotNewExpression, i);
  }
  parseTemplateElement(t) {
    const {
      start: r,
      startLoc: i,
      end: s,
      value: n
    } = this.state, a = r + 1, o = this.startNodeAt(ht(i, 1));
    n === null && (t || this.raise(w.InvalidEscapeSequenceTemplate, ht(this.state.firstInvalidTemplateEscapePos, 1)));
    const l = this.match(24), u = l ? -1 : -2, c = s + u;
    o.value = {
      raw: this.input.slice(a, c).replace(/\r\n?/g, `
`),
      cooked: n === null ? null : n.slice(1, u)
    }, o.tail = l, this.next();
    const f = this.finishNode(o, "TemplateElement");
    return this.resetEndLocation(f, ht(this.state.lastTokEndLoc, u)), f;
  }
  parseTemplate(t) {
    const r = this.startNode();
    let i = this.parseTemplateElement(t);
    const s = [i], n = [];
    for (; !i.tail; )
      n.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), s.push(i = this.parseTemplateElement(t));
    return r.expressions = n, r.quasis = s, this.finishNode(r, "TemplateLiteral");
  }
  parseTemplateSubstitution() {
    return this.parseExpression();
  }
  parseObjectLike(t, r, i, s) {
    i && this.expectPlugin("recordAndTuple");
    const n = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !1;
    const a = /* @__PURE__ */ Object.create(null);
    let o = !0;
    const l = this.startNode();
    for (l.properties = [], this.next(); !this.match(t); ) {
      if (o)
        o = !1;
      else if (this.expect(12), this.match(t)) {
        this.addTrailingCommaExtraToNode(l);
        break;
      }
      let c;
      r ? c = this.parseBindingProperty() : (c = this.parsePropertyDefinition(s), this.checkProto(c, i, a, s)), i && !this.isObjectProperty(c) && c.type !== "SpreadElement" && this.raise(w.InvalidRecordProperty, c), c.shorthand && this.addExtra(c, "shorthand", !0), l.properties.push(c);
    }
    this.next(), this.state.inFSharpPipelineDirectBody = n;
    let u = "ObjectExpression";
    return r ? u = "ObjectPattern" : i && (u = "RecordExpression"), this.finishNode(l, u);
  }
  addTrailingCommaExtraToNode(t) {
    this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
  }
  maybeAsyncOrAccessorProp(t) {
    return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
  }
  parsePropertyDefinition(t) {
    let r = [];
    if (this.match(26))
      for (this.hasPlugin("decorators") && this.raise(w.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
        r.push(this.parseDecorator());
    const i = this.startNode();
    let s = !1, n = !1, a;
    if (this.match(21))
      return r.length && this.unexpected(), this.parseSpread();
    r.length && (i.decorators = r, r = []), i.method = !1, t && (a = this.state.startLoc);
    let o = this.eat(55);
    this.parsePropertyNamePrefixOperator(i);
    const l = this.state.containsEsc;
    if (this.parsePropertyName(i, t), !o && !l && this.maybeAsyncOrAccessorProp(i)) {
      const {
        key: u
      } = i, c = u.name;
      c === "async" && !this.hasPrecedingLineBreak() && (s = !0, this.resetPreviousNodeTrailingComments(u), o = this.eat(55), this.parsePropertyName(i)), (c === "get" || c === "set") && (n = !0, this.resetPreviousNodeTrailingComments(u), i.kind = c, this.match(55) && (o = !0, this.raise(w.AccessorIsGenerator, this.state.curPosition(), {
        kind: c
      }), this.next()), this.parsePropertyName(i));
    }
    return this.parseObjPropValue(i, a, o, s, !1, n, t);
  }
  getGetterSetterExpectedParamCount(t) {
    return t.kind === "get" ? 0 : 1;
  }
  getObjectOrClassMethodParams(t) {
    return t.params;
  }
  checkGetterSetterParams(t) {
    var r;
    const i = this.getGetterSetterExpectedParamCount(t), s = this.getObjectOrClassMethodParams(t);
    s.length !== i && this.raise(t.kind === "get" ? w.BadGetterArity : w.BadSetterArity, t), t.kind === "set" && ((r = s[s.length - 1]) == null ? void 0 : r.type) === "RestElement" && this.raise(w.BadSetterRestParameter, t);
  }
  parseObjectMethod(t, r, i, s, n) {
    if (n) {
      const a = this.parseMethod(t, r, !1, !1, !1, "ObjectMethod");
      return this.checkGetterSetterParams(a), a;
    }
    if (i || r || this.match(10))
      return s && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, r, i, !1, !1, "ObjectMethod");
  }
  parseObjectProperty(t, r, i, s) {
    if (t.shorthand = !1, this.eat(14))
      return t.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(s), this.finishNode(t, "ObjectProperty");
    if (!t.computed && t.key.type === "Identifier") {
      if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), i)
        t.value = this.parseMaybeDefault(r, $t(t.key));
      else if (this.match(29)) {
        const n = this.state.startLoc;
        s != null ? s.shorthandAssignLoc === null && (s.shorthandAssignLoc = n) : this.raise(w.InvalidCoverInitializedName, n), t.value = this.parseMaybeDefault(r, $t(t.key));
      } else
        t.value = $t(t.key);
      return t.shorthand = !0, this.finishNode(t, "ObjectProperty");
    }
  }
  parseObjPropValue(t, r, i, s, n, a, o) {
    const l = this.parseObjectMethod(t, i, s, n, a) || this.parseObjectProperty(t, r, n, o);
    return l || this.unexpected(), l;
  }
  parsePropertyName(t, r) {
    if (this.eat(0))
      t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
    else {
      const {
        type: i,
        value: s
      } = this.state;
      let n;
      if (At(i))
        n = this.parseIdentifier(!0);
      else
        switch (i) {
          case 134:
            n = this.parseNumericLiteral(s);
            break;
          case 133:
            n = this.parseStringLiteral(s);
            break;
          case 135:
            n = this.parseBigIntLiteral(s);
            break;
          case 136:
            n = this.parseDecimalLiteral(s);
            break;
          case 138: {
            const a = this.state.startLoc;
            r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = a) : this.raise(w.UnexpectedPrivateField, a), n = this.parsePrivateName();
            break;
          }
          default:
            this.unexpected();
        }
      t.key = n, i !== 138 && (t.computed = !1);
    }
  }
  initFunction(t, r) {
    t.id = null, t.generator = !1, t.async = r;
  }
  parseMethod(t, r, i, s, n, a, o = !1) {
    this.initFunction(t, i), t.generator = r, this.scope.enter(18 | (o ? 64 : 0) | (n ? 32 : 0)), this.prodParam.enter(zi(i, t.generator)), this.parseFunctionParams(t, s);
    const l = this.parseFunctionBodyAndFinish(t, a, !0);
    return this.prodParam.exit(), this.scope.exit(), l;
  }
  parseArrayLike(t, r, i, s) {
    i && this.expectPlugin("recordAndTuple");
    const n = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !1;
    const a = this.startNode();
    return this.next(), a.elements = this.parseExprList(t, !i, s, a), this.state.inFSharpPipelineDirectBody = n, this.finishNode(a, i ? "TupleExpression" : "ArrayExpression");
  }
  parseArrowExpression(t, r, i, s) {
    this.scope.enter(6);
    let n = zi(i, !1);
    !this.match(5) && this.prodParam.hasIn && (n |= 8), this.prodParam.enter(n), this.initFunction(t, i);
    const a = this.state.maybeInArrowParameters;
    return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, r, s)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a, this.finishNode(t, "ArrowFunctionExpression");
  }
  setArrowFunctionParameters(t, r, i) {
    this.toAssignableList(r, i, !1), t.params = r;
  }
  parseFunctionBodyAndFinish(t, r, i = !1) {
    return this.parseFunctionBody(t, !1, i), this.finishNode(t, r);
  }
  parseFunctionBody(t, r, i = !1) {
    const s = r && !this.match(5);
    if (this.expressionScope.enter(af()), s)
      t.body = this.parseMaybeAssign(), this.checkParams(t, !1, r, !1);
    else {
      const n = this.state.strict, a = this.state.labels;
      this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (o) => {
        const l = !this.isSimpleParamList(t.params);
        o && l && this.raise(w.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
        const u = !n && this.state.strict;
        this.checkParams(t, !this.state.strict && !r && !i && !l, r, u), this.state.strict && t.id && this.checkIdentifier(t.id, 65, u);
      }), this.prodParam.exit(), this.state.labels = a;
    }
    this.expressionScope.exit();
  }
  isSimpleParameter(t) {
    return t.type === "Identifier";
  }
  isSimpleParamList(t) {
    for (let r = 0, i = t.length; r < i; r++)
      if (!this.isSimpleParameter(t[r])) return !1;
    return !0;
  }
  checkParams(t, r, i, s = !0) {
    const n = !r && /* @__PURE__ */ new Set(), a = {
      type: "FormalParameters"
    };
    for (const o of t.params)
      this.checkLVal(o, {
        in: a,
        binding: 5,
        checkClashes: n,
        strictModeChanged: s
      });
  }
  parseExprList(t, r, i, s) {
    const n = [];
    let a = !0;
    for (; !this.eat(t); ) {
      if (a)
        a = !1;
      else if (this.expect(12), this.match(t)) {
        s && this.addTrailingCommaExtraToNode(s), this.next();
        break;
      }
      n.push(this.parseExprListItem(r, i));
    }
    return n;
  }
  parseExprListItem(t, r, i) {
    let s;
    if (this.match(12))
      t || this.raise(w.UnexpectedToken, this.state.curPosition(), {
        unexpected: ","
      }), s = null;
    else if (this.match(21)) {
      const n = this.state.startLoc;
      s = this.parseParenItem(this.parseSpread(r), n);
    } else if (this.match(17)) {
      this.expectPlugin("partialApplication"), i || this.raise(w.UnexpectedArgumentPlaceholder, this.state.startLoc);
      const n = this.startNode();
      this.next(), s = this.finishNode(n, "ArgumentPlaceholder");
    } else
      s = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
    return s;
  }
  parseIdentifier(t) {
    const r = this.startNode(), i = this.parseIdentifierName(t);
    return this.createIdentifier(r, i);
  }
  createIdentifier(t, r) {
    return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
  }
  parseIdentifierName(t) {
    let r;
    const {
      startLoc: i,
      type: s
    } = this.state;
    At(s) ? r = this.state.value : this.unexpected();
    const n = TL(s);
    return t ? n && this.replaceToken(132) : this.checkReservedWord(r, i, n, !1), this.next(), r;
  }
  checkReservedWord(t, r, i, s) {
    if (t.length > 10 || !BL(t))
      return;
    if (i && DL(t)) {
      this.raise(w.UnexpectedKeyword, r, {
        keyword: t
      });
      return;
    }
    if ((this.state.strict ? s ? Zc : zc : Gc)(t, this.inModule)) {
      this.raise(w.UnexpectedReservedWord, r, {
        reservedWord: t
      });
      return;
    } else if (t === "yield") {
      if (this.prodParam.hasYield) {
        this.raise(w.YieldBindingIdentifier, r);
        return;
      }
    } else if (t === "await") {
      if (this.prodParam.hasAwait) {
        this.raise(w.AwaitBindingIdentifier, r);
        return;
      }
      if (this.scope.inStaticBlock) {
        this.raise(w.AwaitBindingIdentifierInStaticBlock, r);
        return;
      }
      this.expressionScope.recordAsyncArrowParametersError(r);
    } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
      this.raise(w.ArgumentsInClass, r);
      return;
    }
  }
  isAwaitAllowed() {
    return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
  }
  parseAwait(t) {
    const r = this.startNodeAt(t);
    return this.expressionScope.recordParameterInitializerError(w.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(w.ObsoleteAwaitStar, r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExpression");
  }
  isAmbiguousAwait() {
    if (this.hasPrecedingLineBreak()) return !0;
    const {
      type: t
    } = this.state;
    return t === 53 || t === 10 || t === 0 || is(t) || t === 102 && !this.state.containsEsc || t === 137 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
  }
  parseYield() {
    const t = this.startNode();
    this.expressionScope.recordParameterInitializerError(w.YieldInParameter, t), this.next();
    let r = !1, i = null;
    if (!this.hasPrecedingLineBreak())
      switch (r = this.eat(55), this.state.type) {
        case 13:
        case 139:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!r) break;
        default:
          i = this.parseMaybeAssign();
      }
    return t.delegate = r, t.argument = i, this.finishNode(t, "YieldExpression");
  }
  parseImportCall(t) {
    return this.next(), t.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (t.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(t, "ImportExpression");
  }
  checkPipelineAtInfixOperator(t, r) {
    this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }]) && t.type === "SequenceExpression" && this.raise(w.PipelineHeadSequenceExpression, r);
  }
  parseSmartPipelineBodyInStyle(t, r) {
    if (this.isSimpleReference(t)) {
      const i = this.startNodeAt(r);
      return i.callee = t, this.finishNode(i, "PipelineBareFunction");
    } else {
      const i = this.startNodeAt(r);
      return this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = t, this.finishNode(i, "PipelineTopicExpression");
    }
  }
  isSimpleReference(t) {
    switch (t.type) {
      case "MemberExpression":
        return !t.computed && this.isSimpleReference(t.object);
      case "Identifier":
        return !0;
      default:
        return !1;
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(t) {
    if (this.match(19))
      throw this.raise(w.PipelineBodyNoArrow, this.state.startLoc);
    this.topicReferenceWasUsedInCurrentContext() || this.raise(w.PipelineTopicUnused, t);
  }
  withTopicBindingContext(t) {
    const r = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 1,
      maxTopicIndex: null
    };
    try {
      return t();
    } finally {
      this.state.topicContext = r;
    }
  }
  withSmartMixTopicForbiddingContext(t) {
    if (this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }])) {
      const r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      try {
        return t();
      } finally {
        this.state.topicContext = r;
      }
    } else
      return t();
  }
  withSoloAwaitPermittingContext(t) {
    const r = this.state.soloAwait;
    this.state.soloAwait = !0;
    try {
      return t();
    } finally {
      this.state.soloAwait = r;
    }
  }
  allowInAnd(t) {
    const r = this.prodParam.currentFlags();
    if (8 & ~r) {
      this.prodParam.enter(r | 8);
      try {
        return t();
      } finally {
        this.prodParam.exit();
      }
    }
    return t();
  }
  disallowInAnd(t) {
    const r = this.prodParam.currentFlags();
    if (8 & r) {
      this.prodParam.enter(r & -9);
      try {
        return t();
      } finally {
        this.prodParam.exit();
      }
    }
    return t();
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }
  parseFSharpPipelineBody(t) {
    const r = this.state.startLoc;
    this.state.potentialArrowAt = this.state.start;
    const i = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !0;
    const s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
    return this.state.inFSharpPipelineDirectBody = i, s;
  }
  parseModuleExpression() {
    this.expectPlugin("moduleBlocks");
    const t = this.startNode();
    this.next(), this.match(5) || this.unexpected(null, 5);
    const r = this.startNodeAt(this.state.endLoc);
    this.next();
    const i = this.initializeScopes(!0);
    this.enterInitialScopes();
    try {
      t.body = this.parseProgram(r, 8, "module");
    } finally {
      i();
    }
    return this.finishNode(t, "ModuleExpression");
  }
  parsePropertyNamePrefixOperator(t) {
  }
}
const mn = {
  kind: 1
}, _M = {
  kind: 2
}, kM = /[\uD800-\uDFFF]/u, yn = /in(?:stanceof)?/y;
function DM(e, t) {
  for (let r = 0; r < e.length; r++) {
    const i = e[r], {
      type: s
    } = i;
    if (typeof s == "number") {
      {
        if (s === 138) {
          const {
            loc: n,
            start: a,
            value: o,
            end: l
          } = i, u = a + 1, c = ht(n.start, 1);
          e.splice(r, 1, new Yt({
            type: Mt(27),
            value: "#",
            start: a,
            end: u,
            startLoc: n.start,
            endLoc: c
          }), new Yt({
            type: Mt(132),
            value: o,
            start: u,
            end: l,
            startLoc: c,
            endLoc: n.end
          })), r++;
          continue;
        }
        if (is(s)) {
          const {
            loc: n,
            start: a,
            value: o,
            end: l
          } = i, u = a + 1, c = ht(n.start, 1);
          let f;
          t.charCodeAt(a) === 96 ? f = new Yt({
            type: Mt(22),
            value: "`",
            start: a,
            end: u,
            startLoc: n.start,
            endLoc: c
          }) : f = new Yt({
            type: Mt(8),
            value: "}",
            start: a,
            end: u,
            startLoc: n.start,
            endLoc: c
          });
          let p, h, y, b;
          s === 24 ? (h = l - 1, y = ht(n.end, -1), p = o === null ? null : o.slice(1, -1), b = new Yt({
            type: Mt(22),
            value: "`",
            start: h,
            end: l,
            startLoc: y,
            endLoc: n.end
          })) : (h = l - 2, y = ht(n.end, -2), p = o === null ? null : o.slice(1, -2), b = new Yt({
            type: Mt(23),
            value: "${",
            start: h,
            end: l,
            startLoc: y,
            endLoc: n.end
          })), e.splice(r, 1, f, new Yt({
            type: Mt(20),
            value: p,
            start: u,
            end: h,
            startLoc: c,
            endLoc: y
          }), b), r += 2;
          continue;
        }
      }
      i.type = Mt(s);
    }
  }
  return e;
}
class LM extends NM {
  parseTopLevel(t, r) {
    return t.program = this.parseProgram(r), t.comments = this.comments, this.options.tokens && (t.tokens = DM(this.tokens, this.input)), this.finishNode(t, "File");
  }
  parseProgram(t, r = 139, i = this.options.sourceType) {
    if (t.sourceType = i, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, r), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
      for (const [n, a] of Array.from(this.scope.undefinedExports))
        this.raise(w.ModuleExportUndefined, a, {
          localName: n
        });
    let s;
    return r === 139 ? s = this.finishNode(t, "Program") : s = this.finishNodeAt(t, "Program", ht(this.state.startLoc, -1)), s;
  }
  stmtToDirective(t) {
    const r = t;
    r.type = "Directive", r.value = r.expression, delete r.expression;
    const i = r.value, s = i.value, n = this.input.slice(i.start, i.end), a = i.value = n.slice(1, -1);
    return this.addExtra(i, "raw", n), this.addExtra(i, "rawValue", a), this.addExtra(i, "expressionValue", s), i.type = "DirectiveLiteral", r;
  }
  parseInterpreterDirective() {
    if (!this.match(28))
      return null;
    const t = this.startNode();
    return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
  }
  isLet() {
    return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
  }
  chStartsBindingIdentifier(t, r) {
    if (Rt(t)) {
      if (yn.lastIndex = r, yn.test(this.input)) {
        const i = this.codePointAtPos(yn.lastIndex);
        if (!Sr(i) && i !== 92)
          return !1;
      }
      return !0;
    } else return t === 92;
  }
  chStartsBindingPattern(t) {
    return t === 91 || t === 123;
  }
  hasFollowingBindingAtom() {
    const t = this.nextTokenStart(), r = this.codePointAtPos(t);
    return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
  }
  hasInLineFollowingBindingIdentifierOrBrace() {
    const t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
    return r === 123 || this.chStartsBindingIdentifier(r, t);
  }
  startsUsingForOf() {
    const {
      type: t,
      containsEsc: r
    } = this.lookahead();
    if (t === 102 && !r)
      return !1;
    if (Le(t) && !this.hasFollowingLineBreak())
      return this.expectPlugin("explicitResourceManagement"), !0;
  }
  startsAwaitUsing() {
    let t = this.nextTokenInLineStart();
    if (this.isUnparsedContextual(t, "using")) {
      t = this.nextTokenInLineStartSince(t + 5);
      const r = this.codePointAtPos(t);
      if (this.chStartsBindingIdentifier(r, t))
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    return !1;
  }
  parseModuleItem() {
    return this.parseStatementLike(15);
  }
  parseStatementListItem() {
    return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
  }
  parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
    let r = 0;
    return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
  }
  parseStatement() {
    return this.parseStatementLike(0);
  }
  parseStatementLike(t) {
    let r = null;
    return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(t, r);
  }
  parseStatementContent(t, r) {
    const i = this.state.type, s = this.startNode(), n = !!(t & 2), a = !!(t & 4), o = t & 1;
    switch (i) {
      case 60:
        return this.parseBreakContinueStatement(s, !0);
      case 63:
        return this.parseBreakContinueStatement(s, !1);
      case 64:
        return this.parseDebuggerStatement(s);
      case 90:
        return this.parseDoWhileStatement(s);
      case 91:
        return this.parseForStatement(s);
      case 68:
        if (this.lookaheadCharCode() === 46) break;
        return a || this.raise(this.state.strict ? w.StrictFunction : this.options.annexB ? w.SloppyFunctionAnnexB : w.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(s, !1, !n && a);
      case 80:
        return n || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, s), !0);
      case 69:
        return this.parseIfStatement(s);
      case 70:
        return this.parseReturnStatement(s);
      case 71:
        return this.parseSwitchStatement(s);
      case 72:
        return this.parseThrowStatement(s);
      case 73:
        return this.parseTryStatement(s);
      case 96:
        if (!this.state.containsEsc && this.startsAwaitUsing())
          return this.isAwaitAllowed() ? n || this.raise(w.UnexpectedLexicalDeclaration, s) : this.raise(w.AwaitUsingNotInAsyncContext, s), this.next(), this.parseVarStatement(s, "await using");
        break;
      case 107:
        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
          break;
        return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(w.UnexpectedUsingDeclaration, this.state.startLoc) : n || this.raise(w.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(s, "using");
      case 100: {
        if (this.state.containsEsc)
          break;
        const c = this.nextTokenStart(), f = this.codePointAtPos(c);
        if (f !== 91 && (!n && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, c) && f !== 123))
          break;
      }
      case 75:
        n || this.raise(w.UnexpectedLexicalDeclaration, this.state.startLoc);
      case 74: {
        const c = this.state.value;
        return this.parseVarStatement(s, c);
      }
      case 92:
        return this.parseWhileStatement(s);
      case 76:
        return this.parseWithStatement(s);
      case 5:
        return this.parseBlock();
      case 13:
        return this.parseEmptyStatement(s);
      case 83: {
        const c = this.lookaheadCharCode();
        if (c === 40 || c === 46)
          break;
      }
      case 82: {
        !this.options.allowImportExportEverywhere && !o && this.raise(w.UnexpectedImportExport, this.state.startLoc), this.next();
        let c;
        return i === 83 ? (c = this.parseImport(s), c.type === "ImportDeclaration" && (!c.importKind || c.importKind === "value") && (this.sawUnambiguousESM = !0)) : (c = this.parseExport(s, r), (c.type === "ExportNamedDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportAllDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(c), c;
      }
      default:
        if (this.isAsyncFunction())
          return n || this.raise(w.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(s, !0, !n && a);
    }
    const l = this.state.value, u = this.parseExpression();
    return Le(i) && u.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(s, l, u, t) : this.parseExpressionStatement(s, u, r);
  }
  assertModuleNodeAllowed(t) {
    !this.options.allowImportExportEverywhere && !this.inModule && this.raise(w.ImportOutsideModule, t);
  }
  decoratorsEnabledBeforeExport() {
    return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
  }
  maybeTakeDecorators(t, r, i) {
    return t && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(w.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(r, t[0]), i && this.resetStartLocationFromNode(i, r)), r;
  }
  canHaveLeadingDecorator() {
    return this.match(80);
  }
  parseDecorators(t) {
    const r = [];
    do
      r.push(this.parseDecorator());
    while (this.match(26));
    if (this.match(82))
      t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(w.DecoratorExportClass, this.state.startLoc);
    else if (!this.canHaveLeadingDecorator())
      throw this.raise(w.UnexpectedLeadingDecorator, this.state.startLoc);
    return r;
  }
  parseDecorator() {
    this.expectOnePlugin(["decorators", "decorators-legacy"]);
    const t = this.startNode();
    if (this.next(), this.hasPlugin("decorators")) {
      const r = this.state.startLoc;
      let i;
      if (this.match(10)) {
        const s = this.state.startLoc;
        this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(s, i);
        const n = this.state.startLoc;
        t.expression = this.parseMaybeDecoratorArguments(i), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !== i && this.raise(w.DecoratorArgumentsOutsideParentheses, n);
      } else {
        for (i = this.parseIdentifier(!1); this.eat(16); ) {
          const s = this.startNodeAt(r);
          s.object = i, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), s.property = this.parsePrivateName()) : s.property = this.parseIdentifier(!0), s.computed = !1, i = this.finishNode(s, "MemberExpression");
        }
        t.expression = this.parseMaybeDecoratorArguments(i);
      }
    } else
      t.expression = this.parseExprSubscripts();
    return this.finishNode(t, "Decorator");
  }
  parseMaybeDecoratorArguments(t) {
    if (this.eat(10)) {
      const r = this.startNodeAtNode(t);
      return r.callee = t, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r, "CallExpression");
    }
    return t;
  }
  parseBreakContinueStatement(t, r) {
    return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
  }
  verifyBreakContinue(t, r) {
    let i;
    for (i = 0; i < this.state.labels.length; ++i) {
      const s = this.state.labels[i];
      if ((t.label == null || s.name === t.label.name) && (s.kind != null && (r || s.kind === 1) || t.label && r))
        break;
    }
    if (i === this.state.labels.length) {
      const s = r ? "BreakStatement" : "ContinueStatement";
      this.raise(w.IllegalBreakContinue, t, {
        type: s
      });
    }
  }
  parseDebuggerStatement(t) {
    return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
  }
  parseHeaderExpression() {
    this.expect(10);
    const t = this.parseExpression();
    return this.expect(11), t;
  }
  parseDoWhileStatement(t) {
    return this.next(), this.state.labels.push(mn), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
  }
  parseForStatement(t) {
    this.next(), this.state.labels.push(mn);
    let r = null;
    if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
      return r !== null && this.unexpected(r), this.parseFor(t, null);
    const i = this.isContextual(100);
    {
      const l = this.isContextual(96) && this.startsAwaitUsing(), u = l || this.isContextual(107) && this.startsUsingForOf(), c = i && this.hasFollowingBindingAtom() || u;
      if (this.match(74) || this.match(75) || c) {
        const f = this.startNode();
        let p;
        l ? (p = "await using", this.isAwaitAllowed() || this.raise(w.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : p = this.state.value, this.next(), this.parseVar(f, !0, p);
        const h = this.finishNode(f, "VariableDeclaration"), y = this.match(58);
        return y && u && this.raise(w.ForInUsing, h), (y || this.isContextual(102)) && h.declarations.length === 1 ? this.parseForIn(t, h, r) : (r !== null && this.unexpected(r), this.parseFor(t, h));
      }
    }
    const s = this.isContextual(95), n = new Qi(), a = this.parseExpression(!0, n), o = this.isContextual(102);
    if (o && (i && this.raise(w.ForOfLet, a), r === null && s && a.type === "Identifier" && this.raise(w.ForOfAsync, a)), o || this.match(58)) {
      this.checkDestructuringPrivate(n), this.toAssignable(a, !0);
      const l = o ? "ForOfStatement" : "ForInStatement";
      return this.checkLVal(a, {
        in: {
          type: l
        }
      }), this.parseForIn(t, a, r);
    } else
      this.checkExpressionErrors(n, !0);
    return r !== null && this.unexpected(r), this.parseFor(t, a);
  }
  parseFunctionStatement(t, r, i) {
    return this.next(), this.parseFunction(t, 1 | (i ? 2 : 0) | (r ? 8 : 0));
  }
  parseIfStatement(t) {
    return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
  }
  parseReturnStatement(t) {
    return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(w.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
  }
  parseSwitchStatement(t) {
    this.next(), t.discriminant = this.parseHeaderExpression();
    const r = t.cases = [];
    this.expect(5), this.state.labels.push(_M), this.scope.enter(0);
    let i;
    for (let s; !this.match(8); )
      if (this.match(61) || this.match(65)) {
        const n = this.match(61);
        i && this.finishNode(i, "SwitchCase"), r.push(i = this.startNode()), i.consequent = [], this.next(), n ? i.test = this.parseExpression() : (s && this.raise(w.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), s = !0, i.test = null), this.expect(14);
      } else
        i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
    return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
  }
  parseThrowStatement(t) {
    return this.next(), this.hasPrecedingLineBreak() && this.raise(w.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
  }
  parseCatchClauseParam() {
    const t = this.parseBindingAtom();
    return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {
      in: {
        type: "CatchClause"
      },
      binding: 9
    }), t;
  }
  parseTryStatement(t) {
    if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
      const r = this.startNode();
      this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(r, "CatchClause");
    }
    return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(w.NoCatchOrFinally, t), this.finishNode(t, "TryStatement");
  }
  parseVarStatement(t, r, i = !1) {
    return this.next(), this.parseVar(t, !1, r, i), this.semicolon(), this.finishNode(t, "VariableDeclaration");
  }
  parseWhileStatement(t) {
    return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(mn), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
  }
  parseWithStatement(t) {
    return this.state.strict && this.raise(w.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
  }
  parseEmptyStatement(t) {
    return this.next(), this.finishNode(t, "EmptyStatement");
  }
  parseLabeledStatement(t, r, i, s) {
    for (const a of this.state.labels)
      a.name === r && this.raise(w.LabelRedeclaration, i, {
        labelName: r
      });
    const n = SL(this.state.type) ? 1 : this.match(71) ? 2 : null;
    for (let a = this.state.labels.length - 1; a >= 0; a--) {
      const o = this.state.labels[a];
      if (o.statementStart === t.start)
        o.statementStart = this.state.start, o.kind = n;
      else
        break;
    }
    return this.state.labels.push({
      name: r,
      kind: n,
      statementStart: this.state.start
    }), t.body = s & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label = i, this.finishNode(t, "LabeledStatement");
  }
  parseExpressionStatement(t, r, i) {
    return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
  }
  parseBlock(t = !1, r = !0, i) {
    const s = this.startNode();
    return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(s, t, !1, 8, i), r && this.scope.exit(), this.finishNode(s, "BlockStatement");
  }
  isValidDirective(t) {
    return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
  }
  parseBlockBody(t, r, i, s, n) {
    const a = t.body = [], o = t.directives = [];
    this.parseBlockOrModuleBlockBody(a, r ? o : void 0, i, s, n);
  }
  parseBlockOrModuleBlockBody(t, r, i, s, n) {
    const a = this.state.strict;
    let o = !1, l = !1;
    for (; !this.match(s); ) {
      const u = i ? this.parseModuleItem() : this.parseStatementListItem();
      if (r && !l) {
        if (this.isValidDirective(u)) {
          const c = this.stmtToDirective(u);
          r.push(c), !o && c.value.value === "use strict" && (o = !0, this.setStrict(!0));
          continue;
        }
        l = !0, this.state.strictErrors.clear();
      }
      t.push(u);
    }
    n == null || n.call(this, o), a || this.setStrict(!1), this.next();
  }
  parseFor(t, r) {
    return t.init = r, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
  }
  parseForIn(t, r, i) {
    const s = this.match(58);
    return this.next(), s ? i !== null && this.unexpected(i) : t.await = i !== null, r.type === "VariableDeclaration" && r.declarations[0].init != null && (!s || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") && this.raise(w.ForInOfLoopInitializer, r, {
      type: s ? "ForInStatement" : "ForOfStatement"
    }), r.type === "AssignmentPattern" && this.raise(w.InvalidLhs, r, {
      ancestor: {
        type: "ForStatement"
      }
    }), t.left = r, t.right = s ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, s ? "ForInStatement" : "ForOfStatement");
  }
  parseVar(t, r, i, s = !1) {
    const n = t.declarations = [];
    for (t.kind = i; ; ) {
      const a = this.startNode();
      if (this.parseVarId(a, i), a.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a.init === null && !s && (a.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(w.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
        kind: "destructuring"
      }) : (i === "const" || i === "using" || i === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(w.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
        kind: i
      })), n.push(this.finishNode(a, "VariableDeclarator")), !this.eat(12)) break;
    }
    return t;
  }
  parseVarId(t, r) {
    const i = this.parseBindingAtom();
    (r === "using" || r === "await using") && (i.type === "ArrayPattern" || i.type === "ObjectPattern") && this.raise(w.UsingDeclarationHasBindingPattern, i.loc.start), this.checkLVal(i, {
      in: {
        type: "VariableDeclarator"
      },
      binding: r === "var" ? 5 : 8201
    }), t.id = i;
  }
  parseAsyncFunctionExpression(t) {
    return this.parseFunction(t, 8);
  }
  parseFunction(t, r = 0) {
    const i = r & 2, s = !!(r & 1), n = s && !(r & 4), a = !!(r & 8);
    this.initFunction(t, a), this.match(55) && (i && this.raise(w.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.generator = !0), s && (t.id = this.parseFunctionId(n));
    const o = this.state.maybeInArrowParameters;
    return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(zi(a, t.generator)), s || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(t, s ? "FunctionDeclaration" : "FunctionExpression");
    }), this.prodParam.exit(), this.scope.exit(), s && !i && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = o, t;
  }
  parseFunctionId(t) {
    return t || Le(this.state.type) ? this.parseIdentifier() : null;
  }
  parseFunctionParams(t, r) {
    this.expect(10), this.expressionScope.enter(zL()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
  }
  registerFunctionStatementId(t) {
    t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t.id.loc.start);
  }
  parseClass(t, r, i) {
    this.next();
    const s = this.state.strict;
    return this.state.strict = !0, this.parseClassId(t, r, i), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, s), this.finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
  }
  isClassProperty() {
    return this.match(29) || this.match(13) || this.match(8);
  }
  isClassMethod() {
    return this.match(10);
  }
  nameIsConstructor(t) {
    return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
  }
  isNonstaticConstructor(t) {
    return !t.computed && !t.static && this.nameIsConstructor(t.key);
  }
  parseClassBody(t, r) {
    this.classScope.enter();
    const i = {
      hadConstructor: !1,
      hadSuperClass: t
    };
    let s = [];
    const n = this.startNode();
    if (n.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
      for (; !this.match(8); ) {
        if (this.eat(13)) {
          if (s.length > 0)
            throw this.raise(w.DecoratorSemicolon, this.state.lastTokEndLoc);
          continue;
        }
        if (this.match(26)) {
          s.push(this.parseDecorator());
          continue;
        }
        const a = this.startNode();
        s.length && (a.decorators = s, this.resetStartLocationFromNode(a, s[0]), s = []), this.parseClassMember(n, a, i), a.kind === "constructor" && a.decorators && a.decorators.length > 0 && this.raise(w.DecoratorConstructor, a);
      }
    }), this.state.strict = r, this.next(), s.length)
      throw this.raise(w.TrailingDecorator, this.state.startLoc);
    return this.classScope.exit(), this.finishNode(n, "ClassBody");
  }
  parseClassMemberFromModifier(t, r) {
    const i = this.parseIdentifier(!0);
    if (this.isClassMethod()) {
      const s = r;
      return s.kind = "method", s.computed = !1, s.key = i, s.static = !1, this.pushClassMethod(t, s, !1, !1, !1, !1), !0;
    } else if (this.isClassProperty()) {
      const s = r;
      return s.computed = !1, s.key = i, s.static = !1, t.body.push(this.parseClassProperty(s)), !0;
    }
    return this.resetPreviousNodeTrailingComments(i), !1;
  }
  parseClassMember(t, r, i) {
    const s = this.isContextual(106);
    if (s) {
      if (this.parseClassMemberFromModifier(t, r))
        return;
      if (this.eat(5)) {
        this.parseClassStaticBlock(t, r);
        return;
      }
    }
    this.parseClassMemberWithIsStatic(t, r, i, s);
  }
  parseClassMemberWithIsStatic(t, r, i, s) {
    const n = r, a = r, o = r, l = r, u = r, c = n, f = n;
    if (r.static = s, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
      c.kind = "method";
      const I = this.match(138);
      if (this.parseClassElementName(c), I) {
        this.pushClassPrivateMethod(t, a, !0, !1);
        return;
      }
      this.isNonstaticConstructor(n) && this.raise(w.ConstructorIsGenerator, n.key), this.pushClassMethod(t, n, !0, !1, !1, !1);
      return;
    }
    const p = !this.state.containsEsc && Le(this.state.type), h = this.parseClassElementName(r), y = p ? h.name : null, b = this.isPrivateName(h), A = this.state.startLoc;
    if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
      if (c.kind = "method", b) {
        this.pushClassPrivateMethod(t, a, !1, !1);
        return;
      }
      const I = this.isNonstaticConstructor(n);
      let _ = !1;
      I && (n.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(w.DuplicateConstructor, h), I && this.hasPlugin("typescript") && r.override && this.raise(w.OverrideOnConstructor, h), i.hadConstructor = !0, _ = i.hadSuperClass), this.pushClassMethod(t, n, !1, !1, I, _);
    } else if (this.isClassProperty())
      b ? this.pushClassPrivateProperty(t, l) : this.pushClassProperty(t, o);
    else if (y === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(h);
      const I = this.eat(55);
      f.optional && this.unexpected(A), c.kind = "method";
      const _ = this.match(138);
      this.parseClassElementName(c), this.parsePostMemberNameModifiers(f), _ ? this.pushClassPrivateMethod(t, a, I, !0) : (this.isNonstaticConstructor(n) && this.raise(w.ConstructorIsAsync, n.key), this.pushClassMethod(t, n, I, !0, !1, !1));
    } else if ((y === "get" || y === "set") && !(this.match(55) && this.isLineTerminator())) {
      this.resetPreviousNodeTrailingComments(h), c.kind = y;
      const I = this.match(138);
      this.parseClassElementName(n), I ? this.pushClassPrivateMethod(t, a, !1, !1) : (this.isNonstaticConstructor(n) && this.raise(w.ConstructorIsAccessor, n.key), this.pushClassMethod(t, n, !1, !1, !1, !1)), this.checkGetterSetterParams(n);
    } else if (y === "accessor" && !this.isLineTerminator()) {
      this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(h);
      const I = this.match(138);
      this.parseClassElementName(o), this.pushClassAccessorProperty(t, u, I);
    } else this.isLineTerminator() ? b ? this.pushClassPrivateProperty(t, l) : this.pushClassProperty(t, o) : this.unexpected();
  }
  parseClassElementName(t) {
    const {
      type: r,
      value: i
    } = this.state;
    if ((r === 132 || r === 133) && t.static && i === "prototype" && this.raise(w.StaticPrototype, this.state.startLoc), r === 138) {
      i === "constructor" && this.raise(w.ConstructorClassPrivateField, this.state.startLoc);
      const s = this.parsePrivateName();
      return t.key = s, s;
    }
    return this.parsePropertyName(t), t.key;
  }
  parseClassStaticBlock(t, r) {
    var i;
    this.scope.enter(208);
    const s = this.state.labels;
    this.state.labels = [], this.prodParam.enter(0);
    const n = r.body = [];
    this.parseBlockOrModuleBlockBody(n, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s, t.body.push(this.finishNode(r, "StaticBlock")), (i = r.decorators) != null && i.length && this.raise(w.DecoratorStaticBlock, r);
  }
  pushClassProperty(t, r) {
    !r.computed && this.nameIsConstructor(r.key) && this.raise(w.ConstructorClassField, r.key), t.body.push(this.parseClassProperty(r));
  }
  pushClassPrivateProperty(t, r) {
    const i = this.parseClassPrivateProperty(r);
    t.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
  }
  pushClassAccessorProperty(t, r, i) {
    !i && !r.computed && this.nameIsConstructor(r.key) && this.raise(w.ConstructorClassField, r.key);
    const s = this.parseClassAccessorProperty(r);
    t.body.push(s), i && this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
  }
  pushClassMethod(t, r, i, s, n, a) {
    t.body.push(this.parseMethod(r, i, s, n, a, "ClassMethod", !0));
  }
  pushClassPrivateMethod(t, r, i, s) {
    const n = this.parseMethod(r, i, s, !1, !1, "ClassPrivateMethod", !0);
    t.body.push(n);
    const a = n.kind === "get" ? n.static ? 6 : 2 : n.kind === "set" ? n.static ? 5 : 1 : 0;
    this.declareClassPrivateMethodInScope(n, a);
  }
  declareClassPrivateMethodInScope(t, r) {
    this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
  }
  parsePostMemberNameModifiers(t) {
  }
  parseClassPrivateProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
  }
  parseClassProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
  }
  parseClassAccessorProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
  }
  parseInitializer(t) {
    this.scope.enter(80), this.expressionScope.enter(af()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
  }
  parseClassId(t, r, i, s = 8331) {
    if (Le(this.state.type))
      t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, s);
    else if (i || !r)
      t.id = null;
    else
      throw this.raise(w.MissingClassName, this.state.startLoc);
  }
  parseClassSuper(t) {
    t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
  }
  parseExport(t, r) {
    const i = this.parseMaybeImportPhase(t, !0), s = this.maybeParseExportDefaultSpecifier(t, i), n = !s || this.eat(12), a = n && this.eatExportStar(t), o = a && this.maybeParseExportNamespaceSpecifier(t), l = n && (!o || this.eat(12)), u = s || a;
    if (a && !o) {
      if (s && this.unexpected(), r)
        throw this.raise(w.UnsupportedDecoratorExport, t);
      return this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
    }
    const c = this.maybeParseExportNamedSpecifiers(t);
    s && n && !a && !c && this.unexpected(null, 5), o && l && this.unexpected(null, 98);
    let f;
    if (u || c) {
      if (f = !1, r)
        throw this.raise(w.UnsupportedDecoratorExport, t);
      this.parseExportFrom(t, u);
    } else
      f = this.maybeParseExportDeclaration(t);
    if (u || c || f) {
      var p;
      const h = t;
      if (this.checkExport(h, !0, !1, !!h.source), ((p = h.declaration) == null ? void 0 : p.type) === "ClassDeclaration")
        this.maybeTakeDecorators(r, h.declaration, h);
      else if (r)
        throw this.raise(w.UnsupportedDecoratorExport, t);
      return this.finishNode(h, "ExportNamedDeclaration");
    }
    if (this.eat(65)) {
      const h = t, y = this.parseExportDefaultExpression();
      if (h.declaration = y, y.type === "ClassDeclaration")
        this.maybeTakeDecorators(r, y, h);
      else if (r)
        throw this.raise(w.UnsupportedDecoratorExport, t);
      return this.checkExport(h, !0, !0), this.finishNode(h, "ExportDefaultDeclaration");
    }
    this.unexpected(null, 5);
  }
  eatExportStar(t) {
    return this.eat(55);
  }
  maybeParseExportDefaultSpecifier(t, r) {
    if (r || this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom", r == null ? void 0 : r.loc.start);
      const i = r || this.parseIdentifier(!0), s = this.startNodeAtNode(i);
      return s.exported = i, t.specifiers = [this.finishNode(s, "ExportDefaultSpecifier")], !0;
    }
    return !1;
  }
  maybeParseExportNamespaceSpecifier(t) {
    if (this.isContextual(93)) {
      var r, i;
      (i = (r = t).specifiers) != null || (r.specifiers = []);
      const s = this.startNodeAt(this.state.lastTokStartLoc);
      return this.next(), s.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(s, "ExportNamespaceSpecifier")), !0;
    }
    return !1;
  }
  maybeParseExportNamedSpecifiers(t) {
    if (this.match(5)) {
      const r = t;
      r.specifiers || (r.specifiers = []);
      const i = r.exportKind === "type";
      return r.specifiers.push(...this.parseExportSpecifiers(i)), r.source = null, r.declaration = null, this.hasPlugin("importAssertions") && (r.assertions = []), !0;
    }
    return !1;
  }
  maybeParseExportDeclaration(t) {
    return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), !0) : !1;
  }
  isAsyncFunction() {
    if (!this.isContextual(95)) return !1;
    const t = this.nextTokenInLineStart();
    return this.isUnparsedContextual(t, "function");
  }
  parseExportDefaultExpression() {
    const t = this.startNode();
    if (this.match(68))
      return this.next(), this.parseFunction(t, 5);
    if (this.isAsyncFunction())
      return this.next(), this.next(), this.parseFunction(t, 13);
    if (this.match(80))
      return this.parseClass(t, !0, !0);
    if (this.match(26))
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(w.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
    if (this.match(75) || this.match(74) || this.isLet())
      throw this.raise(w.UnsupportedDefaultExport, this.state.startLoc);
    const r = this.parseMaybeAssignAllowIn();
    return this.semicolon(), r;
  }
  parseExportDeclaration(t) {
    return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
  }
  isExportDefaultSpecifier() {
    const {
      type: t
    } = this.state;
    if (Le(t)) {
      if (t === 95 && !this.state.containsEsc || t === 100)
        return !1;
      if ((t === 130 || t === 129) && !this.state.containsEsc) {
        const {
          type: s
        } = this.lookahead();
        if (Le(s) && s !== 98 || s === 5)
          return this.expectOnePlugin(["flow", "typescript"]), !1;
      }
    } else if (!this.match(65))
      return !1;
    const r = this.nextTokenStart(), i = this.isUnparsedContextual(r, "from");
    if (this.input.charCodeAt(r) === 44 || Le(this.state.type) && i)
      return !0;
    if (this.match(65) && i) {
      const s = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
      return s === 34 || s === 39;
    }
    return !1;
  }
  parseExportFrom(t, r) {
    this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(t)) : r && this.unexpected(), this.semicolon();
  }
  shouldParseExportDeclaration() {
    const {
      type: t
    } = this.state;
    return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(w.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.raise(w.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(w.UsingDeclarationExport, this.state.startLoc), !0) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
  }
  checkExport(t, r, i, s) {
    if (r) {
      var n;
      if (i) {
        if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
          var a;
          const o = t.declaration;
          o.type === "Identifier" && o.name === "from" && o.end - o.start === 4 && !((a = o.extra) != null && a.parenthesized) && this.raise(w.ExportDefaultFromAsIdentifier, o);
        }
      } else if ((n = t.specifiers) != null && n.length)
        for (const o of t.specifiers) {
          const {
            exported: l
          } = o, u = l.type === "Identifier" ? l.name : l.value;
          if (this.checkDuplicateExports(o, u), !s && o.local) {
            const {
              local: c
            } = o;
            c.type !== "Identifier" ? this.raise(w.ExportBindingIsString, o, {
              localName: c.value,
              exportName: u
            }) : (this.checkReservedWord(c.name, c.loc.start, !0, !1), this.scope.checkLocalExport(c));
          }
        }
      else if (t.declaration) {
        const o = t.declaration;
        if (o.type === "FunctionDeclaration" || o.type === "ClassDeclaration") {
          const {
            id: l
          } = o;
          if (!l) throw new Error("Assertion failure");
          this.checkDuplicateExports(t, l.name);
        } else if (o.type === "VariableDeclaration")
          for (const l of o.declarations)
            this.checkDeclaration(l.id);
      }
    }
  }
  checkDeclaration(t) {
    if (t.type === "Identifier")
      this.checkDuplicateExports(t, t.name);
    else if (t.type === "ObjectPattern")
      for (const r of t.properties)
        this.checkDeclaration(r);
    else if (t.type === "ArrayPattern")
      for (const r of t.elements)
        r && this.checkDeclaration(r);
    else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
  }
  checkDuplicateExports(t, r) {
    this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(w.DuplicateDefaultExport, t) : this.raise(w.DuplicateExport, t, {
      exportName: r
    })), this.exportedIdentifiers.add(r);
  }
  parseExportSpecifiers(t) {
    const r = [];
    let i = !0;
    for (this.expect(5); !this.eat(8); ) {
      if (i)
        i = !1;
      else if (this.expect(12), this.eat(8)) break;
      const s = this.isContextual(130), n = this.match(133), a = this.startNode();
      a.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(a, n, t, s));
    }
    return r;
  }
  parseExportSpecifier(t, r, i, s) {
    return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = iM(t.local) : t.exported || (t.exported = $t(t.local)), this.finishNode(t, "ExportSpecifier");
  }
  parseModuleExportName() {
    if (this.match(133)) {
      const t = this.parseStringLiteral(this.state.value), r = kM.exec(t.value);
      return r && this.raise(w.ModuleExportNameHasLoneSurrogate, t, {
        surrogateCharCode: r[0].charCodeAt(0)
      }), t;
    }
    return this.parseIdentifier(!0);
  }
  isJSONModuleImport(t) {
    return t.assertions != null ? t.assertions.some(({
      key: r,
      value: i
    }) => i.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
  }
  checkImportReflection(t) {
    const {
      specifiers: r
    } = t, i = r.length === 1 ? r[0].type : null;
    if (t.phase === "source")
      i !== "ImportDefaultSpecifier" && this.raise(w.SourcePhaseImportRequiresDefault, r[0].loc.start);
    else if (t.phase === "defer")
      i !== "ImportNamespaceSpecifier" && this.raise(w.DeferImportRequiresNamespace, r[0].loc.start);
    else if (t.module) {
      var s;
      i !== "ImportDefaultSpecifier" && this.raise(w.ImportReflectionNotBinding, r[0].loc.start), ((s = t.assertions) == null ? void 0 : s.length) > 0 && this.raise(w.ImportReflectionHasAssertion, r[0].loc.start);
    }
  }
  checkJSONModuleImport(t) {
    if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
      const {
        specifiers: r
      } = t;
      if (r != null) {
        const i = r.find((s) => {
          let n;
          if (s.type === "ExportSpecifier" ? n = s.local : s.type === "ImportSpecifier" && (n = s.imported), n !== void 0)
            return n.type === "Identifier" ? n.name !== "default" : n.value !== "default";
        });
        i !== void 0 && this.raise(w.ImportJSONBindingNotDefault, i.loc.start);
      }
    }
  }
  isPotentialImportPhase(t) {
    return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
  }
  applyImportPhase(t, r, i, s) {
    r || (i === "module" ? (this.expectPlugin("importReflection", s), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1), i === "source" ? (this.expectPlugin("sourcePhaseImports", s), t.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImportEvaluation", s), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
  }
  parseMaybeImportPhase(t, r) {
    if (!this.isPotentialImportPhase(r))
      return this.applyImportPhase(t, r, null), null;
    const i = this.parseIdentifier(!0), {
      type: s
    } = this.state;
    return (At(s) ? s !== 98 || this.lookaheadCharCode() === 102 : s !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(t, r, i.name, i.loc.start), null) : (this.applyImportPhase(t, r, null), i);
  }
  isPrecedingIdImportPhase(t) {
    const {
      type: r
    } = this.state;
    return Le(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
  }
  parseImport(t) {
    return this.match(133) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
  }
  parseImportSpecifiersAndAfter(t, r) {
    t.specifiers = [];
    const s = !this.maybeParseDefaultImportSpecifier(t, r) || this.eat(12), n = s && this.maybeParseStarImportSpecifier(t);
    return s && !n && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
  }
  parseImportSourceAndAttributes(t) {
    var r;
    return (r = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
  }
  parseImportSource() {
    return this.match(133) || this.unexpected(), this.parseExprAtom();
  }
  parseImportSpecifierLocal(t, r, i) {
    r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, i));
  }
  finishImportSpecifier(t, r, i = 8201) {
    return this.checkLVal(t.local, {
      in: {
        type: r
      },
      binding: i
    }), this.finishNode(t, r);
  }
  parseImportAttributes() {
    this.expect(5);
    const t = [], r = /* @__PURE__ */ new Set();
    do {
      if (this.match(8))
        break;
      const i = this.startNode(), s = this.state.value;
      if (r.has(s) && this.raise(w.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
        key: s
      }), r.add(s), this.match(133) ? i.key = this.parseStringLiteral(s) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(133))
        throw this.raise(w.ModuleAttributeInvalidValue, this.state.startLoc);
      i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
    } while (this.eat(12));
    return this.expect(8), t;
  }
  parseModuleAttributes() {
    const t = [], r = /* @__PURE__ */ new Set();
    do {
      const i = this.startNode();
      if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(w.ModuleAttributeDifferentFromType, i.key), r.has(i.key.name) && this.raise(w.ModuleAttributesWithDuplicateKeys, i.key, {
        key: i.key.name
      }), r.add(i.key.name), this.expect(14), !this.match(133))
        throw this.raise(w.ModuleAttributeInvalidValue, this.state.startLoc);
      i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
    } while (this.eat(12));
    return t;
  }
  maybeParseImportAttributes(t) {
    let r, i = !1;
    if (this.match(76)) {
      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
        return;
      this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.parseImportAttributes()), i = !0;
    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
      this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(w.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(t, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), r = this.parseImportAttributes();
    else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
      r = [];
    else if (this.hasPlugin("moduleAttributes"))
      r = [];
    else return;
    !i && this.hasPlugin("importAssertions") ? t.assertions = r : t.attributes = r;
  }
  maybeParseDefaultImportSpecifier(t, r) {
    if (r) {
      const i = this.startNodeAtNode(r);
      return i.local = r, t.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
    } else if (At(this.state.type))
      return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
    return !1;
  }
  maybeParseStarImportSpecifier(t) {
    if (this.match(55)) {
      const r = this.startNode();
      return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), !0;
    }
    return !1;
  }
  parseNamedImportSpecifiers(t) {
    let r = !0;
    for (this.expect(5); !this.eat(8); ) {
      if (r)
        r = !1;
      else {
        if (this.eat(14))
          throw this.raise(w.DestructureNamedImport, this.state.startLoc);
        if (this.expect(12), this.eat(8)) break;
      }
      const i = this.startNode(), s = this.match(133), n = this.isContextual(130);
      i.imported = this.parseModuleExportName();
      const a = this.parseImportSpecifier(i, s, t.importKind === "type" || t.importKind === "typeof", n, void 0);
      t.specifiers.push(a);
    }
  }
  parseImportSpecifier(t, r, i, s, n) {
    if (this.eatContextual(93))
      t.local = this.parseIdentifier();
    else {
      const {
        imported: a
      } = t;
      if (r)
        throw this.raise(w.ImportBindingIsString, t, {
          importName: a.value
        });
      this.checkReservedWord(a.name, t.loc.start, !0, !0), t.local || (t.local = $t(a));
    }
    return this.finishImportSpecifier(t, "ImportSpecifier", n);
  }
  isThisParam(t) {
    return t.type === "Identifier" && t.name === "this";
  }
}
class ff extends LM {
  constructor(t, r) {
    t = OM(t), super(t, r), this.options = t, this.initializeScopes(), this.plugins = MM(this.options.plugins), this.filename = t.sourceFilename;
  }
  getScopeHandler() {
    return Fa;
  }
  parse() {
    this.enterInitialScopes();
    const t = this.startNode(), r = this.startNode();
    return this.nextToken(), t.errors = null, this.parseTopLevel(t, r), t.errors = this.state.errors, t.comments.length = this.state.commentsLen, t;
  }
}
function MM(e) {
  const t = /* @__PURE__ */ new Map();
  for (const r of e) {
    const [i, s] = Array.isArray(r) ? r : [r, {}];
    t.has(i) || t.set(i, s || {});
  }
  return t;
}
function BM(e, t) {
  var r;
  if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
    t = Object.assign({}, t);
    try {
      t.sourceType = "module";
      const i = Jr(t, e), s = i.parse();
      if (i.sawUnambiguousESM)
        return s;
      if (i.ambiguousScriptDifferentAst)
        try {
          return t.sourceType = "script", Jr(t, e).parse();
        } catch {
        }
      else
        s.program.sourceType = "script";
      return s;
    } catch (i) {
      try {
        return t.sourceType = "script", Jr(t, e).parse();
      } catch {
      }
      throw i;
    }
  } else
    return Jr(t, e).parse();
}
function FM(e, t) {
  const r = Jr(t, e);
  return r.options.strictMode && (r.state.strict = !0), r.getExpression();
}
function jM(e) {
  const t = {};
  for (const r of Object.keys(e))
    t[r] = Mt(e[r]);
  return t;
}
const RM = jM(yL);
function Jr(e, t) {
  let r = ff;
  return e != null && e.plugins && (IM(e.plugins), r = UM(e.plugins)), new r(e, t);
}
const Ql = {};
function UM(e) {
  const t = wM.filter((s) => st(e, s)), r = t.join("/");
  let i = Ql[r];
  if (!i) {
    i = ff;
    for (const s of t)
      i = cf[s](i);
    Ql[r] = i;
  }
  return i;
}
var $M = Ar.parse = BM;
Ar.parseExpression = FM;
Ar.tokTypes = RM;
var Ua = {};
Object.defineProperty(Ua, "__esModule", {
  value: !0
});
Ua.default = XM;
var VM = Ae();
const {
  assignmentExpression: KM,
  expressionStatement: qM,
  identifier: WM
} = VM, JM = {
  Scope(e, t) {
    t.kind === "let" && e.skip();
  },
  FunctionParent(e) {
    e.skip();
  },
  VariableDeclaration(e, t) {
    if (t.kind && e.node.kind !== t.kind) return;
    const r = [], i = e.get("declarations");
    let s;
    for (const n of i) {
      s = n.node.id, n.node.init && r.push(qM(KM("=", n.node.id, n.node.init)));
      for (const a of Object.keys(n.getBindingIdentifiers()))
        t.emit(WM(a), a, n.node.init !== null);
    }
    e.parentPath.isFor({
      left: e.node
    }) ? e.replaceWith(s) : e.replaceWithMultiple(r);
  }
};
function XM(e, t, r = "var") {
  e.traverse(JM, {
    kind: r,
    emit: t
  });
}
var Zl;
function pf() {
  if (Zl) return Dt;
  Zl = 1, Object.defineProperty(Dt, "__esModule", {
    value: !0
  }), Dt._replaceWith = H, Dt.replaceExpressionWithStatements = se, Dt.replaceInline = Ue, Dt.replaceWith = $, Dt.replaceWithMultiple = R, Dt.replaceWithSourceString = V;
  var e = pi, t = Us(), r = mr(), i = nt, s = qc(), n = Ar, a = Ae(), o = Ua;
  const {
    FUNCTION_TYPES: l,
    arrowFunctionExpression: u,
    assignmentExpression: c,
    awaitExpression: f,
    blockStatement: p,
    buildUndefinedNode: h,
    callExpression: y,
    cloneNode: b,
    conditionalExpression: A,
    expressionStatement: I,
    getBindingIdentifiers: _,
    identifier: j,
    inheritLeadingComments: G,
    inheritTrailingComments: ce,
    inheritsComments: te,
    isBlockStatement: ae,
    isEmptyStatement: q,
    isExpression: Y,
    isExpressionStatement: re,
    isIfStatement: W,
    isProgram: Q,
    isStatement: U,
    isVariableDeclaration: L,
    removeComments: k,
    returnStatement: F,
    sequenceExpression: B,
    validate: N,
    yieldExpression: D
  } = a;
  function R(fe) {
    var pe;
    this.resync(), fe = s._verifyNodeList.call(this, fe), G(fe[0], this.node), ce(fe[fe.length - 1], this.node), (pe = (0, i.getCachedPaths)(this.hub, this.parent)) == null || pe.delete(this.node), this.node = this.container[this.key] = null;
    const Se = this.insertAfter(fe);
    return this.node ? this.requeue() : this.remove(), Se;
  }
  function V(fe) {
    this.resync();
    let pe;
    try {
      fe = `(${fe})`, pe = (0, n.parse)(fe);
    } catch (Ce) {
      const Ee = Ce.loc;
      throw Ee && (Ce.message += ` - make sure this is an expression.
` + (0, e.codeFrameColumns)(fe, {
        start: {
          line: Ee.line,
          column: Ee.column + 1
        }
      }), Ce.code = "BABEL_REPLACE_SOURCE_ERROR"), Ce;
    }
    const Se = pe.program.body[0].expression;
    return t.default.removeProperties(Se), this.replaceWith(Se);
  }
  function $(fe) {
    if (this.resync(), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let pe = fe instanceof r.default ? fe.node : fe;
    if (!pe)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === pe)
      return [this];
    if (this.isProgram() && !Q(pe))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(pe))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof pe == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let Se = "";
    if (this.isNodeType("Statement") && Y(pe) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(pe) && !this.parentPath.isExportDefaultDeclaration() && (pe = I(pe), Se = "expression"), this.isNodeType("Expression") && U(pe) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(pe))
      return this.replaceExpressionWithStatements([pe]);
    const Ce = this.node;
    return Ce && (te(pe, Ce), k(Ce)), H.call(this, pe), this.type = pe.type, this.setScope(), this.requeue(), [Se ? this.get(Se) : this];
  }
  function H(fe) {
    var pe;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? N(this.parent, this.key, [fe]) : N(this.parent, this.key, fe), this.debug(`Replace with ${fe == null ? void 0 : fe.type}`), (pe = (0, i.getCachedPaths)(this.hub, this.parent)) == null || pe.set(fe, this).delete(this.node), this.node = this.container[this.key] = fe;
  }
  function se(fe) {
    this.resync();
    const pe = [], Se = oe(fe, pe);
    if (Se) {
      for (const Re of pe) this.scope.push({
        id: Re
      });
      return this.replaceWith(Se)[0].get("expressions");
    }
    const Ce = this.getFunctionParent(), Ee = Ce == null ? void 0 : Ce.is("async"), Ne = Ce == null ? void 0 : Ce.is("generator"), _e = u([], p(fe));
    this.replaceWith(y(_e, []));
    const qe = this.get("callee");
    (0, o.default)(qe.get("body"), (Re) => {
      this.scope.push({
        id: Re
      });
    }, "var");
    const tt = this.get("callee").getCompletionRecords();
    for (const Re of tt) {
      if (!Re.isExpressionStatement()) continue;
      const lt = Re.findParent((He) => He.isLoop());
      if (lt) {
        let He = lt.getData("expressionReplacementReturnUid");
        He ? He = j(He.name) : (He = qe.scope.generateDeclaredUidIdentifier("ret"), qe.get("body").pushContainer("body", F(b(He))), lt.setData("expressionReplacementReturnUid", He)), Re.get("expression").replaceWith(c("=", b(He), Re.node.expression));
      } else
        Re.replaceWith(F(Re.node.expression));
    }
    qe.arrowFunctionToExpression();
    const Pe = qe, Be = Ee && t.default.hasType(this.get("callee.body").node, "AwaitExpression", l), ve = Ne && t.default.hasType(this.get("callee.body").node, "YieldExpression", l);
    return Be && (Pe.set("async", !0), ve || this.replaceWith(f(this.node))), ve && (Pe.set("generator", !0), this.replaceWith(D(this.node, !0))), Pe.get("body.body");
  }
  function oe(fe, pe) {
    const Se = [];
    let Ce = !0;
    for (const Ee of fe)
      if (q(Ee) || (Ce = !1), Y(Ee))
        Se.push(Ee);
      else if (re(Ee))
        Se.push(Ee.expression);
      else if (L(Ee)) {
        if (Ee.kind !== "var") return;
        for (const Ne of Ee.declarations) {
          const _e = _(Ne);
          for (const qe of Object.keys(_e))
            pe.push(b(_e[qe]));
          Ne.init && Se.push(c("=", Ne.id, Ne.init));
        }
        Ce = !0;
      } else if (W(Ee)) {
        const Ne = Ee.consequent ? oe([Ee.consequent], pe) : h(), _e = Ee.alternate ? oe([Ee.alternate], pe) : h();
        if (!Ne || !_e) return;
        Se.push(A(Ee.test, Ne, _e));
      } else if (ae(Ee)) {
        const Ne = oe(Ee.body, pe);
        if (!Ne) return;
        Se.push(Ne);
      } else if (q(Ee))
        fe.indexOf(Ee) === 0 && (Ce = !0);
      else
        return;
    return Ce && Se.push(h()), Se.length === 1 ? Se[0] : B(Se);
  }
  function Ue(fe) {
    if (this.resync(), Array.isArray(fe))
      if (Array.isArray(this.container)) {
        fe = s._verifyNodeList.call(this, fe);
        const pe = s._containerInsertAfter.call(this, fe);
        return this.remove(), pe;
      } else
        return this.replaceWithMultiple(fe);
    else
      return this.replaceWith(fe);
  }
  return Dt;
}
var Bs = {};
Object.defineProperty(Bs, "__esModule", {
  value: !0
});
Bs.evaluate = tB;
Bs.evaluateTruthy = ZM;
const YM = ["Number", "String", "Math"], HM = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null], GM = ["random"];
function eu(e) {
  return YM.includes(e);
}
function zM(e) {
  return HM.includes(e);
}
function QM(e) {
  return GM.includes(e);
}
function ZM() {
  const e = this.evaluate();
  if (e.confident) return !!e.value;
}
function Bt(e, t) {
  t.confident && (t.deoptPath = e, t.confident = !1);
}
const tu = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
function pt(e, t) {
  const {
    node: r
  } = e, {
    seen: i
  } = t;
  if (i.has(r)) {
    const s = i.get(r);
    if (s.resolved)
      return s.value;
    Bt(e, t);
    return;
  } else {
    const s = {
      resolved: !1
    };
    i.set(r, s);
    const n = eB(e, t);
    return t.confident && (s.resolved = !0, s.value = n), n;
  }
}
function eB(e, t) {
  if (t.confident) {
    if (e.isSequenceExpression()) {
      const r = e.get("expressions");
      return pt(r[r.length - 1], t);
    }
    if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral())
      return e.node.value;
    if (e.isNullLiteral())
      return null;
    if (e.isTemplateLiteral())
      return ru(e, e.node.quasis, t);
    if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
      const r = e.get("tag.object"), {
        node: {
          name: i
        }
      } = r, s = e.get("tag.property");
      if (r.isIdentifier() && i === "String" && !e.scope.getBinding(i) && s.isIdentifier() && s.node.name === "raw")
        return ru(e, e.node.quasi.quasis, t, !0);
    }
    if (e.isConditionalExpression()) {
      const r = pt(e.get("test"), t);
      return t.confident ? pt(r ? e.get("consequent") : e.get("alternate"), t) : void 0;
    }
    if (e.isExpressionWrapper())
      return pt(e.get("expression"), t);
    if (e.isMemberExpression() && !e.parentPath.isCallExpression({
      callee: e.node
    })) {
      const r = e.get("property"), i = e.get("object");
      if (i.isLiteral()) {
        const s = i.node.value, n = typeof s;
        let a = null;
        if (e.node.computed) {
          if (a = pt(r, t), !t.confident) return;
        } else r.isIdentifier() && (a = r.node.name);
        if ((n === "number" || n === "string") && a != null && (typeof a == "number" || typeof a == "string"))
          return s[a];
      }
    }
    if (e.isReferencedIdentifier()) {
      const r = e.scope.getBinding(e.node.name);
      if (r) {
        if (r.constantViolations.length > 0 || e.node.start < r.path.node.end) {
          Bt(r.path, t);
          return;
        }
        if (r.hasValue)
          return r.value;
      }
      const i = e.node.name;
      if (tu.has(i)) {
        if (!r)
          return tu.get(i);
        Bt(r.path, t);
        return;
      }
      const s = e.resolve();
      if (s === e) {
        Bt(e, t);
        return;
      } else
        return pt(s, t);
    }
    if (e.isUnaryExpression({
      prefix: !0
    })) {
      if (e.node.operator === "void")
        return;
      const r = e.get("argument");
      if (e.node.operator === "typeof" && (r.isFunction() || r.isClass()))
        return "function";
      const i = pt(r, t);
      if (!t.confident) return;
      switch (e.node.operator) {
        case "!":
          return !i;
        case "+":
          return +i;
        case "-":
          return -i;
        case "~":
          return ~i;
        case "typeof":
          return typeof i;
      }
    }
    if (e.isArrayExpression()) {
      const r = [], i = e.get("elements");
      for (const s of i) {
        const n = s.evaluate();
        if (n.confident)
          r.push(n.value);
        else {
          Bt(n.deopt, t);
          return;
        }
      }
      return r;
    }
    if (e.isObjectExpression()) {
      const r = {}, i = e.get("properties");
      for (const s of i) {
        if (s.isObjectMethod() || s.isSpreadElement()) {
          Bt(s, t);
          return;
        }
        const n = s.get("key");
        let a;
        if (s.node.computed) {
          if (a = n.evaluate(), !a.confident) {
            Bt(a.deopt, t);
            return;
          }
          a = a.value;
        } else n.isIdentifier() ? a = n.node.name : a = n.node.value;
        let l = s.get("value").evaluate();
        if (!l.confident) {
          Bt(l.deopt, t);
          return;
        }
        l = l.value, r[a] = l;
      }
      return r;
    }
    if (e.isLogicalExpression()) {
      const r = t.confident, i = pt(e.get("left"), t), s = t.confident;
      t.confident = r;
      const n = pt(e.get("right"), t), a = t.confident;
      switch (e.node.operator) {
        case "||":
          return t.confident = s && (!!i || a), t.confident ? i || n : void 0;
        case "&&":
          return t.confident = s && (!i || a), t.confident ? i && n : void 0;
        case "??":
          return t.confident = s && (i != null || a), t.confident ? i ?? n : void 0;
      }
    }
    if (e.isBinaryExpression()) {
      const r = pt(e.get("left"), t);
      if (!t.confident) return;
      const i = pt(e.get("right"), t);
      if (!t.confident) return;
      switch (e.node.operator) {
        case "-":
          return r - i;
        case "+":
          return r + i;
        case "/":
          return r / i;
        case "*":
          return r * i;
        case "%":
          return r % i;
        case "**":
          return Math.pow(r, i);
        case "<":
          return r < i;
        case ">":
          return r > i;
        case "<=":
          return r <= i;
        case ">=":
          return r >= i;
        case "==":
          return r == i;
        case "!=":
          return r != i;
        case "===":
          return r === i;
        case "!==":
          return r !== i;
        case "|":
          return r | i;
        case "&":
          return r & i;
        case "^":
          return r ^ i;
        case "<<":
          return r << i;
        case ">>":
          return r >> i;
        case ">>>":
          return r >>> i;
      }
    }
    if (e.isCallExpression()) {
      const r = e.get("callee");
      let i, s;
      if (r.isIdentifier() && !e.scope.getBinding(r.node.name) && (eu(r.node.name) || zM(r.node.name)) && (s = ur[r.node.name]), r.isMemberExpression()) {
        const n = r.get("object"), a = r.get("property");
        if (n.isIdentifier() && a.isIdentifier() && eu(n.node.name) && !QM(a.node.name)) {
          i = ur[n.node.name];
          const o = a.node.name;
          hasOwnProperty.call(i, o) && (s = i[o]);
        }
        if (n.isLiteral() && a.isIdentifier()) {
          const o = typeof n.node.value;
          (o === "string" || o === "number") && (i = n.node.value, s = i[a.node.name]);
        }
      }
      if (s) {
        const n = e.get("arguments").map((a) => pt(a, t));
        return t.confident ? s.apply(i, n) : void 0;
      }
    }
    Bt(e, t);
  }
}
function ru(e, t, r, i = !1) {
  let s = "", n = 0;
  const a = e.isTemplateLiteral() ? e.get("expressions") : e.get("quasi.expressions");
  for (const o of t) {
    if (!r.confident) break;
    s += i ? o.value.raw : o.value.cooked;
    const l = a[n++];
    l && (s += String(pt(l, r)));
  }
  if (r.confident)
    return s;
}
function tB() {
  const e = {
    confident: !0,
    deoptPath: null,
    seen: /* @__PURE__ */ new Map()
  };
  let t = pt(this, e);
  return e.confident || (t = void 0), {
    confident: e.confident,
    deopt: e.deoptPath,
    value: t
  };
}
var hr = {}, $a = {}, yt = {}, St = {};
Object.defineProperty(St, "__esModule", {
  value: !0
});
St.statements = St.statement = St.smart = St.program = St.expression = void 0;
var rB = Ae();
const {
  assertExpressionStatement: iB
} = rB;
function Va(e) {
  return {
    code: (t) => `/* @babel/template */;
${t}`,
    validate: () => {
    },
    unwrap: (t) => e(t.program.body.slice(1))
  };
}
St.smart = Va((e) => e.length > 1 ? e : e[0]);
St.statements = Va((e) => e);
St.statement = Va((e) => {
  if (e.length === 0)
    throw new Error("Found nothing to return.");
  if (e.length > 1)
    throw new Error("Found multiple statements but wanted one");
  return e[0];
});
const sB = St.expression = {
  code: (e) => `(
${e}
)`,
  validate: (e) => {
    if (e.program.body.length > 1)
      throw new Error("Found multiple statements but wanted one");
    if (sB.unwrap(e).start === 0)
      throw new Error("Parse result included parens.");
  },
  unwrap: ({
    program: e
  }) => {
    const [t] = e.body;
    return iB(t), t.expression;
  }
};
St.program = {
  code: (e) => e,
  validate: () => {
  },
  unwrap: (e) => e.program
};
var Ka = {}, dr = {};
Object.defineProperty(dr, "__esModule", {
  value: !0
});
dr.merge = oB;
dr.normalizeReplacements = uB;
dr.validate = lB;
const nB = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
function aB(e, t) {
  if (e == null) return {};
  var r = {}, i = Object.keys(e), s, n;
  for (n = 0; n < i.length; n++)
    s = i[n], !(t.indexOf(s) >= 0) && (r[s] = e[s]);
  return r;
}
function oB(e, t) {
  const {
    placeholderWhitelist: r = e.placeholderWhitelist,
    placeholderPattern: i = e.placeholderPattern,
    preserveComments: s = e.preserveComments,
    syntacticPlaceholders: n = e.syntacticPlaceholders
  } = t;
  return {
    parser: Object.assign({}, e.parser, t.parser),
    placeholderWhitelist: r,
    placeholderPattern: i,
    preserveComments: s,
    syntacticPlaceholders: n
  };
}
function lB(e) {
  if (e != null && typeof e != "object")
    throw new Error("Unknown template options.");
  const t = e || {}, {
    placeholderWhitelist: r,
    placeholderPattern: i,
    preserveComments: s,
    syntacticPlaceholders: n
  } = t, a = aB(t, nB);
  if (r != null && !(r instanceof Set))
    throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
  if (i != null && !(i instanceof RegExp) && i !== !1)
    throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
  if (s != null && typeof s != "boolean")
    throw new Error("'.preserveComments' must be a boolean, null, or undefined");
  if (n != null && typeof n != "boolean")
    throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
  if (n === !0 && (r != null || i != null))
    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
  return {
    parser: a,
    placeholderWhitelist: r || void 0,
    placeholderPattern: i ?? void 0,
    preserveComments: s ?? void 0,
    syntacticPlaceholders: n ?? void 0
  };
}
function uB(e) {
  if (Array.isArray(e))
    return e.reduce((t, r, i) => (t["$" + i] = r, t), {});
  if (typeof e == "object" || e == null)
    return e || void 0;
  throw new Error("Template replacements must be an array, object, null, or undefined");
}
var qa = {}, Fs = {};
Object.defineProperty(Fs, "__esModule", {
  value: !0
});
Fs.default = xB;
var cB = Ae(), fB = Ar, pB = pi;
const {
  isCallExpression: hB,
  isExpressionStatement: dB,
  isFunction: mB,
  isIdentifier: yB,
  isJSXIdentifier: TB,
  isNewExpression: gB,
  isPlaceholder: Wi,
  isStatement: bB,
  isStringLiteral: iu,
  removePropertiesDeep: SB,
  traverse: EB
} = cB, PB = /^[_$A-Z0-9]+$/;
function xB(e, t, r) {
  const {
    placeholderWhitelist: i,
    placeholderPattern: s,
    preserveComments: n,
    syntacticPlaceholders: a
  } = r, o = CB(t, r.parser, a);
  SB(o, {
    preserveComments: n
  }), e.validate(o);
  const l = {
    syntactic: {
      placeholders: [],
      placeholderNames: /* @__PURE__ */ new Set()
    },
    legacy: {
      placeholders: [],
      placeholderNames: /* @__PURE__ */ new Set()
    },
    placeholderWhitelist: i,
    placeholderPattern: s,
    syntacticPlaceholders: a
  };
  return EB(o, vB, l), Object.assign({
    ast: o
  }, l.syntactic.placeholders.length ? l.syntactic : l.legacy);
}
function vB(e, t, r) {
  var i;
  let s, n = r.syntactic.placeholders.length > 0;
  if (Wi(e)) {
    if (r.syntacticPlaceholders === !1)
      throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
    s = e.name.name, n = !0;
  } else {
    if (n || r.syntacticPlaceholders)
      return;
    if (yB(e) || TB(e))
      s = e.name;
    else if (iu(e))
      s = e.value;
    else
      return;
  }
  if (n && (r.placeholderPattern != null || r.placeholderWhitelist != null))
    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
  if (!n && (r.placeholderPattern === !1 || !(r.placeholderPattern || PB).test(s)) && !((i = r.placeholderWhitelist) != null && i.has(s)))
    return;
  t = t.slice();
  const {
    node: a,
    key: o
  } = t[t.length - 1];
  let l;
  iu(e) || Wi(e, {
    expectedNode: "StringLiteral"
  }) ? l = "string" : gB(a) && o === "arguments" || hB(a) && o === "arguments" || mB(a) && o === "params" ? l = "param" : dB(a) && !Wi(e) ? (l = "statement", t = t.slice(0, -1)) : bB(e) && Wi(e) ? l = "statement" : l = "other";
  const {
    placeholders: u,
    placeholderNames: c
  } = n ? r.syntactic : r.legacy;
  u.push({
    name: s,
    type: l,
    resolve: (f) => AB(f, t),
    isDuplicate: c.has(s)
  }), c.add(s);
}
function AB(e, t) {
  let r = e;
  for (let n = 0; n < t.length - 1; n++) {
    const {
      key: a,
      index: o
    } = t[n];
    o === void 0 ? r = r[a] : r = r[a][o];
  }
  const {
    key: i,
    index: s
  } = t[t.length - 1];
  return {
    parent: r,
    key: i,
    index: s
  };
}
function CB(e, t, r) {
  const i = (t.plugins || []).slice();
  r !== !1 && i.push("placeholders"), t = Object.assign({
    allowReturnOutsideFunction: !0,
    allowSuperOutsideMethod: !0,
    sourceType: "module"
  }, t, {
    plugins: i
  });
  try {
    return (0, fB.parse)(e, t);
  } catch (s) {
    const n = s.loc;
    throw n && (s.message += `
` + (0, pB.codeFrameColumns)(e, {
      start: n
    }), s.code = "BABEL_TEMPLATE_PARSE_ERROR"), s;
  }
}
var js = {};
Object.defineProperty(js, "__esModule", {
  value: !0
});
js.default = kB;
var IB = Ae();
const {
  blockStatement: wB,
  cloneNode: Fn,
  emptyStatement: OB,
  expressionStatement: Tn,
  identifier: Ji,
  isStatement: su,
  isStringLiteral: NB,
  stringLiteral: _B,
  validate: nu
} = IB;
function kB(e, t) {
  const r = Fn(e.ast);
  return t && (e.placeholders.forEach((i) => {
    if (!hasOwnProperty.call(t, i.name)) {
      const s = i.name;
      throw new Error(`Error: No substitution given for "${s}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${s}'])}
            - { placeholderPattern: /^${s}$/ }`);
    }
  }), Object.keys(t).forEach((i) => {
    if (!e.placeholderNames.has(i))
      throw new Error(`Unknown substitution "${i}" given`);
  })), e.placeholders.slice().reverse().forEach((i) => {
    try {
      DB(i, r, t && t[i.name] || null);
    } catch (s) {
      throw s.message = `@babel/template placeholder "${i.name}": ${s.message}`, s;
    }
  }), r;
}
function DB(e, t, r) {
  e.isDuplicate && (Array.isArray(r) ? r = r.map((a) => Fn(a)) : typeof r == "object" && (r = Fn(r)));
  const {
    parent: i,
    key: s,
    index: n
  } = e.resolve(t);
  if (e.type === "string") {
    if (typeof r == "string" && (r = _B(r)), !r || !NB(r))
      throw new Error("Expected string substitution");
  } else if (e.type === "statement")
    n === void 0 ? r ? Array.isArray(r) ? r = wB(r) : typeof r == "string" ? r = Tn(Ji(r)) : su(r) || (r = Tn(r)) : r = OB() : r && !Array.isArray(r) && (typeof r == "string" && (r = Ji(r)), su(r) || (r = Tn(r)));
  else if (e.type === "param") {
    if (typeof r == "string" && (r = Ji(r)), n === void 0) throw new Error("Assertion failure.");
  } else if (typeof r == "string" && (r = Ji(r)), Array.isArray(r))
    throw new Error("Cannot replace single expression with an array.");
  if (n === void 0)
    nu(i, s, r), i[s] = r;
  else {
    const a = i[s].slice();
    e.type === "statement" || e.type === "param" ? r == null ? a.splice(n, 1) : Array.isArray(r) ? a.splice(n, 1, ...r) : a[n] = r : a[n] = r, nu(i, s, a), i[s] = a;
  }
}
Object.defineProperty(qa, "__esModule", {
  value: !0
});
qa.default = FB;
var LB = dr, MB = Fs, BB = js;
function FB(e, t, r) {
  t = e.code(t);
  let i;
  return (s) => {
    const n = (0, LB.normalizeReplacements)(s);
    return i || (i = (0, MB.default)(e, t, r)), e.unwrap((0, BB.default)(i, n));
  };
}
var Wa = {};
Object.defineProperty(Wa, "__esModule", {
  value: !0
});
Wa.default = $B;
var jB = dr, RB = Fs, UB = js;
function $B(e, t, r) {
  const {
    metadata: i,
    names: s
  } = VB(e, t, r);
  return (n) => {
    const a = {};
    return n.forEach((o, l) => {
      a[s[l]] = o;
    }), (o) => {
      const l = (0, jB.normalizeReplacements)(o);
      return l && Object.keys(l).forEach((u) => {
        if (hasOwnProperty.call(a, u))
          throw new Error("Unexpected replacement overlap.");
      }), e.unwrap((0, UB.default)(i, l ? Object.assign(l, a) : a));
    };
  };
}
function VB(e, t, r) {
  let i = "BABEL_TPL$";
  const s = t.join("");
  do
    i = "$$" + i;
  while (s.includes(i));
  const {
    names: n,
    code: a
  } = KB(t, i);
  return {
    metadata: (0, RB.default)(e, e.code(a), {
      parser: r.parser,
      placeholderWhitelist: new Set(n.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
      placeholderPattern: r.placeholderPattern,
      preserveComments: r.preserveComments,
      syntacticPlaceholders: r.syntacticPlaceholders
    }),
    names: n
  };
}
function KB(e, t) {
  const r = [];
  let i = e[0];
  for (let s = 1; s < e.length; s++) {
    const n = `${t}${s - 1}`;
    r.push(n), i += n + e[s];
  }
  return {
    names: r,
    code: i
  };
}
Object.defineProperty(Ka, "__esModule", {
  value: !0
});
Ka.default = hf;
var wt = dr, au = qa, ou = Wa;
const lu = (0, wt.validate)({
  placeholderPattern: !1
});
function hf(e, t) {
  const r = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), s = t || (0, wt.validate)(null);
  return Object.assign((n, ...a) => {
    if (typeof n == "string") {
      if (a.length > 1) throw new Error("Unexpected extra params.");
      return uu((0, au.default)(e, n, (0, wt.merge)(s, (0, wt.validate)(a[0]))));
    } else if (Array.isArray(n)) {
      let o = r.get(n);
      return o || (o = (0, ou.default)(e, n, s), r.set(n, o)), uu(o(a));
    } else if (typeof n == "object" && n) {
      if (a.length > 0) throw new Error("Unexpected extra params.");
      return hf(e, (0, wt.merge)(s, (0, wt.validate)(n)));
    }
    throw new Error(`Unexpected template param ${typeof n}`);
  }, {
    ast: (n, ...a) => {
      if (typeof n == "string") {
        if (a.length > 1) throw new Error("Unexpected extra params.");
        return (0, au.default)(e, n, (0, wt.merge)((0, wt.merge)(s, (0, wt.validate)(a[0])), lu))();
      } else if (Array.isArray(n)) {
        let o = i.get(n);
        return o || (o = (0, ou.default)(e, n, (0, wt.merge)(s, lu)), i.set(n, o)), o(a)();
      }
      throw new Error(`Unexpected template param ${typeof n}`);
    }
  });
}
function uu(e) {
  let t = "";
  try {
    throw new Error();
  } catch (r) {
    r.stack && (t = r.stack.split(`
`).slice(3).join(`
`));
  }
  return (r) => {
    try {
      return e(r);
    } catch (i) {
      throw i.stack += `
    =============
${t}`, i;
    }
  };
}
Object.defineProperty(yt, "__esModule", {
  value: !0
});
yt.statements = yt.statement = yt.smart = yt.program = yt.expression = yt.default = void 0;
var di = St, mi = Ka;
const gn = yt.smart = (0, mi.default)(di.smart), qB = yt.statement = (0, mi.default)(di.statement), WB = yt.statements = (0, mi.default)(di.statements), JB = yt.expression = (0, mi.default)(di.expression), XB = yt.program = (0, mi.default)(di.program);
yt.default = Object.assign(gn.bind(void 0), {
  smart: gn,
  statement: qB,
  statements: WB,
  expression: JB,
  program: XB,
  ast: gn.ast
});
Object.defineProperty($a, "__esModule", {
  value: !0
});
$a.default = d3;
var df = yt, YB = Ae();
const {
  NOT_LOCAL_BINDING: cu,
  cloneNode: HB,
  identifier: GB,
  isAssignmentExpression: zB,
  isAssignmentPattern: QB,
  isFunction: mf,
  isIdentifier: fu,
  isLiteral: pu,
  isNullLiteral: ZB,
  isObjectMethod: e3,
  isObjectProperty: t3,
  isRegExpLiteral: r3,
  isRestElement: i3,
  isTemplateLiteral: s3,
  isVariableDeclarator: n3,
  toBindingIdentifierName: a3
} = YB;
function o3(e) {
  const t = e.params.findIndex((r) => QB(r) || i3(r));
  return t === -1 ? e.params.length : t;
}
const l3 = df.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`), u3 = df.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`), c3 = {
  "ReferencedIdentifier|BindingIdentifier"(e, t) {
    e.node.name !== t.name || e.scope.getBindingIdentifier(t.name) !== t.outerDeclar || (t.selfReference = !0, e.stop());
  }
};
function f3(e) {
  return ZB(e) ? "null" : r3(e) ? `_${e.pattern}_${e.flags}` : s3(e) ? e.quasis.map((t) => t.value.raw).join("") : e.value !== void 0 ? e.value + "" : "";
}
function p3(e, t, r, i) {
  if (e.selfReference)
    if (i.hasBinding(r.name) && !i.hasGlobal(r.name))
      i.rename(r.name);
    else {
      if (!mf(t)) return;
      let s = l3;
      t.generator && (s = u3);
      const n = s({
        FUNCTION: t,
        FUNCTION_ID: r,
        FUNCTION_KEY: i.generateUidIdentifier(r.name)
      }).expression, a = n.callee.body.body[0].params;
      for (let o = 0, l = o3(t); o < l; o++)
        a.push(i.generateUidIdentifier("x"));
      return n;
    }
  t.id = r, i.getProgramParent().references[r.name] = !0;
}
function h3(e, t, r) {
  const i = {
    selfAssignment: !1,
    selfReference: !1,
    outerDeclar: r.getBindingIdentifier(t),
    name: t
  }, s = r.getOwnBinding(t);
  return s ? s.kind === "param" && (i.selfReference = !0) : (i.outerDeclar || r.hasGlobal(t)) && r.traverse(e, c3, i), i;
}
function d3({
  node: e,
  parent: t,
  scope: r,
  id: i
}, s = !1, n = !1) {
  if (e.id) return;
  if ((t3(t) || e3(t, {
    kind: "method"
  })) && (!t.computed || pu(t.key)))
    i = t.key;
  else if (n3(t)) {
    if (i = t.id, fu(i) && !s) {
      const u = r.parent.getBinding(i.name);
      if (u && u.constant && r.getBinding(i.name) === u) {
        e.id = HB(i), e.id[cu] = !0;
        return;
      }
    }
  } else if (zB(t, {
    operator: "="
  }))
    i = t.left;
  else if (!i)
    return;
  let a;
  if (i && pu(i) ? a = f3(i) : i && fu(i) && (a = i.name), a === void 0 || !n && mf(e) && /[\uD800-\uDFFF]/.test(a))
    return;
  a = a3(a);
  const o = GB(a);
  o[cu] = !0;
  const l = h3(e, a, r);
  return p3(l, e, o, r) || e;
}
Object.defineProperty(hr, "__esModule", {
  value: !0
});
hr.arrowFunctionToExpression = B3;
hr.ensureBlock = D3;
hr.toComputedKey = k3;
hr.unwrapFunctionEnvironment = L3;
var m3 = Ae(), Ja = pr, y3 = $a, Xa = Vt;
const {
  arrowFunctionExpression: Ya,
  assignmentExpression: sr,
  binaryExpression: jn,
  blockStatement: T3,
  callExpression: Er,
  conditionalExpression: g3,
  expressionStatement: yf,
  identifier: Ye,
  isIdentifier: b3,
  jsxIdentifier: S3,
  logicalExpression: E3,
  LOGICAL_OPERATORS: P3,
  memberExpression: vt,
  metaProperty: x3,
  numericLiteral: v3,
  objectExpression: A3,
  restElement: C3,
  returnStatement: I3,
  sequenceExpression: w3,
  spreadElement: O3,
  stringLiteral: Tf,
  super: Rn,
  thisExpression: Qr,
  toExpression: N3,
  unaryExpression: _3
} = m3;
function k3() {
  let e;
  if (this.isMemberExpression())
    e = this.node.property;
  else if (this.isProperty() || this.isMethod())
    e = this.node.key;
  else
    throw new ReferenceError("todo");
  return this.node.computed || b3(e) && (e = Tf(e.name)), e;
}
function D3() {
  const e = this.get("body"), t = e.node;
  if (Array.isArray(e))
    throw new Error("Can't convert array path to a block statement");
  if (!t)
    throw new Error("Can't convert node without a body");
  if (e.isBlockStatement())
    return t;
  const r = [];
  let i = "body", s, n;
  e.isStatement() ? (n = "body", s = 0, r.push(e.node)) : (i += ".body.0", this.isFunction() ? (s = "argument", r.push(I3(e.node))) : (s = "expression", r.push(yf(e.node)))), this.node.body = T3(r);
  const a = this.get(i);
  return e.setup(a, n ? a.node[n] : a.node, n, s), this.node;
}
hr.arrowFunctionToShadowed = function() {
  this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
};
function L3() {
  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
  gf(this);
}
function M3(e, t) {
  e.node.type = t;
}
function B3({
  allowInsertArrow: e = !0,
  allowInsertArrowWithRest: t = e,
  noNewArrows: r = !((i) => (i = arguments[0]) == null ? void 0 : i.specCompliant)()
} = {}) {
  if (!this.isArrowFunctionExpression())
    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
  const {
    thisBinding: i,
    fnPath: s
  } = gf(this, r, e, t);
  if (s.ensureBlock(), M3(s, "FunctionExpression"), !r) {
    const n = i ? null : s.scope.generateUidIdentifier("arrowCheckId");
    return n && s.parentPath.scope.push({
      id: n,
      init: A3([])
    }), s.get("body").unshiftContainer("body", yf(Er(this.hub.addHelper("newArrowCheck"), [Qr(), Ye(n ? n.name : i)]))), s.replaceWith(Er(vt((0, y3.default)(this, !0) || s.node, Ye("bind")), [n ? Ye(n.name) : Qr()])), s.get("callee.object");
  }
  return s;
}
const F3 = (0, Xa.merge)([{
  CallExpression(e, {
    allSuperCalls: t
  }) {
    e.get("callee").isSuper() && t.push(e);
  }
}, Ja.default]);
function gf(e, t = !0, r = !0, i = !0) {
  let s, n = e.findParent((h) => {
    if (h.isArrowFunctionExpression()) {
      var y;
      return (y = s) != null || (s = h), !1;
    }
    return h.isFunction() || h.isProgram() || h.isClassProperty({
      static: !1
    }) || h.isClassPrivateProperty({
      static: !1
    });
  });
  const a = n.isClassMethod({
    kind: "constructor"
  });
  if (n.isClassProperty() || n.isClassPrivateProperty())
    if (s)
      n = s;
    else if (r)
      e.replaceWith(Er(Ya([], N3(e.node)), [])), n = e.get("callee"), e = n.get("body");
    else
      throw e.buildCodeFrameError("Unable to transform arrow inside class property");
  const {
    thisPaths: o,
    argumentsPaths: l,
    newTargetPaths: u,
    superProps: c,
    superCalls: f
  } = W3(e);
  if (a && f.length > 0) {
    if (!r)
      throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
    if (!i)
      throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
    const h = [];
    n.traverse(F3, {
      allSuperCalls: h
    });
    const y = V3(n);
    h.forEach((b) => {
      const A = Ye(y);
      A.loc = b.node.callee.loc, b.get("callee").replaceWith(A);
    });
  }
  if (l.length > 0) {
    const h = Zr(n, "arguments", () => {
      const y = () => Ye("arguments");
      return n.scope.path.isProgram() ? g3(jn("===", _3("typeof", y()), Tf("undefined")), n.scope.buildUndefinedNode(), y()) : y();
    });
    l.forEach((y) => {
      const b = Ye(h);
      b.loc = y.node.loc, y.replaceWith(b);
    });
  }
  if (u.length > 0) {
    const h = Zr(n, "newtarget", () => x3(Ye("new"), Ye("target")));
    u.forEach((y) => {
      const b = Ye(h);
      b.loc = y.node.loc, y.replaceWith(b);
    });
  }
  if (c.length > 0) {
    if (!r)
      throw c[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
    c.reduce((y, b) => y.concat(R3(b)), []).forEach((y) => {
      const b = y.node.computed ? "" : y.get("property").node.name, A = y.parentPath, I = A.isAssignmentExpression({
        left: y.node
      }), _ = A.isCallExpression({
        callee: y.node
      }), j = A.isTaggedTemplateExpression({
        tag: y.node
      }), G = K3(n, I, b), ce = [];
      if (y.node.computed && ce.push(y.get("property").node), I) {
        const ae = A.node.right;
        ce.push(ae);
      }
      const te = Er(Ye(G), ce);
      _ ? (A.unshiftContainer("arguments", Qr()), y.replaceWith(vt(te, Ye("call"))), o.push(A.get("arguments.0"))) : I ? A.replaceWith(te) : j ? (y.replaceWith(Er(vt(te, Ye("bind"), !1), [Qr()])), o.push(y.get("arguments.0"))) : y.replaceWith(te);
    });
  }
  let p;
  return (o.length > 0 || !t) && (p = $3(n, a), (t || a && bf(n)) && (o.forEach((h) => {
    const y = h.isJSX() ? S3(p) : Ye(p);
    y.loc = h.node.loc, h.replaceWith(y);
  }), t || (p = null))), {
    thisBinding: p,
    fnPath: e
  };
}
function j3(e) {
  return P3.includes(e);
}
function R3(e) {
  if (e.parentPath.isAssignmentExpression() && e.parentPath.node.operator !== "=") {
    const r = e.parentPath, i = r.node.operator.slice(0, -1), s = r.node.right, n = j3(i);
    if (e.node.computed) {
      const a = e.scope.generateDeclaredUidIdentifier("tmp"), o = e.node.object, l = e.node.property;
      r.get("left").replaceWith(vt(o, sr("=", a, l), !0)), r.get("right").replaceWith(t(n ? "=" : i, vt(o, Ye(a.name), !0), s));
    } else {
      const a = e.node.object, o = e.node.property;
      r.get("left").replaceWith(vt(a, o)), r.get("right").replaceWith(t(n ? "=" : i, vt(a, Ye(o.name)), s));
    }
    return n ? r.replaceWith(E3(i, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
  } else if (e.parentPath.isUpdateExpression()) {
    const r = e.parentPath, i = e.scope.generateDeclaredUidIdentifier("tmp"), s = e.node.computed ? e.scope.generateDeclaredUidIdentifier("prop") : null, n = [sr("=", i, vt(e.node.object, s ? sr("=", s, e.node.property) : e.node.property, e.node.computed)), sr("=", vt(e.node.object, s ? Ye(s.name) : e.node.property, e.node.computed), jn(e.parentPath.node.operator[0], Ye(i.name), v3(1)))];
    e.parentPath.node.prefix || n.push(Ye(i.name)), r.replaceWith(w3(n));
    const a = r.get("expressions.0.right"), o = r.get("expressions.1.left");
    return [a, o];
  }
  return [e];
  function t(r, i, s) {
    return r === "=" ? sr("=", i, s) : jn(r, i, s);
  }
}
function bf(e) {
  return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
}
const U3 = (0, Xa.merge)([{
  CallExpression(e, {
    supers: t,
    thisBinding: r
  }) {
    e.get("callee").isSuper() && (t.has(e.node) || (t.add(e.node), e.replaceWithMultiple([e.node, sr("=", Ye(r), Ye("this"))])));
  }
}, Ja.default]);
function $3(e, t) {
  return Zr(e, "this", (r) => {
    if (!t || !bf(e)) return Qr();
    e.traverse(U3, {
      supers: /* @__PURE__ */ new WeakSet(),
      thisBinding: r
    });
  });
}
function V3(e) {
  return Zr(e, "supercall", () => {
    const t = e.scope.generateUidIdentifier("args");
    return Ya([C3(t)], Er(Rn(), [O3(Ye(t.name))]));
  });
}
function K3(e, t, r) {
  return Zr(e, `superprop_${t ? "set" : "get"}:${r || ""}`, () => {
    const s = [];
    let n;
    if (r)
      n = vt(Rn(), Ye(r));
    else {
      const a = e.scope.generateUidIdentifier("prop");
      s.unshift(a), n = vt(Rn(), Ye(a.name), !0);
    }
    if (t) {
      const a = e.scope.generateUidIdentifier("value");
      s.push(a), n = sr("=", n, Ye(a.name));
    }
    return Ya(s, n);
  });
}
function Zr(e, t, r) {
  const i = "binding:" + t;
  let s = e.getData(i);
  if (!s) {
    const n = e.scope.generateUidIdentifier(t);
    s = n.name, e.setData(i, s), e.scope.push({
      id: n,
      init: r(s)
    });
  }
  return s;
}
const q3 = (0, Xa.merge)([{
  ThisExpression(e, {
    thisPaths: t
  }) {
    t.push(e);
  },
  JSXIdentifier(e, {
    thisPaths: t
  }) {
    e.node.name === "this" && (!e.parentPath.isJSXMemberExpression({
      object: e.node
    }) && !e.parentPath.isJSXOpeningElement({
      name: e.node
    }) || t.push(e));
  },
  CallExpression(e, {
    superCalls: t
  }) {
    e.get("callee").isSuper() && t.push(e);
  },
  MemberExpression(e, {
    superProps: t
  }) {
    e.get("object").isSuper() && t.push(e);
  },
  Identifier(e, {
    argumentsPaths: t
  }) {
    if (!e.isReferencedIdentifier({
      name: "arguments"
    })) return;
    let r = e.scope;
    do {
      if (r.hasOwnBinding("arguments")) {
        r.rename("arguments");
        return;
      }
      if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
        break;
    } while (r = r.parent);
    t.push(e);
  },
  MetaProperty(e, {
    newTargetPaths: t
  }) {
    e.get("meta").isIdentifier({
      name: "new"
    }) && e.get("property").isIdentifier({
      name: "target"
    }) && t.push(e);
  }
}, Ja.default]);
function W3(e) {
  const t = [], r = [], i = [], s = [], n = [];
  return e.traverse(q3, {
    thisPaths: t,
    argumentsPaths: r,
    newTargetPaths: i,
    superProps: s,
    superCalls: n
  }), {
    thisPaths: t,
    argumentsPaths: r,
    newTargetPaths: i,
    superProps: s,
    superCalls: n
  };
}
var Qe = {};
Object.defineProperty(Qe, "__esModule", {
  value: !0
});
Qe._guessExecutionStatusRelativeTo = dF;
Qe._resolve = Pf;
Qe.canHaveVariableDeclarationOrExpression = aF;
Qe.canSwapBetweenExpressionAndStatement = oF;
Qe.equals = sF;
Qe.getSource = fF;
Qe.has = Ef;
Qe.is = void 0;
Qe.isCompletionRecord = lF;
Qe.isConstantExpression = gF;
Qe.isInStrictMode = bF;
Qe.isNodeType = nF;
Qe.isStatementOrBlock = uF;
Qe.isStatic = rF;
Qe.isnt = iF;
Qe.matchesPattern = tF;
Qe.referencesImport = cF;
Qe.resolve = TF;
Qe.willIMaybeExecuteBefore = pF;
var J3 = Ae();
const {
  STATEMENT_OR_BLOCK_KEYS: X3,
  VISITOR_KEYS: Y3,
  isBlockStatement: Sf,
  isExpression: H3,
  isIdentifier: G3,
  isLiteral: z3,
  isStringLiteral: Q3,
  isType: Z3,
  matchesPattern: eF
} = J3;
function tF(e, t) {
  return eF(this.node, e, t);
}
function Ef(e) {
  var t;
  const r = (t = this.node) == null ? void 0 : t[e];
  return r && Array.isArray(r) ? !!r.length : !!r;
}
function rF() {
  return this.scope.isStatic(this.node);
}
Qe.is = Ef;
function iF(e) {
  return !this.has(e);
}
function sF(e, t) {
  return this.node[e] === t;
}
function nF(e) {
  return Z3(this.type, e);
}
function aF() {
  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
}
function oF(e) {
  return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? Sf(e) : this.isBlockStatement() ? H3(e) : !1;
}
function lF(e) {
  let t = this, r = !0;
  do {
    const {
      type: i,
      container: s
    } = t;
    if (!r && (t.isFunction() || i === "StaticBlock"))
      return !!e;
    if (r = !1, Array.isArray(s) && t.key !== s.length - 1)
      return !1;
  } while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
  return !0;
}
function uF() {
  return this.parentPath.isLabeledStatement() || Sf(this.container) ? !1 : X3.includes(this.key);
}
function cF(e, t) {
  if (!this.isReferencedIdentifier()) {
    if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? Q3(this.node.property, {
      value: t
    }) : this.node.property.name === t)) {
      const n = this.get("object");
      return n.isReferencedIdentifier() && n.referencesImport(e, "*");
    }
    return !1;
  }
  const r = this.scope.getBinding(this.node.name);
  if (!r || r.kind !== "module") return !1;
  const i = r.path, s = i.parentPath;
  if (!s.isImportDeclaration()) return !1;
  if (s.node.source.value === e) {
    if (!t) return !0;
  } else
    return !1;
  return !!(i.isImportDefaultSpecifier() && t === "default" || i.isImportNamespaceSpecifier() && t === "*" || i.isImportSpecifier() && G3(i.node.imported, {
    name: t
  }));
}
function fF() {
  const e = this.node;
  if (e.end) {
    const t = this.hub.getCode();
    if (t) return t.slice(e.start, e.end);
  }
  return "";
}
function pF(e) {
  return this._guessExecutionStatusRelativeTo(e) !== "after";
}
function hu(e) {
  return e.isProgram() ? e : (e.parentPath.scope.getFunctionParent() || e.parentPath.scope.getProgramParent()).path;
}
function hF(e, t) {
  switch (e) {
    case "LogicalExpression":
      return t === "right";
    case "ConditionalExpression":
    case "IfStatement":
      return t === "consequent" || t === "alternate";
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForOfStatement":
      return t === "body";
    case "ForStatement":
      return t === "body" || t === "update";
    case "SwitchStatement":
      return t === "cases";
    case "TryStatement":
      return t === "handler";
    case "AssignmentPattern":
      return t === "right";
    case "OptionalMemberExpression":
      return t === "property";
    case "OptionalCallExpression":
      return t === "arguments";
    default:
      return !1;
  }
}
function du(e, t) {
  for (let r = 0; r < t; r++) {
    const i = e[r];
    if (hF(i.parent.type, i.parentKey))
      return !0;
  }
  return !1;
}
const mu = Symbol();
function dF(e) {
  return Un(this, e, /* @__PURE__ */ new Map());
}
function Un(e, t, r) {
  const i = {
    this: hu(e),
    target: hu(t)
  };
  if (i.target.node !== i.this.node)
    return yF(e, i.target, r);
  const s = {
    target: t.getAncestry(),
    this: e.getAncestry()
  };
  if (s.target.includes(e)) return "after";
  if (s.this.includes(t)) return "before";
  let n;
  const a = {
    target: 0,
    this: 0
  };
  for (; !n && a.this < s.this.length; ) {
    const c = s.this[a.this];
    a.target = s.target.indexOf(c), a.target >= 0 ? n = c : a.this++;
  }
  if (!n)
    throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
  if (du(s.this, a.this - 1) || du(s.target, a.target - 1))
    return "unknown";
  const o = {
    this: s.this[a.this - 1],
    target: s.target[a.target - 1]
  };
  if (o.target.listKey && o.this.listKey && o.target.container === o.this.container)
    return o.target.key > o.this.key ? "before" : "after";
  const l = Y3[n.type], u = {
    this: l.indexOf(o.this.parentKey),
    target: l.indexOf(o.target.parentKey)
  };
  return u.target > u.this ? "before" : "after";
}
function mF(e, t, r) {
  if (t.isFunctionDeclaration()) {
    if (t.parentPath.isExportDeclaration())
      return "unknown";
  } else return Un(e, t, r) === "before" ? "before" : "unknown";
  const i = t.scope.getBinding(t.node.id.name);
  if (!i.references) return "before";
  const s = i.referencePaths;
  let n;
  for (const a of s) {
    if (!!a.find((u) => u.node === t.node)) continue;
    if (a.key !== "callee" || !a.parentPath.isCallExpression())
      return "unknown";
    const l = Un(e, a, r);
    if (n && n !== l)
      return "unknown";
    n = l;
  }
  return n;
}
function yF(e, t, r) {
  let i = r.get(e.node), s;
  if (!i)
    r.set(e.node, i = /* @__PURE__ */ new Map());
  else if (s = i.get(t.node))
    return s === mu ? "unknown" : s;
  i.set(t.node, mu);
  const n = mF(e, t, r);
  return i.set(t.node, n), n;
}
function TF(e, t) {
  return Pf.call(this, e, t) || this;
}
function Pf(e, t) {
  var r;
  if (!((r = t) != null && r.includes(this)))
    if (t = t || [], t.push(this), this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier())
        return this.get("init").resolve(e, t);
    } else if (this.isReferencedIdentifier()) {
      const i = this.scope.getBinding(this.node.name);
      if (!i || !i.constant || i.kind === "module") return;
      if (i.path !== this) {
        const s = i.path.resolve(e, t);
        return this.find((n) => n.node === s.node) ? void 0 : s;
      }
    } else {
      if (this.isTypeCastExpression())
        return this.get("expression").resolve(e, t);
      if (e && this.isMemberExpression()) {
        const i = this.toComputedKey();
        if (!z3(i)) return;
        const s = i.value, n = this.get("object").resolve(e, t);
        if (n.isObjectExpression()) {
          const a = n.get("properties");
          for (const o of a) {
            if (!o.isProperty()) continue;
            const l = o.get("key");
            let u = o.isnt("computed") && l.isIdentifier({
              name: s
            });
            if (u = u || l.isLiteral({
              value: s
            }), u) return o.get("value").resolve(e, t);
          }
        } else if (n.isArrayExpression() && !isNaN(+s)) {
          const o = n.get("elements")[s];
          if (o) return o.resolve(e, t);
        }
      }
    }
}
function gF() {
  if (this.isIdentifier()) {
    const e = this.scope.getBinding(this.node.name);
    return e ? e.constant : !1;
  }
  if (this.isLiteral())
    return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((e) => e.isConstantExpression()) : !0;
  if (this.isUnaryExpression())
    return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
  if (this.isBinaryExpression()) {
    const {
      operator: e
    } = this.node;
    return e !== "in" && e !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
  }
  return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
    name: "Symbol"
  }) && !this.scope.hasBinding("Symbol", {
    noGlobals: !0
  }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
    noGlobals: !0
  }) && this.get("arguments")[0].isStringLiteral() : !1;
}
function bF() {
  return !!(this.isProgram() ? this : this.parentPath).find((r) => {
    if (r.isProgram({
      sourceType: "module"
    }) || r.isClass()) return !0;
    if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement())
      return !1;
    let i;
    if (r.isFunction())
      i = r.node.body;
    else if (r.isProgram())
      i = r.node;
    else
      return !1;
    for (const s of i.directives)
      if (s.value.value === "use strict")
        return !0;
  });
}
var at = {}, yu;
function SF() {
  if (yu) return at;
  yu = 1, Object.defineProperty(at, "__esModule", {
    value: !0
  }), at._getKey = q, at._getPattern = Y, at.get = ae, at.getAllNextSiblings = ce, at.getAllPrevSiblings = te, at.getBindingIdentifierPaths = Q, at.getBindingIdentifiers = re, at.getCompletionRecords = I, at.getNextSibling = G, at.getOpposite = c, at.getOuterBindingIdentifierPaths = U, at.getOuterBindingIdentifiers = W, at.getPrevSibling = j, at.getSibling = _;
  var e = mr(), t = Ae();
  const {
    getBindingIdentifiers: r,
    getOuterBindingIdentifiers: i,
    numericLiteral: s,
    unaryExpression: n
  } = t, a = 0, o = 1;
  function l(L) {
    return {
      type: a,
      path: L
    };
  }
  function u(L) {
    return {
      type: o,
      path: L
    };
  }
  function c() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  function f(L, k, F) {
    return L && k.push(...A(L, F)), k;
  }
  function p(L, k, F) {
    let B = [];
    for (let N = 0; N < L.length; N++) {
      const D = L[N], R = A(D, F), V = [], $ = [];
      for (const H of R)
        H.type === a && V.push(H), H.type === o && $.push(H);
      V.length && (B = V), k.push(...$);
    }
    return k.push(...B), k;
  }
  function h(L) {
    L.forEach((k) => {
      k.type = o;
    });
  }
  function y(L, k) {
    L.forEach((F) => {
      F.path.isBreakStatement({
        label: null
      }) && (k ? F.path.replaceWith(n("void", s(0))) : F.path.remove());
    });
  }
  function b(L, k) {
    const F = [];
    if (k.canHaveBreak) {
      let B = [];
      for (let N = 0; N < L.length; N++) {
        const D = L[N], R = Object.assign({}, k, {
          inCaseClause: !1
        });
        D.isBlockStatement() && (k.inCaseClause || k.shouldPopulateBreak) ? R.shouldPopulateBreak = !0 : R.shouldPopulateBreak = !1;
        const V = A(D, R);
        if (V.length > 0 && V.every(($) => $.type === o)) {
          B.length > 0 && V.every(($) => $.path.isBreakStatement({
            label: null
          })) ? (h(B), F.push(...B), B.some(($) => $.path.isDeclaration()) && (F.push(...V), y(V, !0)), y(V, !1)) : (F.push(...V), k.shouldPopulateBreak || y(V, !0));
          break;
        }
        if (N === L.length - 1)
          F.push(...V);
        else {
          B = [];
          for (let $ = 0; $ < V.length; $++) {
            const H = V[$];
            H.type === o && F.push(H), H.type === a && B.push(H);
          }
        }
      }
    } else if (L.length)
      for (let B = L.length - 1; B >= 0; B--) {
        const N = A(L[B], k);
        if (N.length > 1 || N.length === 1 && !N[0].path.isVariableDeclaration()) {
          F.push(...N);
          break;
        }
      }
    return F;
  }
  function A(L, k) {
    let F = [];
    if (L.isIfStatement())
      F = f(L.get("consequent"), F, k), F = f(L.get("alternate"), F, k);
    else {
      if (L.isDoExpression() || L.isFor() || L.isWhile() || L.isLabeledStatement())
        return f(L.get("body"), F, k);
      if (L.isProgram() || L.isBlockStatement())
        return b(L.get("body"), k);
      if (L.isFunction())
        return A(L.get("body"), k);
      if (L.isTryStatement())
        F = f(L.get("block"), F, k), F = f(L.get("handler"), F, k);
      else {
        if (L.isCatchClause())
          return f(L.get("body"), F, k);
        if (L.isSwitchStatement())
          return p(L.get("cases"), F, k);
        if (L.isSwitchCase())
          return b(L.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        L.isBreakStatement() ? F.push(u(L)) : F.push(l(L));
      }
    }
    return F;
  }
  function I() {
    return A(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((k) => k.path);
  }
  function _(L) {
    return e.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: L
    }).setContext(this.context);
  }
  function j() {
    return this.getSibling(this.key - 1);
  }
  function G() {
    return this.getSibling(this.key + 1);
  }
  function ce() {
    let L = this.key, k = this.getSibling(++L);
    const F = [];
    for (; k.node; )
      F.push(k), k = this.getSibling(++L);
    return F;
  }
  function te() {
    let L = this.key, k = this.getSibling(--L);
    const F = [];
    for (; k.node; )
      F.push(k), k = this.getSibling(--L);
    return F;
  }
  function ae(L, k = !0) {
    k === !0 && (k = this.context);
    const F = L.split(".");
    return F.length === 1 ? q.call(this, L, k) : Y.call(this, F, k);
  }
  function q(L, k) {
    const F = this.node, B = F[L];
    return Array.isArray(B) ? B.map((N, D) => e.default.get({
      listKey: L,
      parentPath: this,
      parent: F,
      container: B,
      key: D
    }).setContext(k)) : e.default.get({
      parentPath: this,
      parent: F,
      container: F,
      key: L
    }).setContext(k);
  }
  function Y(L, k) {
    let F = this;
    for (const B of L)
      B === "." ? F = F.parentPath : Array.isArray(F) ? F = F[B] : F = F.get(B, k);
    return F;
  }
  function re(L) {
    return r(this.node, L);
  }
  function W(L) {
    return i(this.node, L);
  }
  function Q(L = !1, k = !1) {
    const B = [this], N = /* @__PURE__ */ Object.create(null);
    for (; B.length; ) {
      const D = B.shift();
      if (!D || !D.node) continue;
      const R = r.keys[D.node.type];
      if (D.isIdentifier()) {
        L ? (N[D.node.name] = N[D.node.name] || []).push(D) : N[D.node.name] = D;
        continue;
      }
      if (D.isExportDeclaration()) {
        const V = D.get("declaration");
        V.isDeclaration() && B.push(V);
        continue;
      }
      if (k) {
        if (D.isFunctionDeclaration()) {
          B.push(D.get("id"));
          continue;
        }
        if (D.isFunctionExpression())
          continue;
      }
      if (R)
        for (let V = 0; V < R.length; V++) {
          const $ = R[V], H = D.get($);
          Array.isArray(H) ? B.push(...H) : H.node && B.push(H);
        }
    }
    return N;
  }
  function U(L = !1) {
    return this.getBindingIdentifierPaths(L, !0);
  }
  return at;
}
var yi = {};
Object.defineProperty(yi, "__esModule", {
  value: !0
});
yi.addComment = AF;
yi.addComments = CF;
yi.shareCommentsWithSiblings = vF;
var EF = Ae();
const {
  addComment: PF,
  addComments: xF
} = EF;
function vF() {
  if (typeof this.key == "string") return;
  const e = this.node;
  if (!e) return;
  const t = e.trailingComments, r = e.leadingComments;
  if (!t && !r) return;
  const i = this.getSibling(this.key - 1), s = this.getSibling(this.key + 1), n = !!i.node, a = !!s.node;
  n && (r && i.addComments("trailing", Tu(r, i.node.trailingComments)), t && !a && i.addComments("trailing", t)), a && (t && s.addComments("leading", Tu(t, s.node.leadingComments)), r && !n && s.addComments("leading", r));
}
function Tu(e, t) {
  if (!(t != null && t.length)) return e;
  const r = new Set(t);
  return e.filter((i) => !r.has(i));
}
function AF(e, t, r) {
  PF(this.node, e, t, r);
}
function CF(e, t) {
  xF(this.node, e, t);
}
var gu;
function mr() {
  if (gu) return xt;
  gu = 1, Object.defineProperty(xt, "__esModule", {
    value: !0
  }), xt.default = xt.SHOULD_STOP = xt.SHOULD_SKIP = xt.REMOVED = void 0;
  var e = Oe, t = cI, r = Us(), i = rc(), s = Ae(), n = s, a = nt, o = vs, l = Pt, u = Zt, c = pf(), f = Bs, p = hr, h = Qe, y = Kc(), b = Ca(), A = qc(), I = SF(), _ = yi, j = et;
  const {
    validate: G
  } = s, ce = t("babel");
  xt.REMOVED = 1, xt.SHOULD_STOP = 2, xt.SHOULD_SKIP = 4;
  const te = xt.default = class xf {
    constructor(Y, re) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = re, this.hub = Y, this.data = null, this.context = null, this.scope = null;
    }
    get removed() {
      return (this._traverseFlags & 1) > 0;
    }
    set removed(Y) {
      Y ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
    }
    get shouldStop() {
      return (this._traverseFlags & 2) > 0;
    }
    set shouldStop(Y) {
      Y ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
    }
    get shouldSkip() {
      return (this._traverseFlags & 4) > 0;
    }
    set shouldSkip(Y) {
      Y ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
    }
    static get({
      hub: Y,
      parentPath: re,
      parent: W,
      container: Q,
      listKey: U,
      key: L
    }) {
      if (!Y && re && (Y = re.hub), !W)
        throw new Error("To get a node path the parent needs to exist");
      const k = Q[L], F = a.getOrCreateCachedPaths(Y, W);
      let B = F.get(k);
      return B || (B = new xf(Y, W), k && F.set(k, B)), B.setup(re, Q, U, L), B;
    }
    getScope(Y) {
      return this.isScope() ? new i.default(this) : Y;
    }
    setData(Y, re) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[Y] = re;
    }
    getData(Y, re) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let W = this.data[Y];
      return W === void 0 && re !== void 0 && (W = this.data[Y] = re), W;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(Y, re = SyntaxError) {
      return this.hub.buildError(this.node, Y, re);
    }
    traverse(Y, re) {
      (0, r.default)(this.node, Y, this.scope, re, this);
    }
    set(Y, re) {
      G(this.node, Y, re), this.node[Y] = re;
    }
    getPathLocation() {
      const Y = [];
      let re = this;
      do {
        let W = re.key;
        re.inList && (W = `${re.listKey}[${W}]`), Y.unshift(W);
      } while (re = re.parentPath);
      return Y.join(".");
    }
    debug(Y) {
      ce.enabled && ce(`${this.getPathLocation()} ${this.type}: ${Y}`);
    }
    toString() {
      return (0, o.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(Y) {
      Y || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
  }, ae = {
    findParent: l.findParent,
    find: l.find,
    getFunctionParent: l.getFunctionParent,
    getStatementParent: l.getStatementParent,
    getEarliestCommonAncestorFrom: l.getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: l.getDeepestCommonAncestorFrom,
    getAncestry: l.getAncestry,
    isAncestor: l.isAncestor,
    isDescendant: l.isDescendant,
    inType: l.inType,
    getTypeAnnotation: u.getTypeAnnotation,
    isBaseType: u.isBaseType,
    couldBeBaseType: u.couldBeBaseType,
    baseTypeStrictlyMatches: u.baseTypeStrictlyMatches,
    isGenericType: u.isGenericType,
    replaceWithMultiple: c.replaceWithMultiple,
    replaceWithSourceString: c.replaceWithSourceString,
    replaceWith: c.replaceWith,
    replaceExpressionWithStatements: c.replaceExpressionWithStatements,
    replaceInline: c.replaceInline,
    evaluateTruthy: f.evaluateTruthy,
    evaluate: f.evaluate,
    toComputedKey: p.toComputedKey,
    ensureBlock: p.ensureBlock,
    unwrapFunctionEnvironment: p.unwrapFunctionEnvironment,
    arrowFunctionToExpression: p.arrowFunctionToExpression,
    matchesPattern: h.matchesPattern,
    has: h.has,
    isStatic: h.isStatic,
    is: h.is,
    isnt: h.isnt,
    equals: h.equals,
    isNodeType: h.isNodeType,
    canHaveVariableDeclarationOrExpression: h.canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: h.canSwapBetweenExpressionAndStatement,
    isCompletionRecord: h.isCompletionRecord,
    isStatementOrBlock: h.isStatementOrBlock,
    referencesImport: h.referencesImport,
    getSource: h.getSource,
    willIMaybeExecuteBefore: h.willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: h._guessExecutionStatusRelativeTo,
    resolve: h.resolve,
    isConstantExpression: h.isConstantExpression,
    isInStrictMode: h.isInStrictMode,
    call: y.call,
    isDenylisted: y.isDenylisted,
    isBlacklisted: y.isBlacklisted,
    visit: y.visit,
    skip: y.skip,
    skipKey: y.skipKey,
    stop: y.stop,
    setScope: y.setScope,
    setContext: y.setContext,
    resync: y.resync,
    popContext: y.popContext,
    pushContext: y.pushContext,
    setup: y.setup,
    setKey: y.setKey,
    requeue: y.requeue,
    remove: b.remove,
    insertBefore: A.insertBefore,
    insertAfter: A.insertAfter,
    updateSiblingKeys: A.updateSiblingKeys,
    unshiftContainer: A.unshiftContainer,
    pushContainer: A.pushContainer,
    hoist: A.hoist,
    getOpposite: I.getOpposite,
    getCompletionRecords: I.getCompletionRecords,
    getSibling: I.getSibling,
    getPrevSibling: I.getPrevSibling,
    getNextSibling: I.getNextSibling,
    getAllNextSiblings: I.getAllNextSiblings,
    getAllPrevSiblings: I.getAllPrevSiblings,
    get: I.get,
    getBindingIdentifiers: I.getBindingIdentifiers,
    getOuterBindingIdentifiers: I.getOuterBindingIdentifiers,
    getBindingIdentifierPaths: I.getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: I.getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings: _.shareCommentsWithSiblings,
    addComment: _.addComment,
    addComments: _.addComments
  };
  Object.assign(te.prototype, ae), te.prototype.arrowFunctionToShadowed = p.arrowFunctionToShadowed, te.prototype._guessExecutionStatusRelativeToDifferentFunctions = h._guessExecutionStatusRelativeTo, te.prototype._guessExecutionStatusRelativeToDifferentFunctions = h._guessExecutionStatusRelativeTo, Object.assign(te.prototype, {
    _getTypeAnnotation: u._getTypeAnnotation,
    _replaceWith: c._replaceWith,
    _resolve: h._resolve,
    _call: y._call,
    _resyncParent: y._resyncParent,
    _resyncKey: y._resyncKey,
    _resyncList: y._resyncList,
    _resyncRemoved: y._resyncRemoved,
    _getQueueContexts: y._getQueueContexts,
    _removeFromScope: b._removeFromScope,
    _callRemovalHooks: b._callRemovalHooks,
    _remove: b._remove,
    _markRemoved: b._markRemoved,
    _assertUnremoved: b._assertUnremoved,
    _containerInsert: A._containerInsert,
    _containerInsertBefore: A._containerInsertBefore,
    _containerInsertAfter: A._containerInsertAfter,
    _verifyNodeList: A._verifyNodeList,
    _getKey: I._getKey,
    _getPattern: I._getPattern
  });
  for (const q of n.TYPES) {
    const Y = `is${q}`, re = n[Y];
    te.prototype[Y] = function(W) {
      return re(this.node, W);
    }, te.prototype[`assert${q}`] = function(W) {
      if (!re(this.node, W))
        throw new TypeError(`Expected node path of type ${q}`);
    };
  }
  Object.assign(te.prototype, j);
  for (const q of Object.keys(e))
    q[0] !== "_" && (n.TYPES.includes(q) || n.TYPES.push(q));
  return xt;
}
var bu;
function IF() {
  if (bu) return Lr;
  bu = 1, Object.defineProperty(Lr, "__esModule", {
    value: !0
  }), Lr.default = void 0;
  var e = mr(), t = Ae();
  const {
    VISITOR_KEYS: r
  } = t;
  class i {
    constructor(n, a, o, l) {
      this.queue = null, this.priorityQueue = null, this.parentPath = l, this.scope = n, this.state = o, this.opts = a;
    }
    shouldVisit(n) {
      const a = this.opts;
      if (a.enter || a.exit || a[n.type]) return !0;
      const o = r[n.type];
      if (!(o != null && o.length)) return !1;
      for (const l of o)
        if (n[l])
          return !0;
      return !1;
    }
    create(n, a, o, l) {
      return e.default.get({
        parentPath: this.parentPath,
        parent: n,
        container: a,
        key: o,
        listKey: l
      });
    }
    maybeQueue(n, a) {
      this.queue && (a ? this.queue.push(n) : this.priorityQueue.push(n));
    }
    visitMultiple(n, a, o) {
      if (n.length === 0) return !1;
      const l = [];
      for (let u = 0; u < n.length; u++) {
        const c = n[u];
        c && this.shouldVisit(c) && l.push(this.create(a, n, u, o));
      }
      return this.visitQueue(l);
    }
    visitSingle(n, a) {
      return this.shouldVisit(n[a]) ? this.visitQueue([this.create(n, n, a)]) : !1;
    }
    visitQueue(n) {
      this.queue = n, this.priorityQueue = [];
      const a = /* @__PURE__ */ new WeakSet();
      let o = !1, l = 0;
      for (; l < n.length; ) {
        const u = n[l];
        if (l++, u.resync(), (u.contexts.length === 0 || u.contexts[u.contexts.length - 1] !== this) && u.pushContext(this), u.key === null) continue;
        const {
          node: c
        } = u;
        if (!a.has(c)) {
          if (c && a.add(c), u.visit()) {
            o = !0;
            break;
          }
          if (this.priorityQueue.length && (o = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = n, o))
            break;
        }
      }
      for (let u = 0; u < l; u++)
        n[u].popContext();
      return this.queue = null, o;
    }
    visit(n, a) {
      const o = n[a];
      return o ? Array.isArray(o) ? this.visitMultiple(o, n, a) : this.visitSingle(n, a) : !1;
    }
  }
  return Lr.default = i, Lr;
}
var Su;
function Ha() {
  if (Su) return Ui;
  Su = 1, Object.defineProperty(Ui, "__esModule", {
    value: !0
  }), Ui.traverseNode = i;
  var e = IF(), t = Ae();
  const {
    VISITOR_KEYS: r
  } = t;
  function i(s, n, a, o, l, u, c) {
    const f = r[s.type];
    if (!f) return !1;
    const p = new e.default(a, n, o, l);
    if (c)
      return u != null && u[l.parentKey] ? !1 : p.visitQueue([l]);
    for (const h of f)
      if (!(u != null && u[h]) && p.visit(s, h))
        return !0;
    return !1;
  }
  return Ui;
}
var Rs = {};
Object.defineProperty(Rs, "__esModule", {
  value: !0
});
Rs.default = void 0;
class wF {
  getCode() {
  }
  getScope() {
  }
  addHelper() {
    throw new Error("Helpers are not supported by the default hub.");
  }
  buildError(t, r, i = TypeError) {
    return new i(r);
  }
}
Rs.default = wF;
var Eu;
function Us() {
  return Eu || (Eu = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "Hub", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "NodePath", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "Scope", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), e.visitors = e.default = void 0;
    var t = Vt;
    e.visitors = t;
    var r = Ae(), i = nt, s = Ha(), n = mr(), a = rc(), o = Rs;
    const {
      VISITOR_KEYS: l,
      removeProperties: u,
      traverseFast: c
    } = r;
    function f(h, y = {}, b, A, I, _) {
      if (h) {
        if (!y.noScope && !b && h.type !== "Program" && h.type !== "File")
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${h.type} node without passing scope and parentPath.`);
        if (!I && _)
          throw new Error("visitSelf can only be used when providing a NodePath.");
        l[h.type] && (t.explode(y), (0, s.traverseNode)(h, y, b, A, I, null, _));
      }
    }
    e.default = f, f.visitors = t, f.verify = t.verify, f.explode = t.explode, f.cheap = function(h, y) {
      c(h, y);
    }, f.node = function(h, y, b, A, I, _) {
      (0, s.traverseNode)(h, y, b, A, I, _);
    }, f.clearNode = function(h, y) {
      u(h, y);
    }, f.removeProperties = function(h, y) {
      return c(h, f.clearNode, y), h;
    };
    function p(h, y) {
      h.node.type === y.type && (y.has = !0, h.stop());
    }
    f.hasType = function(h, y, b) {
      if (b != null && b.includes(h.type)) return !1;
      if (h.type === y) return !0;
      const A = {
        has: !1,
        type: y
      };
      return f(h, {
        noScope: !0,
        denylist: b,
        enter: p
      }, null, A), A.has;
    }, f.cache = i;
  }(Ks)), Ks;
}
var OF = Us();
const NF = /* @__PURE__ */ Au(OF);
function Pu(e) {
  return $M(e, {
    plugins: ["typescript", "jsx"],
    sourceType: "module"
  });
}
function _F(e, t) {
  NF(e, t);
}
function kF(e) {
  return Dk(e, {}).code;
}
var vf = Ae();
const DF = /* @__PURE__ */ Au(vf), LF = /* @__PURE__ */ Ld({
  __proto__: null,
  default: DF
}, [vf]);
var or = "_$", Ke = LF;
function Af(e) {
  return e.type === "FunctionDeclaration" || e.type === "ArrowFunctionExpression";
}
function Cf(e) {
  if (!e) return !1;
  var t = e.type;
  return t === "JSXElement" || t === "JSXFragment" ? !0 : t === "CallExpression" ? MF(e) : !1;
}
function MF(e) {
  return e.callee.type === "Identifier" ? e.callee.name === "jsxDEV" : !!BF(e.callee, "React", "createElement");
}
function BF(e, t, r) {
  return e.type === "MemberExpression" && e.object.name === t && e.property.name === r;
}
function $n(e) {
  for (var t = e.object; t.type === "MemberExpression"; )
    t = t.object;
  return t.type === "Identifier" ? t.name : "";
}
function FF(e) {
  var t, r, i = ((t = e.container) === null || t === void 0 ? void 0 : t.type) || "", s = (r = e.container) === null || r === void 0 ? void 0 : r.operator, n = e.key, a = e.listKey;
  return {
    type: i,
    key: n,
    listKey: a,
    operator: s
  };
}
function jF(e) {
  var t = FF(e), r = t.type, i = t.key, s = t.operator;
  return r === "AssignmentExpression" && i === "left" || r === "UpdateExpression" && i === "argument" || r === "UnaryExpression" && s === "delete" || // delete a.a;
  RF(e);
}
function RF(e) {
  var t = e.parentPath;
  if (t.type === "CallExpression") {
    var r, i, s = t.node.callee;
    if (s.type === "MemberExpression" && ((r = s.object) === null || r === void 0 ? void 0 : r.name) === "Object" && ((i = s.property) === null || i === void 0 ? void 0 : i.name) === "assign" && e.key === 0)
      return !0;
  }
  return !1;
}
var If = /* @__PURE__ */ new Set(["push", "pop", "unshift", "shift", "splice", "sort", "reverse"]);
function UF(e) {
  if (e.type !== "MemberExpression") return !1;
  if (e.parent.type === "CallExpression") {
    var t = e.node.property.name;
    if (typeof t != "string") return;
    if (If.has(t))
      return !0;
  }
  return !1;
}
function $F(e) {
  for (var t = null, r = e.parentPath; r && r.type === "MemberExpression"; )
    t = r, r = r.parentPath;
  return t;
}
function bn(e) {
  return e.__skip;
}
function $r(e) {
  return e.__skip = !0, e;
}
var VF = /* @__PURE__ */ function() {
  function e(t, r) {
    xu(this, e), this.path = r, this.parent = t;
  }
  return vu(e, [{
    key: "exit",
    value: function() {
      var r = this;
      if (this.returnJsx) {
        var i = this.path.node.body;
        i.type === "BlockStatement" && i.body.forEach(function(s) {
          if (s.type === "VariableDeclaration") {
            var n = s.declarations;
            n.forEach(function(a, o) {
              if (!Af(a.init)) {
                var l = a.id.name, u = r.path.scope.getBinding(l);
                if (u) {
                  var c = {
                    isModified: !1,
                    isState: !1,
                    name: l,
                    refs: []
                  };
                  u.referencePaths.forEach(function(f) {
                    r.handleReference(f, c), r.handleState(f, c);
                  }), u.constantViolations.forEach(function(f) {
                    return r.handleViolation(f, c);
                  }), c.isModified && c.isState && (r.parent.addImport(), c.refs.forEach(function(f) {
                    f.replaceWithSourceString("".concat(or).concat(c.name, "(").concat(f.toString(), ")"));
                  }), n.splice(o, 1, Ke.variableDeclarator(Ke.arrayPattern([Ke.identifier(l), Ke.identifier("_".concat(or).concat(l))]), Ke.callExpression(Ke.identifier("useState"), [a.init])), Ke.variableDeclarator(Ke.identifier("".concat(or).concat(l)), Ke.arrowFunctionExpression([Ke.identifier("v")], Ke.sequenceExpression([Ke.callExpression(Ke.identifier("_".concat(or).concat(l)), [Ke.callExpression(Ke.identifier("__clone"), [Ke.identifier(l)])]), Ke.identifier("v")])))));
                }
              }
            });
          }
        });
      }
    }
  }, {
    key: "handleViolation",
    value: function(r, i) {
      return r.type === "UpdateExpression" || r.type === "CallExpression" ? !1 : (i.refs.push(r), i.isModified = !0, i.isState = !0, !0);
    }
  }, {
    key: "handleReference",
    value: function(r, i) {
      var s = r.findParent(function(n) {
        var a = n.type, o = n.node;
        if (a === "AssignmentExpression" || a === "UpdateExpression")
          return !0;
        if (a === "UnaryExpression") {
          if (n.node.operator === "delete")
            return !0;
        } else if (a === "CallExpression") {
          if (o.callee.type === "MemberExpression") {
            var l = o.callee.object.name, u = o.callee.property.name;
            if (
              // @ts-ignore
              l === "Object" && u === "assign" && o.arguments[0] === r.node
            )
              return !0;
            if ($n(o.callee) === r.node.name) {
              if (If.has(u)) return !0;
              u === "map" && (i.isModified = !0);
            }
          }
          var c = Bd(o.arguments), f;
          try {
            for (c.s(); !(f = c.n()).done; ) {
              var p = f.value;
              if (p.type === "Identifier") {
                if (p.name === i.name)
                  return i.isState = !0, !0;
              } else if (p.type === "MemberExpression" && $n(p) === i.name)
                return i.isState = !0, !0;
            }
          } catch (h) {
            c.e(h);
          } finally {
            c.f();
          }
        }
        return !1;
      });
      return s ? (i.refs.push(s), i.isModified = !0, !0) : !1;
    }
  }, {
    key: "handleState",
    value: function(r, i) {
      if (!i.isState) {
        var s = r.findParent(function(n) {
          var a = n.type, o = n.node;
          return !!(a === "JSXExpressionContainer" || Cf(o));
        });
        s && (i.isState = !0);
      }
    }
  }]);
}(), KF = /* @__PURE__ */ function() {
  function e(t) {
    var r = this;
    xu(this, e), this.components = {}, this.current = null, this._added_import = !1, this.ast = Pu(t);
    var i = 0;
    _F(this.ast, {
      BlockStatement: {
        enter: function() {
          i++;
        },
        exit: function() {
          i--;
        }
      },
      Identifier: function(n) {
        r.checkListItemUpdated(n);
      },
      "FunctionDeclaration|ArrowFunctionExpression": {
        enter: function(n) {
          var a;
          if (i === 0) {
            var o = (a = n.node.id) === null || a === void 0 ? void 0 : a.name;
            o && (r.current = r.components[n.node.start] = new VF(r, n));
          }
        },
        exit: function(n) {
          var a;
          if (i === 0) {
            var o = (a = n.node.id) === null || a === void 0 ? void 0 : a.name;
            if (o) {
              var l = n.node.start, u = r.components[l];
              u != null && u.returnJsx ? u.exit() : delete r.components[l], r.current = null;
            }
          }
        }
      },
      ReturnStatement: function(n) {
        if (Cf(n.node.argument)) {
          var a = n.findParent(function(l) {
            return Af(l.node);
          });
          if (a) {
            var o = r.components[a.node.start];
            o.returnJsx = !0;
          }
        }
      }
    });
  }
  return vu(e, [{
    key: "checkListItemUpdated",
    value: function(r) {
      var i = this;
      if (this.current && !(r.listKey !== "params" && r.key !== 0)) {
        var s = "", n = r.node.name, a = r.findParent(function(l) {
          var u, c;
          if (l.type !== "CallExpression") return !1;
          var f = l.node.callee;
          if (f.type !== "MemberExpression") return !1;
          var p = (u = f.property) === null || u === void 0 ? void 0 : u.name;
          if (p !== "map") return !1;
          var h = $n(f), y = (c = i.current) === null || c === void 0 ? void 0 : c.path.scope.getBinding(h);
          return y ? (s = h, !0) : !1;
        });
        if (a) {
          var o = r.scope.getBinding(n);
          o && o.referencePaths.forEach(function(l) {
            var u = $F(l);
            if (u) {
              var c = u.parentPath.node;
              if (jF(u) || UF(u)) {
                if (bn(c)) return;
                $r(c), u.parentPath.replaceInline(
                  // @ts-ignore
                  Ke.callExpression(Ke.identifier("".concat(or).concat(s)), [c])
                );
              } else if (u.listKey === "arguments") {
                if (bn(c)) return;
                $r(c), u.parentPath.replaceInline(
                  // @ts-ignore
                  $r(Ke.callExpression(Ke.identifier("".concat(or).concat(s)), [c]))
                );
              }
            } else if (l.listKey === "arguments") {
              var f = l.parentPath.node;
              if (bn(f)) return;
              $r(f), l.parentPath.replaceInline(
                // @ts-ignore
                $r(Ke.callExpression(Ke.identifier("".concat(or).concat(s)), [f]))
              );
            }
          });
        }
      }
    }
  }, {
    key: "toString",
    value: function() {
      return kF(this.ast);
    }
  }, {
    key: "addImport",
    value: function() {
      if (!this._added_import) {
        this._added_import = !0;
        for (var r = Ke.importSpecifier(Ke.identifier("useState"), Ke.identifier("useState")), i = this.ast.program.body, s = 0; s < i.length; s++) {
          var n = i[s];
          if (n.type !== "ImportDeclaration") {
            var a = Pu("var __clone = (v)=> ((v && typeof v === 'object') ? (Array.isArray(v) ? [...v]: {...v}): v);");
            i.splice(s, 0, a.program.body[0]);
            break;
          }
        }
        i.unshift(Ke.importDeclaration([r], Ke.stringLiteral("react")));
      }
    }
  }]);
}();
typeof window < "u" && (window.process || (window.process = {
  env: {}
}), window.Buffer || (window.Buffer = {
  // @ts-ignore
  from: function(t) {
    return new Uint8Array(t);
  },
  // @ts-ignore
  isBuffer: function(t) {
    return t instanceof Uint8Array;
  }
}));
function qF(e) {
  var t = new KF(e);
  return t.toString();
}
function WF(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return /\.lim\.[tj]sx$/.test(t) || /\/\/ *use lim/.test(e) || /['"]use lim['"]/.test(e);
}
const ej = {
  transformReact: qF,
  isLimReact: WF
};
export {
  ej as default,
  WF as isLimReact,
  qF as transformReact
};
